
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 77 08 00 00       	call   8008a8 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...

00800040 <put_buffer>:

	return va;
}

static void
put_buffer(void *va) {
  800040:	55                   	push   %ebp
  800041:	89 e5                	mov    %esp,%ebp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  800043:	2d 00 b0 fe 0f       	sub    $0xffeb000,%eax
  800048:	c1 e8 0c             	shr    $0xc,%eax
  80004b:	c7 04 85 40 60 81 00 	movl   $0x0,0x816040(,%eax,4)
  800052:	00 00 00 00 
}
  800056:	5d                   	pop    %ebp
  800057:	c3                   	ret    

00800058 <umain>:
	serve();
}

void
umain(int argc, char **argv)
{
  800058:	55                   	push   %ebp
  800059:	89 e5                	mov    %esp,%ebp
  80005b:	53                   	push   %ebx
  80005c:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  80005f:	e8 b3 17 00 00       	call   801817 <sys_getenvid>
  800064:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800066:	c7 05 00 50 81 00 20 	movl   $0x811f20,0x815000
  80006d:	1f 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800070:	e8 ad 18 00 00       	call   801922 <fork>
  800075:	a3 24 60 81 00       	mov    %eax,0x816024
	if (timer_envid < 0)
  80007a:	85 c0                	test   %eax,%eax
  80007c:	79 1c                	jns    80009a <umain+0x42>
		panic("error forking");
  80007e:	c7 44 24 08 23 1f 81 	movl   $0x811f23,0x8(%esp)
  800085:	00 
  800086:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  80008d:	00 
  80008e:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  800095:	e8 7a 08 00 00       	call   800914 <_panic>
	else if (timer_envid == 0) {
  80009a:	85 c0                	test   %eax,%eax
  80009c:	75 15                	jne    8000b3 <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  80009e:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  8000a5:	00 
  8000a6:	89 1c 24             	mov    %ebx,(%esp)
  8000a9:	e8 d2 06 00 00       	call   800780 <timer>
		return;
  8000ae:	e9 a3 00 00 00       	jmp    800156 <umain+0xfe>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8000b3:	e8 6a 18 00 00       	call   801922 <fork>
  8000b8:	a3 28 60 81 00       	mov    %eax,0x816028
	if (input_envid < 0)
  8000bd:	85 c0                	test   %eax,%eax
  8000bf:	79 1c                	jns    8000dd <umain+0x85>
		panic("error forking");
  8000c1:	c7 44 24 08 23 1f 81 	movl   $0x811f23,0x8(%esp)
  8000c8:	00 
  8000c9:	c7 44 24 04 4d 01 00 	movl   $0x14d,0x4(%esp)
  8000d0:	00 
  8000d1:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  8000d8:	e8 37 08 00 00       	call   800914 <_panic>
	else if (input_envid == 0) {
  8000dd:	85 c0                	test   %eax,%eax
  8000df:	75 0a                	jne    8000eb <umain+0x93>
		input(ns_envid);
  8000e1:	89 1c 24             	mov    %ebx,(%esp)
  8000e4:	e8 5f 07 00 00       	call   800848 <input>
		return;
  8000e9:	eb 6b                	jmp    800156 <umain+0xfe>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8000eb:	90                   	nop
  8000ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8000f0:	e8 2d 18 00 00       	call   801922 <fork>
  8000f5:	a3 2c 60 81 00       	mov    %eax,0x81602c
	if (output_envid < 0)
  8000fa:	85 c0                	test   %eax,%eax
  8000fc:	79 1c                	jns    80011a <umain+0xc2>
		panic("error forking");
  8000fe:	c7 44 24 08 23 1f 81 	movl   $0x811f23,0x8(%esp)
  800105:	00 
  800106:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
  80010d:	00 
  80010e:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  800115:	e8 fa 07 00 00       	call   800914 <_panic>
	else if (output_envid == 0) {
  80011a:	85 c0                	test   %eax,%eax
  80011c:	75 0a                	jne    800128 <umain+0xd0>
		output(ns_envid);
  80011e:	89 1c 24             	mov    %ebx,(%esp)
  800121:	e8 32 07 00 00       	call   800858 <output>
		return;
  800126:	eb 2e                	jmp    800156 <umain+0xfe>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  800128:	e8 03 d8 00 00       	call   80d930 <thread_init>
	thread_create(0, "main", tmain, 0);
  80012d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800134:	00 
  800135:	c7 44 24 08 14 07 80 	movl   $0x800714,0x8(%esp)
  80013c:	00 
  80013d:	c7 44 24 04 3c 1f 81 	movl   $0x811f3c,0x4(%esp)
  800144:	00 
  800145:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80014c:	e8 c6 d9 00 00       	call   80db17 <thread_create>
	thread_yield();
  800151:	e8 7a d8 00 00       	call   80d9d0 <thread_yield>
	// never coming here!
}
  800156:	83 c4 14             	add    $0x14,%esp
  800159:	5b                   	pop    %ebx
  80015a:	5d                   	pop    %ebp
  80015b:	c3                   	ret    

0080015c <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80015c:	55                   	push   %ebp
  80015d:	89 e5                	mov    %esp,%ebp
  80015f:	57                   	push   %edi
  800160:	56                   	push   %esi
  800161:	53                   	push   %ebx
  800162:	83 ec 3c             	sub    $0x3c,%esp
  800165:	bb 00 00 00 00       	mov    $0x0,%ebx
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80016a:	8d 7d e0             	lea    -0x20(%ebp),%edi
  80016d:	eb 08                	jmp    800177 <serve+0x1b>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  80016f:	e8 5c d8 00 00       	call   80d9d0 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800174:	83 c3 01             	add    $0x1,%ebx
  800177:	e8 05 d8 00 00       	call   80d981 <thread_wakeups_pending>
  80017c:	85 c0                	test   %eax,%eax
  80017e:	74 05                	je     800185 <serve+0x29>
  800180:	83 fb 1f             	cmp    $0x1f,%ebx
  800183:	7e ea                	jle    80016f <serve+0x13>
			thread_yield();

		perm = 0;
  800185:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
		if (!buse[i]) break;
  80018c:	83 3d 40 60 81 00 00 	cmpl   $0x0,0x816040
  800193:	74 3b                	je     8001d0 <serve+0x74>
  800195:	b8 01 00 00 00       	mov    $0x1,%eax
  80019a:	ba 40 60 81 00       	mov    $0x816040,%edx
  80019f:	83 3c 82 00          	cmpl   $0x0,(%edx,%eax,4)
  8001a3:	74 0a                	je     8001af <serve+0x53>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8001a5:	83 c0 01             	add    $0x1,%eax
  8001a8:	83 f8 14             	cmp    $0x14,%eax
  8001ab:	75 f2                	jne    80019f <serve+0x43>
  8001ad:	eb 05                	jmp    8001b4 <serve+0x58>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8001af:	83 f8 14             	cmp    $0x14,%eax
  8001b2:	75 21                	jne    8001d5 <serve+0x79>
		panic("NS: buffer overflow");
  8001b4:	c7 44 24 08 41 1f 81 	movl   $0x811f41,0x8(%esp)
  8001bb:	00 
  8001bc:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8001c3:	00 
  8001c4:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  8001cb:	e8 44 07 00 00       	call   800914 <_panic>
  8001d0:	b8 00 00 00 00       	mov    $0x0,%eax
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8001d5:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  8001db:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  8001de:	c7 04 85 40 60 81 00 	movl   $0x1,0x816040(,%eax,4)
  8001e5:	01 00 00 00 
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8001e9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8001ed:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8001f1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8001f4:	89 04 24             	mov    %eax,(%esp)
  8001f7:	e8 03 1c 00 00       	call   801dff <ipc_recv>
  8001fc:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  8001fe:	83 f8 0c             	cmp    $0xc,%eax
  800201:	75 67                	jne    80026a <serve+0x10e>
			process_timer(whom);
  800203:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800206:	3b 35 24 60 81 00    	cmp    0x816024,%esi
  80020c:	74 12                	je     800220 <serve+0xc4>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80020e:	89 74 24 04          	mov    %esi,0x4(%esp)
  800212:	c7 04 24 d0 1f 81 00 	movl   $0x811fd0,(%esp)
  800219:	e8 af 07 00 00       	call   8009cd <cprintf>
  80021e:	eb 39                	jmp    800259 <serve+0xfd>
		return;
	}

	start = sys_time_msec();
  800220:	e8 85 13 00 00       	call   8015aa <sys_time_msec>
  800225:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800228:	e8 a3 d7 00 00       	call   80d9d0 <thread_yield>
	now = sys_time_msec();
  80022d:	e8 78 13 00 00       	call   8015aa <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  800232:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800239:	00 
  80023a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800241:	00 
  800242:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800245:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  80024b:	29 c2                	sub    %eax,%edx
  80024d:	89 54 24 04          	mov    %edx,0x4(%esp)
  800251:	89 34 24             	mov    %esi,(%esp)
  800254:	e8 3b 1b 00 00       	call   801d94 <ipc_send>
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
  800259:	89 d8                	mov    %ebx,%eax
  80025b:	e8 e0 fd ff ff       	call   800040 <put_buffer>
  800260:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue;
  800265:	e9 0d ff ff ff       	jmp    800177 <serve+0x1b>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80026a:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80026e:	66 90                	xchg   %ax,%ax
  800270:	75 1d                	jne    80028f <serve+0x133>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800272:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800275:	89 44 24 04          	mov    %eax,0x4(%esp)
  800279:	c7 04 24 0c 20 81 00 	movl   $0x81200c,(%esp)
  800280:	e8 48 07 00 00       	call   8009cd <cprintf>
  800285:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue; // just leave it hanging...
  80028a:	e9 e8 fe ff ff       	jmp    800177 <serve+0x1b>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  80028f:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  800296:	e8 c8 2a 00 00       	call   802d63 <malloc>
		if (!args)
  80029b:	85 c0                	test   %eax,%eax
  80029d:	75 1c                	jne    8002bb <serve+0x15f>
			panic("could not allocate thread args structure");
  80029f:	c7 44 24 08 3c 20 81 	movl   $0x81203c,0x8(%esp)
  8002a6:	00 
  8002a7:	c7 44 24 04 26 01 00 	movl   $0x126,0x4(%esp)
  8002ae:	00 
  8002af:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  8002b6:	e8 59 06 00 00       	call   800914 <_panic>

		args->reqno = reqno;
  8002bb:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8002bd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8002c0:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8002c3:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8002c6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8002ca:	c7 44 24 08 f5 02 80 	movl   $0x8002f5,0x8(%esp)
  8002d1:	00 
  8002d2:	c7 44 24 04 55 1f 81 	movl   $0x811f55,0x4(%esp)
  8002d9:	00 
  8002da:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8002e1:	e8 31 d8 00 00       	call   80db17 <thread_create>
		thread_yield(); // let the thread created run
  8002e6:	e8 e5 d6 00 00       	call   80d9d0 <thread_yield>
  8002eb:	bb 00 00 00 00       	mov    $0x0,%ebx
  8002f0:	e9 82 fe ff ff       	jmp    800177 <serve+0x1b>

008002f5 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8002f5:	55                   	push   %ebp
  8002f6:	89 e5                	mov    %esp,%ebp
  8002f8:	81 ec 98 00 00 00    	sub    $0x98,%esp
  8002fe:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  800301:	89 75 f8             	mov    %esi,-0x8(%ebp)
  800304:	89 7d fc             	mov    %edi,-0x4(%ebp)
	struct st_args *args = (struct st_args *)a;
  800307:	8b 5d 08             	mov    0x8(%ebp),%ebx
	union Nsipc *req = args->req;
  80030a:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  80030d:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800310:	0f 87 34 01 00 00    	ja     80044a <serve_thread+0x155>
  800316:	8b 03                	mov    (%ebx),%eax
  800318:	ff 24 85 08 21 81 00 	jmp    *0x812108(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  80031f:	8d 45 94             	lea    -0x6c(%ebp),%eax
  800322:	89 44 24 08          	mov    %eax,0x8(%esp)
  800326:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800329:	89 44 24 04          	mov    %eax,0x4(%esp)
  80032d:	8b 06                	mov    (%esi),%eax
  80032f:	89 04 24             	mov    %eax,(%esp)
  800332:	e8 a0 44 00 00       	call   8047d7 <lwip_accept>
  800337:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  800339:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  800340:	00 
  800341:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800344:	89 44 24 04          	mov    %eax,0x4(%esp)
  800348:	89 34 24             	mov    %esi,(%esp)
  80034b:	e8 a5 0f 00 00       	call   8012f5 <memmove>
		break;
  800350:	e9 13 01 00 00       	jmp    800468 <serve_thread+0x173>
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800355:	8b 46 14             	mov    0x14(%esi),%eax
  800358:	89 44 24 08          	mov    %eax,0x8(%esp)
  80035c:	8d 46 04             	lea    0x4(%esi),%eax
  80035f:	89 44 24 04          	mov    %eax,0x4(%esp)
  800363:	8b 06                	mov    (%esi),%eax
  800365:	89 04 24             	mov    %eax,(%esp)
  800368:	e8 b1 43 00 00       	call   80471e <lwip_bind>
  80036d:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  80036f:	e9 f4 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800374:	8b 46 04             	mov    0x4(%esi),%eax
  800377:	89 44 24 04          	mov    %eax,0x4(%esp)
  80037b:	8b 06                	mov    (%esi),%eax
  80037d:	89 04 24             	mov    %eax,(%esp)
  800380:	e8 3f 42 00 00       	call   8045c4 <lwip_shutdown>
  800385:	89 c7                	mov    %eax,%edi
		break;
  800387:	e9 dc 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  80038c:	8b 06                	mov    (%esi),%eax
  80038e:	89 04 24             	mov    %eax,(%esp)
  800391:	e8 b2 41 00 00       	call   804548 <lwip_close>
  800396:	89 c7                	mov    %eax,%edi
		break;
  800398:	e9 cb 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80039d:	8b 46 14             	mov    0x14(%esi),%eax
  8003a0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003a4:	8d 46 04             	lea    0x4(%esi),%eax
  8003a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003ab:	8b 06                	mov    (%esi),%eax
  8003ad:	89 04 24             	mov    %eax,(%esp)
  8003b0:	e8 b0 42 00 00       	call   804665 <lwip_connect>
  8003b5:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  8003b7:	e9 ac 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8003bc:	8b 46 04             	mov    0x4(%esi),%eax
  8003bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003c3:	8b 06                	mov    (%esi),%eax
  8003c5:	89 04 24             	mov    %eax,(%esp)
  8003c8:	e8 0a 42 00 00       	call   8045d7 <lwip_listen>
  8003cd:	89 c7                	mov    %eax,%edi
		break;
  8003cf:	e9 94 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8003d4:	8b 46 08             	mov    0x8(%esi),%eax
  8003d7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003db:	8b 46 04             	mov    0x4(%esi),%eax
  8003de:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003e2:	89 74 24 04          	mov    %esi,0x4(%esp)
  8003e6:	8b 06                	mov    (%esi),%eax
  8003e8:	89 04 24             	mov    %eax,(%esp)
  8003eb:	e8 e7 40 00 00       	call   8044d7 <lwip_recv>
  8003f0:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  8003f2:	eb 74                	jmp    800468 <serve_thread+0x173>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8003f4:	8b 46 08             	mov    0x8(%esi),%eax
  8003f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003fb:	8b 46 04             	mov    0x4(%esi),%eax
  8003fe:	89 44 24 08          	mov    %eax,0x8(%esp)
  800402:	8d 46 0c             	lea    0xc(%esi),%eax
  800405:	89 44 24 04          	mov    %eax,0x4(%esp)
  800409:	8b 06                	mov    (%esi),%eax
  80040b:	89 04 24             	mov    %eax,(%esp)
  80040e:	e8 47 3c 00 00       	call   80405a <lwip_send>
  800413:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  800415:	eb 51                	jmp    800468 <serve_thread+0x173>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800417:	8b 46 08             	mov    0x8(%esi),%eax
  80041a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80041e:	8b 46 04             	mov    0x4(%esi),%eax
  800421:	89 44 24 04          	mov    %eax,0x4(%esp)
  800425:	8b 06                	mov    (%esi),%eax
  800427:	89 04 24             	mov    %eax,(%esp)
  80042a:	e8 40 3b 00 00       	call   803f6f <lwip_socket>
  80042f:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  800431:	eb 35                	jmp    800468 <serve_thread+0x173>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800433:	89 74 24 04          	mov    %esi,0x4(%esp)
  800437:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  80043e:	e8 17 db 00 00       	call   80df5a <jif_input>
  800443:	bf 00 00 00 00       	mov    $0x0,%edi
		r = 0;
		break;
  800448:	eb 4c                	jmp    800496 <serve_thread+0x1a1>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80044a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80044e:	8b 43 04             	mov    0x4(%ebx),%eax
  800451:	89 44 24 04          	mov    %eax,0x4(%esp)
  800455:	c7 04 24 68 20 81 00 	movl   $0x812068,(%esp)
  80045c:	e8 6c 05 00 00       	call   8009cd <cprintf>
  800461:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800466:	eb 2e                	jmp    800496 <serve_thread+0x1a1>
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800468:	83 ff ff             	cmp    $0xffffffff,%edi
  80046b:	75 29                	jne    800496 <serve_thread+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  80046d:	8b 03                	mov    (%ebx),%eax
  80046f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800473:	c7 44 24 08 62 1f 81 	movl   $0x811f62,0x8(%esp)
  80047a:	00 
  80047b:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  800482:	00 
  800483:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800486:	89 34 24             	mov    %esi,(%esp)
  800489:	e8 da 0b 00 00       	call   801068 <snprintf>
		perror(buf);
  80048e:	89 34 24             	mov    %esi,(%esp)
  800491:	e8 91 d8 00 00       	call   80dd27 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  800496:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800499:	74 1f                	je     8004ba <serve_thread+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  80049b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8004a2:	00 
  8004a3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8004aa:	00 
  8004ab:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8004af:	8b 43 04             	mov    0x4(%ebx),%eax
  8004b2:	89 04 24             	mov    %eax,(%esp)
  8004b5:	e8 da 18 00 00       	call   801d94 <ipc_send>

	put_buffer(args->req);
  8004ba:	8b 43 08             	mov    0x8(%ebx),%eax
  8004bd:	e8 7e fb ff ff       	call   800040 <put_buffer>
	sys_page_unmap(0, (void*) args->req);
  8004c2:	8b 43 08             	mov    0x8(%ebx),%eax
  8004c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8004c9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8004d0:	e8 27 12 00 00       	call   8016fc <sys_page_unmap>
	free(args);
  8004d5:	89 1c 24             	mov    %ebx,(%esp)
  8004d8:	e8 b3 27 00 00       	call   802c90 <free>
}
  8004dd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8004e0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8004e3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8004e6:	89 ec                	mov    %ebp,%esp
  8004e8:	5d                   	pop    %ebp
  8004e9:	c3                   	ret    

008004ea <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  8004ea:	55                   	push   %ebp
  8004eb:	89 e5                	mov    %esp,%ebp
  8004ed:	56                   	push   %esi
  8004ee:	53                   	push   %ebx
  8004ef:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  8004f2:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  8004f5:	e8 b0 10 00 00       	call   8015aa <sys_time_msec>
  8004fa:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  8004fc:	e8 f8 ca 00 00       	call   80cff9 <lwip_core_lock>
		t->func();
  800501:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  800504:	e8 f5 ca 00 00       	call   80cffe <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  800509:	03 33                	add    (%ebx),%esi
  80050b:	89 74 24 08          	mov    %esi,0x8(%esp)
  80050f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800516:	00 
  800517:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80051e:	e8 3c d7 00 00       	call   80dc5f <thread_wait>
  800523:	eb d0                	jmp    8004f5 <net_timer+0xb>

00800525 <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800525:	55                   	push   %ebp
  800526:	89 e5                	mov    %esp,%ebp
  800528:	53                   	push   %ebx
  800529:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  80052c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80052f:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800531:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800534:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800537:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80053b:	c7 44 24 08 ea 04 80 	movl   $0x8004ea,0x8(%esp)
  800542:	00 
  800543:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800547:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80054e:	e8 c4 d5 00 00       	call   80db17 <thread_create>
	if (r < 0)
  800553:	85 c0                	test   %eax,%eax
  800555:	79 28                	jns    80057f <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  800557:	89 04 24             	mov    %eax,(%esp)
  80055a:	e8 b9 d7 00 00       	call   80dd18 <e2s>
  80055f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800563:	c7 44 24 08 8c 20 81 	movl   $0x81208c,0x8(%esp)
  80056a:	00 
  80056b:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  800572:	00 
  800573:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  80057a:	e8 95 03 00 00       	call   800914 <_panic>
}
  80057f:	83 c4 14             	add    $0x14,%esp
  800582:	5b                   	pop    %ebx
  800583:	5d                   	pop    %ebp
  800584:	c3                   	ret    

00800585 <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800585:	55                   	push   %ebp
  800586:	89 e5                	mov    %esp,%ebp
  800588:	56                   	push   %esi
  800589:	53                   	push   %ebx
  80058a:	83 ec 30             	sub    $0x30,%esp
  80058d:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800590:	e8 64 ca 00 00       	call   80cff9 <lwip_core_lock>

	uint32_t done = 0;
  800595:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  80059c:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80059f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8005a3:	c7 04 24 67 07 80 00 	movl   $0x800767,(%esp)
  8005aa:	e8 14 44 00 00       	call   8049c3 <tcpip_init>
	lwip_core_unlock();
  8005af:	e8 4a ca 00 00       	call   80cffe <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8005b4:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  8005bb:	ff 
  8005bc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8005c3:	00 
  8005c4:	89 1c 24             	mov    %ebx,(%esp)
  8005c7:	e8 93 d6 00 00       	call   80dc5f <thread_wait>
	lwip_core_lock();
  8005cc:	e8 28 ca 00 00       	call   80cff9 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8005d1:	89 75 f0             	mov    %esi,-0x10(%ebp)
	netmask.addr = init_mask;
  8005d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8005d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8005da:	8b 45 10             	mov    0x10(%ebp),%eax
  8005dd:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8005e0:	c7 44 24 18 34 96 80 	movl   $0x809634,0x18(%esp)
  8005e7:	00 
  8005e8:	c7 44 24 14 60 dd 80 	movl   $0x80dd60,0x14(%esp)
  8005ef:	00 
  8005f0:	c7 44 24 10 2c 60 81 	movl   $0x81602c,0x10(%esp)
  8005f7:	00 
  8005f8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8005fb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005ff:	8d 45 ec             	lea    -0x14(%ebp),%eax
  800602:	89 44 24 08          	mov    %eax,0x8(%esp)
  800606:	8d 45 f0             	lea    -0x10(%ebp),%eax
  800609:	89 44 24 04          	mov    %eax,0x4(%esp)
  80060d:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  800614:	e8 78 6e 00 00       	call   807491 <netif_add>
  800619:	85 c0                	test   %eax,%eax
  80061b:	75 1c                	jne    800639 <serve_init+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  80061d:	c7 44 24 08 ac 20 81 	movl   $0x8120ac,0x8(%esp)
  800624:	00 
  800625:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  80062c:	00 
  80062d:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  800634:	e8 db 02 00 00       	call   800914 <_panic>

	netif_set_default(nif);
  800639:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  800640:	e8 cc 6c 00 00       	call   807311 <netif_set_default>
	netif_set_up(nif);
  800645:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  80064c:	e8 4d 6d 00 00       	call   80739e <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800651:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800658:	b9 71 1f 81 00       	mov    $0x811f71,%ecx
  80065d:	ba 99 ca 80 00       	mov    $0x80ca99,%edx
  800662:	b8 00 60 81 00       	mov    $0x816000,%eax
  800667:	e8 b9 fe ff ff       	call   800525 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80066c:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  800673:	b9 7b 1f 81 00       	mov    $0x811f7b,%ecx
  800678:	ba 2c 84 80 00       	mov    $0x80842c,%edx
  80067d:	b8 0c 60 81 00       	mov    $0x81600c,%eax
  800682:	e8 9e fe ff ff       	call   800525 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800687:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80068e:	b9 87 1f 81 00       	mov    $0x811f87,%ecx
  800693:	ba 5e 8d 80 00       	mov    $0x808d5e,%edx
  800698:	b8 18 60 81 00       	mov    $0x816018,%eax
  80069d:	e8 83 fe ff ff       	call   800525 <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8006a2:	89 34 24             	mov    %esi,(%esp)
  8006a5:	e8 f6 9f 00 00       	call   80a6a0 <inet_ntoa>
  8006aa:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  8006ae:	0f b6 05 6a c2 b3 00 	movzbl 0xb3c26a,%eax
  8006b5:	89 44 24 18          	mov    %eax,0x18(%esp)
  8006b9:	0f b6 05 69 c2 b3 00 	movzbl 0xb3c269,%eax
  8006c0:	89 44 24 14          	mov    %eax,0x14(%esp)
  8006c4:	0f b6 05 68 c2 b3 00 	movzbl 0xb3c268,%eax
  8006cb:	89 44 24 10          	mov    %eax,0x10(%esp)
  8006cf:	0f b6 05 67 c2 b3 00 	movzbl 0xb3c267,%eax
  8006d6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8006da:	0f b6 05 66 c2 b3 00 	movzbl 0xb3c266,%eax
  8006e1:	89 44 24 08          	mov    %eax,0x8(%esp)
  8006e5:	0f b6 05 65 c2 b3 00 	movzbl 0xb3c265,%eax
  8006ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  8006f0:	c7 04 24 cc 20 81 00 	movl   $0x8120cc,(%esp)
  8006f7:	e8 d1 02 00 00       	call   8009cd <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8006fc:	e8 fd c8 00 00       	call   80cffe <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  800701:	c7 04 24 93 1f 81 00 	movl   $0x811f93,(%esp)
  800708:	e8 c0 02 00 00       	call   8009cd <cprintf>
}
  80070d:	83 c4 30             	add    $0x30,%esp
  800710:	5b                   	pop    %ebx
  800711:	5e                   	pop    %esi
  800712:	5d                   	pop    %ebp
  800713:	c3                   	ret    

00800714 <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  800714:	55                   	push   %ebp
  800715:	89 e5                	mov    %esp,%ebp
  800717:	83 ec 18             	sub    $0x18,%esp
  80071a:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80071d:	89 75 fc             	mov    %esi,-0x4(%ebp)
	serve_init(inet_addr(IP),
  800720:	c7 04 24 ac 1f 81 00 	movl   $0x811fac,(%esp)
  800727:	e8 64 a2 00 00       	call   80a990 <inet_addr>
  80072c:	89 c3                	mov    %eax,%ebx
  80072e:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  800735:	e8 56 a2 00 00       	call   80a990 <inet_addr>
  80073a:	89 c6                	mov    %eax,%esi
  80073c:	c7 04 24 c3 1f 81 00 	movl   $0x811fc3,(%esp)
  800743:	e8 48 a2 00 00       	call   80a990 <inet_addr>
  800748:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80074c:	89 74 24 04          	mov    %esi,0x4(%esp)
  800750:	89 04 24             	mov    %eax,(%esp)
  800753:	e8 2d fe ff ff       	call   800585 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800758:	e8 ff f9 ff ff       	call   80015c <serve>
}
  80075d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  800760:	8b 75 fc             	mov    -0x4(%ebp),%esi
  800763:	89 ec                	mov    %ebp,%esp
  800765:	5d                   	pop    %ebp
  800766:	c3                   	ret    

00800767 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800767:	55                   	push   %ebp
  800768:	89 e5                	mov    %esp,%ebp
  80076a:	83 ec 18             	sub    $0x18,%esp
  80076d:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800770:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800776:	89 04 24             	mov    %eax,(%esp)
  800779:	e8 e1 d1 00 00       	call   80d95f <thread_wakeup>
}
  80077e:	c9                   	leave  
  80077f:	c3                   	ret    

00800780 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800780:	55                   	push   %ebp
  800781:	89 e5                	mov    %esp,%ebp
  800783:	57                   	push   %edi
  800784:	56                   	push   %esi
  800785:	53                   	push   %ebx
  800786:	83 ec 2c             	sub    $0x2c,%esp
  800789:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80078c:	e8 19 0e 00 00       	call   8015aa <sys_time_msec>
  800791:	89 c3                	mov    %eax,%ebx
  800793:	03 5d 0c             	add    0xc(%ebp),%ebx

	binaryname = "ns_timer";
  800796:	c7 05 00 50 81 00 34 	movl   $0x812134,0x815000
  80079d:	21 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007a0:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  8007a3:	eb 05                	jmp    8007aa <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  8007a5:	e8 fa 0f 00 00       	call   8017a4 <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  8007aa:	e8 fb 0d 00 00       	call   8015aa <sys_time_msec>
  8007af:	39 c3                	cmp    %eax,%ebx
  8007b1:	76 07                	jbe    8007ba <timer+0x3a>
  8007b3:	85 c0                	test   %eax,%eax
  8007b5:	79 ee                	jns    8007a5 <timer+0x25>
  8007b7:	90                   	nop
  8007b8:	eb 08                	jmp    8007c2 <timer+0x42>
			sys_yield();
		}
		if (r < 0)
  8007ba:	85 c0                	test   %eax,%eax
  8007bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8007c0:	79 20                	jns    8007e2 <timer+0x62>
			panic("sys_time_msec: %e", r);
  8007c2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8007c6:	c7 44 24 08 3d 21 81 	movl   $0x81213d,0x8(%esp)
  8007cd:	00 
  8007ce:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  8007d5:	00 
  8007d6:	c7 04 24 4f 21 81 00 	movl   $0x81214f,(%esp)
  8007dd:	e8 32 01 00 00       	call   800914 <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007e2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007e9:	00 
  8007ea:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007f1:	00 
  8007f2:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007f9:	00 
  8007fa:	89 34 24             	mov    %esi,(%esp)
  8007fd:	e8 92 15 00 00       	call   801d94 <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800802:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800809:	00 
  80080a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800811:	00 
  800812:	89 3c 24             	mov    %edi,(%esp)
  800815:	e8 e5 15 00 00       	call   801dff <ipc_recv>
  80081a:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  80081c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80081f:	39 c6                	cmp    %eax,%esi
  800821:	74 12                	je     800835 <timer+0xb5>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800823:	89 44 24 04          	mov    %eax,0x4(%esp)
  800827:	c7 04 24 5c 21 81 00 	movl   $0x81215c,(%esp)
  80082e:	e8 9a 01 00 00       	call   8009cd <cprintf>
				continue;
			}

			stop = sys_time_msec() + to;
			break;
		}
  800833:	eb cd                	jmp    800802 <timer+0x82>
			if (whom != ns_envid) {
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  800835:	e8 70 0d 00 00       	call   8015aa <sys_time_msec>
  80083a:	01 c3                	add    %eax,%ebx
  80083c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800840:	e9 65 ff ff ff       	jmp    8007aa <timer+0x2a>
  800845:	00 00                	add    %al,(%eax)
	...

00800848 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  800848:	55                   	push   %ebp
  800849:	89 e5                	mov    %esp,%ebp
	binaryname = "ns_input";
  80084b:	c7 05 00 50 81 00 97 	movl   $0x812197,0x815000
  800852:	21 81 00 
	// 	- read a packet from the device driver
	//	- send it to the network server
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
}
  800855:	5d                   	pop    %ebp
  800856:	c3                   	ret    
	...

00800858 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  800858:	55                   	push   %ebp
  800859:	89 e5                	mov    %esp,%ebp
  80085b:	56                   	push   %esi
  80085c:	53                   	push   %ebx
  80085d:	83 ec 10             	sub    $0x10,%esp
  800860:	8b 75 08             	mov    0x8(%ebp),%esi
	binaryname = "ns_output";
  800863:	c7 05 00 50 81 00 a0 	movl   $0x8121a0,0x815000
  80086a:	21 81 00 
	// 	- read a packet from the network server
	//	- send the packet to the device driver
    int r;

    while (1) {
        r = sys_ipc_recv(&nsipcbuf);
  80086d:	bb 00 e0 b3 00       	mov    $0xb3e000,%ebx
  800872:	89 1c 24             	mov    %ebx,(%esp)
  800875:	e8 6b 0d 00 00       	call   8015e5 <sys_ipc_recv>
        if ((thisenv->env_ipc_from != ns_envid) ||
  80087a:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  80087f:	8b 50 74             	mov    0x74(%eax),%edx
  800882:	39 f2                	cmp    %esi,%edx
  800884:	75 ec                	jne    800872 <output+0x1a>
            (thisenv->env_ipc_value != NSREQ_OUTPUT)) {
  800886:	8b 40 70             	mov    0x70(%eax),%eax
	//	- send the packet to the device driver
    int r;

    while (1) {
        r = sys_ipc_recv(&nsipcbuf);
        if ((thisenv->env_ipc_from != ns_envid) ||
  800889:	83 f8 0b             	cmp    $0xb,%eax
  80088c:	75 e4                	jne    800872 <output+0x1a>
            (thisenv->env_ipc_value != NSREQ_OUTPUT)) {
            continue;
        }

        while ((r = sys_net_try_send(nsipcbuf.pkt.jp_data,
  80088e:	8b 03                	mov    (%ebx),%eax
  800890:	89 44 24 04          	mov    %eax,0x4(%esp)
  800894:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  80089b:	e8 d2 0c 00 00       	call   801572 <sys_net_try_send>
  8008a0:	85 c0                	test   %eax,%eax
  8008a2:	78 ea                	js     80088e <output+0x36>
  8008a4:	eb cc                	jmp    800872 <output+0x1a>
	...

008008a8 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  8008a8:	55                   	push   %ebp
  8008a9:	89 e5                	mov    %esp,%ebp
  8008ab:	83 ec 18             	sub    $0x18,%esp
  8008ae:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8008b1:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8008b4:	8b 75 08             	mov    0x8(%ebp),%esi
  8008b7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = envs + ENVX(sys_getenvid ());
  8008ba:	e8 58 0f 00 00       	call   801817 <sys_getenvid>
  8008bf:	25 ff 03 00 00       	and    $0x3ff,%eax
  8008c4:	6b c0 7c             	imul   $0x7c,%eax,%eax
  8008c7:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  8008cc:	a3 74 c2 b3 00       	mov    %eax,0xb3c274

	// save the name of the program so that panic() can use it
	if (argc > 0)
  8008d1:	85 f6                	test   %esi,%esi
  8008d3:	7e 07                	jle    8008dc <libmain+0x34>
		binaryname = argv[0];
  8008d5:	8b 03                	mov    (%ebx),%eax
  8008d7:	a3 00 50 81 00       	mov    %eax,0x815000

	// call user main routine
	umain(argc, argv);
  8008dc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8008e0:	89 34 24             	mov    %esi,(%esp)
  8008e3:	e8 70 f7 ff ff       	call   800058 <umain>

	// exit gracefully
	exit();
  8008e8:	e8 0b 00 00 00       	call   8008f8 <exit>
}
  8008ed:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8008f0:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8008f3:	89 ec                	mov    %ebp,%esp
  8008f5:	5d                   	pop    %ebp
  8008f6:	c3                   	ret    
	...

008008f8 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  8008f8:	55                   	push   %ebp
  8008f9:	89 e5                	mov    %esp,%ebp
  8008fb:	83 ec 18             	sub    $0x18,%esp
	close_all();
  8008fe:	e8 76 1a 00 00       	call   802379 <close_all>
	sys_env_destroy(0);
  800903:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80090a:	e8 43 0f 00 00       	call   801852 <sys_env_destroy>
}
  80090f:	c9                   	leave  
  800910:	c3                   	ret    
  800911:	00 00                	add    %al,(%eax)
	...

00800914 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  800914:	55                   	push   %ebp
  800915:	89 e5                	mov    %esp,%ebp
  800917:	56                   	push   %esi
  800918:	53                   	push   %ebx
  800919:	83 ec 20             	sub    $0x20,%esp
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
  80091c:	8d 75 14             	lea    0x14(%ebp),%esi
	va_list ap;

	va_start(ap, fmt);

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80091f:	8b 1d 00 50 81 00    	mov    0x815000,%ebx
  800925:	e8 ed 0e 00 00       	call   801817 <sys_getenvid>
  80092a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80092d:	89 54 24 10          	mov    %edx,0x10(%esp)
  800931:	8b 55 08             	mov    0x8(%ebp),%edx
  800934:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800938:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80093c:	89 44 24 04          	mov    %eax,0x4(%esp)
  800940:	c7 04 24 b4 21 81 00 	movl   $0x8121b4,(%esp)
  800947:	e8 81 00 00 00       	call   8009cd <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80094c:	89 74 24 04          	mov    %esi,0x4(%esp)
  800950:	8b 45 10             	mov    0x10(%ebp),%eax
  800953:	89 04 24             	mov    %eax,(%esp)
  800956:	e8 11 00 00 00       	call   80096c <vcprintf>
	cprintf("\n");
  80095b:	c7 04 24 aa 1f 81 00 	movl   $0x811faa,(%esp)
  800962:	e8 66 00 00 00       	call   8009cd <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  800967:	cc                   	int3   
  800968:	eb fd                	jmp    800967 <_panic+0x53>
	...

0080096c <vcprintf>:
	b->cnt++;
}

int
vcprintf(const char *fmt, va_list ap)
{
  80096c:	55                   	push   %ebp
  80096d:	89 e5                	mov    %esp,%ebp
  80096f:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  800975:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80097c:	00 00 00 
	b.cnt = 0;
  80097f:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  800986:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  800989:	8b 45 0c             	mov    0xc(%ebp),%eax
  80098c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800990:	8b 45 08             	mov    0x8(%ebp),%eax
  800993:	89 44 24 08          	mov    %eax,0x8(%esp)
  800997:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80099d:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009a1:	c7 04 24 e7 09 80 00 	movl   $0x8009e7,(%esp)
  8009a8:	e8 d0 01 00 00       	call   800b7d <vprintfmt>
	sys_cputs(b.buf, b.idx);
  8009ad:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  8009b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009b7:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  8009bd:	89 04 24             	mov    %eax,(%esp)
  8009c0:	e8 01 0f 00 00       	call   8018c6 <sys_cputs>

	return b.cnt;
}
  8009c5:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  8009cb:	c9                   	leave  
  8009cc:	c3                   	ret    

008009cd <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8009cd:	55                   	push   %ebp
  8009ce:	89 e5                	mov    %esp,%ebp
  8009d0:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
cprintf(const char *fmt, ...)
  8009d3:	8d 45 0c             	lea    0xc(%ebp),%eax
{
	va_list ap;
	int cnt;

	va_start(ap, fmt);
	cnt = vcprintf(fmt, ap);
  8009d6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009da:	8b 45 08             	mov    0x8(%ebp),%eax
  8009dd:	89 04 24             	mov    %eax,(%esp)
  8009e0:	e8 87 ff ff ff       	call   80096c <vcprintf>
	va_end(ap);

	return cnt;
}
  8009e5:	c9                   	leave  
  8009e6:	c3                   	ret    

008009e7 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  8009e7:	55                   	push   %ebp
  8009e8:	89 e5                	mov    %esp,%ebp
  8009ea:	53                   	push   %ebx
  8009eb:	83 ec 14             	sub    $0x14,%esp
  8009ee:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  8009f1:	8b 03                	mov    (%ebx),%eax
  8009f3:	8b 55 08             	mov    0x8(%ebp),%edx
  8009f6:	88 54 03 08          	mov    %dl,0x8(%ebx,%eax,1)
  8009fa:	83 c0 01             	add    $0x1,%eax
  8009fd:	89 03                	mov    %eax,(%ebx)
	if (b->idx == 256-1) {
  8009ff:	3d ff 00 00 00       	cmp    $0xff,%eax
  800a04:	75 19                	jne    800a1f <putch+0x38>
		sys_cputs(b->buf, b->idx);
  800a06:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  800a0d:	00 
  800a0e:	8d 43 08             	lea    0x8(%ebx),%eax
  800a11:	89 04 24             	mov    %eax,(%esp)
  800a14:	e8 ad 0e 00 00       	call   8018c6 <sys_cputs>
		b->idx = 0;
  800a19:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  800a1f:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  800a23:	83 c4 14             	add    $0x14,%esp
  800a26:	5b                   	pop    %ebx
  800a27:	5d                   	pop    %ebp
  800a28:	c3                   	ret    
  800a29:	00 00                	add    %al,(%eax)
  800a2b:	00 00                	add    %al,(%eax)
  800a2d:	00 00                	add    %al,(%eax)
	...

00800a30 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800a30:	55                   	push   %ebp
  800a31:	89 e5                	mov    %esp,%ebp
  800a33:	57                   	push   %edi
  800a34:	56                   	push   %esi
  800a35:	53                   	push   %ebx
  800a36:	83 ec 4c             	sub    $0x4c,%esp
  800a39:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800a3c:	89 d6                	mov    %edx,%esi
  800a3e:	8b 45 08             	mov    0x8(%ebp),%eax
  800a41:	89 45 d8             	mov    %eax,-0x28(%ebp)
  800a44:	8b 55 0c             	mov    0xc(%ebp),%edx
  800a47:	89 55 e0             	mov    %edx,-0x20(%ebp)
  800a4a:	8b 45 10             	mov    0x10(%ebp),%eax
  800a4d:	8b 5d 14             	mov    0x14(%ebp),%ebx
  800a50:	8b 7d 18             	mov    0x18(%ebp),%edi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800a53:	89 45 dc             	mov    %eax,-0x24(%ebp)
  800a56:	b9 00 00 00 00       	mov    $0x0,%ecx
  800a5b:	39 d1                	cmp    %edx,%ecx
  800a5d:	72 15                	jb     800a74 <printnum+0x44>
  800a5f:	77 07                	ja     800a68 <printnum+0x38>
  800a61:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800a64:	39 d0                	cmp    %edx,%eax
  800a66:	76 0c                	jbe    800a74 <printnum+0x44>
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800a68:	83 eb 01             	sub    $0x1,%ebx
  800a6b:	85 db                	test   %ebx,%ebx
  800a6d:	8d 76 00             	lea    0x0(%esi),%esi
  800a70:	7f 61                	jg     800ad3 <printnum+0xa3>
  800a72:	eb 70                	jmp    800ae4 <printnum+0xb4>
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800a74:	89 7c 24 10          	mov    %edi,0x10(%esp)
  800a78:	83 eb 01             	sub    $0x1,%ebx
  800a7b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800a7f:	89 44 24 08          	mov    %eax,0x8(%esp)
  800a83:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  800a87:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  800a8b:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  800a8e:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  800a91:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  800a94:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800a98:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800a9f:	00 
  800aa0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800aa3:	89 04 24             	mov    %eax,(%esp)
  800aa6:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800aa9:	89 54 24 04          	mov    %edx,0x4(%esp)
  800aad:	e8 ee 11 01 00       	call   811ca0 <__udivdi3>
  800ab2:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  800ab5:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  800ab8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  800abc:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800ac0:	89 04 24             	mov    %eax,(%esp)
  800ac3:	89 54 24 04          	mov    %edx,0x4(%esp)
  800ac7:	89 f2                	mov    %esi,%edx
  800ac9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800acc:	e8 5f ff ff ff       	call   800a30 <printnum>
  800ad1:	eb 11                	jmp    800ae4 <printnum+0xb4>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  800ad3:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ad7:	89 3c 24             	mov    %edi,(%esp)
  800ada:	ff 55 e4             	call   *-0x1c(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800add:	83 eb 01             	sub    $0x1,%ebx
  800ae0:	85 db                	test   %ebx,%ebx
  800ae2:	7f ef                	jg     800ad3 <printnum+0xa3>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800ae4:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ae8:	8b 74 24 04          	mov    0x4(%esp),%esi
  800aec:	8b 45 dc             	mov    -0x24(%ebp),%eax
  800aef:	89 44 24 08          	mov    %eax,0x8(%esp)
  800af3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800afa:	00 
  800afb:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800afe:	89 14 24             	mov    %edx,(%esp)
  800b01:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800b04:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800b08:	e8 c3 12 01 00       	call   811dd0 <__umoddi3>
  800b0d:	89 74 24 04          	mov    %esi,0x4(%esp)
  800b11:	0f be 80 d7 21 81 00 	movsbl 0x8121d7(%eax),%eax
  800b18:	89 04 24             	mov    %eax,(%esp)
  800b1b:	ff 55 e4             	call   *-0x1c(%ebp)
}
  800b1e:	83 c4 4c             	add    $0x4c,%esp
  800b21:	5b                   	pop    %ebx
  800b22:	5e                   	pop    %esi
  800b23:	5f                   	pop    %edi
  800b24:	5d                   	pop    %ebp
  800b25:	c3                   	ret    

00800b26 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800b26:	55                   	push   %ebp
  800b27:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  800b29:	83 fa 01             	cmp    $0x1,%edx
  800b2c:	7e 0e                	jle    800b3c <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  800b2e:	8b 10                	mov    (%eax),%edx
  800b30:	8d 4a 08             	lea    0x8(%edx),%ecx
  800b33:	89 08                	mov    %ecx,(%eax)
  800b35:	8b 02                	mov    (%edx),%eax
  800b37:	8b 52 04             	mov    0x4(%edx),%edx
  800b3a:	eb 22                	jmp    800b5e <getuint+0x38>
	else if (lflag)
  800b3c:	85 d2                	test   %edx,%edx
  800b3e:	74 10                	je     800b50 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  800b40:	8b 10                	mov    (%eax),%edx
  800b42:	8d 4a 04             	lea    0x4(%edx),%ecx
  800b45:	89 08                	mov    %ecx,(%eax)
  800b47:	8b 02                	mov    (%edx),%eax
  800b49:	ba 00 00 00 00       	mov    $0x0,%edx
  800b4e:	eb 0e                	jmp    800b5e <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  800b50:	8b 10                	mov    (%eax),%edx
  800b52:	8d 4a 04             	lea    0x4(%edx),%ecx
  800b55:	89 08                	mov    %ecx,(%eax)
  800b57:	8b 02                	mov    (%edx),%eax
  800b59:	ba 00 00 00 00       	mov    $0x0,%edx
}
  800b5e:	5d                   	pop    %ebp
  800b5f:	c3                   	ret    

00800b60 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800b60:	55                   	push   %ebp
  800b61:	89 e5                	mov    %esp,%ebp
  800b63:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  800b66:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  800b6a:	8b 10                	mov    (%eax),%edx
  800b6c:	3b 50 04             	cmp    0x4(%eax),%edx
  800b6f:	73 0a                	jae    800b7b <sprintputch+0x1b>
		*b->buf++ = ch;
  800b71:	8b 4d 08             	mov    0x8(%ebp),%ecx
  800b74:	88 0a                	mov    %cl,(%edx)
  800b76:	83 c2 01             	add    $0x1,%edx
  800b79:	89 10                	mov    %edx,(%eax)
}
  800b7b:	5d                   	pop    %ebp
  800b7c:	c3                   	ret    

00800b7d <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800b7d:	55                   	push   %ebp
  800b7e:	89 e5                	mov    %esp,%ebp
  800b80:	57                   	push   %edi
  800b81:	56                   	push   %esi
  800b82:	53                   	push   %ebx
  800b83:	83 ec 5c             	sub    $0x5c,%esp
  800b86:	8b 7d 08             	mov    0x8(%ebp),%edi
  800b89:	8b 75 0c             	mov    0xc(%ebp),%esi
  800b8c:	8b 5d 10             	mov    0x10(%ebp),%ebx
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  800b8f:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
  800b96:	eb 11                	jmp    800ba9 <vprintfmt+0x2c>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  800b98:	85 c0                	test   %eax,%eax
  800b9a:	0f 84 68 04 00 00    	je     801008 <vprintfmt+0x48b>
				return;
			putch(ch, putdat);
  800ba0:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ba4:	89 04 24             	mov    %eax,(%esp)
  800ba7:	ff d7                	call   *%edi
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800ba9:	0f b6 03             	movzbl (%ebx),%eax
  800bac:	83 c3 01             	add    $0x1,%ebx
  800baf:	83 f8 25             	cmp    $0x25,%eax
  800bb2:	75 e4                	jne    800b98 <vprintfmt+0x1b>
  800bb4:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,-0x34(%ebp)
  800bbb:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
  800bc2:	b9 00 00 00 00       	mov    $0x0,%ecx
  800bc7:	c6 45 e0 20          	movb   $0x20,-0x20(%ebp)
  800bcb:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  800bd2:	eb 06                	jmp    800bda <vprintfmt+0x5d>
  800bd4:	c6 45 e0 2d          	movb   $0x2d,-0x20(%ebp)
  800bd8:	89 c3                	mov    %eax,%ebx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800bda:	0f b6 13             	movzbl (%ebx),%edx
  800bdd:	0f b6 c2             	movzbl %dl,%eax
  800be0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800be3:	8d 43 01             	lea    0x1(%ebx),%eax
  800be6:	83 ea 23             	sub    $0x23,%edx
  800be9:	80 fa 55             	cmp    $0x55,%dl
  800bec:	0f 87 f9 03 00 00    	ja     800feb <vprintfmt+0x46e>
  800bf2:	0f b6 d2             	movzbl %dl,%edx
  800bf5:	ff 24 95 c0 23 81 00 	jmp    *0x8123c0(,%edx,4)
  800bfc:	c6 45 e0 30          	movb   $0x30,-0x20(%ebp)
  800c00:	eb d6                	jmp    800bd8 <vprintfmt+0x5b>
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  800c02:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800c05:	83 ea 30             	sub    $0x30,%edx
  800c08:	89 55 cc             	mov    %edx,-0x34(%ebp)
				ch = *fmt;
  800c0b:	0f be 10             	movsbl (%eax),%edx
				if (ch < '0' || ch > '9')
  800c0e:	8d 5a d0             	lea    -0x30(%edx),%ebx
  800c11:	83 fb 09             	cmp    $0x9,%ebx
  800c14:	77 54                	ja     800c6a <vprintfmt+0xed>
  800c16:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  800c19:	8b 4d cc             	mov    -0x34(%ebp),%ecx
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800c1c:	83 c0 01             	add    $0x1,%eax
				precision = precision * 10 + ch - '0';
  800c1f:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  800c22:	8d 4c 4a d0          	lea    -0x30(%edx,%ecx,2),%ecx
				ch = *fmt;
  800c26:	0f be 10             	movsbl (%eax),%edx
				if (ch < '0' || ch > '9')
  800c29:	8d 5a d0             	lea    -0x30(%edx),%ebx
  800c2c:	83 fb 09             	cmp    $0x9,%ebx
  800c2f:	76 eb                	jbe    800c1c <vprintfmt+0x9f>
  800c31:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  800c34:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  800c37:	eb 31                	jmp    800c6a <vprintfmt+0xed>
					break;
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  800c39:	8b 55 14             	mov    0x14(%ebp),%edx
  800c3c:	8d 5a 04             	lea    0x4(%edx),%ebx
  800c3f:	89 5d 14             	mov    %ebx,0x14(%ebp)
  800c42:	8b 12                	mov    (%edx),%edx
  800c44:	89 55 cc             	mov    %edx,-0x34(%ebp)
			goto process_precision;
  800c47:	eb 21                	jmp    800c6a <vprintfmt+0xed>

		case '.':
			if (width < 0)
  800c49:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  800c4d:	ba 00 00 00 00       	mov    $0x0,%edx
  800c52:	0f 49 55 d4          	cmovns -0x2c(%ebp),%edx
  800c56:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  800c59:	e9 7a ff ff ff       	jmp    800bd8 <vprintfmt+0x5b>
  800c5e:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
			goto reswitch;
  800c65:	e9 6e ff ff ff       	jmp    800bd8 <vprintfmt+0x5b>

		process_precision:
			if (width < 0)
  800c6a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  800c6e:	0f 89 64 ff ff ff    	jns    800bd8 <vprintfmt+0x5b>
  800c74:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800c77:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  800c7a:	8b 55 c8             	mov    -0x38(%ebp),%edx
  800c7d:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800c80:	e9 53 ff ff ff       	jmp    800bd8 <vprintfmt+0x5b>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800c85:	83 c1 01             	add    $0x1,%ecx
			goto reswitch;
  800c88:	e9 4b ff ff ff       	jmp    800bd8 <vprintfmt+0x5b>
  800c8d:	89 45 d0             	mov    %eax,-0x30(%ebp)

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  800c90:	8b 45 14             	mov    0x14(%ebp),%eax
  800c93:	8d 50 04             	lea    0x4(%eax),%edx
  800c96:	89 55 14             	mov    %edx,0x14(%ebp)
  800c99:	89 74 24 04          	mov    %esi,0x4(%esp)
  800c9d:	8b 00                	mov    (%eax),%eax
  800c9f:	89 04 24             	mov    %eax,(%esp)
  800ca2:	ff d7                	call   *%edi
  800ca4:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  800ca7:	e9 fd fe ff ff       	jmp    800ba9 <vprintfmt+0x2c>
  800cac:	89 45 d0             	mov    %eax,-0x30(%ebp)

		// error message
		case 'e':
			err = va_arg(ap, int);
  800caf:	8b 45 14             	mov    0x14(%ebp),%eax
  800cb2:	8d 50 04             	lea    0x4(%eax),%edx
  800cb5:	89 55 14             	mov    %edx,0x14(%ebp)
  800cb8:	8b 00                	mov    (%eax),%eax
  800cba:	89 c2                	mov    %eax,%edx
  800cbc:	c1 fa 1f             	sar    $0x1f,%edx
  800cbf:	31 d0                	xor    %edx,%eax
  800cc1:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800cc3:	83 f8 0f             	cmp    $0xf,%eax
  800cc6:	7f 0b                	jg     800cd3 <vprintfmt+0x156>
  800cc8:	8b 14 85 20 25 81 00 	mov    0x812520(,%eax,4),%edx
  800ccf:	85 d2                	test   %edx,%edx
  800cd1:	75 20                	jne    800cf3 <vprintfmt+0x176>
				printfmt(putch, putdat, "error %d", err);
  800cd3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800cd7:	c7 44 24 08 e8 21 81 	movl   $0x8121e8,0x8(%esp)
  800cde:	00 
  800cdf:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ce3:	89 3c 24             	mov    %edi,(%esp)
  800ce6:	e8 a5 03 00 00       	call   801090 <printfmt>
  800ceb:	8b 5d d0             	mov    -0x30(%ebp),%ebx
		// error message
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800cee:	e9 b6 fe ff ff       	jmp    800ba9 <vprintfmt+0x2c>
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800cf3:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800cf7:	c7 44 24 08 b3 28 81 	movl   $0x8128b3,0x8(%esp)
  800cfe:	00 
  800cff:	89 74 24 04          	mov    %esi,0x4(%esp)
  800d03:	89 3c 24             	mov    %edi,(%esp)
  800d06:	e8 85 03 00 00       	call   801090 <printfmt>
  800d0b:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  800d0e:	e9 96 fe ff ff       	jmp    800ba9 <vprintfmt+0x2c>
  800d13:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800d16:	89 c3                	mov    %eax,%ebx
  800d18:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  800d1b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800d1e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  800d21:	8b 45 14             	mov    0x14(%ebp),%eax
  800d24:	8d 50 04             	lea    0x4(%eax),%edx
  800d27:	89 55 14             	mov    %edx,0x14(%ebp)
  800d2a:	8b 00                	mov    (%eax),%eax
  800d2c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800d2f:	85 c0                	test   %eax,%eax
  800d31:	b8 f1 21 81 00       	mov    $0x8121f1,%eax
  800d36:	0f 45 45 e4          	cmovne -0x1c(%ebp),%eax
  800d3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				p = "(null)";
			if (width > 0 && padc != '-')
  800d3d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  800d41:	7e 06                	jle    800d49 <vprintfmt+0x1cc>
  800d43:	80 7d e0 2d          	cmpb   $0x2d,-0x20(%ebp)
  800d47:	75 13                	jne    800d5c <vprintfmt+0x1df>
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800d49:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800d4c:	0f be 02             	movsbl (%edx),%eax
  800d4f:	85 c0                	test   %eax,%eax
  800d51:	0f 85 a2 00 00 00    	jne    800df9 <vprintfmt+0x27c>
  800d57:	e9 8f 00 00 00       	jmp    800deb <vprintfmt+0x26e>
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800d5c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800d60:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  800d63:	89 0c 24             	mov    %ecx,(%esp)
  800d66:	e8 70 03 00 00       	call   8010db <strnlen>
  800d6b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  800d6e:	29 c2                	sub    %eax,%edx
  800d70:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  800d73:	85 d2                	test   %edx,%edx
  800d75:	7e d2                	jle    800d49 <vprintfmt+0x1cc>
					putch(padc, putdat);
  800d77:	0f be 4d e0          	movsbl -0x20(%ebp),%ecx
  800d7b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  800d7e:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
  800d81:	89 d3                	mov    %edx,%ebx
  800d83:	89 74 24 04          	mov    %esi,0x4(%esp)
  800d87:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800d8a:	89 04 24             	mov    %eax,(%esp)
  800d8d:	ff d7                	call   *%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800d8f:	83 eb 01             	sub    $0x1,%ebx
  800d92:	85 db                	test   %ebx,%ebx
  800d94:	7f ed                	jg     800d83 <vprintfmt+0x206>
  800d96:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
  800d99:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  800da0:	eb a7                	jmp    800d49 <vprintfmt+0x1cc>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  800da2:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  800da6:	74 1b                	je     800dc3 <vprintfmt+0x246>
  800da8:	8d 50 e0             	lea    -0x20(%eax),%edx
  800dab:	83 fa 5e             	cmp    $0x5e,%edx
  800dae:	76 13                	jbe    800dc3 <vprintfmt+0x246>
					putch('?', putdat);
  800db0:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800db3:	89 54 24 04          	mov    %edx,0x4(%esp)
  800db7:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  800dbe:	ff 55 e4             	call   *-0x1c(%ebp)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  800dc1:	eb 0d                	jmp    800dd0 <vprintfmt+0x253>
					putch('?', putdat);
				else
					putch(ch, putdat);
  800dc3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800dc6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800dca:	89 04 24             	mov    %eax,(%esp)
  800dcd:	ff 55 e4             	call   *-0x1c(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800dd0:	83 ef 01             	sub    $0x1,%edi
  800dd3:	0f be 03             	movsbl (%ebx),%eax
  800dd6:	85 c0                	test   %eax,%eax
  800dd8:	74 05                	je     800ddf <vprintfmt+0x262>
  800dda:	83 c3 01             	add    $0x1,%ebx
  800ddd:	eb 31                	jmp    800e10 <vprintfmt+0x293>
  800ddf:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  800de2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  800de5:	8b 75 e0             	mov    -0x20(%ebp),%esi
  800de8:	8b 5d cc             	mov    -0x34(%ebp),%ebx
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800deb:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  800def:	7f 36                	jg     800e27 <vprintfmt+0x2aa>
  800df1:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  800df4:	e9 b0 fd ff ff       	jmp    800ba9 <vprintfmt+0x2c>
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800df9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800dfc:	83 c2 01             	add    $0x1,%edx
  800dff:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  800e02:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  800e05:	89 75 e0             	mov    %esi,-0x20(%ebp)
  800e08:	8b 75 cc             	mov    -0x34(%ebp),%esi
  800e0b:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  800e0e:	89 d3                	mov    %edx,%ebx
  800e10:	85 f6                	test   %esi,%esi
  800e12:	78 8e                	js     800da2 <vprintfmt+0x225>
  800e14:	83 ee 01             	sub    $0x1,%esi
  800e17:	79 89                	jns    800da2 <vprintfmt+0x225>
  800e19:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  800e1c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  800e1f:	8b 75 e0             	mov    -0x20(%ebp),%esi
  800e22:	8b 5d cc             	mov    -0x34(%ebp),%ebx
  800e25:	eb c4                	jmp    800deb <vprintfmt+0x26e>
  800e27:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  800e2a:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  800e2d:	89 74 24 04          	mov    %esi,0x4(%esp)
  800e31:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  800e38:	ff d7                	call   *%edi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800e3a:	83 eb 01             	sub    $0x1,%ebx
  800e3d:	85 db                	test   %ebx,%ebx
  800e3f:	7f ec                	jg     800e2d <vprintfmt+0x2b0>
  800e41:	8b 5d d8             	mov    -0x28(%ebp),%ebx
  800e44:	e9 60 fd ff ff       	jmp    800ba9 <vprintfmt+0x2c>
  800e49:	89 45 d0             	mov    %eax,-0x30(%ebp)
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  800e4c:	83 f9 01             	cmp    $0x1,%ecx
  800e4f:	7e 16                	jle    800e67 <vprintfmt+0x2ea>
		return va_arg(*ap, long long);
  800e51:	8b 45 14             	mov    0x14(%ebp),%eax
  800e54:	8d 50 08             	lea    0x8(%eax),%edx
  800e57:	89 55 14             	mov    %edx,0x14(%ebp)
  800e5a:	8b 10                	mov    (%eax),%edx
  800e5c:	8b 48 04             	mov    0x4(%eax),%ecx
  800e5f:	89 55 d8             	mov    %edx,-0x28(%ebp)
  800e62:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  800e65:	eb 32                	jmp    800e99 <vprintfmt+0x31c>
	else if (lflag)
  800e67:	85 c9                	test   %ecx,%ecx
  800e69:	74 18                	je     800e83 <vprintfmt+0x306>
		return va_arg(*ap, long);
  800e6b:	8b 45 14             	mov    0x14(%ebp),%eax
  800e6e:	8d 50 04             	lea    0x4(%eax),%edx
  800e71:	89 55 14             	mov    %edx,0x14(%ebp)
  800e74:	8b 00                	mov    (%eax),%eax
  800e76:	89 45 d8             	mov    %eax,-0x28(%ebp)
  800e79:	89 c1                	mov    %eax,%ecx
  800e7b:	c1 f9 1f             	sar    $0x1f,%ecx
  800e7e:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  800e81:	eb 16                	jmp    800e99 <vprintfmt+0x31c>
	else
		return va_arg(*ap, int);
  800e83:	8b 45 14             	mov    0x14(%ebp),%eax
  800e86:	8d 50 04             	lea    0x4(%eax),%edx
  800e89:	89 55 14             	mov    %edx,0x14(%ebp)
  800e8c:	8b 00                	mov    (%eax),%eax
  800e8e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  800e91:	89 c2                	mov    %eax,%edx
  800e93:	c1 fa 1f             	sar    $0x1f,%edx
  800e96:	89 55 dc             	mov    %edx,-0x24(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  800e99:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800e9c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  800e9f:	bb 0a 00 00 00       	mov    $0xa,%ebx
			if ((long long) num < 0) {
  800ea4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  800ea8:	0f 89 8a 00 00 00    	jns    800f38 <vprintfmt+0x3bb>
				putch('-', putdat);
  800eae:	89 74 24 04          	mov    %esi,0x4(%esp)
  800eb2:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  800eb9:	ff d7                	call   *%edi
				num = -(long long) num;
  800ebb:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800ebe:	8b 55 dc             	mov    -0x24(%ebp),%edx
  800ec1:	f7 d8                	neg    %eax
  800ec3:	83 d2 00             	adc    $0x0,%edx
  800ec6:	f7 da                	neg    %edx
  800ec8:	eb 6e                	jmp    800f38 <vprintfmt+0x3bb>
  800eca:	89 45 d0             	mov    %eax,-0x30(%ebp)
			base = 10;
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  800ecd:	89 ca                	mov    %ecx,%edx
  800ecf:	8d 45 14             	lea    0x14(%ebp),%eax
  800ed2:	e8 4f fc ff ff       	call   800b26 <getuint>
  800ed7:	bb 0a 00 00 00       	mov    $0xa,%ebx
			base = 10;
			goto number;
  800edc:	eb 5a                	jmp    800f38 <vprintfmt+0x3bb>
  800ede:	89 45 d0             	mov    %eax,-0x30(%ebp)
		case 'o':
			// Replace this with your code.
			// putch('X', putdat);
			// putch('X', putdat);
			// putch('X', putdat);
			num = getuint(&ap, lflag);
  800ee1:	89 ca                	mov    %ecx,%edx
  800ee3:	8d 45 14             	lea    0x14(%ebp),%eax
  800ee6:	e8 3b fc ff ff       	call   800b26 <getuint>
  800eeb:	bb 08 00 00 00       	mov    $0x8,%ebx
			base = 8;
			goto number;
  800ef0:	eb 46                	jmp    800f38 <vprintfmt+0x3bb>
  800ef2:	89 45 d0             	mov    %eax,-0x30(%ebp)
			

		// pointer
		case 'p':
			putch('0', putdat);
  800ef5:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ef9:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  800f00:	ff d7                	call   *%edi
			putch('x', putdat);
  800f02:	89 74 24 04          	mov    %esi,0x4(%esp)
  800f06:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  800f0d:	ff d7                	call   *%edi
			num = (unsigned long long)
  800f0f:	8b 45 14             	mov    0x14(%ebp),%eax
  800f12:	8d 50 04             	lea    0x4(%eax),%edx
  800f15:	89 55 14             	mov    %edx,0x14(%ebp)
  800f18:	8b 00                	mov    (%eax),%eax
  800f1a:	ba 00 00 00 00       	mov    $0x0,%edx
  800f1f:	bb 10 00 00 00       	mov    $0x10,%ebx
				(uintptr_t) va_arg(ap, void *);
			base = 16;
			goto number;
  800f24:	eb 12                	jmp    800f38 <vprintfmt+0x3bb>
  800f26:	89 45 d0             	mov    %eax,-0x30(%ebp)

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  800f29:	89 ca                	mov    %ecx,%edx
  800f2b:	8d 45 14             	lea    0x14(%ebp),%eax
  800f2e:	e8 f3 fb ff ff       	call   800b26 <getuint>
  800f33:	bb 10 00 00 00       	mov    $0x10,%ebx
			base = 16;
		number:
			printnum(putch, putdat, num, base, width, padc);
  800f38:	0f be 4d e0          	movsbl -0x20(%ebp),%ecx
  800f3c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  800f40:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  800f43:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  800f47:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800f4b:	89 04 24             	mov    %eax,(%esp)
  800f4e:	89 54 24 04          	mov    %edx,0x4(%esp)
  800f52:	89 f2                	mov    %esi,%edx
  800f54:	89 f8                	mov    %edi,%eax
  800f56:	e8 d5 fa ff ff       	call   800a30 <printnum>
  800f5b:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  800f5e:	e9 46 fc ff ff       	jmp    800ba9 <vprintfmt+0x2c>
  800f63:	89 45 d0             	mov    %eax,-0x30(%ebp)

            const char *null_error = "\nerror! writing through NULL pointer! (%n argument)\n";
            const char *overflow_error = "\nwarning! The value %n argument pointed to has been overflowed!\n";

            // Your code here
		if ((p = va_arg(ap, void *)) == NULL)
  800f66:	8b 45 14             	mov    0x14(%ebp),%eax
  800f69:	8d 50 04             	lea    0x4(%eax),%edx
  800f6c:	89 55 14             	mov    %edx,0x14(%ebp)
  800f6f:	8b 00                	mov    (%eax),%eax
  800f71:	85 c0                	test   %eax,%eax
  800f73:	75 24                	jne    800f99 <vprintfmt+0x41c>
		{		
			printfmt(putch, putdat, "%s", null_error);
  800f75:	c7 44 24 0c 0c 23 81 	movl   $0x81230c,0xc(%esp)
  800f7c:	00 
  800f7d:	c7 44 24 08 b3 28 81 	movl   $0x8128b3,0x8(%esp)
  800f84:	00 
  800f85:	89 74 24 04          	mov    %esi,0x4(%esp)
  800f89:	89 3c 24             	mov    %edi,(%esp)
  800f8c:	e8 ff 00 00 00       	call   801090 <printfmt>
  800f91:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  800f94:	e9 10 fc ff ff       	jmp    800ba9 <vprintfmt+0x2c>
		}		
		if( (*(int *)putdat) > 127)
  800f99:	83 3e 7f             	cmpl   $0x7f,(%esi)
  800f9c:	7e 29                	jle    800fc7 <vprintfmt+0x44a>
		{
			(*((unsigned char *)p)) = (*((unsigned char *)putdat));
  800f9e:	0f b6 16             	movzbl (%esi),%edx
  800fa1:	88 10                	mov    %dl,(%eax)
			printfmt(putch, putdat, "%s", overflow_error);			
  800fa3:	c7 44 24 0c 44 23 81 	movl   $0x812344,0xc(%esp)
  800faa:	00 
  800fab:	c7 44 24 08 b3 28 81 	movl   $0x8128b3,0x8(%esp)
  800fb2:	00 
  800fb3:	89 74 24 04          	mov    %esi,0x4(%esp)
  800fb7:	89 3c 24             	mov    %edi,(%esp)
  800fba:	e8 d1 00 00 00       	call   801090 <printfmt>
  800fbf:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  800fc2:	e9 e2 fb ff ff       	jmp    800ba9 <vprintfmt+0x2c>
		}

		(*((char *)p)) = (*((char *)putdat));		
  800fc7:	0f b6 16             	movzbl (%esi),%edx
  800fca:	88 10                	mov    %dl,(%eax)
  800fcc:	8b 5d d0             	mov    -0x30(%ebp),%ebx

            break;
  800fcf:	e9 d5 fb ff ff       	jmp    800ba9 <vprintfmt+0x2c>
  800fd4:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800fd7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
        }

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  800fda:	89 74 24 04          	mov    %esi,0x4(%esp)
  800fde:	89 14 24             	mov    %edx,(%esp)
  800fe1:	ff d7                	call   *%edi
  800fe3:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  800fe6:	e9 be fb ff ff       	jmp    800ba9 <vprintfmt+0x2c>
			
		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800feb:	89 74 24 04          	mov    %esi,0x4(%esp)
  800fef:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  800ff6:	ff d7                	call   *%edi
			for (fmt--; fmt[-1] != '%'; fmt--)
  800ff8:	8d 43 ff             	lea    -0x1(%ebx),%eax
  800ffb:	80 38 25             	cmpb   $0x25,(%eax)
  800ffe:	0f 84 a5 fb ff ff    	je     800ba9 <vprintfmt+0x2c>
  801004:	89 c3                	mov    %eax,%ebx
  801006:	eb f0                	jmp    800ff8 <vprintfmt+0x47b>
				/* do nothing */;
			break;
		}
	}
}
  801008:	83 c4 5c             	add    $0x5c,%esp
  80100b:	5b                   	pop    %ebx
  80100c:	5e                   	pop    %esi
  80100d:	5f                   	pop    %edi
  80100e:	5d                   	pop    %ebp
  80100f:	c3                   	ret    

00801010 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801010:	55                   	push   %ebp
  801011:	89 e5                	mov    %esp,%ebp
  801013:	83 ec 28             	sub    $0x28,%esp
  801016:	8b 45 08             	mov    0x8(%ebp),%eax
  801019:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
  80101c:	85 c0                	test   %eax,%eax
  80101e:	74 04                	je     801024 <vsnprintf+0x14>
  801020:	85 d2                	test   %edx,%edx
  801022:	7f 07                	jg     80102b <vsnprintf+0x1b>
  801024:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801029:	eb 3b                	jmp    801066 <vsnprintf+0x56>
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};
  80102b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80102e:	8d 44 10 ff          	lea    -0x1(%eax,%edx,1),%eax
  801032:	89 45 f0             	mov    %eax,-0x10(%ebp)
  801035:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80103c:	8b 45 14             	mov    0x14(%ebp),%eax
  80103f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801043:	8b 45 10             	mov    0x10(%ebp),%eax
  801046:	89 44 24 08          	mov    %eax,0x8(%esp)
  80104a:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80104d:	89 44 24 04          	mov    %eax,0x4(%esp)
  801051:	c7 04 24 60 0b 80 00 	movl   $0x800b60,(%esp)
  801058:	e8 20 fb ff ff       	call   800b7d <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80105d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  801060:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  801063:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  801066:	c9                   	leave  
  801067:	c3                   	ret    

00801068 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801068:	55                   	push   %ebp
  801069:	89 e5                	mov    %esp,%ebp
  80106b:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
snprintf(char *buf, int n, const char *fmt, ...)
  80106e:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;
	int rc;

	va_start(ap, fmt);
	rc = vsnprintf(buf, n, fmt, ap);
  801071:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801075:	8b 45 10             	mov    0x10(%ebp),%eax
  801078:	89 44 24 08          	mov    %eax,0x8(%esp)
  80107c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80107f:	89 44 24 04          	mov    %eax,0x4(%esp)
  801083:	8b 45 08             	mov    0x8(%ebp),%eax
  801086:	89 04 24             	mov    %eax,(%esp)
  801089:	e8 82 ff ff ff       	call   801010 <vsnprintf>
	va_end(ap);

	return rc;
}
  80108e:	c9                   	leave  
  80108f:	c3                   	ret    

00801090 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  801090:	55                   	push   %ebp
  801091:	89 e5                	mov    %esp,%ebp
  801093:	83 ec 18             	sub    $0x18,%esp
		}
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
  801096:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;

	va_start(ap, fmt);
	vprintfmt(putch, putdat, fmt, ap);
  801099:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80109d:	8b 45 10             	mov    0x10(%ebp),%eax
  8010a0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8010a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8010a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8010ab:	8b 45 08             	mov    0x8(%ebp),%eax
  8010ae:	89 04 24             	mov    %eax,(%esp)
  8010b1:	e8 c7 fa ff ff       	call   800b7d <vprintfmt>
	va_end(ap);
}
  8010b6:	c9                   	leave  
  8010b7:	c3                   	ret    
	...

008010c0 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  8010c0:	55                   	push   %ebp
  8010c1:	89 e5                	mov    %esp,%ebp
  8010c3:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  8010c6:	b8 00 00 00 00       	mov    $0x0,%eax
  8010cb:	80 3a 00             	cmpb   $0x0,(%edx)
  8010ce:	74 09                	je     8010d9 <strlen+0x19>
		n++;
  8010d0:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  8010d3:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  8010d7:	75 f7                	jne    8010d0 <strlen+0x10>
		n++;
	return n;
}
  8010d9:	5d                   	pop    %ebp
  8010da:	c3                   	ret    

008010db <strnlen>:

int
strnlen(const char *s, size_t size)
{
  8010db:	55                   	push   %ebp
  8010dc:	89 e5                	mov    %esp,%ebp
  8010de:	53                   	push   %ebx
  8010df:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8010e2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8010e5:	85 c9                	test   %ecx,%ecx
  8010e7:	74 19                	je     801102 <strnlen+0x27>
  8010e9:	80 3b 00             	cmpb   $0x0,(%ebx)
  8010ec:	74 14                	je     801102 <strnlen+0x27>
  8010ee:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
  8010f3:	83 c0 01             	add    $0x1,%eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8010f6:	39 c8                	cmp    %ecx,%eax
  8010f8:	74 0d                	je     801107 <strnlen+0x2c>
  8010fa:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
  8010fe:	75 f3                	jne    8010f3 <strnlen+0x18>
  801100:	eb 05                	jmp    801107 <strnlen+0x2c>
  801102:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
	return n;
}
  801107:	5b                   	pop    %ebx
  801108:	5d                   	pop    %ebp
  801109:	c3                   	ret    

0080110a <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80110a:	55                   	push   %ebp
  80110b:	89 e5                	mov    %esp,%ebp
  80110d:	53                   	push   %ebx
  80110e:	8b 45 08             	mov    0x8(%ebp),%eax
  801111:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801114:	ba 00 00 00 00       	mov    $0x0,%edx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  801119:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  80111d:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  801120:	83 c2 01             	add    $0x1,%edx
  801123:	84 c9                	test   %cl,%cl
  801125:	75 f2                	jne    801119 <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  801127:	5b                   	pop    %ebx
  801128:	5d                   	pop    %ebp
  801129:	c3                   	ret    

0080112a <strcat>:

char *
strcat(char *dst, const char *src)
{
  80112a:	55                   	push   %ebp
  80112b:	89 e5                	mov    %esp,%ebp
  80112d:	53                   	push   %ebx
  80112e:	83 ec 08             	sub    $0x8,%esp
  801131:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  801134:	89 1c 24             	mov    %ebx,(%esp)
  801137:	e8 84 ff ff ff       	call   8010c0 <strlen>
	strcpy(dst + len, src);
  80113c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80113f:	89 54 24 04          	mov    %edx,0x4(%esp)
  801143:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  801146:	89 04 24             	mov    %eax,(%esp)
  801149:	e8 bc ff ff ff       	call   80110a <strcpy>
	return dst;
}
  80114e:	89 d8                	mov    %ebx,%eax
  801150:	83 c4 08             	add    $0x8,%esp
  801153:	5b                   	pop    %ebx
  801154:	5d                   	pop    %ebp
  801155:	c3                   	ret    

00801156 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801156:	55                   	push   %ebp
  801157:	89 e5                	mov    %esp,%ebp
  801159:	56                   	push   %esi
  80115a:	53                   	push   %ebx
  80115b:	8b 45 08             	mov    0x8(%ebp),%eax
  80115e:	8b 55 0c             	mov    0xc(%ebp),%edx
  801161:	8b 75 10             	mov    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801164:	85 f6                	test   %esi,%esi
  801166:	74 18                	je     801180 <strncpy+0x2a>
  801168:	b9 00 00 00 00       	mov    $0x0,%ecx
		*dst++ = *src;
  80116d:	0f b6 1a             	movzbl (%edx),%ebx
  801170:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  801173:	80 3a 01             	cmpb   $0x1,(%edx)
  801176:	83 da ff             	sbb    $0xffffffff,%edx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801179:	83 c1 01             	add    $0x1,%ecx
  80117c:	39 ce                	cmp    %ecx,%esi
  80117e:	77 ed                	ja     80116d <strncpy+0x17>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  801180:	5b                   	pop    %ebx
  801181:	5e                   	pop    %esi
  801182:	5d                   	pop    %ebp
  801183:	c3                   	ret    

00801184 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801184:	55                   	push   %ebp
  801185:	89 e5                	mov    %esp,%ebp
  801187:	56                   	push   %esi
  801188:	53                   	push   %ebx
  801189:	8b 75 08             	mov    0x8(%ebp),%esi
  80118c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80118f:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  801192:	89 f0                	mov    %esi,%eax
  801194:	85 c9                	test   %ecx,%ecx
  801196:	74 27                	je     8011bf <strlcpy+0x3b>
		while (--size > 0 && *src != '\0')
  801198:	83 e9 01             	sub    $0x1,%ecx
  80119b:	74 1d                	je     8011ba <strlcpy+0x36>
  80119d:	0f b6 1a             	movzbl (%edx),%ebx
  8011a0:	84 db                	test   %bl,%bl
  8011a2:	74 16                	je     8011ba <strlcpy+0x36>
			*dst++ = *src++;
  8011a4:	88 18                	mov    %bl,(%eax)
  8011a6:	83 c0 01             	add    $0x1,%eax
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  8011a9:	83 e9 01             	sub    $0x1,%ecx
  8011ac:	74 0e                	je     8011bc <strlcpy+0x38>
			*dst++ = *src++;
  8011ae:	83 c2 01             	add    $0x1,%edx
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  8011b1:	0f b6 1a             	movzbl (%edx),%ebx
  8011b4:	84 db                	test   %bl,%bl
  8011b6:	75 ec                	jne    8011a4 <strlcpy+0x20>
  8011b8:	eb 02                	jmp    8011bc <strlcpy+0x38>
  8011ba:	89 f0                	mov    %esi,%eax
			*dst++ = *src++;
		*dst = '\0';
  8011bc:	c6 00 00             	movb   $0x0,(%eax)
  8011bf:	29 f0                	sub    %esi,%eax
	}
	return dst - dst_in;
}
  8011c1:	5b                   	pop    %ebx
  8011c2:	5e                   	pop    %esi
  8011c3:	5d                   	pop    %ebp
  8011c4:	c3                   	ret    

008011c5 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  8011c5:	55                   	push   %ebp
  8011c6:	89 e5                	mov    %esp,%ebp
  8011c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8011cb:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  8011ce:	0f b6 01             	movzbl (%ecx),%eax
  8011d1:	84 c0                	test   %al,%al
  8011d3:	74 15                	je     8011ea <strcmp+0x25>
  8011d5:	3a 02                	cmp    (%edx),%al
  8011d7:	75 11                	jne    8011ea <strcmp+0x25>
		p++, q++;
  8011d9:	83 c1 01             	add    $0x1,%ecx
  8011dc:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  8011df:	0f b6 01             	movzbl (%ecx),%eax
  8011e2:	84 c0                	test   %al,%al
  8011e4:	74 04                	je     8011ea <strcmp+0x25>
  8011e6:	3a 02                	cmp    (%edx),%al
  8011e8:	74 ef                	je     8011d9 <strcmp+0x14>
  8011ea:	0f b6 c0             	movzbl %al,%eax
  8011ed:	0f b6 12             	movzbl (%edx),%edx
  8011f0:	29 d0                	sub    %edx,%eax
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
}
  8011f2:	5d                   	pop    %ebp
  8011f3:	c3                   	ret    

008011f4 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  8011f4:	55                   	push   %ebp
  8011f5:	89 e5                	mov    %esp,%ebp
  8011f7:	53                   	push   %ebx
  8011f8:	8b 55 08             	mov    0x8(%ebp),%edx
  8011fb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8011fe:	8b 45 10             	mov    0x10(%ebp),%eax
	while (n > 0 && *p && *p == *q)
  801201:	85 c0                	test   %eax,%eax
  801203:	74 23                	je     801228 <strncmp+0x34>
  801205:	0f b6 1a             	movzbl (%edx),%ebx
  801208:	84 db                	test   %bl,%bl
  80120a:	74 25                	je     801231 <strncmp+0x3d>
  80120c:	3a 19                	cmp    (%ecx),%bl
  80120e:	75 21                	jne    801231 <strncmp+0x3d>
  801210:	83 e8 01             	sub    $0x1,%eax
  801213:	74 13                	je     801228 <strncmp+0x34>
		n--, p++, q++;
  801215:	83 c2 01             	add    $0x1,%edx
  801218:	83 c1 01             	add    $0x1,%ecx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80121b:	0f b6 1a             	movzbl (%edx),%ebx
  80121e:	84 db                	test   %bl,%bl
  801220:	74 0f                	je     801231 <strncmp+0x3d>
  801222:	3a 19                	cmp    (%ecx),%bl
  801224:	74 ea                	je     801210 <strncmp+0x1c>
  801226:	eb 09                	jmp    801231 <strncmp+0x3d>
  801228:	b8 00 00 00 00       	mov    $0x0,%eax
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80122d:	5b                   	pop    %ebx
  80122e:	5d                   	pop    %ebp
  80122f:	90                   	nop
  801230:	c3                   	ret    
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  801231:	0f b6 02             	movzbl (%edx),%eax
  801234:	0f b6 11             	movzbl (%ecx),%edx
  801237:	29 d0                	sub    %edx,%eax
  801239:	eb f2                	jmp    80122d <strncmp+0x39>

0080123b <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80123b:	55                   	push   %ebp
  80123c:	89 e5                	mov    %esp,%ebp
  80123e:	8b 45 08             	mov    0x8(%ebp),%eax
  801241:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801245:	0f b6 10             	movzbl (%eax),%edx
  801248:	84 d2                	test   %dl,%dl
  80124a:	74 18                	je     801264 <strchr+0x29>
		if (*s == c)
  80124c:	38 ca                	cmp    %cl,%dl
  80124e:	75 0a                	jne    80125a <strchr+0x1f>
  801250:	eb 17                	jmp    801269 <strchr+0x2e>
  801252:	38 ca                	cmp    %cl,%dl
  801254:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  801258:	74 0f                	je     801269 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80125a:	83 c0 01             	add    $0x1,%eax
  80125d:	0f b6 10             	movzbl (%eax),%edx
  801260:	84 d2                	test   %dl,%dl
  801262:	75 ee                	jne    801252 <strchr+0x17>
  801264:	b8 00 00 00 00       	mov    $0x0,%eax
		if (*s == c)
			return (char *) s;
	return 0;
}
  801269:	5d                   	pop    %ebp
  80126a:	c3                   	ret    

0080126b <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80126b:	55                   	push   %ebp
  80126c:	89 e5                	mov    %esp,%ebp
  80126e:	8b 45 08             	mov    0x8(%ebp),%eax
  801271:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801275:	0f b6 10             	movzbl (%eax),%edx
  801278:	84 d2                	test   %dl,%dl
  80127a:	74 18                	je     801294 <strfind+0x29>
		if (*s == c)
  80127c:	38 ca                	cmp    %cl,%dl
  80127e:	75 0a                	jne    80128a <strfind+0x1f>
  801280:	eb 12                	jmp    801294 <strfind+0x29>
  801282:	38 ca                	cmp    %cl,%dl
  801284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  801288:	74 0a                	je     801294 <strfind+0x29>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80128a:	83 c0 01             	add    $0x1,%eax
  80128d:	0f b6 10             	movzbl (%eax),%edx
  801290:	84 d2                	test   %dl,%dl
  801292:	75 ee                	jne    801282 <strfind+0x17>
		if (*s == c)
			break;
	return (char *) s;
}
  801294:	5d                   	pop    %ebp
  801295:	c3                   	ret    

00801296 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  801296:	55                   	push   %ebp
  801297:	89 e5                	mov    %esp,%ebp
  801299:	83 ec 0c             	sub    $0xc,%esp
  80129c:	89 1c 24             	mov    %ebx,(%esp)
  80129f:	89 74 24 04          	mov    %esi,0x4(%esp)
  8012a3:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8012a7:	8b 7d 08             	mov    0x8(%ebp),%edi
  8012aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8012ad:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  8012b0:	85 c9                	test   %ecx,%ecx
  8012b2:	74 30                	je     8012e4 <memset+0x4e>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  8012b4:	f7 c7 03 00 00 00    	test   $0x3,%edi
  8012ba:	75 25                	jne    8012e1 <memset+0x4b>
  8012bc:	f6 c1 03             	test   $0x3,%cl
  8012bf:	75 20                	jne    8012e1 <memset+0x4b>
		c &= 0xFF;
  8012c1:	0f b6 d0             	movzbl %al,%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  8012c4:	89 d3                	mov    %edx,%ebx
  8012c6:	c1 e3 08             	shl    $0x8,%ebx
  8012c9:	89 d6                	mov    %edx,%esi
  8012cb:	c1 e6 18             	shl    $0x18,%esi
  8012ce:	89 d0                	mov    %edx,%eax
  8012d0:	c1 e0 10             	shl    $0x10,%eax
  8012d3:	09 f0                	or     %esi,%eax
  8012d5:	09 d0                	or     %edx,%eax
		asm volatile("cld; rep stosl\n"
  8012d7:	09 d8                	or     %ebx,%eax
  8012d9:	c1 e9 02             	shr    $0x2,%ecx
  8012dc:	fc                   	cld    
  8012dd:	f3 ab                	rep stos %eax,%es:(%edi)
{
	char *p;

	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  8012df:	eb 03                	jmp    8012e4 <memset+0x4e>
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8012e1:	fc                   	cld    
  8012e2:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  8012e4:	89 f8                	mov    %edi,%eax
  8012e6:	8b 1c 24             	mov    (%esp),%ebx
  8012e9:	8b 74 24 04          	mov    0x4(%esp),%esi
  8012ed:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8012f1:	89 ec                	mov    %ebp,%esp
  8012f3:	5d                   	pop    %ebp
  8012f4:	c3                   	ret    

008012f5 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8012f5:	55                   	push   %ebp
  8012f6:	89 e5                	mov    %esp,%ebp
  8012f8:	83 ec 08             	sub    $0x8,%esp
  8012fb:	89 34 24             	mov    %esi,(%esp)
  8012fe:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801302:	8b 45 08             	mov    0x8(%ebp),%eax
  801305:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;
	
	s = src;
  801308:	8b 75 0c             	mov    0xc(%ebp),%esi
	d = dst;
  80130b:	89 c7                	mov    %eax,%edi
	if (s < d && s + n > d) {
  80130d:	39 c6                	cmp    %eax,%esi
  80130f:	73 35                	jae    801346 <memmove+0x51>
  801311:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  801314:	39 d0                	cmp    %edx,%eax
  801316:	73 2e                	jae    801346 <memmove+0x51>
		s += n;
		d += n;
  801318:	01 cf                	add    %ecx,%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80131a:	f6 c2 03             	test   $0x3,%dl
  80131d:	75 1b                	jne    80133a <memmove+0x45>
  80131f:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801325:	75 13                	jne    80133a <memmove+0x45>
  801327:	f6 c1 03             	test   $0x3,%cl
  80132a:	75 0e                	jne    80133a <memmove+0x45>
			asm volatile("std; rep movsl\n"
  80132c:	83 ef 04             	sub    $0x4,%edi
  80132f:	8d 72 fc             	lea    -0x4(%edx),%esi
  801332:	c1 e9 02             	shr    $0x2,%ecx
  801335:	fd                   	std    
  801336:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801338:	eb 09                	jmp    801343 <memmove+0x4e>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80133a:	83 ef 01             	sub    $0x1,%edi
  80133d:	8d 72 ff             	lea    -0x1(%edx),%esi
  801340:	fd                   	std    
  801341:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  801343:	fc                   	cld    
	const char *s;
	char *d;
	
	s = src;
	d = dst;
	if (s < d && s + n > d) {
  801344:	eb 20                	jmp    801366 <memmove+0x71>
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801346:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80134c:	75 15                	jne    801363 <memmove+0x6e>
  80134e:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801354:	75 0d                	jne    801363 <memmove+0x6e>
  801356:	f6 c1 03             	test   $0x3,%cl
  801359:	75 08                	jne    801363 <memmove+0x6e>
			asm volatile("cld; rep movsl\n"
  80135b:	c1 e9 02             	shr    $0x2,%ecx
  80135e:	fc                   	cld    
  80135f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801361:	eb 03                	jmp    801366 <memmove+0x71>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  801363:	fc                   	cld    
  801364:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  801366:	8b 34 24             	mov    (%esp),%esi
  801369:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80136d:	89 ec                	mov    %ebp,%esp
  80136f:	5d                   	pop    %ebp
  801370:	c3                   	ret    

00801371 <memcpy>:

/* sigh - gcc emits references to this for structure assignments! */
/* it is *not* prototyped in inc/string.h - do not use directly. */
void *
memcpy(void *dst, void *src, size_t n)
{
  801371:	55                   	push   %ebp
  801372:	89 e5                	mov    %esp,%ebp
  801374:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  801377:	8b 45 10             	mov    0x10(%ebp),%eax
  80137a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80137e:	8b 45 0c             	mov    0xc(%ebp),%eax
  801381:	89 44 24 04          	mov    %eax,0x4(%esp)
  801385:	8b 45 08             	mov    0x8(%ebp),%eax
  801388:	89 04 24             	mov    %eax,(%esp)
  80138b:	e8 65 ff ff ff       	call   8012f5 <memmove>
}
  801390:	c9                   	leave  
  801391:	c3                   	ret    

00801392 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  801392:	55                   	push   %ebp
  801393:	89 e5                	mov    %esp,%ebp
  801395:	57                   	push   %edi
  801396:	56                   	push   %esi
  801397:	53                   	push   %ebx
  801398:	8b 75 08             	mov    0x8(%ebp),%esi
  80139b:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80139e:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8013a1:	85 c9                	test   %ecx,%ecx
  8013a3:	74 36                	je     8013db <memcmp+0x49>
		if (*s1 != *s2)
  8013a5:	0f b6 06             	movzbl (%esi),%eax
  8013a8:	0f b6 1f             	movzbl (%edi),%ebx
  8013ab:	38 d8                	cmp    %bl,%al
  8013ad:	74 20                	je     8013cf <memcmp+0x3d>
  8013af:	eb 14                	jmp    8013c5 <memcmp+0x33>
  8013b1:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  8013b6:	0f b6 5c 17 01       	movzbl 0x1(%edi,%edx,1),%ebx
  8013bb:	83 c2 01             	add    $0x1,%edx
  8013be:	83 e9 01             	sub    $0x1,%ecx
  8013c1:	38 d8                	cmp    %bl,%al
  8013c3:	74 12                	je     8013d7 <memcmp+0x45>
			return (int) *s1 - (int) *s2;
  8013c5:	0f b6 c0             	movzbl %al,%eax
  8013c8:	0f b6 db             	movzbl %bl,%ebx
  8013cb:	29 d8                	sub    %ebx,%eax
  8013cd:	eb 11                	jmp    8013e0 <memcmp+0x4e>
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8013cf:	83 e9 01             	sub    $0x1,%ecx
  8013d2:	ba 00 00 00 00       	mov    $0x0,%edx
  8013d7:	85 c9                	test   %ecx,%ecx
  8013d9:	75 d6                	jne    8013b1 <memcmp+0x1f>
  8013db:	b8 00 00 00 00       	mov    $0x0,%eax
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
}
  8013e0:	5b                   	pop    %ebx
  8013e1:	5e                   	pop    %esi
  8013e2:	5f                   	pop    %edi
  8013e3:	5d                   	pop    %ebp
  8013e4:	c3                   	ret    

008013e5 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8013e5:	55                   	push   %ebp
  8013e6:	89 e5                	mov    %esp,%ebp
  8013e8:	8b 45 08             	mov    0x8(%ebp),%eax
	const void *ends = (const char *) s + n;
  8013eb:	89 c2                	mov    %eax,%edx
  8013ed:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  8013f0:	39 d0                	cmp    %edx,%eax
  8013f2:	73 15                	jae    801409 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
  8013f4:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
  8013f8:	38 08                	cmp    %cl,(%eax)
  8013fa:	75 06                	jne    801402 <memfind+0x1d>
  8013fc:	eb 0b                	jmp    801409 <memfind+0x24>
  8013fe:	38 08                	cmp    %cl,(%eax)
  801400:	74 07                	je     801409 <memfind+0x24>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  801402:	83 c0 01             	add    $0x1,%eax
  801405:	39 c2                	cmp    %eax,%edx
  801407:	77 f5                	ja     8013fe <memfind+0x19>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  801409:	5d                   	pop    %ebp
  80140a:	c3                   	ret    

0080140b <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80140b:	55                   	push   %ebp
  80140c:	89 e5                	mov    %esp,%ebp
  80140e:	57                   	push   %edi
  80140f:	56                   	push   %esi
  801410:	53                   	push   %ebx
  801411:	83 ec 04             	sub    $0x4,%esp
  801414:	8b 55 08             	mov    0x8(%ebp),%edx
  801417:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80141a:	0f b6 02             	movzbl (%edx),%eax
  80141d:	3c 20                	cmp    $0x20,%al
  80141f:	74 04                	je     801425 <strtol+0x1a>
  801421:	3c 09                	cmp    $0x9,%al
  801423:	75 0e                	jne    801433 <strtol+0x28>
		s++;
  801425:	83 c2 01             	add    $0x1,%edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  801428:	0f b6 02             	movzbl (%edx),%eax
  80142b:	3c 20                	cmp    $0x20,%al
  80142d:	74 f6                	je     801425 <strtol+0x1a>
  80142f:	3c 09                	cmp    $0x9,%al
  801431:	74 f2                	je     801425 <strtol+0x1a>
		s++;

	// plus/minus sign
	if (*s == '+')
  801433:	3c 2b                	cmp    $0x2b,%al
  801435:	75 0c                	jne    801443 <strtol+0x38>
		s++;
  801437:	83 c2 01             	add    $0x1,%edx
  80143a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  801441:	eb 15                	jmp    801458 <strtol+0x4d>
	else if (*s == '-')
  801443:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  80144a:	3c 2d                	cmp    $0x2d,%al
  80144c:	75 0a                	jne    801458 <strtol+0x4d>
		s++, neg = 1;
  80144e:	83 c2 01             	add    $0x1,%edx
  801451:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  801458:	85 db                	test   %ebx,%ebx
  80145a:	0f 94 c0             	sete   %al
  80145d:	74 05                	je     801464 <strtol+0x59>
  80145f:	83 fb 10             	cmp    $0x10,%ebx
  801462:	75 18                	jne    80147c <strtol+0x71>
  801464:	80 3a 30             	cmpb   $0x30,(%edx)
  801467:	75 13                	jne    80147c <strtol+0x71>
  801469:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80146d:	8d 76 00             	lea    0x0(%esi),%esi
  801470:	75 0a                	jne    80147c <strtol+0x71>
		s += 2, base = 16;
  801472:	83 c2 02             	add    $0x2,%edx
  801475:	bb 10 00 00 00       	mov    $0x10,%ebx
		s++;
	else if (*s == '-')
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80147a:	eb 15                	jmp    801491 <strtol+0x86>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80147c:	84 c0                	test   %al,%al
  80147e:	66 90                	xchg   %ax,%ax
  801480:	74 0f                	je     801491 <strtol+0x86>
  801482:	bb 0a 00 00 00       	mov    $0xa,%ebx
  801487:	80 3a 30             	cmpb   $0x30,(%edx)
  80148a:	75 05                	jne    801491 <strtol+0x86>
		s++, base = 8;
  80148c:	83 c2 01             	add    $0x1,%edx
  80148f:	b3 08                	mov    $0x8,%bl
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  801491:	b8 00 00 00 00       	mov    $0x0,%eax
  801496:	89 de                	mov    %ebx,%esi

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  801498:	0f b6 0a             	movzbl (%edx),%ecx
  80149b:	89 cf                	mov    %ecx,%edi
  80149d:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  8014a0:	80 fb 09             	cmp    $0x9,%bl
  8014a3:	77 08                	ja     8014ad <strtol+0xa2>
			dig = *s - '0';
  8014a5:	0f be c9             	movsbl %cl,%ecx
  8014a8:	83 e9 30             	sub    $0x30,%ecx
  8014ab:	eb 1e                	jmp    8014cb <strtol+0xc0>
		else if (*s >= 'a' && *s <= 'z')
  8014ad:	8d 5f 9f             	lea    -0x61(%edi),%ebx
  8014b0:	80 fb 19             	cmp    $0x19,%bl
  8014b3:	77 08                	ja     8014bd <strtol+0xb2>
			dig = *s - 'a' + 10;
  8014b5:	0f be c9             	movsbl %cl,%ecx
  8014b8:	83 e9 57             	sub    $0x57,%ecx
  8014bb:	eb 0e                	jmp    8014cb <strtol+0xc0>
		else if (*s >= 'A' && *s <= 'Z')
  8014bd:	8d 5f bf             	lea    -0x41(%edi),%ebx
  8014c0:	80 fb 19             	cmp    $0x19,%bl
  8014c3:	77 15                	ja     8014da <strtol+0xcf>
			dig = *s - 'A' + 10;
  8014c5:	0f be c9             	movsbl %cl,%ecx
  8014c8:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  8014cb:	39 f1                	cmp    %esi,%ecx
  8014cd:	7d 0b                	jge    8014da <strtol+0xcf>
			break;
		s++, val = (val * base) + dig;
  8014cf:	83 c2 01             	add    $0x1,%edx
  8014d2:	0f af c6             	imul   %esi,%eax
  8014d5:	8d 04 01             	lea    (%ecx,%eax,1),%eax
		// we don't properly detect overflow!
	}
  8014d8:	eb be                	jmp    801498 <strtol+0x8d>
  8014da:	89 c1                	mov    %eax,%ecx

	if (endptr)
  8014dc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8014e0:	74 05                	je     8014e7 <strtol+0xdc>
		*endptr = (char *) s;
  8014e2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8014e5:	89 13                	mov    %edx,(%ebx)
	return (neg ? -val : val);
  8014e7:	89 ca                	mov    %ecx,%edx
  8014e9:	f7 da                	neg    %edx
  8014eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  8014ef:	0f 45 c2             	cmovne %edx,%eax
}
  8014f2:	83 c4 04             	add    $0x4,%esp
  8014f5:	5b                   	pop    %ebx
  8014f6:	5e                   	pop    %esi
  8014f7:	5f                   	pop    %edi
  8014f8:	5d                   	pop    %ebp
  8014f9:	c3                   	ret    
	...

008014fc <syscall>:
#include <inc/syscall.h>
#include <inc/lib.h>

static int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
  8014fc:	55                   	push   %ebp
  8014fd:	89 e5                	mov    %esp,%ebp
  8014ff:	83 ec 48             	sub    $0x48,%esp
  801502:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801505:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801508:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80150b:	89 c6                	mov    %eax,%esi
  80150d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  801510:	89 ca                	mov    %ecx,%edx
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801512:	8b 7d 10             	mov    0x10(%ebp),%edi
  801515:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801518:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80151b:	51                   	push   %ecx
  80151c:	52                   	push   %edx
  80151d:	53                   	push   %ebx
  80151e:	54                   	push   %esp
  80151f:	55                   	push   %ebp
  801520:	56                   	push   %esi
  801521:	57                   	push   %edi
  801522:	89 e5                	mov    %esp,%ebp
  801524:	8d 35 2c 15 80 00    	lea    0x80152c,%esi
  80152a:	0f 34                	sysenter 

0080152c <.after_sysenter_label>:
  80152c:	5f                   	pop    %edi
  80152d:	5e                   	pop    %esi
  80152e:	5d                   	pop    %ebp
  80152f:	5c                   	pop    %esp
  801530:	5b                   	pop    %ebx
  801531:	5a                   	pop    %edx
  801532:	59                   	pop    %ecx
  801533:	89 c2                	mov    %eax,%edx
                   "b" (a3),
                   "D" (a4)
                 : "cc", "memory");


	if(check && ret > 0)
  801535:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  801539:	74 28                	je     801563 <.after_sysenter_label+0x37>
  80153b:	85 c0                	test   %eax,%eax
  80153d:	7e 24                	jle    801563 <.after_sysenter_label+0x37>
		panic("syscall %d returned %d (> 0)", num, ret);
  80153f:	89 44 24 10          	mov    %eax,0x10(%esp)
  801543:	89 74 24 0c          	mov    %esi,0xc(%esp)
  801547:	c7 44 24 08 60 25 81 	movl   $0x812560,0x8(%esp)
  80154e:	00 
  80154f:	c7 44 24 04 2b 00 00 	movl   $0x2b,0x4(%esp)
  801556:	00 
  801557:	c7 04 24 7d 25 81 00 	movl   $0x81257d,(%esp)
  80155e:	e8 b1 f3 ff ff       	call   800914 <_panic>

	return ret;
}
  801563:	89 d0                	mov    %edx,%eax
  801565:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801568:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80156b:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80156e:	89 ec                	mov    %ebp,%esp
  801570:	5d                   	pop    %ebp
  801571:	c3                   	ret    

00801572 <sys_net_try_send>:
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}

int
sys_net_try_send(void *data, size_t len)
{
  801572:	55                   	push   %ebp
  801573:	89 e5                	mov    %esp,%ebp
  801575:	83 ec 18             	sub    $0x18,%esp
  return syscall(SYS_net_try_send, 0, (uint32_t)data, len, 0, 0, 0);
  801578:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80157f:	00 
  801580:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801587:	00 
  801588:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80158f:	00 
  801590:	8b 45 0c             	mov    0xc(%ebp),%eax
  801593:	89 04 24             	mov    %eax,(%esp)
  801596:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801599:	ba 00 00 00 00       	mov    $0x0,%edx
  80159e:	b8 10 00 00 00       	mov    $0x10,%eax
  8015a3:	e8 54 ff ff ff       	call   8014fc <syscall>
}
  8015a8:	c9                   	leave  
  8015a9:	c3                   	ret    

008015aa <sys_time_msec>:
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}

unsigned int
sys_time_msec(void)
{
  8015aa:	55                   	push   %ebp
  8015ab:	89 e5                	mov    %esp,%ebp
  8015ad:	83 ec 18             	sub    $0x18,%esp
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
  8015b0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8015b7:	00 
  8015b8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8015bf:	00 
  8015c0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8015c7:	00 
  8015c8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8015cf:	b9 00 00 00 00       	mov    $0x0,%ecx
  8015d4:	ba 00 00 00 00       	mov    $0x0,%edx
  8015d9:	b8 0f 00 00 00       	mov    $0xf,%eax
  8015de:	e8 19 ff ff ff       	call   8014fc <syscall>
}
  8015e3:	c9                   	leave  
  8015e4:	c3                   	ret    

008015e5 <sys_ipc_recv>:
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}

int
sys_ipc_recv(void *dstva)
{
  8015e5:	55                   	push   %ebp
  8015e6:	89 e5                	mov    %esp,%ebp
  8015e8:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
  8015eb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8015f2:	00 
  8015f3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8015fa:	00 
  8015fb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801602:	00 
  801603:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80160a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80160d:	ba 01 00 00 00       	mov    $0x1,%edx
  801612:	b8 0e 00 00 00       	mov    $0xe,%eax
  801617:	e8 e0 fe ff ff       	call   8014fc <syscall>
}
  80161c:	c9                   	leave  
  80161d:	c3                   	ret    

0080161e <sys_ipc_try_send>:
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80161e:	55                   	push   %ebp
  80161f:	89 e5                	mov    %esp,%ebp
  801621:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
  801624:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80162b:	00 
  80162c:	8b 45 14             	mov    0x14(%ebp),%eax
  80162f:	89 44 24 08          	mov    %eax,0x8(%esp)
  801633:	8b 45 10             	mov    0x10(%ebp),%eax
  801636:	89 44 24 04          	mov    %eax,0x4(%esp)
  80163a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80163d:	89 04 24             	mov    %eax,(%esp)
  801640:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801643:	ba 00 00 00 00       	mov    $0x0,%edx
  801648:	b8 0d 00 00 00       	mov    $0xd,%eax
  80164d:	e8 aa fe ff ff       	call   8014fc <syscall>
}
  801652:	c9                   	leave  
  801653:	c3                   	ret    

00801654 <sys_env_set_pgfault_upcall>:
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  801654:	55                   	push   %ebp
  801655:	89 e5                	mov    %esp,%ebp
  801657:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
  80165a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801661:	00 
  801662:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801669:	00 
  80166a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801671:	00 
  801672:	8b 45 0c             	mov    0xc(%ebp),%eax
  801675:	89 04 24             	mov    %eax,(%esp)
  801678:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80167b:	ba 01 00 00 00       	mov    $0x1,%edx
  801680:	b8 0b 00 00 00       	mov    $0xb,%eax
  801685:	e8 72 fe ff ff       	call   8014fc <syscall>
}
  80168a:	c9                   	leave  
  80168b:	c3                   	ret    

0080168c <sys_env_set_trapframe>:
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80168c:	55                   	push   %ebp
  80168d:	89 e5                	mov    %esp,%ebp
  80168f:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
  801692:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801699:	00 
  80169a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8016a1:	00 
  8016a2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8016a9:	00 
  8016aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8016ad:	89 04 24             	mov    %eax,(%esp)
  8016b0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8016b3:	ba 01 00 00 00       	mov    $0x1,%edx
  8016b8:	b8 0a 00 00 00       	mov    $0xa,%eax
  8016bd:	e8 3a fe ff ff       	call   8014fc <syscall>
}
  8016c2:	c9                   	leave  
  8016c3:	c3                   	ret    

008016c4 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  8016c4:	55                   	push   %ebp
  8016c5:	89 e5                	mov    %esp,%ebp
  8016c7:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
  8016ca:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8016d1:	00 
  8016d2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8016d9:	00 
  8016da:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8016e1:	00 
  8016e2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8016e5:	89 04 24             	mov    %eax,(%esp)
  8016e8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8016eb:	ba 01 00 00 00       	mov    $0x1,%edx
  8016f0:	b8 09 00 00 00       	mov    $0x9,%eax
  8016f5:	e8 02 fe ff ff       	call   8014fc <syscall>
}
  8016fa:	c9                   	leave  
  8016fb:	c3                   	ret    

008016fc <sys_page_unmap>:
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva | perm, 0);
}

int
sys_page_unmap(envid_t envid, void *va)
{
  8016fc:	55                   	push   %ebp
  8016fd:	89 e5                	mov    %esp,%ebp
  8016ff:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
  801702:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801709:	00 
  80170a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801711:	00 
  801712:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801719:	00 
  80171a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80171d:	89 04 24             	mov    %eax,(%esp)
  801720:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801723:	ba 01 00 00 00       	mov    $0x1,%edx
  801728:	b8 07 00 00 00       	mov    $0x7,%eax
  80172d:	e8 ca fd ff ff       	call   8014fc <syscall>
}
  801732:	c9                   	leave  
  801733:	c3                   	ret    

00801734 <sys_page_map>:
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  801734:	55                   	push   %ebp
  801735:	89 e5                	mov    %esp,%ebp
  801737:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva | perm, 0);
  80173a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801741:	00 
  801742:	8b 45 18             	mov    0x18(%ebp),%eax
  801745:	0b 45 14             	or     0x14(%ebp),%eax
  801748:	89 44 24 08          	mov    %eax,0x8(%esp)
  80174c:	8b 45 10             	mov    0x10(%ebp),%eax
  80174f:	89 44 24 04          	mov    %eax,0x4(%esp)
  801753:	8b 45 0c             	mov    0xc(%ebp),%eax
  801756:	89 04 24             	mov    %eax,(%esp)
  801759:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80175c:	ba 01 00 00 00       	mov    $0x1,%edx
  801761:	b8 06 00 00 00       	mov    $0x6,%eax
  801766:	e8 91 fd ff ff       	call   8014fc <syscall>
}
  80176b:	c9                   	leave  
  80176c:	c3                   	ret    

0080176d <sys_page_alloc>:
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80176d:	55                   	push   %ebp
  80176e:	89 e5                	mov    %esp,%ebp
  801770:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
  801773:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80177a:	00 
  80177b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801782:	00 
  801783:	8b 45 10             	mov    0x10(%ebp),%eax
  801786:	89 44 24 04          	mov    %eax,0x4(%esp)
  80178a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80178d:	89 04 24             	mov    %eax,(%esp)
  801790:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801793:	ba 01 00 00 00       	mov    $0x1,%edx
  801798:	b8 05 00 00 00       	mov    $0x5,%eax
  80179d:	e8 5a fd ff ff       	call   8014fc <syscall>
}
  8017a2:	c9                   	leave  
  8017a3:	c3                   	ret    

008017a4 <sys_yield>:
	 return syscall(SYS_map_kernel_page, 0, (uint32_t)kpage, (uint32_t)va, 0, 0, 0);
}

void
sys_yield(void)
{
  8017a4:	55                   	push   %ebp
  8017a5:	89 e5                	mov    %esp,%ebp
  8017a7:	83 ec 18             	sub    $0x18,%esp
	//cprintf("%s:sys_yield[%d]: [%x] calling sys_yield\n", __FILE__, __LINE__, thisenv->env_id);
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
  8017aa:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8017b1:	00 
  8017b2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8017b9:	00 
  8017ba:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8017c1:	00 
  8017c2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8017c9:	b9 00 00 00 00       	mov    $0x0,%ecx
  8017ce:	ba 00 00 00 00       	mov    $0x0,%edx
  8017d3:	b8 0c 00 00 00       	mov    $0xc,%eax
  8017d8:	e8 1f fd ff ff       	call   8014fc <syscall>
}
  8017dd:	c9                   	leave  
  8017de:	c3                   	ret    

008017df <sys_map_kernel_page>:
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}

int
sys_map_kernel_page(void* kpage, void* va)
{
  8017df:	55                   	push   %ebp
  8017e0:	89 e5                	mov    %esp,%ebp
  8017e2:	83 ec 18             	sub    $0x18,%esp
	 return syscall(SYS_map_kernel_page, 0, (uint32_t)kpage, (uint32_t)va, 0, 0, 0);
  8017e5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8017ec:	00 
  8017ed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8017f4:	00 
  8017f5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8017fc:	00 
  8017fd:	8b 45 0c             	mov    0xc(%ebp),%eax
  801800:	89 04 24             	mov    %eax,(%esp)
  801803:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801806:	ba 00 00 00 00       	mov    $0x0,%edx
  80180b:	b8 04 00 00 00       	mov    $0x4,%eax
  801810:	e8 e7 fc ff ff       	call   8014fc <syscall>
}
  801815:	c9                   	leave  
  801816:	c3                   	ret    

00801817 <sys_getenvid>:
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}

envid_t
sys_getenvid(void)
{
  801817:	55                   	push   %ebp
  801818:	89 e5                	mov    %esp,%ebp
  80181a:	83 ec 18             	sub    $0x18,%esp
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
  80181d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801824:	00 
  801825:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80182c:	00 
  80182d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801834:	00 
  801835:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80183c:	b9 00 00 00 00       	mov    $0x0,%ecx
  801841:	ba 00 00 00 00       	mov    $0x0,%edx
  801846:	b8 02 00 00 00       	mov    $0x2,%eax
  80184b:	e8 ac fc ff ff       	call   8014fc <syscall>
}
  801850:	c9                   	leave  
  801851:	c3                   	ret    

00801852 <sys_env_destroy>:
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}

int
sys_env_destroy(envid_t envid)
{
  801852:	55                   	push   %ebp
  801853:	89 e5                	mov    %esp,%ebp
  801855:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
  801858:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80185f:	00 
  801860:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801867:	00 
  801868:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80186f:	00 
  801870:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801877:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80187a:	ba 01 00 00 00       	mov    $0x1,%edx
  80187f:	b8 03 00 00 00       	mov    $0x3,%eax
  801884:	e8 73 fc ff ff       	call   8014fc <syscall>
}
  801889:	c9                   	leave  
  80188a:	c3                   	ret    

0080188b <sys_cgetc>:
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}

int
sys_cgetc(void)
{
  80188b:	55                   	push   %ebp
  80188c:	89 e5                	mov    %esp,%ebp
  80188e:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
  801891:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801898:	00 
  801899:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8018a0:	00 
  8018a1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8018a8:	00 
  8018a9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8018b0:	b9 00 00 00 00       	mov    $0x0,%ecx
  8018b5:	ba 00 00 00 00       	mov    $0x0,%edx
  8018ba:	b8 01 00 00 00       	mov    $0x1,%eax
  8018bf:	e8 38 fc ff ff       	call   8014fc <syscall>
}
  8018c4:	c9                   	leave  
  8018c5:	c3                   	ret    

008018c6 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  8018c6:	55                   	push   %ebp
  8018c7:	89 e5                	mov    %esp,%ebp
  8018c9:	83 ec 18             	sub    $0x18,%esp
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
  8018cc:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8018d3:	00 
  8018d4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8018db:	00 
  8018dc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8018e3:	00 
  8018e4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8018e7:	89 04 24             	mov    %eax,(%esp)
  8018ea:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8018ed:	ba 00 00 00 00       	mov    $0x0,%edx
  8018f2:	b8 00 00 00 00       	mov    $0x0,%eax
  8018f7:	e8 00 fc ff ff       	call   8014fc <syscall>
}
  8018fc:	c9                   	leave  
  8018fd:	c3                   	ret    
	...

00801900 <sfork>:
}

// Challenge!
int
sfork(void)
{
  801900:	55                   	push   %ebp
  801901:	89 e5                	mov    %esp,%ebp
  801903:	83 ec 18             	sub    $0x18,%esp
	panic("sfork not implemented");
  801906:	c7 44 24 08 8b 25 81 	movl   $0x81258b,0x8(%esp)
  80190d:	00 
  80190e:	c7 44 24 04 a4 00 00 	movl   $0xa4,0x4(%esp)
  801915:	00 
  801916:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  80191d:	e8 f2 ef ff ff       	call   800914 <_panic>

00801922 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  801922:	55                   	push   %ebp
  801923:	89 e5                	mov    %esp,%ebp
  801925:	57                   	push   %edi
  801926:	56                   	push   %esi
  801927:	53                   	push   %ebx
  801928:	83 ec 3c             	sub    $0x3c,%esp
	envid_t envidnum;
	uint32_t addr;
	int r;
	extern void _pgfault_upcall(void);
	
	set_pgfault_handler(pgfault);
  80192b:	c7 04 24 e6 1b 80 00 	movl   $0x801be6,(%esp)
  801932:	e8 05 16 00 00       	call   802f3c <set_pgfault_handler>
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	//if I push esp it will be a pagefault.I come across a bug here.
	__asm __volatile(  
  801937:	ba 08 00 00 00       	mov    $0x8,%edx
  80193c:	89 d0                	mov    %edx,%eax
  80193e:	51                   	push   %ecx
  80193f:	52                   	push   %edx
  801940:	53                   	push   %ebx
  801941:	55                   	push   %ebp
  801942:	56                   	push   %esi
  801943:	57                   	push   %edi
  801944:	89 e5                	mov    %esp,%ebp
  801946:	8d 35 4e 19 80 00    	lea    0x80194e,%esi
  80194c:	0f 34                	sysenter 

0080194e <.after_sysenter_label>:
  80194e:	5f                   	pop    %edi
  80194f:	5e                   	pop    %esi
  801950:	5d                   	pop    %ebp
  801951:	5b                   	pop    %ebx
  801952:	5a                   	pop    %edx
  801953:	59                   	pop    %ecx
  801954:	89 45 e0             	mov    %eax,-0x20(%ebp)
	
	envidnum = sys_exofork();
	cprintf("%s:fork[%d]: sys_exofork() return %x\n",__FILE__, __LINE__, envidnum);
  801957:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80195b:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  801962:	00 
  801963:	c7 44 24 04 a1 25 81 	movl   $0x8125a1,0x4(%esp)
  80196a:	00 
  80196b:	c7 04 24 e8 25 81 00 	movl   $0x8125e8,(%esp)
  801972:	e8 56 f0 ff ff       	call   8009cd <cprintf>
	if (envidnum < 0)
  801977:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80197b:	79 23                	jns    8019a0 <.after_sysenter_label+0x52>
		panic("sys_exofork: %e", envidnum);
  80197d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801980:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801984:	c7 44 24 08 ac 25 81 	movl   $0x8125ac,0x8(%esp)
  80198b:	00 
  80198c:	c7 44 24 04 82 00 00 	movl   $0x82,0x4(%esp)
  801993:	00 
  801994:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  80199b:	e8 74 ef ff ff       	call   800914 <_panic>
	// We’re the child
	if (envidnum == 0) {
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
  8019a0:	bb 00 00 80 00       	mov    $0x800000,%ebx
	}
	// We’re the parent.
	for (addr =  UTEXT; addr < UXSTACKTOP - PGSIZE; addr += PGSIZE) 
	{
		if(	(vpd[PDX(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_U) > 0)
  8019a5:	be 00 d0 7b ef       	mov    $0xef7bd000,%esi
  8019aa:	bf 00 00 40 ef       	mov    $0xef400000,%edi
	envidnum = sys_exofork();
	cprintf("%s:fork[%d]: sys_exofork() return %x\n",__FILE__, __LINE__, envidnum);
	if (envidnum < 0)
		panic("sys_exofork: %e", envidnum);
	// We’re the child
	if (envidnum == 0) {
  8019af:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8019b3:	75 1c                	jne    8019d1 <.after_sysenter_label+0x83>
		thisenv = &envs[ENVX(sys_getenvid())];
  8019b5:	e8 5d fe ff ff       	call   801817 <sys_getenvid>
  8019ba:	25 ff 03 00 00       	and    $0x3ff,%eax
  8019bf:	6b c0 7c             	imul   $0x7c,%eax,%eax
  8019c2:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  8019c7:	a3 74 c2 b3 00       	mov    %eax,0xb3c274
		return 0;
  8019cc:	e9 0a 02 00 00       	jmp    801bdb <.after_sysenter_label+0x28d>
	}
	// We’re the parent.
	for (addr =  UTEXT; addr < UXSTACKTOP - PGSIZE; addr += PGSIZE) 
	{
		if(	(vpd[PDX(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_U) > 0)
  8019d1:	89 d8                	mov    %ebx,%eax
  8019d3:	c1 e8 16             	shr    $0x16,%eax
  8019d6:	8b 04 86             	mov    (%esi,%eax,4),%eax
  8019d9:	a8 01                	test   $0x1,%al
  8019db:	0f 84 43 01 00 00    	je     801b24 <.after_sysenter_label+0x1d6>
  8019e1:	89 d8                	mov    %ebx,%eax
  8019e3:	c1 e8 0c             	shr    $0xc,%eax
  8019e6:	8b 14 87             	mov    (%edi,%eax,4),%edx
  8019e9:	f6 c2 01             	test   $0x1,%dl
  8019ec:	0f 84 32 01 00 00    	je     801b24 <.after_sysenter_label+0x1d6>
  8019f2:	8b 14 87             	mov    (%edi,%eax,4),%edx
  8019f5:	f6 c2 04             	test   $0x4,%dl
  8019f8:	0f 84 26 01 00 00    	je     801b24 <.after_sysenter_label+0x1d6>
{
	int r;

	// LAB 4: Your code here.
	int perm;
	void * addr = (void *) ((uint32_t) pn * PGSIZE);
  8019fe:	c1 e0 0c             	shl    $0xc,%eax
  801a01:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	pte_t pte = vpt[PGNUM(addr)];
  801a04:	c1 e8 0c             	shr    $0xc,%eax
  801a07:	8b 04 87             	mov    (%edi,%eax,4),%eax
	perm = pte & PTE_SYSCALL;
  801a0a:	89 c2                	mov    %eax,%edx
  801a0c:	81 e2 07 0e 00 00    	and    $0xe07,%edx
	
	if (perm & (PTE_W|PTE_COW)) 
  801a12:	a9 02 08 00 00       	test   $0x802,%eax
  801a17:	0f 84 a0 00 00 00    	je     801abd <.after_sysenter_label+0x16f>
	{
		 perm &= ~PTE_W;
  801a1d:	83 e2 fd             	and    $0xfffffffd,%edx
		 perm |= PTE_COW;
  801a20:	80 ce 08             	or     $0x8,%dh
  801a23:	89 55 dc             	mov    %edx,-0x24(%ebp)
		//map in child
		if ((r = sys_page_map(0, addr, envid, addr, perm)) < 0)
  801a26:	89 54 24 10          	mov    %edx,0x10(%esp)
  801a2a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801a2d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801a31:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801a34:	89 44 24 08          	mov    %eax,0x8(%esp)
  801a38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801a3b:	89 44 24 04          	mov    %eax,0x4(%esp)
  801a3f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801a46:	e8 e9 fc ff ff       	call   801734 <sys_page_map>
  801a4b:	85 c0                	test   %eax,%eax
  801a4d:	79 20                	jns    801a6f <.after_sysenter_label+0x121>
			panic ("duppage: page re-mapping failed at 1 : %e", r);
  801a4f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801a53:	c7 44 24 08 10 26 81 	movl   $0x812610,0x8(%esp)
  801a5a:	00 
  801a5b:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  801a62:	00 
  801a63:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801a6a:	e8 a5 ee ff ff       	call   800914 <_panic>
		//remap in the parent		
		if ((r = sys_page_map(0, addr, 0, addr, perm)) < 0)
  801a6f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801a72:	89 44 24 10          	mov    %eax,0x10(%esp)
  801a76:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801a79:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801a7d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801a84:	00 
  801a85:	89 44 24 04          	mov    %eax,0x4(%esp)
  801a89:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801a90:	e8 9f fc ff ff       	call   801734 <sys_page_map>
  801a95:	85 c0                	test   %eax,%eax
  801a97:	0f 89 87 00 00 00    	jns    801b24 <.after_sysenter_label+0x1d6>
			panic ("duppage: page re-mapping failed at 2 : %e", r);
  801a9d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801aa1:	c7 44 24 08 3c 26 81 	movl   $0x81263c,0x8(%esp)
  801aa8:	00 
  801aa9:	c7 44 24 04 57 00 00 	movl   $0x57,0x4(%esp)
  801ab0:	00 
  801ab1:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801ab8:	e8 57 ee ff ff       	call   800914 <_panic>
	}
	else //include PTE_SHARE
	{
		cprintf("map two %x----%x\n",envid,addr);
  801abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801ac0:	89 44 24 08          	mov    %eax,0x8(%esp)
  801ac4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801ac7:	89 44 24 04          	mov    %eax,0x4(%esp)
  801acb:	c7 04 24 bc 25 81 00 	movl   $0x8125bc,(%esp)
  801ad2:	e8 f6 ee ff ff       	call   8009cd <cprintf>
		if ((r = sys_page_map (0, addr, envid, addr, PTE_U|PTE_P)) < 0)
  801ad7:	c7 44 24 10 05 00 00 	movl   $0x5,0x10(%esp)
  801ade:	00 
  801adf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801ae2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801ae6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801ae9:	89 44 24 08          	mov    %eax,0x8(%esp)
  801aed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801af0:	89 44 24 04          	mov    %eax,0x4(%esp)
  801af4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801afb:	e8 34 fc ff ff       	call   801734 <sys_page_map>
  801b00:	85 c0                	test   %eax,%eax
  801b02:	79 20                	jns    801b24 <.after_sysenter_label+0x1d6>
			panic ("duppage: page re-mapping failed at 3 : %e", r);
  801b04:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801b08:	c7 44 24 08 68 26 81 	movl   $0x812668,0x8(%esp)
  801b0f:	00 
  801b10:	c7 44 24 04 5d 00 00 	movl   $0x5d,0x4(%esp)
  801b17:	00 
  801b18:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801b1f:	e8 f0 ed ff ff       	call   800914 <_panic>
	if (envidnum == 0) {
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	// We’re the parent.
	for (addr =  UTEXT; addr < UXSTACKTOP - PGSIZE; addr += PGSIZE) 
  801b24:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  801b2a:	81 fb 00 f0 bf ee    	cmp    $0xeebff000,%ebx
  801b30:	0f 85 9b fe ff ff    	jne    8019d1 <.after_sysenter_label+0x83>
	{
		if(	(vpd[PDX(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_U) > 0)
			duppage(envidnum,PGNUM(addr));
	}
	if ((r = sys_page_alloc (envidnum, (void *)(UXSTACKTOP - PGSIZE), PTE_U|PTE_W|PTE_P)) < 0)
  801b36:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801b3d:	00 
  801b3e:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  801b45:	ee 
  801b46:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801b49:	89 04 24             	mov    %eax,(%esp)
  801b4c:	e8 1c fc ff ff       	call   80176d <sys_page_alloc>
  801b51:	85 c0                	test   %eax,%eax
  801b53:	79 20                	jns    801b75 <.after_sysenter_label+0x227>
		panic ("fork: page allocation failed : %e", r);
  801b55:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801b59:	c7 44 24 08 94 26 81 	movl   $0x812694,0x8(%esp)
  801b60:	00 
  801b61:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  801b68:	00 
  801b69:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801b70:	e8 9f ed ff ff       	call   800914 <_panic>
	//cprintf("%x-----%x\n",&envid,envid);
	sys_env_set_pgfault_upcall (envidnum, _pgfault_upcall);
  801b75:	c7 44 24 04 ac 2f 80 	movl   $0x802fac,0x4(%esp)
  801b7c:	00 
  801b7d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801b80:	89 04 24             	mov    %eax,(%esp)
  801b83:	e8 cc fa ff ff       	call   801654 <sys_env_set_pgfault_upcall>
	//cprintf("%x-----%x\n",&envid,envid);
	// Start the child environment running
	if((r = sys_env_set_status(envidnum, ENV_RUNNABLE)) < 0)
  801b88:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  801b8f:	00 
  801b90:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801b93:	89 04 24             	mov    %eax,(%esp)
  801b96:	e8 29 fb ff ff       	call   8016c4 <sys_env_set_status>
  801b9b:	85 c0                	test   %eax,%eax
  801b9d:	79 20                	jns    801bbf <.after_sysenter_label+0x271>
		panic("fork: set child env status failed : %e", r);
  801b9f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801ba3:	c7 44 24 08 b8 26 81 	movl   $0x8126b8,0x8(%esp)
  801baa:	00 
  801bab:	c7 44 24 04 95 00 00 	movl   $0x95,0x4(%esp)
  801bb2:	00 
  801bb3:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801bba:	e8 55 ed ff ff       	call   800914 <_panic>
	//cprintf("%x-----%x\n",&envid,envid);
	//cprintf("fork in %x have set %x ,runnable\n",sys_getenvid(),envidnum);
	//cprintf("fork in %x have set %x ,runnable\n",sys_getenvid(),envidnum);
	//cprintf("%x-----%x\n",&envidnum,envidnum);
	cprintf("%s:fork[%d]: fork return\n", __FILE__, __LINE__);
  801bbf:	c7 44 24 08 9a 00 00 	movl   $0x9a,0x8(%esp)
  801bc6:	00 
  801bc7:	c7 44 24 04 a1 25 81 	movl   $0x8125a1,0x4(%esp)
  801bce:	00 
  801bcf:	c7 04 24 ce 25 81 00 	movl   $0x8125ce,(%esp)
  801bd6:	e8 f2 ed ff ff       	call   8009cd <cprintf>
	return envidnum;

	//panic("fork not implemented");
}
  801bdb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801bde:	83 c4 3c             	add    $0x3c,%esp
  801be1:	5b                   	pop    %ebx
  801be2:	5e                   	pop    %esi
  801be3:	5f                   	pop    %edi
  801be4:	5d                   	pop    %ebp
  801be5:	c3                   	ret    

00801be6 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  801be6:	55                   	push   %ebp
  801be7:	89 e5                	mov    %esp,%ebp
  801be9:	53                   	push   %ebx
  801bea:	83 ec 24             	sub    $0x24,%esp
  801bed:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  801bf0:	8b 18                	mov    (%eax),%ebx
	uint32_t err = utf->utf_err;
  801bf2:	8b 50 04             	mov    0x4(%eax),%edx
	// Hint:
	//   Use the read-only page table mappings at vpt
	//   (see <inc/memlayout.h>).
	//cprintf("pgfault: do page fault here %x\n",utf->utf_eflags);
	// LAB 4: Your code here.
	if((err & FEC_WR) == 0)
  801bf5:	f6 c2 02             	test   $0x2,%dl
  801bf8:	75 2b                	jne    801c25 <pgfault+0x3f>
		panic("pgfault: fault is not a write (err: %08x va: %08x ip: %08x)",err, addr, utf->utf_eip);
  801bfa:	8b 40 28             	mov    0x28(%eax),%eax
  801bfd:	89 44 24 14          	mov    %eax,0x14(%esp)
  801c01:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  801c05:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801c09:	c7 44 24 08 e0 26 81 	movl   $0x8126e0,0x8(%esp)
  801c10:	00 
  801c11:	c7 44 24 04 1c 00 00 	movl   $0x1c,0x4(%esp)
  801c18:	00 
  801c19:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801c20:	e8 ef ec ff ff       	call   800914 <_panic>
	if ((vpd[PDX(addr)] & PTE_P) == 0 || (vpt[PGNUM(addr)] & PTE_COW) == 0)
  801c25:	89 d8                	mov    %ebx,%eax
  801c27:	c1 e8 16             	shr    $0x16,%eax
  801c2a:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  801c31:	a8 01                	test   $0x1,%al
  801c33:	74 11                	je     801c46 <pgfault+0x60>
  801c35:	89 d8                	mov    %ebx,%eax
  801c37:	c1 e8 0c             	shr    $0xc,%eax
  801c3a:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  801c41:	f6 c4 08             	test   $0x8,%ah
  801c44:	75 1c                	jne    801c62 <pgfault+0x7c>
		panic ("pgfault: not a write or attempting to access a non-COW page");
  801c46:	c7 44 24 08 1c 27 81 	movl   $0x81271c,0x8(%esp)
  801c4d:	00 
  801c4e:	c7 44 24 04 1e 00 00 	movl   $0x1e,0x4(%esp)
  801c55:	00 
  801c56:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801c5d:	e8 b2 ec ff ff       	call   800914 <_panic>
	// Hint:
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.

	// LAB 4: Your code here.
	if ((r = sys_page_alloc (0, (void *)PFTEMP, PTE_U|PTE_P|PTE_W)) < 0)
  801c62:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801c69:	00 
  801c6a:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801c71:	00 
  801c72:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801c79:	e8 ef fa ff ff       	call   80176d <sys_page_alloc>
  801c7e:	85 c0                	test   %eax,%eax
  801c80:	79 20                	jns    801ca2 <pgfault+0xbc>
		panic ("pgfault: page allocation failed : %e", r);
  801c82:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801c86:	c7 44 24 08 58 27 81 	movl   $0x812758,0x8(%esp)
  801c8d:	00 
  801c8e:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  801c95:	00 
  801c96:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801c9d:	e8 72 ec ff ff       	call   800914 <_panic>
	addr = ROUNDDOWN (addr, PGSIZE);
  801ca2:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	memmove (PFTEMP, addr, PGSIZE);
  801ca8:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  801caf:	00 
  801cb0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  801cb4:	c7 04 24 00 f0 7f 00 	movl   $0x7ff000,(%esp)
  801cbb:	e8 35 f6 ff ff       	call   8012f5 <memmove>
	if((r = sys_page_map (0, PFTEMP, 0, addr, PTE_U|PTE_P|PTE_W)) < 0)
  801cc0:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  801cc7:	00 
  801cc8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  801ccc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801cd3:	00 
  801cd4:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801cdb:	00 
  801cdc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801ce3:	e8 4c fa ff ff       	call   801734 <sys_page_map>
  801ce8:	85 c0                	test   %eax,%eax
  801cea:	79 20                	jns    801d0c <pgfault+0x126>
		panic ("pgfault: page mapping failed : %e", r);
  801cec:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801cf0:	c7 44 24 08 80 27 81 	movl   $0x812780,0x8(%esp)
  801cf7:	00 
  801cf8:	c7 44 24 04 2c 00 00 	movl   $0x2c,0x4(%esp)
  801cff:	00 
  801d00:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801d07:	e8 08 ec ff ff       	call   800914 <_panic>
	if((r = sys_page_unmap(0,PFTEMP)) < 0)
  801d0c:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801d13:	00 
  801d14:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801d1b:	e8 dc f9 ff ff       	call   8016fc <sys_page_unmap>
  801d20:	85 c0                	test   %eax,%eax
  801d22:	79 20                	jns    801d44 <pgfault+0x15e>
		panic("pgfault: page unmapping failed : %e", r);
  801d24:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801d28:	c7 44 24 08 a4 27 81 	movl   $0x8127a4,0x8(%esp)
  801d2f:	00 
  801d30:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
  801d37:	00 
  801d38:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801d3f:	e8 d0 eb ff ff       	call   800914 <_panic>
	/* __asm__ volatile("movl %%esp, %0\n\t" */
	/* 		 :"=r"(gaga) */
	/* 		 ::); */
	/* cprintf("gaga----------%x\n", gaga); */
	//panic("pgfault not implemented");
}
  801d44:	83 c4 24             	add    $0x24,%esp
  801d47:	5b                   	pop    %ebx
  801d48:	5d                   	pop    %ebp
  801d49:	c3                   	ret    
  801d4a:	00 00                	add    %al,(%eax)
  801d4c:	00 00                	add    %al,(%eax)
	...

00801d50 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  801d50:	55                   	push   %ebp
  801d51:	89 e5                	mov    %esp,%ebp
  801d53:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
		if (envs[i].env_type == type)
  801d56:	8b 15 50 00 c0 ee    	mov    0xeec00050,%edx
  801d5c:	b8 01 00 00 00       	mov    $0x1,%eax
  801d61:	39 ca                	cmp    %ecx,%edx
  801d63:	75 04                	jne    801d69 <ipc_find_env+0x19>
  801d65:	b0 00                	mov    $0x0,%al
  801d67:	eb 0f                	jmp    801d78 <ipc_find_env+0x28>
  801d69:	6b d0 7c             	imul   $0x7c,%eax,%edx
  801d6c:	81 c2 50 00 c0 ee    	add    $0xeec00050,%edx
  801d72:	8b 12                	mov    (%edx),%edx
  801d74:	39 ca                	cmp    %ecx,%edx
  801d76:	75 0c                	jne    801d84 <ipc_find_env+0x34>
			return envs[i].env_id;
  801d78:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801d7b:	05 48 00 c0 ee       	add    $0xeec00048,%eax
  801d80:	8b 00                	mov    (%eax),%eax
  801d82:	eb 0e                	jmp    801d92 <ipc_find_env+0x42>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  801d84:	83 c0 01             	add    $0x1,%eax
  801d87:	3d 00 04 00 00       	cmp    $0x400,%eax
  801d8c:	75 db                	jne    801d69 <ipc_find_env+0x19>
  801d8e:	66 b8 00 00          	mov    $0x0,%ax
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
}
  801d92:	5d                   	pop    %ebp
  801d93:	c3                   	ret    

00801d94 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  801d94:	55                   	push   %ebp
  801d95:	89 e5                	mov    %esp,%ebp
  801d97:	57                   	push   %edi
  801d98:	56                   	push   %esi
  801d99:	53                   	push   %ebx
  801d9a:	83 ec 1c             	sub    $0x1c,%esp
  801d9d:	8b 75 08             	mov    0x8(%ebp),%esi
  801da0:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801da3:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	int r;
	if(!pg)
  801da6:	85 db                	test   %ebx,%ebx
  801da8:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  801dad:	0f 44 d8             	cmove  %eax,%ebx
  801db0:	eb 25                	jmp    801dd7 <ipc_send+0x43>
		pg = (void*)UTOP; 
	while((r = sys_ipc_try_send(to_env,val,pg,perm)) != 0)
	{
		if(/* r < 0 && */r != -E_IPC_NOT_RECV )
  801db2:	83 f8 f9             	cmp    $0xfffffff9,%eax
  801db5:	74 20                	je     801dd7 <ipc_send+0x43>
			panic ("ipc: sys try send failed : %e", r);
  801db7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801dbb:	c7 44 24 08 c8 27 81 	movl   $0x8127c8,0x8(%esp)
  801dc2:	00 
  801dc3:	c7 44 24 04 41 00 00 	movl   $0x41,0x4(%esp)
  801dca:	00 
  801dcb:	c7 04 24 e6 27 81 00 	movl   $0x8127e6,(%esp)
  801dd2:	e8 3d eb ff ff       	call   800914 <_panic>
{
	// LAB 4: Your code here.
	int r;
	if(!pg)
		pg = (void*)UTOP; 
	while((r = sys_ipc_try_send(to_env,val,pg,perm)) != 0)
  801dd7:	8b 45 14             	mov    0x14(%ebp),%eax
  801dda:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801dde:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  801de2:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801de6:	89 34 24             	mov    %esi,(%esp)
  801de9:	e8 30 f8 ff ff       	call   80161e <sys_ipc_try_send>
  801dee:	85 c0                	test   %eax,%eax
  801df0:	75 c0                	jne    801db2 <ipc_send+0x1e>
	{
		if(/* r < 0 && */r != -E_IPC_NOT_RECV )
			panic ("ipc: sys try send failed : %e", r);
	}
	sys_yield();
  801df2:	e8 ad f9 ff ff       	call   8017a4 <sys_yield>
}
  801df7:	83 c4 1c             	add    $0x1c,%esp
  801dfa:	5b                   	pop    %ebx
  801dfb:	5e                   	pop    %esi
  801dfc:	5f                   	pop    %edi
  801dfd:	5d                   	pop    %ebp
  801dfe:	c3                   	ret    

00801dff <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  801dff:	55                   	push   %ebp
  801e00:	89 e5                	mov    %esp,%ebp
  801e02:	83 ec 28             	sub    $0x28,%esp
  801e05:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801e08:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801e0b:	89 7d fc             	mov    %edi,-0x4(%ebp)
  801e0e:	8b 75 08             	mov    0x8(%ebp),%esi
  801e11:	8b 45 0c             	mov    0xc(%ebp),%eax
  801e14:	8b 7d 10             	mov    0x10(%ebp),%edi
	// LAB 4: Your code here.
	int r;
	if(!pg)
  801e17:	85 c0                	test   %eax,%eax
  801e19:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  801e1e:	0f 44 c2             	cmove  %edx,%eax
		pg = (void*)UTOP;

	if((r = sys_ipc_recv(pg)) < 0)
  801e21:	89 04 24             	mov    %eax,(%esp)
  801e24:	e8 bc f7 ff ff       	call   8015e5 <sys_ipc_recv>
  801e29:	89 c3                	mov    %eax,%ebx
  801e2b:	85 c0                	test   %eax,%eax
  801e2d:	79 2a                	jns    801e59 <ipc_recv+0x5a>
	{
		cprintf("recv wrong %e %x\n",r,r);
  801e2f:	89 44 24 08          	mov    %eax,0x8(%esp)
  801e33:	89 44 24 04          	mov    %eax,0x4(%esp)
  801e37:	c7 04 24 f0 27 81 00 	movl   $0x8127f0,(%esp)
  801e3e:	e8 8a eb ff ff       	call   8009cd <cprintf>
		if(from_env_store != NULL)
  801e43:	85 f6                	test   %esi,%esi
  801e45:	74 06                	je     801e4d <ipc_recv+0x4e>
			*from_env_store = 0;
  801e47:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		if(perm_store != NULL)
  801e4d:	85 ff                	test   %edi,%edi
  801e4f:	74 2c                	je     801e7d <ipc_recv+0x7e>
			*perm_store = 0;
  801e51:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
  801e57:	eb 24                	jmp    801e7d <ipc_recv+0x7e>
		return r;
	}
	if(from_env_store != NULL)
  801e59:	85 f6                	test   %esi,%esi
  801e5b:	74 0a                	je     801e67 <ipc_recv+0x68>
		*from_env_store = thisenv->env_ipc_from;
  801e5d:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  801e62:	8b 40 74             	mov    0x74(%eax),%eax
  801e65:	89 06                	mov    %eax,(%esi)
	if(perm_store != NULL)
  801e67:	85 ff                	test   %edi,%edi
  801e69:	74 0a                	je     801e75 <ipc_recv+0x76>
		*perm_store = thisenv->env_ipc_perm;
  801e6b:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  801e70:	8b 40 78             	mov    0x78(%eax),%eax
  801e73:	89 07                	mov    %eax,(%edi)
	//panic("ipc_recv not implemented");
	return thisenv->env_ipc_value;
  801e75:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  801e7a:	8b 58 70             	mov    0x70(%eax),%ebx
}
  801e7d:	89 d8                	mov    %ebx,%eax
  801e7f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801e82:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801e85:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801e88:	89 ec                	mov    %ebp,%esp
  801e8a:	5d                   	pop    %ebp
  801e8b:	c3                   	ret    
  801e8c:	00 00                	add    %al,(%eax)
	...

00801e90 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  801e90:	55                   	push   %ebp
  801e91:	89 e5                	mov    %esp,%ebp
  801e93:	8b 45 08             	mov    0x8(%ebp),%eax
  801e96:	05 00 00 00 30       	add    $0x30000000,%eax
  801e9b:	c1 e8 0c             	shr    $0xc,%eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
}
  801e9e:	5d                   	pop    %ebp
  801e9f:	c3                   	ret    

00801ea0 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  801ea0:	55                   	push   %ebp
  801ea1:	89 e5                	mov    %esp,%ebp
  801ea3:	83 ec 04             	sub    $0x4,%esp
	return INDEX2DATA(fd2num(fd));
  801ea6:	8b 45 08             	mov    0x8(%ebp),%eax
  801ea9:	89 04 24             	mov    %eax,(%esp)
  801eac:	e8 df ff ff ff       	call   801e90 <fd2num>
  801eb1:	05 20 00 0d 00       	add    $0xd0020,%eax
  801eb6:	c1 e0 0c             	shl    $0xc,%eax
}
  801eb9:	c9                   	leave  
  801eba:	c3                   	ret    

00801ebb <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  801ebb:	55                   	push   %ebp
  801ebc:	89 e5                	mov    %esp,%ebp
  801ebe:	57                   	push   %edi
  801ebf:	56                   	push   %esi
  801ec0:	53                   	push   %ebx
  801ec1:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[PGNUM(fd)] & PTE_P) == 0) {
  801ec4:	a1 00 dd 7b ef       	mov    0xef7bdd00,%eax
  801ec9:	a8 01                	test   $0x1,%al
  801ecb:	74 36                	je     801f03 <fd_alloc+0x48>
  801ecd:	a1 00 00 74 ef       	mov    0xef740000,%eax
  801ed2:	a8 01                	test   $0x1,%al
  801ed4:	74 2d                	je     801f03 <fd_alloc+0x48>
  801ed6:	b8 00 10 00 d0       	mov    $0xd0001000,%eax
  801edb:	b9 00 d0 7b ef       	mov    $0xef7bd000,%ecx
  801ee0:	be 00 00 40 ef       	mov    $0xef400000,%esi
  801ee5:	89 c3                	mov    %eax,%ebx
  801ee7:	89 c2                	mov    %eax,%edx
  801ee9:	c1 ea 16             	shr    $0x16,%edx
  801eec:	8b 14 91             	mov    (%ecx,%edx,4),%edx
  801eef:	f6 c2 01             	test   $0x1,%dl
  801ef2:	74 14                	je     801f08 <fd_alloc+0x4d>
  801ef4:	89 c2                	mov    %eax,%edx
  801ef6:	c1 ea 0c             	shr    $0xc,%edx
  801ef9:	8b 14 96             	mov    (%esi,%edx,4),%edx
  801efc:	f6 c2 01             	test   $0x1,%dl
  801eff:	75 10                	jne    801f11 <fd_alloc+0x56>
  801f01:	eb 05                	jmp    801f08 <fd_alloc+0x4d>
  801f03:	bb 00 00 00 d0       	mov    $0xd0000000,%ebx
			*fd_store = fd;
  801f08:	89 1f                	mov    %ebx,(%edi)
  801f0a:	b8 00 00 00 00       	mov    $0x0,%eax
			return 0;
  801f0f:	eb 17                	jmp    801f28 <fd_alloc+0x6d>
  801f11:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  801f16:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  801f1b:	75 c8                	jne    801ee5 <fd_alloc+0x2a>
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  801f1d:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
  801f23:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
	return -E_MAX_OPEN;
}
  801f28:	5b                   	pop    %ebx
  801f29:	5e                   	pop    %esi
  801f2a:	5f                   	pop    %edi
  801f2b:	5d                   	pop    %ebp
  801f2c:	c3                   	ret    

00801f2d <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  801f2d:	55                   	push   %ebp
  801f2e:	89 e5                	mov    %esp,%ebp
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  801f30:	8b 45 08             	mov    0x8(%ebp),%eax
  801f33:	83 f8 1f             	cmp    $0x1f,%eax
  801f36:	77 36                	ja     801f6e <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fd);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  801f38:	05 00 00 0d 00       	add    $0xd0000,%eax
  801f3d:	c1 e0 0c             	shl    $0xc,%eax
	if (!(vpd[PDX(fd)] & PTE_P) || !(vpt[PGNUM(fd)] & PTE_P)) {
  801f40:	89 c2                	mov    %eax,%edx
  801f42:	c1 ea 16             	shr    $0x16,%edx
  801f45:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  801f4c:	f6 c2 01             	test   $0x1,%dl
  801f4f:	74 1d                	je     801f6e <fd_lookup+0x41>
  801f51:	89 c2                	mov    %eax,%edx
  801f53:	c1 ea 0c             	shr    $0xc,%edx
  801f56:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  801f5d:	f6 c2 01             	test   $0x1,%dl
  801f60:	74 0c                	je     801f6e <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fd);
		return -E_INVAL;
	}
	*fd_store = fd;
  801f62:	8b 55 0c             	mov    0xc(%ebp),%edx
  801f65:	89 02                	mov    %eax,(%edx)
  801f67:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
  801f6c:	eb 05                	jmp    801f73 <fd_lookup+0x46>
  801f6e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  801f73:	5d                   	pop    %ebp
  801f74:	c3                   	ret    

00801f75 <seek>:
	return (*dev->dev_write)(fd, buf, n);
}

int
seek(int fdnum, off_t offset)
{
  801f75:	55                   	push   %ebp
  801f76:	89 e5                	mov    %esp,%ebp
  801f78:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  801f7b:	8d 45 fc             	lea    -0x4(%ebp),%eax
  801f7e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801f82:	8b 45 08             	mov    0x8(%ebp),%eax
  801f85:	89 04 24             	mov    %eax,(%esp)
  801f88:	e8 a0 ff ff ff       	call   801f2d <fd_lookup>
  801f8d:	85 c0                	test   %eax,%eax
  801f8f:	78 0e                	js     801f9f <seek+0x2a>
		return r;
	fd->fd_offset = offset;
  801f91:	8b 45 fc             	mov    -0x4(%ebp),%eax
  801f94:	8b 55 0c             	mov    0xc(%ebp),%edx
  801f97:	89 50 04             	mov    %edx,0x4(%eax)
  801f9a:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  801f9f:	c9                   	leave  
  801fa0:	c3                   	ret    

00801fa1 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  801fa1:	55                   	push   %ebp
  801fa2:	89 e5                	mov    %esp,%ebp
  801fa4:	56                   	push   %esi
  801fa5:	53                   	push   %ebx
  801fa6:	83 ec 10             	sub    $0x10,%esp
  801fa9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801fac:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int i;
	for (i = 0; devtab[i]; i++)
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
  801faf:	ba 00 00 00 00       	mov    $0x0,%edx
int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
		if (devtab[i]->dev_id == dev_id) {
  801fb4:	b8 04 50 81 00       	mov    $0x815004,%eax
  801fb9:	39 0d 04 50 81 00    	cmp    %ecx,0x815004
  801fbf:	75 11                	jne    801fd2 <dev_lookup+0x31>
  801fc1:	eb 04                	jmp    801fc7 <dev_lookup+0x26>
  801fc3:	39 08                	cmp    %ecx,(%eax)
  801fc5:	75 10                	jne    801fd7 <dev_lookup+0x36>
			*dev = devtab[i];
  801fc7:	89 03                	mov    %eax,(%ebx)
  801fc9:	b8 00 00 00 00       	mov    $0x0,%eax
			return 0;
  801fce:	66 90                	xchg   %ax,%ax
  801fd0:	eb 36                	jmp    802008 <dev_lookup+0x67>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  801fd2:	be 80 28 81 00       	mov    $0x812880,%esi
  801fd7:	83 c2 01             	add    $0x1,%edx
  801fda:	8b 04 96             	mov    (%esi,%edx,4),%eax
  801fdd:	85 c0                	test   %eax,%eax
  801fdf:	75 e2                	jne    801fc3 <dev_lookup+0x22>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  801fe1:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  801fe6:	8b 40 48             	mov    0x48(%eax),%eax
  801fe9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  801fed:	89 44 24 04          	mov    %eax,0x4(%esp)
  801ff1:	c7 04 24 04 28 81 00 	movl   $0x812804,(%esp)
  801ff8:	e8 d0 e9 ff ff       	call   8009cd <cprintf>
	*dev = 0;
  801ffd:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  802003:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	return -E_INVAL;
}
  802008:	83 c4 10             	add    $0x10,%esp
  80200b:	5b                   	pop    %ebx
  80200c:	5e                   	pop    %esi
  80200d:	5d                   	pop    %ebp
  80200e:	c3                   	ret    

0080200f <fstat>:
	return (*dev->dev_trunc)(fd, newsize);
}

int
fstat(int fdnum, struct Stat *stat)
{
  80200f:	55                   	push   %ebp
  802010:	89 e5                	mov    %esp,%ebp
  802012:	53                   	push   %ebx
  802013:	83 ec 24             	sub    $0x24,%esp
  802016:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802019:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80201c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802020:	8b 45 08             	mov    0x8(%ebp),%eax
  802023:	89 04 24             	mov    %eax,(%esp)
  802026:	e8 02 ff ff ff       	call   801f2d <fd_lookup>
  80202b:	85 c0                	test   %eax,%eax
  80202d:	78 53                	js     802082 <fstat+0x73>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80202f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802032:	89 44 24 04          	mov    %eax,0x4(%esp)
  802036:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802039:	8b 00                	mov    (%eax),%eax
  80203b:	89 04 24             	mov    %eax,(%esp)
  80203e:	e8 5e ff ff ff       	call   801fa1 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802043:	85 c0                	test   %eax,%eax
  802045:	78 3b                	js     802082 <fstat+0x73>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
  802047:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80204c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80204f:	83 7a 14 00          	cmpl   $0x0,0x14(%edx)
  802053:	74 2d                	je     802082 <fstat+0x73>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  802055:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  802058:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80205f:	00 00 00 
	stat->st_isdir = 0;
  802062:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  802069:	00 00 00 
	stat->st_dev = dev;
  80206c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80206f:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  802075:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802079:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80207c:	89 14 24             	mov    %edx,(%esp)
  80207f:	ff 50 14             	call   *0x14(%eax)
}
  802082:	83 c4 24             	add    $0x24,%esp
  802085:	5b                   	pop    %ebx
  802086:	5d                   	pop    %ebp
  802087:	c3                   	ret    

00802088 <ftruncate>:
	return 0;
}

int
ftruncate(int fdnum, off_t newsize)
{
  802088:	55                   	push   %ebp
  802089:	89 e5                	mov    %esp,%ebp
  80208b:	53                   	push   %ebx
  80208c:	83 ec 24             	sub    $0x24,%esp
  80208f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  802092:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802095:	89 44 24 04          	mov    %eax,0x4(%esp)
  802099:	89 1c 24             	mov    %ebx,(%esp)
  80209c:	e8 8c fe ff ff       	call   801f2d <fd_lookup>
  8020a1:	85 c0                	test   %eax,%eax
  8020a3:	78 5f                	js     802104 <ftruncate+0x7c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8020a5:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8020a8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8020af:	8b 00                	mov    (%eax),%eax
  8020b1:	89 04 24             	mov    %eax,(%esp)
  8020b4:	e8 e8 fe ff ff       	call   801fa1 <dev_lookup>
ftruncate(int fdnum, off_t newsize)
{
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  8020b9:	85 c0                	test   %eax,%eax
  8020bb:	78 47                	js     802104 <ftruncate+0x7c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8020bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8020c0:	f6 42 08 03          	testb  $0x3,0x8(%edx)
  8020c4:	75 23                	jne    8020e9 <ftruncate+0x61>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  8020c6:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  8020cb:	8b 40 48             	mov    0x48(%eax),%eax
  8020ce:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8020d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020d6:	c7 04 24 24 28 81 00 	movl   $0x812824,(%esp)
  8020dd:	e8 eb e8 ff ff       	call   8009cd <cprintf>
  8020e2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
			thisenv->env_id, fdnum);
		return -E_INVAL;
  8020e7:	eb 1b                	jmp    802104 <ftruncate+0x7c>
	}
	if (!dev->dev_trunc)
  8020e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8020ec:	8b 48 18             	mov    0x18(%eax),%ecx
  8020ef:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8020f4:	85 c9                	test   %ecx,%ecx
  8020f6:	74 0c                	je     802104 <ftruncate+0x7c>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  8020f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8020fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020ff:	89 14 24             	mov    %edx,(%esp)
  802102:	ff d1                	call   *%ecx
}
  802104:	83 c4 24             	add    $0x24,%esp
  802107:	5b                   	pop    %ebx
  802108:	5d                   	pop    %ebp
  802109:	c3                   	ret    

0080210a <write>:
	return tot;
}

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80210a:	55                   	push   %ebp
  80210b:	89 e5                	mov    %esp,%ebp
  80210d:	53                   	push   %ebx
  80210e:	83 ec 24             	sub    $0x24,%esp
  802111:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802114:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802117:	89 44 24 04          	mov    %eax,0x4(%esp)
  80211b:	89 1c 24             	mov    %ebx,(%esp)
  80211e:	e8 0a fe ff ff       	call   801f2d <fd_lookup>
  802123:	85 c0                	test   %eax,%eax
  802125:	78 66                	js     80218d <write+0x83>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  802127:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80212a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80212e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802131:	8b 00                	mov    (%eax),%eax
  802133:	89 04 24             	mov    %eax,(%esp)
  802136:	e8 66 fe ff ff       	call   801fa1 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80213b:	85 c0                	test   %eax,%eax
  80213d:	78 4e                	js     80218d <write+0x83>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80213f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  802142:	f6 42 08 03          	testb  $0x3,0x8(%edx)
  802146:	75 23                	jne    80216b <write+0x61>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  802148:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  80214d:	8b 40 48             	mov    0x48(%eax),%eax
  802150:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802154:	89 44 24 04          	mov    %eax,0x4(%esp)
  802158:	c7 04 24 45 28 81 00 	movl   $0x812845,(%esp)
  80215f:	e8 69 e8 ff ff       	call   8009cd <cprintf>
  802164:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		return -E_INVAL;
  802169:	eb 22                	jmp    80218d <write+0x83>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80216b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80216e:	8b 48 0c             	mov    0xc(%eax),%ecx
  802171:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  802176:	85 c9                	test   %ecx,%ecx
  802178:	74 13                	je     80218d <write+0x83>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80217a:	8b 45 10             	mov    0x10(%ebp),%eax
  80217d:	89 44 24 08          	mov    %eax,0x8(%esp)
  802181:	8b 45 0c             	mov    0xc(%ebp),%eax
  802184:	89 44 24 04          	mov    %eax,0x4(%esp)
  802188:	89 14 24             	mov    %edx,(%esp)
  80218b:	ff d1                	call   *%ecx
}
  80218d:	83 c4 24             	add    $0x24,%esp
  802190:	5b                   	pop    %ebx
  802191:	5d                   	pop    %ebp
  802192:	c3                   	ret    

00802193 <read>:
	return r;
}

ssize_t
read(int fdnum, void *buf, size_t n)
{
  802193:	55                   	push   %ebp
  802194:	89 e5                	mov    %esp,%ebp
  802196:	53                   	push   %ebx
  802197:	83 ec 24             	sub    $0x24,%esp
  80219a:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80219d:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8021a0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021a4:	89 1c 24             	mov    %ebx,(%esp)
  8021a7:	e8 81 fd ff ff       	call   801f2d <fd_lookup>
  8021ac:	85 c0                	test   %eax,%eax
  8021ae:	78 6b                	js     80221b <read+0x88>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8021b0:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8021b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8021ba:	8b 00                	mov    (%eax),%eax
  8021bc:	89 04 24             	mov    %eax,(%esp)
  8021bf:	e8 dd fd ff ff       	call   801fa1 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8021c4:	85 c0                	test   %eax,%eax
  8021c6:	78 53                	js     80221b <read+0x88>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  8021c8:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8021cb:	8b 42 08             	mov    0x8(%edx),%eax
  8021ce:	83 e0 03             	and    $0x3,%eax
  8021d1:	83 f8 01             	cmp    $0x1,%eax
  8021d4:	75 23                	jne    8021f9 <read+0x66>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  8021d6:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  8021db:	8b 40 48             	mov    0x48(%eax),%eax
  8021de:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8021e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021e6:	c7 04 24 62 28 81 00 	movl   $0x812862,(%esp)
  8021ed:	e8 db e7 ff ff       	call   8009cd <cprintf>
  8021f2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		return -E_INVAL;
  8021f7:	eb 22                	jmp    80221b <read+0x88>
	}
	if (!dev->dev_read)
  8021f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8021fc:	8b 48 08             	mov    0x8(%eax),%ecx
  8021ff:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  802204:	85 c9                	test   %ecx,%ecx
  802206:	74 13                	je     80221b <read+0x88>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  802208:	8b 45 10             	mov    0x10(%ebp),%eax
  80220b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80220f:	8b 45 0c             	mov    0xc(%ebp),%eax
  802212:	89 44 24 04          	mov    %eax,0x4(%esp)
  802216:	89 14 24             	mov    %edx,(%esp)
  802219:	ff d1                	call   *%ecx
}
  80221b:	83 c4 24             	add    $0x24,%esp
  80221e:	5b                   	pop    %ebx
  80221f:	5d                   	pop    %ebp
  802220:	c3                   	ret    

00802221 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  802221:	55                   	push   %ebp
  802222:	89 e5                	mov    %esp,%ebp
  802224:	57                   	push   %edi
  802225:	56                   	push   %esi
  802226:	53                   	push   %ebx
  802227:	83 ec 1c             	sub    $0x1c,%esp
  80222a:	8b 7d 08             	mov    0x8(%ebp),%edi
  80222d:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  802230:	ba 00 00 00 00       	mov    $0x0,%edx
  802235:	bb 00 00 00 00       	mov    $0x0,%ebx
  80223a:	b8 00 00 00 00       	mov    $0x0,%eax
  80223f:	85 f6                	test   %esi,%esi
  802241:	74 29                	je     80226c <readn+0x4b>
		m = read(fdnum, (char*)buf + tot, n - tot);
  802243:	89 f0                	mov    %esi,%eax
  802245:	29 d0                	sub    %edx,%eax
  802247:	89 44 24 08          	mov    %eax,0x8(%esp)
  80224b:	03 55 0c             	add    0xc(%ebp),%edx
  80224e:	89 54 24 04          	mov    %edx,0x4(%esp)
  802252:	89 3c 24             	mov    %edi,(%esp)
  802255:	e8 39 ff ff ff       	call   802193 <read>
		if (m < 0)
  80225a:	85 c0                	test   %eax,%eax
  80225c:	78 0e                	js     80226c <readn+0x4b>
			return m;
		if (m == 0)
  80225e:	85 c0                	test   %eax,%eax
  802260:	74 08                	je     80226a <readn+0x49>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  802262:	01 c3                	add    %eax,%ebx
  802264:	89 da                	mov    %ebx,%edx
  802266:	39 f3                	cmp    %esi,%ebx
  802268:	72 d9                	jb     802243 <readn+0x22>
  80226a:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  80226c:	83 c4 1c             	add    $0x1c,%esp
  80226f:	5b                   	pop    %ebx
  802270:	5e                   	pop    %esi
  802271:	5f                   	pop    %edi
  802272:	5d                   	pop    %ebp
  802273:	c3                   	ret    

00802274 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  802274:	55                   	push   %ebp
  802275:	89 e5                	mov    %esp,%ebp
  802277:	83 ec 28             	sub    $0x28,%esp
  80227a:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80227d:	89 75 fc             	mov    %esi,-0x4(%ebp)
  802280:	8b 75 08             	mov    0x8(%ebp),%esi
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  802283:	89 34 24             	mov    %esi,(%esp)
  802286:	e8 05 fc ff ff       	call   801e90 <fd2num>
  80228b:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80228e:	89 54 24 04          	mov    %edx,0x4(%esp)
  802292:	89 04 24             	mov    %eax,(%esp)
  802295:	e8 93 fc ff ff       	call   801f2d <fd_lookup>
  80229a:	89 c3                	mov    %eax,%ebx
  80229c:	85 c0                	test   %eax,%eax
  80229e:	78 05                	js     8022a5 <fd_close+0x31>
  8022a0:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  8022a3:	74 0e                	je     8022b3 <fd_close+0x3f>
	    || fd != fd2)
		return (must_exist ? r : 0);
  8022a5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8022a9:	b8 00 00 00 00       	mov    $0x0,%eax
  8022ae:	0f 44 d8             	cmove  %eax,%ebx
  8022b1:	eb 3d                	jmp    8022f0 <fd_close+0x7c>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  8022b3:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8022b6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8022ba:	8b 06                	mov    (%esi),%eax
  8022bc:	89 04 24             	mov    %eax,(%esp)
  8022bf:	e8 dd fc ff ff       	call   801fa1 <dev_lookup>
  8022c4:	89 c3                	mov    %eax,%ebx
  8022c6:	85 c0                	test   %eax,%eax
  8022c8:	78 16                	js     8022e0 <fd_close+0x6c>
		if (dev->dev_close)
  8022ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8022cd:	8b 40 10             	mov    0x10(%eax),%eax
  8022d0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8022d5:	85 c0                	test   %eax,%eax
  8022d7:	74 07                	je     8022e0 <fd_close+0x6c>
			r = (*dev->dev_close)(fd);
  8022d9:	89 34 24             	mov    %esi,(%esp)
  8022dc:	ff d0                	call   *%eax
  8022de:	89 c3                	mov    %eax,%ebx
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  8022e0:	89 74 24 04          	mov    %esi,0x4(%esp)
  8022e4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8022eb:	e8 0c f4 ff ff       	call   8016fc <sys_page_unmap>
	return r;
}
  8022f0:	89 d8                	mov    %ebx,%eax
  8022f2:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8022f5:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8022f8:	89 ec                	mov    %ebp,%esp
  8022fa:	5d                   	pop    %ebp
  8022fb:	c3                   	ret    

008022fc <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  8022fc:	55                   	push   %ebp
  8022fd:	89 e5                	mov    %esp,%ebp
  8022ff:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  802302:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802305:	89 44 24 04          	mov    %eax,0x4(%esp)
  802309:	8b 45 08             	mov    0x8(%ebp),%eax
  80230c:	89 04 24             	mov    %eax,(%esp)
  80230f:	e8 19 fc ff ff       	call   801f2d <fd_lookup>
  802314:	85 c0                	test   %eax,%eax
  802316:	78 13                	js     80232b <close+0x2f>
		return r;
	else
		return fd_close(fd, 1);
  802318:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80231f:	00 
  802320:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802323:	89 04 24             	mov    %eax,(%esp)
  802326:	e8 49 ff ff ff       	call   802274 <fd_close>
}
  80232b:	c9                   	leave  
  80232c:	c3                   	ret    

0080232d <stat>:
	return (*dev->dev_stat)(fd, stat);
}

int
stat(const char *path, struct Stat *stat)
{
  80232d:	55                   	push   %ebp
  80232e:	89 e5                	mov    %esp,%ebp
  802330:	83 ec 18             	sub    $0x18,%esp
  802333:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802336:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  802339:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802340:	00 
  802341:	8b 45 08             	mov    0x8(%ebp),%eax
  802344:	89 04 24             	mov    %eax,(%esp)
  802347:	e8 78 03 00 00       	call   8026c4 <open>
  80234c:	89 c3                	mov    %eax,%ebx
  80234e:	85 c0                	test   %eax,%eax
  802350:	78 1b                	js     80236d <stat+0x40>
		return fd;
	r = fstat(fd, stat);
  802352:	8b 45 0c             	mov    0xc(%ebp),%eax
  802355:	89 44 24 04          	mov    %eax,0x4(%esp)
  802359:	89 1c 24             	mov    %ebx,(%esp)
  80235c:	e8 ae fc ff ff       	call   80200f <fstat>
  802361:	89 c6                	mov    %eax,%esi
	close(fd);
  802363:	89 1c 24             	mov    %ebx,(%esp)
  802366:	e8 91 ff ff ff       	call   8022fc <close>
  80236b:	89 f3                	mov    %esi,%ebx
	return r;
}
  80236d:	89 d8                	mov    %ebx,%eax
  80236f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802372:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802375:	89 ec                	mov    %ebp,%esp
  802377:	5d                   	pop    %ebp
  802378:	c3                   	ret    

00802379 <close_all>:
		return fd_close(fd, 1);
}

void
close_all(void)
{
  802379:	55                   	push   %ebp
  80237a:	89 e5                	mov    %esp,%ebp
  80237c:	53                   	push   %ebx
  80237d:	83 ec 14             	sub    $0x14,%esp
  802380:	bb 00 00 00 00       	mov    $0x0,%ebx
	int i;
	for (i = 0; i < MAXFD; i++)
		close(i);
  802385:	89 1c 24             	mov    %ebx,(%esp)
  802388:	e8 6f ff ff ff       	call   8022fc <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80238d:	83 c3 01             	add    $0x1,%ebx
  802390:	83 fb 20             	cmp    $0x20,%ebx
  802393:	75 f0                	jne    802385 <close_all+0xc>
		close(i);
}
  802395:	83 c4 14             	add    $0x14,%esp
  802398:	5b                   	pop    %ebx
  802399:	5d                   	pop    %ebp
  80239a:	c3                   	ret    

0080239b <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  80239b:	55                   	push   %ebp
  80239c:	89 e5                	mov    %esp,%ebp
  80239e:	83 ec 58             	sub    $0x58,%esp
  8023a1:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8023a4:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8023a7:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8023aa:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  8023ad:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8023b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023b4:	8b 45 08             	mov    0x8(%ebp),%eax
  8023b7:	89 04 24             	mov    %eax,(%esp)
  8023ba:	e8 6e fb ff ff       	call   801f2d <fd_lookup>
  8023bf:	89 c3                	mov    %eax,%ebx
  8023c1:	85 c0                	test   %eax,%eax
  8023c3:	0f 88 e0 00 00 00    	js     8024a9 <dup+0x10e>
		return r;
	close(newfdnum);
  8023c9:	89 3c 24             	mov    %edi,(%esp)
  8023cc:	e8 2b ff ff ff       	call   8022fc <close>

	newfd = INDEX2FD(newfdnum);
  8023d1:	8d b7 00 00 0d 00    	lea    0xd0000(%edi),%esi
  8023d7:	c1 e6 0c             	shl    $0xc,%esi
	ova = fd2data(oldfd);
  8023da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8023dd:	89 04 24             	mov    %eax,(%esp)
  8023e0:	e8 bb fa ff ff       	call   801ea0 <fd2data>
  8023e5:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  8023e7:	89 34 24             	mov    %esi,(%esp)
  8023ea:	e8 b1 fa ff ff       	call   801ea0 <fd2data>
  8023ef:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((vpd[PDX(ova)] & PTE_P) && (vpt[PGNUM(ova)] & PTE_P))
  8023f2:	89 da                	mov    %ebx,%edx
  8023f4:	89 d8                	mov    %ebx,%eax
  8023f6:	c1 e8 16             	shr    $0x16,%eax
  8023f9:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  802400:	a8 01                	test   $0x1,%al
  802402:	74 43                	je     802447 <dup+0xac>
  802404:	c1 ea 0c             	shr    $0xc,%edx
  802407:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80240e:	a8 01                	test   $0x1,%al
  802410:	74 35                	je     802447 <dup+0xac>
		if ((r = sys_page_map(0, ova, 0, nva, vpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  802412:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  802419:	25 07 0e 00 00       	and    $0xe07,%eax
  80241e:	89 44 24 10          	mov    %eax,0x10(%esp)
  802422:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  802425:	89 44 24 0c          	mov    %eax,0xc(%esp)
  802429:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802430:	00 
  802431:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802435:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80243c:	e8 f3 f2 ff ff       	call   801734 <sys_page_map>
  802441:	89 c3                	mov    %eax,%ebx
  802443:	85 c0                	test   %eax,%eax
  802445:	78 3f                	js     802486 <dup+0xeb>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, vpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  802447:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80244a:	89 c2                	mov    %eax,%edx
  80244c:	c1 ea 0c             	shr    $0xc,%edx
  80244f:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  802456:	81 e2 07 0e 00 00    	and    $0xe07,%edx
  80245c:	89 54 24 10          	mov    %edx,0x10(%esp)
  802460:	89 74 24 0c          	mov    %esi,0xc(%esp)
  802464:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80246b:	00 
  80246c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802470:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802477:	e8 b8 f2 ff ff       	call   801734 <sys_page_map>
  80247c:	89 c3                	mov    %eax,%ebx
  80247e:	85 c0                	test   %eax,%eax
  802480:	78 04                	js     802486 <dup+0xeb>
  802482:	89 fb                	mov    %edi,%ebx
  802484:	eb 23                	jmp    8024a9 <dup+0x10e>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  802486:	89 74 24 04          	mov    %esi,0x4(%esp)
  80248a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802491:	e8 66 f2 ff ff       	call   8016fc <sys_page_unmap>
	sys_page_unmap(0, nva);
  802496:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  802499:	89 44 24 04          	mov    %eax,0x4(%esp)
  80249d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8024a4:	e8 53 f2 ff ff       	call   8016fc <sys_page_unmap>
	return r;
}
  8024a9:	89 d8                	mov    %ebx,%eax
  8024ab:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8024ae:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8024b1:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8024b4:	89 ec                	mov    %ebp,%esp
  8024b6:	5d                   	pop    %ebp
  8024b7:	c3                   	ret    

008024b8 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  8024b8:	55                   	push   %ebp
  8024b9:	89 e5                	mov    %esp,%ebp
  8024bb:	83 ec 18             	sub    $0x18,%esp
  8024be:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8024c1:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8024c4:	89 c3                	mov    %eax,%ebx
  8024c6:	89 d6                	mov    %edx,%esi
	static envid_t fsenv;
	if (fsenv == 0)
  8024c8:	83 3d 90 60 81 00 00 	cmpl   $0x0,0x816090
  8024cf:	75 11                	jne    8024e2 <fsipc+0x2a>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  8024d1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8024d8:	e8 73 f8 ff ff       	call   801d50 <ipc_find_env>
  8024dd:	a3 90 60 81 00       	mov    %eax,0x816090
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  8024e2:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  8024e9:	00 
  8024ea:	c7 44 24 08 00 d0 b3 	movl   $0xb3d000,0x8(%esp)
  8024f1:	00 
  8024f2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8024f6:	a1 90 60 81 00       	mov    0x816090,%eax
  8024fb:	89 04 24             	mov    %eax,(%esp)
  8024fe:	e8 91 f8 ff ff       	call   801d94 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  802503:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80250a:	00 
  80250b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80250f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802516:	e8 e4 f8 ff ff       	call   801dff <ipc_recv>
}
  80251b:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80251e:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802521:	89 ec                	mov    %ebp,%esp
  802523:	5d                   	pop    %ebp
  802524:	c3                   	ret    

00802525 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  802525:	55                   	push   %ebp
  802526:	89 e5                	mov    %esp,%ebp
  802528:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80252b:	8b 45 08             	mov    0x8(%ebp),%eax
  80252e:	8b 40 0c             	mov    0xc(%eax),%eax
  802531:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.set_size.req_size = newsize;
  802536:	8b 45 0c             	mov    0xc(%ebp),%eax
  802539:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80253e:	ba 00 00 00 00       	mov    $0x0,%edx
  802543:	b8 02 00 00 00       	mov    $0x2,%eax
  802548:	e8 6b ff ff ff       	call   8024b8 <fsipc>
}
  80254d:	c9                   	leave  
  80254e:	c3                   	ret    

0080254f <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  80254f:	55                   	push   %ebp
  802550:	89 e5                	mov    %esp,%ebp
  802552:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  802555:	8b 45 08             	mov    0x8(%ebp),%eax
  802558:	8b 40 0c             	mov    0xc(%eax),%eax
  80255b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return fsipc(FSREQ_FLUSH, NULL);
  802560:	ba 00 00 00 00       	mov    $0x0,%edx
  802565:	b8 06 00 00 00       	mov    $0x6,%eax
  80256a:	e8 49 ff ff ff       	call   8024b8 <fsipc>
}
  80256f:	c9                   	leave  
  802570:	c3                   	ret    

00802571 <sync>:
}

// Synchronize disk with buffer cache
int
sync(void)
{
  802571:	55                   	push   %ebp
  802572:	89 e5                	mov    %esp,%ebp
  802574:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  802577:	ba 00 00 00 00       	mov    $0x0,%edx
  80257c:	b8 08 00 00 00       	mov    $0x8,%eax
  802581:	e8 32 ff ff ff       	call   8024b8 <fsipc>
}
  802586:	c9                   	leave  
  802587:	c3                   	ret    

00802588 <devfile_stat>:
  return fsipc(FSREQ_WRITE, NULL);	
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  802588:	55                   	push   %ebp
  802589:	89 e5                	mov    %esp,%ebp
  80258b:	53                   	push   %ebx
  80258c:	83 ec 14             	sub    $0x14,%esp
  80258f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  802592:	8b 45 08             	mov    0x8(%ebp),%eax
  802595:	8b 40 0c             	mov    0xc(%eax),%eax
  802598:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  80259d:	ba 00 00 00 00       	mov    $0x0,%edx
  8025a2:	b8 05 00 00 00       	mov    $0x5,%eax
  8025a7:	e8 0c ff ff ff       	call   8024b8 <fsipc>
  8025ac:	85 c0                	test   %eax,%eax
  8025ae:	78 2b                	js     8025db <devfile_stat+0x53>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  8025b0:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  8025b7:	00 
  8025b8:	89 1c 24             	mov    %ebx,(%esp)
  8025bb:	e8 4a eb ff ff       	call   80110a <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  8025c0:	a1 80 d0 b3 00       	mov    0xb3d080,%eax
  8025c5:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  8025cb:	a1 84 d0 b3 00       	mov    0xb3d084,%eax
  8025d0:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
  8025d6:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  8025db:	83 c4 14             	add    $0x14,%esp
  8025de:	5b                   	pop    %ebx
  8025df:	5d                   	pop    %ebp
  8025e0:	c3                   	ret    

008025e1 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  8025e1:	55                   	push   %ebp
  8025e2:	89 e5                	mov    %esp,%ebp
  8025e4:	83 ec 18             	sub    $0x18,%esp
  8025e7:	8b 45 10             	mov    0x10(%ebp),%eax
	// Make an FSREQ_WRITE request to the file system server.  Be
	// careful: fsipcbuf.write.req_buf is only so large, but
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
  fsipcbuf.write.req_fileid = fd->fd_file.id;
  8025ea:	8b 55 08             	mov    0x8(%ebp),%edx
  8025ed:	8b 52 0c             	mov    0xc(%edx),%edx
  8025f0:	89 15 00 d0 b3 00    	mov    %edx,0xb3d000
  fsipcbuf.write.req_n = n;
  8025f6:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
  memmove(fsipcbuf.write.req_buf, buf,
  8025fb:	3d f8 0f 00 00       	cmp    $0xff8,%eax
  802600:	ba f8 0f 00 00       	mov    $0xff8,%edx
  802605:	0f 47 c2             	cmova  %edx,%eax
  802608:	89 44 24 08          	mov    %eax,0x8(%esp)
  80260c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80260f:	89 44 24 04          	mov    %eax,0x4(%esp)
  802613:	c7 04 24 08 d0 b3 00 	movl   $0xb3d008,(%esp)
  80261a:	e8 d6 ec ff ff       	call   8012f5 <memmove>
      MIN(n, PGSIZE - sizeof(int) - sizeof(size_t)));
  return fsipc(FSREQ_WRITE, NULL);	
  80261f:	ba 00 00 00 00       	mov    $0x0,%edx
  802624:	b8 04 00 00 00       	mov    $0x4,%eax
  802629:	e8 8a fe ff ff       	call   8024b8 <fsipc>
}
  80262e:	c9                   	leave  
  80262f:	c3                   	ret    

00802630 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  802630:	55                   	push   %ebp
  802631:	89 e5                	mov    %esp,%ebp
  802633:	53                   	push   %ebx
  802634:	83 ec 14             	sub    $0x14,%esp
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	// LAB 5: Your code here
  int r;

  fsipcbuf.read.req_fileid = fd->fd_file.id;
  802637:	8b 45 08             	mov    0x8(%ebp),%eax
  80263a:	8b 40 0c             	mov    0xc(%eax),%eax
  80263d:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
  fsipcbuf.read.req_n = n;
  802642:	8b 45 10             	mov    0x10(%ebp),%eax
  802645:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
  if((r = fsipc(FSREQ_READ, NULL)) < 0)
  80264a:	ba 00 00 00 00       	mov    $0x0,%edx
  80264f:	b8 03 00 00 00       	mov    $0x3,%eax
  802654:	e8 5f fe ff ff       	call   8024b8 <fsipc>
  802659:	89 c3                	mov    %eax,%ebx
  80265b:	85 c0                	test   %eax,%eax
  80265d:	78 17                	js     802676 <devfile_read+0x46>
    return r;
  memmove(buf, fsipcbuf.readRet.ret_buf, r);
  80265f:	89 44 24 08          	mov    %eax,0x8(%esp)
  802663:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  80266a:	00 
  80266b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80266e:	89 04 24             	mov    %eax,(%esp)
  802671:	e8 7f ec ff ff       	call   8012f5 <memmove>
  return r;	
}
  802676:	89 d8                	mov    %ebx,%eax
  802678:	83 c4 14             	add    $0x14,%esp
  80267b:	5b                   	pop    %ebx
  80267c:	5d                   	pop    %ebp
  80267d:	c3                   	ret    

0080267e <remove>:
}

// Delete a file
int
remove(const char *path)
{
  80267e:	55                   	push   %ebp
  80267f:	89 e5                	mov    %esp,%ebp
  802681:	53                   	push   %ebx
  802682:	83 ec 14             	sub    $0x14,%esp
  802685:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (strlen(path) >= MAXPATHLEN)
  802688:	89 1c 24             	mov    %ebx,(%esp)
  80268b:	e8 30 ea ff ff       	call   8010c0 <strlen>
  802690:	89 c2                	mov    %eax,%edx
  802692:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  802697:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
  80269d:	7f 1f                	jg     8026be <remove+0x40>
		return -E_BAD_PATH;
	strcpy(fsipcbuf.remove.req_path, path);
  80269f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8026a3:	c7 04 24 00 d0 b3 00 	movl   $0xb3d000,(%esp)
  8026aa:	e8 5b ea ff ff       	call   80110a <strcpy>
	return fsipc(FSREQ_REMOVE, NULL);
  8026af:	ba 00 00 00 00       	mov    $0x0,%edx
  8026b4:	b8 07 00 00 00       	mov    $0x7,%eax
  8026b9:	e8 fa fd ff ff       	call   8024b8 <fsipc>
}
  8026be:	83 c4 14             	add    $0x14,%esp
  8026c1:	5b                   	pop    %ebx
  8026c2:	5d                   	pop    %ebp
  8026c3:	c3                   	ret    

008026c4 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  8026c4:	55                   	push   %ebp
  8026c5:	89 e5                	mov    %esp,%ebp
  8026c7:	83 ec 28             	sub    $0x28,%esp
  8026ca:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8026cd:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8026d0:	8b 75 08             	mov    0x8(%ebp),%esi

	// LAB 5: Your code here.
  int r;
  struct Fd *fd;

  r = fd_alloc(&fd);
  8026d3:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8026d6:	89 04 24             	mov    %eax,(%esp)
  8026d9:	e8 dd f7 ff ff       	call   801ebb <fd_alloc>
  8026de:	89 c3                	mov    %eax,%ebx
  if (r < 0) return r;
  8026e0:	85 c0                	test   %eax,%eax
  8026e2:	0f 88 89 00 00 00    	js     802771 <open+0xad>

        // DO NOT ALLOCATE !!
        //r = sys_page_alloc(0, fd, PTE_U|PTE_W|PTE_P);
        //if (r < 0) goto out;

  if (strlen(path) >= MAXPATHLEN)
  8026e8:	89 34 24             	mov    %esi,(%esp)
  8026eb:	e8 d0 e9 ff ff       	call   8010c0 <strlen>
  fsipcbuf.open.req_omode = mode;
  r = fsipc(FSREQ_OPEN, fd);
  if (r < 0) goto out;
  return fd2num(fd);
out:
  assert(fd_close(fd, 0) == 0);
  8026f0:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx

        // DO NOT ALLOCATE !!
        //r = sys_page_alloc(0, fd, PTE_U|PTE_W|PTE_P);
        //if (r < 0) goto out;

  if (strlen(path) >= MAXPATHLEN)
  8026f5:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  8026fa:	7f 75                	jg     802771 <open+0xad>
    return -E_BAD_PATH;
  strcpy(fsipcbuf.open.req_path, path);
  8026fc:	89 74 24 04          	mov    %esi,0x4(%esp)
  802700:	c7 04 24 00 d0 b3 00 	movl   $0xb3d000,(%esp)
  802707:	e8 fe e9 ff ff       	call   80110a <strcpy>
  fsipcbuf.open.req_omode = mode;
  80270c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80270f:	a3 00 d4 b3 00       	mov    %eax,0xb3d400
  r = fsipc(FSREQ_OPEN, fd);
  802714:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802717:	b8 01 00 00 00       	mov    $0x1,%eax
  80271c:	e8 97 fd ff ff       	call   8024b8 <fsipc>
  802721:	89 c3                	mov    %eax,%ebx
  if (r < 0) goto out;
  802723:	85 c0                	test   %eax,%eax
  802725:	78 0f                	js     802736 <open+0x72>
  return fd2num(fd);
  802727:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80272a:	89 04 24             	mov    %eax,(%esp)
  80272d:	e8 5e f7 ff ff       	call   801e90 <fd2num>
  802732:	89 c3                	mov    %eax,%ebx
  802734:	eb 3b                	jmp    802771 <open+0xad>
out:
  assert(fd_close(fd, 0) == 0);
  802736:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80273d:	00 
  80273e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802741:	89 04 24             	mov    %eax,(%esp)
  802744:	e8 2b fb ff ff       	call   802274 <fd_close>
  802749:	85 c0                	test   %eax,%eax
  80274b:	74 24                	je     802771 <open+0xad>
  80274d:	c7 44 24 0c 8c 28 81 	movl   $0x81288c,0xc(%esp)
  802754:	00 
  802755:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80275c:	00 
  80275d:	c7 44 24 04 5a 00 00 	movl   $0x5a,0x4(%esp)
  802764:	00 
  802765:	c7 04 24 b6 28 81 00 	movl   $0x8128b6,(%esp)
  80276c:	e8 a3 e1 ff ff       	call   800914 <_panic>
  return r;
}
  802771:	89 d8                	mov    %ebx,%eax
  802773:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802776:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802779:	89 ec                	mov    %ebp,%esp
  80277b:	5d                   	pop    %ebp
  80277c:	c3                   	ret    
  80277d:	00 00                	add    %al,(%eax)
	...

00802780 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  802780:	55                   	push   %ebp
  802781:	89 e5                	mov    %esp,%ebp
  802783:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<sock>");
  802786:	c7 44 24 04 c1 28 81 	movl   $0x8128c1,0x4(%esp)
  80278d:	00 
  80278e:	8b 45 0c             	mov    0xc(%ebp),%eax
  802791:	89 04 24             	mov    %eax,(%esp)
  802794:	e8 71 e9 ff ff       	call   80110a <strcpy>
	return 0;
}
  802799:	b8 00 00 00 00       	mov    $0x0,%eax
  80279e:	c9                   	leave  
  80279f:	c3                   	ret    

008027a0 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  8027a0:	55                   	push   %ebp
  8027a1:	89 e5                	mov    %esp,%ebp
  8027a3:	53                   	push   %ebx
  8027a4:	83 ec 14             	sub    $0x14,%esp
  8027a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  8027aa:	89 1c 24             	mov    %ebx,(%esp)
  8027ad:	e8 22 08 00 00       	call   802fd4 <pageref>
  8027b2:	89 c2                	mov    %eax,%edx
  8027b4:	b8 00 00 00 00       	mov    $0x0,%eax
  8027b9:	83 fa 01             	cmp    $0x1,%edx
  8027bc:	75 0b                	jne    8027c9 <devsock_close+0x29>
		return nsipc_close(fd->fd_sock.sockid);
  8027be:	8b 43 0c             	mov    0xc(%ebx),%eax
  8027c1:	89 04 24             	mov    %eax,(%esp)
  8027c4:	e8 b9 02 00 00       	call   802a82 <nsipc_close>
	else
		return 0;
}
  8027c9:	83 c4 14             	add    $0x14,%esp
  8027cc:	5b                   	pop    %ebx
  8027cd:	5d                   	pop    %ebp
  8027ce:	c3                   	ret    

008027cf <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  8027cf:	55                   	push   %ebp
  8027d0:	89 e5                	mov    %esp,%ebp
  8027d2:	83 ec 18             	sub    $0x18,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  8027d5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8027dc:	00 
  8027dd:	8b 45 10             	mov    0x10(%ebp),%eax
  8027e0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8027e4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8027e7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027eb:	8b 45 08             	mov    0x8(%ebp),%eax
  8027ee:	8b 40 0c             	mov    0xc(%eax),%eax
  8027f1:	89 04 24             	mov    %eax,(%esp)
  8027f4:	e8 c5 02 00 00       	call   802abe <nsipc_send>
}
  8027f9:	c9                   	leave  
  8027fa:	c3                   	ret    

008027fb <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  8027fb:	55                   	push   %ebp
  8027fc:	89 e5                	mov    %esp,%ebp
  8027fe:	83 ec 18             	sub    $0x18,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  802801:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  802808:	00 
  802809:	8b 45 10             	mov    0x10(%ebp),%eax
  80280c:	89 44 24 08          	mov    %eax,0x8(%esp)
  802810:	8b 45 0c             	mov    0xc(%ebp),%eax
  802813:	89 44 24 04          	mov    %eax,0x4(%esp)
  802817:	8b 45 08             	mov    0x8(%ebp),%eax
  80281a:	8b 40 0c             	mov    0xc(%eax),%eax
  80281d:	89 04 24             	mov    %eax,(%esp)
  802820:	e8 0c 03 00 00       	call   802b31 <nsipc_recv>
}
  802825:	c9                   	leave  
  802826:	c3                   	ret    

00802827 <alloc_sockfd>:
	return sfd->fd_sock.sockid;
}

static int
alloc_sockfd(int sockid)
{
  802827:	55                   	push   %ebp
  802828:	89 e5                	mov    %esp,%ebp
  80282a:	56                   	push   %esi
  80282b:	53                   	push   %ebx
  80282c:	83 ec 20             	sub    $0x20,%esp
  80282f:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  802831:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802834:	89 04 24             	mov    %eax,(%esp)
  802837:	e8 7f f6 ff ff       	call   801ebb <fd_alloc>
  80283c:	89 c3                	mov    %eax,%ebx
  80283e:	85 c0                	test   %eax,%eax
  802840:	78 21                	js     802863 <alloc_sockfd+0x3c>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  802842:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  802849:	00 
  80284a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80284d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802851:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802858:	e8 10 ef ff ff       	call   80176d <sys_page_alloc>
  80285d:	89 c3                	mov    %eax,%ebx
alloc_sockfd(int sockid)
{
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  80285f:	85 c0                	test   %eax,%eax
  802861:	79 0a                	jns    80286d <alloc_sockfd+0x46>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
		nsipc_close(sockid);
  802863:	89 34 24             	mov    %esi,(%esp)
  802866:	e8 17 02 00 00       	call   802a82 <nsipc_close>
		return r;
  80286b:	eb 28                	jmp    802895 <alloc_sockfd+0x6e>
	}

	sfd->fd_dev_id = devsock.dev_id;
  80286d:	8b 15 20 50 81 00    	mov    0x815020,%edx
  802873:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802876:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  802878:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80287b:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  802882:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802885:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  802888:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80288b:	89 04 24             	mov    %eax,(%esp)
  80288e:	e8 fd f5 ff ff       	call   801e90 <fd2num>
  802893:	89 c3                	mov    %eax,%ebx
}
  802895:	89 d8                	mov    %ebx,%eax
  802897:	83 c4 20             	add    $0x20,%esp
  80289a:	5b                   	pop    %ebx
  80289b:	5e                   	pop    %esi
  80289c:	5d                   	pop    %ebp
  80289d:	c3                   	ret    

0080289e <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  80289e:	55                   	push   %ebp
  80289f:	89 e5                	mov    %esp,%ebp
  8028a1:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  8028a4:	8b 45 10             	mov    0x10(%ebp),%eax
  8028a7:	89 44 24 08          	mov    %eax,0x8(%esp)
  8028ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  8028ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  8028b2:	8b 45 08             	mov    0x8(%ebp),%eax
  8028b5:	89 04 24             	mov    %eax,(%esp)
  8028b8:	e8 79 01 00 00       	call   802a36 <nsipc_socket>
  8028bd:	85 c0                	test   %eax,%eax
  8028bf:	78 05                	js     8028c6 <socket+0x28>
		return r;
	return alloc_sockfd(r);
  8028c1:	e8 61 ff ff ff       	call   802827 <alloc_sockfd>
}
  8028c6:	c9                   	leave  
  8028c7:	c3                   	ret    

008028c8 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  8028c8:	55                   	push   %ebp
  8028c9:	89 e5                	mov    %esp,%ebp
  8028cb:	83 ec 28             	sub    $0x28,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  8028ce:	8d 55 f4             	lea    -0xc(%ebp),%edx
  8028d1:	89 54 24 04          	mov    %edx,0x4(%esp)
  8028d5:	89 04 24             	mov    %eax,(%esp)
  8028d8:	e8 50 f6 ff ff       	call   801f2d <fd_lookup>
  8028dd:	85 c0                	test   %eax,%eax
  8028df:	78 15                	js     8028f6 <fd2sockid+0x2e>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  8028e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8028e4:	8b 0a                	mov    (%edx),%ecx
  8028e6:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8028eb:	3b 0d 20 50 81 00    	cmp    0x815020,%ecx
  8028f1:	75 03                	jne    8028f6 <fd2sockid+0x2e>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  8028f3:	8b 42 0c             	mov    0xc(%edx),%eax
}
  8028f6:	c9                   	leave  
  8028f7:	c3                   	ret    

008028f8 <listen>:
	return nsipc_connect(r, name, namelen);
}

int
listen(int s, int backlog)
{
  8028f8:	55                   	push   %ebp
  8028f9:	89 e5                	mov    %esp,%ebp
  8028fb:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  8028fe:	8b 45 08             	mov    0x8(%ebp),%eax
  802901:	e8 c2 ff ff ff       	call   8028c8 <fd2sockid>
  802906:	85 c0                	test   %eax,%eax
  802908:	78 0f                	js     802919 <listen+0x21>
		return r;
	return nsipc_listen(r, backlog);
  80290a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80290d:	89 54 24 04          	mov    %edx,0x4(%esp)
  802911:	89 04 24             	mov    %eax,(%esp)
  802914:	e8 47 01 00 00       	call   802a60 <nsipc_listen>
}
  802919:	c9                   	leave  
  80291a:	c3                   	ret    

0080291b <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80291b:	55                   	push   %ebp
  80291c:	89 e5                	mov    %esp,%ebp
  80291e:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802921:	8b 45 08             	mov    0x8(%ebp),%eax
  802924:	e8 9f ff ff ff       	call   8028c8 <fd2sockid>
  802929:	85 c0                	test   %eax,%eax
  80292b:	78 16                	js     802943 <connect+0x28>
		return r;
	return nsipc_connect(r, name, namelen);
  80292d:	8b 55 10             	mov    0x10(%ebp),%edx
  802930:	89 54 24 08          	mov    %edx,0x8(%esp)
  802934:	8b 55 0c             	mov    0xc(%ebp),%edx
  802937:	89 54 24 04          	mov    %edx,0x4(%esp)
  80293b:	89 04 24             	mov    %eax,(%esp)
  80293e:	e8 6e 02 00 00       	call   802bb1 <nsipc_connect>
}
  802943:	c9                   	leave  
  802944:	c3                   	ret    

00802945 <shutdown>:
	return nsipc_bind(r, name, namelen);
}

int
shutdown(int s, int how)
{
  802945:	55                   	push   %ebp
  802946:	89 e5                	mov    %esp,%ebp
  802948:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80294b:	8b 45 08             	mov    0x8(%ebp),%eax
  80294e:	e8 75 ff ff ff       	call   8028c8 <fd2sockid>
  802953:	85 c0                	test   %eax,%eax
  802955:	78 0f                	js     802966 <shutdown+0x21>
		return r;
	return nsipc_shutdown(r, how);
  802957:	8b 55 0c             	mov    0xc(%ebp),%edx
  80295a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80295e:	89 04 24             	mov    %eax,(%esp)
  802961:	e8 36 01 00 00       	call   802a9c <nsipc_shutdown>
}
  802966:	c9                   	leave  
  802967:	c3                   	ret    

00802968 <bind>:
	return alloc_sockfd(r);
}

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  802968:	55                   	push   %ebp
  802969:	89 e5                	mov    %esp,%ebp
  80296b:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80296e:	8b 45 08             	mov    0x8(%ebp),%eax
  802971:	e8 52 ff ff ff       	call   8028c8 <fd2sockid>
  802976:	85 c0                	test   %eax,%eax
  802978:	78 16                	js     802990 <bind+0x28>
		return r;
	return nsipc_bind(r, name, namelen);
  80297a:	8b 55 10             	mov    0x10(%ebp),%edx
  80297d:	89 54 24 08          	mov    %edx,0x8(%esp)
  802981:	8b 55 0c             	mov    0xc(%ebp),%edx
  802984:	89 54 24 04          	mov    %edx,0x4(%esp)
  802988:	89 04 24             	mov    %eax,(%esp)
  80298b:	e8 60 02 00 00       	call   802bf0 <nsipc_bind>
}
  802990:	c9                   	leave  
  802991:	c3                   	ret    

00802992 <accept>:
	return fd2num(sfd);
}

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  802992:	55                   	push   %ebp
  802993:	89 e5                	mov    %esp,%ebp
  802995:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802998:	8b 45 08             	mov    0x8(%ebp),%eax
  80299b:	e8 28 ff ff ff       	call   8028c8 <fd2sockid>
  8029a0:	85 c0                	test   %eax,%eax
  8029a2:	78 1f                	js     8029c3 <accept+0x31>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  8029a4:	8b 55 10             	mov    0x10(%ebp),%edx
  8029a7:	89 54 24 08          	mov    %edx,0x8(%esp)
  8029ab:	8b 55 0c             	mov    0xc(%ebp),%edx
  8029ae:	89 54 24 04          	mov    %edx,0x4(%esp)
  8029b2:	89 04 24             	mov    %eax,(%esp)
  8029b5:	e8 75 02 00 00       	call   802c2f <nsipc_accept>
  8029ba:	85 c0                	test   %eax,%eax
  8029bc:	78 05                	js     8029c3 <accept+0x31>
		return r;
	return alloc_sockfd(r);
  8029be:	e8 64 fe ff ff       	call   802827 <alloc_sockfd>
}
  8029c3:	c9                   	leave  
  8029c4:	c3                   	ret    
	...

008029d0 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  8029d0:	55                   	push   %ebp
  8029d1:	89 e5                	mov    %esp,%ebp
  8029d3:	53                   	push   %ebx
  8029d4:	83 ec 14             	sub    $0x14,%esp
  8029d7:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  8029d9:	83 3d 94 60 81 00 00 	cmpl   $0x0,0x816094
  8029e0:	75 11                	jne    8029f3 <nsipc+0x23>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  8029e2:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  8029e9:	e8 62 f3 ff ff       	call   801d50 <ipc_find_env>
  8029ee:	a3 94 60 81 00       	mov    %eax,0x816094
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  8029f3:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  8029fa:	00 
  8029fb:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  802a02:	00 
  802a03:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802a07:	a1 94 60 81 00       	mov    0x816094,%eax
  802a0c:	89 04 24             	mov    %eax,(%esp)
  802a0f:	e8 80 f3 ff ff       	call   801d94 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  802a14:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802a1b:	00 
  802a1c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802a23:	00 
  802a24:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802a2b:	e8 cf f3 ff ff       	call   801dff <ipc_recv>
}
  802a30:	83 c4 14             	add    $0x14,%esp
  802a33:	5b                   	pop    %ebx
  802a34:	5d                   	pop    %ebp
  802a35:	c3                   	ret    

00802a36 <nsipc_socket>:
	return nsipc(NSREQ_SEND);
}

int
nsipc_socket(int domain, int type, int protocol)
{
  802a36:	55                   	push   %ebp
  802a37:	89 e5                	mov    %esp,%ebp
  802a39:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  802a3c:	8b 45 08             	mov    0x8(%ebp),%eax
  802a3f:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.socket.req_type = type;
  802a44:	8b 45 0c             	mov    0xc(%ebp),%eax
  802a47:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	nsipcbuf.socket.req_protocol = protocol;
  802a4c:	8b 45 10             	mov    0x10(%ebp),%eax
  802a4f:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SOCKET);
  802a54:	b8 09 00 00 00       	mov    $0x9,%eax
  802a59:	e8 72 ff ff ff       	call   8029d0 <nsipc>
}
  802a5e:	c9                   	leave  
  802a5f:	c3                   	ret    

00802a60 <nsipc_listen>:
	return nsipc(NSREQ_CONNECT);
}

int
nsipc_listen(int s, int backlog)
{
  802a60:	55                   	push   %ebp
  802a61:	89 e5                	mov    %esp,%ebp
  802a63:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  802a66:	8b 45 08             	mov    0x8(%ebp),%eax
  802a69:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.listen.req_backlog = backlog;
  802a6e:	8b 45 0c             	mov    0xc(%ebp),%eax
  802a71:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_LISTEN);
  802a76:	b8 06 00 00 00       	mov    $0x6,%eax
  802a7b:	e8 50 ff ff ff       	call   8029d0 <nsipc>
}
  802a80:	c9                   	leave  
  802a81:	c3                   	ret    

00802a82 <nsipc_close>:
	return nsipc(NSREQ_SHUTDOWN);
}

int
nsipc_close(int s)
{
  802a82:	55                   	push   %ebp
  802a83:	89 e5                	mov    %esp,%ebp
  802a85:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  802a88:	8b 45 08             	mov    0x8(%ebp),%eax
  802a8b:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	return nsipc(NSREQ_CLOSE);
  802a90:	b8 04 00 00 00       	mov    $0x4,%eax
  802a95:	e8 36 ff ff ff       	call   8029d0 <nsipc>
}
  802a9a:	c9                   	leave  
  802a9b:	c3                   	ret    

00802a9c <nsipc_shutdown>:
	return nsipc(NSREQ_BIND);
}

int
nsipc_shutdown(int s, int how)
{
  802a9c:	55                   	push   %ebp
  802a9d:	89 e5                	mov    %esp,%ebp
  802a9f:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  802aa2:	8b 45 08             	mov    0x8(%ebp),%eax
  802aa5:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.shutdown.req_how = how;
  802aaa:	8b 45 0c             	mov    0xc(%ebp),%eax
  802aad:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_SHUTDOWN);
  802ab2:	b8 03 00 00 00       	mov    $0x3,%eax
  802ab7:	e8 14 ff ff ff       	call   8029d0 <nsipc>
}
  802abc:	c9                   	leave  
  802abd:	c3                   	ret    

00802abe <nsipc_send>:
	return r;
}

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  802abe:	55                   	push   %ebp
  802abf:	89 e5                	mov    %esp,%ebp
  802ac1:	53                   	push   %ebx
  802ac2:	83 ec 14             	sub    $0x14,%esp
  802ac5:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  802ac8:	8b 45 08             	mov    0x8(%ebp),%eax
  802acb:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	assert(size < 1600);
  802ad0:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  802ad6:	7e 24                	jle    802afc <nsipc_send+0x3e>
  802ad8:	c7 44 24 0c cd 28 81 	movl   $0x8128cd,0xc(%esp)
  802adf:	00 
  802ae0:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  802ae7:	00 
  802ae8:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  802aef:	00 
  802af0:	c7 04 24 d9 28 81 00 	movl   $0x8128d9,(%esp)
  802af7:	e8 18 de ff ff       	call   800914 <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  802afc:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802b00:	8b 45 0c             	mov    0xc(%ebp),%eax
  802b03:	89 44 24 04          	mov    %eax,0x4(%esp)
  802b07:	c7 04 24 0c e0 b3 00 	movl   $0xb3e00c,(%esp)
  802b0e:	e8 e2 e7 ff ff       	call   8012f5 <memmove>
	nsipcbuf.send.req_size = size;
  802b13:	89 1d 04 e0 b3 00    	mov    %ebx,0xb3e004
	nsipcbuf.send.req_flags = flags;
  802b19:	8b 45 14             	mov    0x14(%ebp),%eax
  802b1c:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SEND);
  802b21:	b8 08 00 00 00       	mov    $0x8,%eax
  802b26:	e8 a5 fe ff ff       	call   8029d0 <nsipc>
}
  802b2b:	83 c4 14             	add    $0x14,%esp
  802b2e:	5b                   	pop    %ebx
  802b2f:	5d                   	pop    %ebp
  802b30:	c3                   	ret    

00802b31 <nsipc_recv>:
	return nsipc(NSREQ_LISTEN);
}

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  802b31:	55                   	push   %ebp
  802b32:	89 e5                	mov    %esp,%ebp
  802b34:	56                   	push   %esi
  802b35:	53                   	push   %ebx
  802b36:	83 ec 10             	sub    $0x10,%esp
  802b39:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  802b3c:	8b 45 08             	mov    0x8(%ebp),%eax
  802b3f:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.recv.req_len = len;
  802b44:	89 35 04 e0 b3 00    	mov    %esi,0xb3e004
	nsipcbuf.recv.req_flags = flags;
  802b4a:	8b 45 14             	mov    0x14(%ebp),%eax
  802b4d:	a3 08 e0 b3 00       	mov    %eax,0xb3e008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  802b52:	b8 07 00 00 00       	mov    $0x7,%eax
  802b57:	e8 74 fe ff ff       	call   8029d0 <nsipc>
  802b5c:	89 c3                	mov    %eax,%ebx
  802b5e:	85 c0                	test   %eax,%eax
  802b60:	78 46                	js     802ba8 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  802b62:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  802b67:	7f 04                	jg     802b6d <nsipc_recv+0x3c>
  802b69:	39 c6                	cmp    %eax,%esi
  802b6b:	7d 24                	jge    802b91 <nsipc_recv+0x60>
  802b6d:	c7 44 24 0c e5 28 81 	movl   $0x8128e5,0xc(%esp)
  802b74:	00 
  802b75:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  802b7c:	00 
  802b7d:	c7 44 24 04 61 00 00 	movl   $0x61,0x4(%esp)
  802b84:	00 
  802b85:	c7 04 24 d9 28 81 00 	movl   $0x8128d9,(%esp)
  802b8c:	e8 83 dd ff ff       	call   800914 <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  802b91:	89 44 24 08          	mov    %eax,0x8(%esp)
  802b95:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  802b9c:	00 
  802b9d:	8b 45 0c             	mov    0xc(%ebp),%eax
  802ba0:	89 04 24             	mov    %eax,(%esp)
  802ba3:	e8 4d e7 ff ff       	call   8012f5 <memmove>
	}

	return r;
}
  802ba8:	89 d8                	mov    %ebx,%eax
  802baa:	83 c4 10             	add    $0x10,%esp
  802bad:	5b                   	pop    %ebx
  802bae:	5e                   	pop    %esi
  802baf:	5d                   	pop    %ebp
  802bb0:	c3                   	ret    

00802bb1 <nsipc_connect>:
	return nsipc(NSREQ_CLOSE);
}

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  802bb1:	55                   	push   %ebp
  802bb2:	89 e5                	mov    %esp,%ebp
  802bb4:	53                   	push   %ebx
  802bb5:	83 ec 14             	sub    $0x14,%esp
  802bb8:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  802bbb:	8b 45 08             	mov    0x8(%ebp),%eax
  802bbe:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  802bc3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802bc7:	8b 45 0c             	mov    0xc(%ebp),%eax
  802bca:	89 44 24 04          	mov    %eax,0x4(%esp)
  802bce:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  802bd5:	e8 1b e7 ff ff       	call   8012f5 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  802bda:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_CONNECT);
  802be0:	b8 05 00 00 00       	mov    $0x5,%eax
  802be5:	e8 e6 fd ff ff       	call   8029d0 <nsipc>
}
  802bea:	83 c4 14             	add    $0x14,%esp
  802bed:	5b                   	pop    %ebx
  802bee:	5d                   	pop    %ebp
  802bef:	c3                   	ret    

00802bf0 <nsipc_bind>:
	return r;
}

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  802bf0:	55                   	push   %ebp
  802bf1:	89 e5                	mov    %esp,%ebp
  802bf3:	53                   	push   %ebx
  802bf4:	83 ec 14             	sub    $0x14,%esp
  802bf7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  802bfa:	8b 45 08             	mov    0x8(%ebp),%eax
  802bfd:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  802c02:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802c06:	8b 45 0c             	mov    0xc(%ebp),%eax
  802c09:	89 44 24 04          	mov    %eax,0x4(%esp)
  802c0d:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  802c14:	e8 dc e6 ff ff       	call   8012f5 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  802c19:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_BIND);
  802c1f:	b8 02 00 00 00       	mov    $0x2,%eax
  802c24:	e8 a7 fd ff ff       	call   8029d0 <nsipc>
}
  802c29:	83 c4 14             	add    $0x14,%esp
  802c2c:	5b                   	pop    %ebx
  802c2d:	5d                   	pop    %ebp
  802c2e:	c3                   	ret    

00802c2f <nsipc_accept>:
	return ipc_recv(NULL, NULL, NULL);
}

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  802c2f:	55                   	push   %ebp
  802c30:	89 e5                	mov    %esp,%ebp
  802c32:	83 ec 18             	sub    $0x18,%esp
  802c35:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802c38:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int r;

	nsipcbuf.accept.req_s = s;
  802c3b:	8b 45 08             	mov    0x8(%ebp),%eax
  802c3e:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  802c43:	b8 01 00 00 00       	mov    $0x1,%eax
  802c48:	e8 83 fd ff ff       	call   8029d0 <nsipc>
  802c4d:	89 c3                	mov    %eax,%ebx
  802c4f:	85 c0                	test   %eax,%eax
  802c51:	78 25                	js     802c78 <nsipc_accept+0x49>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  802c53:	be 10 e0 b3 00       	mov    $0xb3e010,%esi
  802c58:	8b 06                	mov    (%esi),%eax
  802c5a:	89 44 24 08          	mov    %eax,0x8(%esp)
  802c5e:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  802c65:	00 
  802c66:	8b 45 0c             	mov    0xc(%ebp),%eax
  802c69:	89 04 24             	mov    %eax,(%esp)
  802c6c:	e8 84 e6 ff ff       	call   8012f5 <memmove>
		*addrlen = ret->ret_addrlen;
  802c71:	8b 16                	mov    (%esi),%edx
  802c73:	8b 45 10             	mov    0x10(%ebp),%eax
  802c76:	89 10                	mov    %edx,(%eax)
	}
	return r;
}
  802c78:	89 d8                	mov    %ebx,%eax
  802c7a:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802c7d:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802c80:	89 ec                	mov    %ebp,%esp
  802c82:	5d                   	pop    %ebp
  802c83:	c3                   	ret    
	...

00802c90 <free>:
	return v;
}

void
free(void *v)
{
  802c90:	55                   	push   %ebp
  802c91:	89 e5                	mov    %esp,%ebp
  802c93:	56                   	push   %esi
  802c94:	53                   	push   %ebx
  802c95:	83 ec 10             	sub    $0x10,%esp
  802c98:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  802c9b:	85 db                	test   %ebx,%ebx
  802c9d:	0f 84 b9 00 00 00    	je     802d5c <free+0xcc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  802ca3:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  802ca9:	76 08                	jbe    802cb3 <free+0x23>
  802cab:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  802cb1:	76 24                	jbe    802cd7 <free+0x47>
  802cb3:	c7 44 24 0c fc 28 81 	movl   $0x8128fc,0xc(%esp)
  802cba:	00 
  802cbb:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  802cc2:	00 
  802cc3:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  802cca:	00 
  802ccb:	c7 04 24 2a 29 81 00 	movl   $0x81292a,(%esp)
  802cd2:	e8 3d dc ff ff       	call   800914 <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  802cd7:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (vpt[PGNUM(c)] & PTE_CONTINUED) {
  802cdd:	be 00 00 40 ef       	mov    $0xef400000,%esi
  802ce2:	eb 4a                	jmp    802d2e <free+0x9e>
		sys_page_unmap(0, c);
  802ce4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802ce8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802cef:	e8 08 ea ff ff       	call   8016fc <sys_page_unmap>
		c += PGSIZE;
  802cf4:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  802cfa:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  802d00:	76 08                	jbe    802d0a <free+0x7a>
  802d02:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  802d08:	76 24                	jbe    802d2e <free+0x9e>
  802d0a:	c7 44 24 0c 37 29 81 	movl   $0x812937,0xc(%esp)
  802d11:	00 
  802d12:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  802d19:	00 
  802d1a:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  802d21:	00 
  802d22:	c7 04 24 2a 29 81 00 	movl   $0x81292a,(%esp)
  802d29:	e8 e6 db ff ff       	call   800914 <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (vpt[PGNUM(c)] & PTE_CONTINUED) {
  802d2e:	89 d8                	mov    %ebx,%eax
  802d30:	c1 e8 0c             	shr    $0xc,%eax
  802d33:	8b 04 86             	mov    (%esi,%eax,4),%eax
  802d36:	f6 c4 04             	test   $0x4,%ah
  802d39:	75 a9                	jne    802ce4 <free+0x54>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  802d3b:	8d 93 fc 0f 00 00    	lea    0xffc(%ebx),%edx
	if (--(*ref) == 0)
  802d41:	8b 02                	mov    (%edx),%eax
  802d43:	83 e8 01             	sub    $0x1,%eax
  802d46:	89 02                	mov    %eax,(%edx)
  802d48:	85 c0                	test   %eax,%eax
  802d4a:	75 10                	jne    802d5c <free+0xcc>
		sys_page_unmap(0, c);
  802d4c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802d50:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802d57:	e8 a0 e9 ff ff       	call   8016fc <sys_page_unmap>
}
  802d5c:	83 c4 10             	add    $0x10,%esp
  802d5f:	5b                   	pop    %ebx
  802d60:	5e                   	pop    %esi
  802d61:	5d                   	pop    %ebp
  802d62:	c3                   	ret    

00802d63 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  802d63:	55                   	push   %ebp
  802d64:	89 e5                	mov    %esp,%ebp
  802d66:	57                   	push   %edi
  802d67:	56                   	push   %esi
  802d68:	53                   	push   %ebx
  802d69:	83 ec 3c             	sub    $0x3c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  802d6c:	83 3d 98 60 81 00 00 	cmpl   $0x0,0x816098
  802d73:	75 0a                	jne    802d7f <malloc+0x1c>
		mptr = mbegin;
  802d75:	c7 05 98 60 81 00 00 	movl   $0x8000000,0x816098
  802d7c:	00 00 08 

	n = ROUNDUP(n, 4);
  802d7f:	8b 45 08             	mov    0x8(%ebp),%eax
  802d82:	83 c0 03             	add    $0x3,%eax
  802d85:	83 e0 fc             	and    $0xfffffffc,%eax
  802d88:	89 45 d8             	mov    %eax,-0x28(%ebp)

	if (n >= MAXMALLOC)
  802d8b:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  802d90:	0f 87 97 01 00 00    	ja     802f2d <malloc+0x1ca>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  802d96:	a1 98 60 81 00       	mov    0x816098,%eax
  802d9b:	89 c2                	mov    %eax,%edx
  802d9d:	a9 ff 0f 00 00       	test   $0xfff,%eax
  802da2:	74 4d                	je     802df1 <malloc+0x8e>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  802da4:	89 c3                	mov    %eax,%ebx
  802da6:	c1 eb 0c             	shr    $0xc,%ebx
  802da9:	8b 75 d8             	mov    -0x28(%ebp),%esi
  802dac:	8d 4c 30 03          	lea    0x3(%eax,%esi,1),%ecx
  802db0:	c1 e9 0c             	shr    $0xc,%ecx
  802db3:	39 cb                	cmp    %ecx,%ebx
  802db5:	75 1e                	jne    802dd5 <malloc+0x72>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  802db7:	81 c2 ff 0f 00 00    	add    $0xfff,%edx
  802dbd:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  802dc3:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  802dc7:	8d 14 30             	lea    (%eax,%esi,1),%edx
  802dca:	89 15 98 60 81 00    	mov    %edx,0x816098
			return v;
  802dd0:	e9 5d 01 00 00       	jmp    802f32 <malloc+0x1cf>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  802dd5:	89 04 24             	mov    %eax,(%esp)
  802dd8:	e8 b3 fe ff ff       	call   802c90 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  802ddd:	a1 98 60 81 00       	mov    0x816098,%eax
  802de2:	05 00 10 00 00       	add    $0x1000,%eax
  802de7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  802dec:	a3 98 60 81 00       	mov    %eax,0x816098
  802df1:	8b 3d 98 60 81 00    	mov    0x816098,%edi
  802df7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			return 0;
	return 1;
}

void*
malloc(size_t n)
  802dfe:	8b 45 d8             	mov    -0x28(%ebp),%eax
  802e01:	83 c0 04             	add    $0x4,%eax
  802e04:	89 45 dc             	mov    %eax,-0x24(%ebp)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[PGNUM(va)] & PTE_P)))
  802e07:	bb 00 d0 7b ef       	mov    $0xef7bd000,%ebx
  802e0c:	be 00 00 40 ef       	mov    $0xef400000,%esi
			return 0;
	return 1;
}

void*
malloc(size_t n)
  802e11:	8b 45 dc             	mov    -0x24(%ebp),%eax
  802e14:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  802e17:	8d 0c 07             	lea    (%edi,%eax,1),%ecx
  802e1a:	89 7d e4             	mov    %edi,-0x1c(%ebp)
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  802e1d:	39 cf                	cmp    %ecx,%edi
  802e1f:	0f 83 d7 00 00 00    	jae    802efc <malloc+0x199>
		if (va >= (uintptr_t) mend
  802e25:	89 f8                	mov    %edi,%eax
  802e27:	81 ff ff ff ff 0f    	cmp    $0xfffffff,%edi
  802e2d:	76 09                	jbe    802e38 <malloc+0xd5>
  802e2f:	eb 38                	jmp    802e69 <malloc+0x106>
  802e31:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  802e36:	77 31                	ja     802e69 <malloc+0x106>
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[PGNUM(va)] & PTE_P)))
  802e38:	89 c2                	mov    %eax,%edx
  802e3a:	c1 ea 16             	shr    $0x16,%edx
  802e3d:	8b 14 93             	mov    (%ebx,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  802e40:	f6 c2 01             	test   $0x1,%dl
  802e43:	74 0d                	je     802e52 <malloc+0xef>
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[PGNUM(va)] & PTE_P)))
  802e45:	89 c2                	mov    %eax,%edx
  802e47:	c1 ea 0c             	shr    $0xc,%edx
  802e4a:	8b 14 96             	mov    (%esi,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  802e4d:	f6 c2 01             	test   $0x1,%dl
  802e50:	75 17                	jne    802e69 <malloc+0x106>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  802e52:	05 00 10 00 00       	add    $0x1000,%eax
  802e57:	39 c8                	cmp    %ecx,%eax
  802e59:	72 d6                	jb     802e31 <malloc+0xce>
  802e5b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802e5e:	89 35 98 60 81 00    	mov    %esi,0x816098
  802e64:	e9 9b 00 00 00       	jmp    802f04 <malloc+0x1a1>
  802e69:	81 c7 00 10 00 00    	add    $0x1000,%edi
  802e6f:	81 c1 00 10 00 00    	add    $0x1000,%ecx
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  802e75:	81 ff 00 00 00 10    	cmp    $0x10000000,%edi
  802e7b:	75 9d                	jne    802e1a <malloc+0xb7>
			mptr = mbegin;
			if (++nwrap == 2)
  802e7d:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  802e81:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
  802e85:	74 07                	je     802e8e <malloc+0x12b>
  802e87:	bf 00 00 00 08       	mov    $0x8000000,%edi
  802e8c:	eb 83                	jmp    802e11 <malloc+0xae>
  802e8e:	c7 05 98 60 81 00 00 	movl   $0x8000000,0x816098
  802e95:	00 00 08 
  802e98:	b8 00 00 00 00       	mov    $0x0,%eax
  802e9d:	e9 90 00 00 00       	jmp    802f32 <malloc+0x1cf>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  802ea2:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  802ea8:	39 fe                	cmp    %edi,%esi
  802eaa:	19 c0                	sbb    %eax,%eax
  802eac:	25 00 04 00 00       	and    $0x400,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  802eb1:	83 c8 07             	or     $0x7,%eax
  802eb4:	89 44 24 08          	mov    %eax,0x8(%esp)
  802eb8:	03 15 98 60 81 00    	add    0x816098,%edx
  802ebe:	89 54 24 04          	mov    %edx,0x4(%esp)
  802ec2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802ec9:	e8 9f e8 ff ff       	call   80176d <sys_page_alloc>
  802ece:	85 c0                	test   %eax,%eax
  802ed0:	78 04                	js     802ed6 <malloc+0x173>
  802ed2:	89 f3                	mov    %esi,%ebx
  802ed4:	eb 36                	jmp    802f0c <malloc+0x1a9>
			for (; i >= 0; i -= PGSIZE)
  802ed6:	85 db                	test   %ebx,%ebx
  802ed8:	78 53                	js     802f2d <malloc+0x1ca>
				sys_page_unmap(0, mptr + i);
  802eda:	89 d8                	mov    %ebx,%eax
  802edc:	03 05 98 60 81 00    	add    0x816098,%eax
  802ee2:	89 44 24 04          	mov    %eax,0x4(%esp)
  802ee6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802eed:	e8 0a e8 ff ff       	call   8016fc <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  802ef2:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  802ef8:	79 e0                	jns    802eda <malloc+0x177>
  802efa:	eb 31                	jmp    802f2d <malloc+0x1ca>
  802efc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802eff:	a3 98 60 81 00       	mov    %eax,0x816098
  802f04:	bb 00 00 00 00       	mov    $0x0,%ebx
  802f09:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  802f0c:	89 da                	mov    %ebx,%edx
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  802f0e:	39 fb                	cmp    %edi,%ebx
  802f10:	72 90                	jb     802ea2 <malloc+0x13f>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  802f12:	a1 98 60 81 00       	mov    0x816098,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  802f17:	c7 44 18 fc 02 00 00 	movl   $0x2,-0x4(%eax,%ebx,1)
  802f1e:	00 
	v = mptr;
	mptr += n;
  802f1f:	8b 55 d8             	mov    -0x28(%ebp),%edx
  802f22:	8d 14 10             	lea    (%eax,%edx,1),%edx
  802f25:	89 15 98 60 81 00    	mov    %edx,0x816098
	return v;
  802f2b:	eb 05                	jmp    802f32 <malloc+0x1cf>
  802f2d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802f32:	83 c4 3c             	add    $0x3c,%esp
  802f35:	5b                   	pop    %ebx
  802f36:	5e                   	pop    %esi
  802f37:	5f                   	pop    %edi
  802f38:	5d                   	pop    %ebp
  802f39:	c3                   	ret    
	...

00802f3c <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  802f3c:	55                   	push   %ebp
  802f3d:	89 e5                	mov    %esp,%ebp
  802f3f:	83 ec 18             	sub    $0x18,%esp
	int r;

	if (_pgfault_handler == 0) {
  802f42:	83 3d 00 f0 b3 00 00 	cmpl   $0x0,0xb3f000
  802f49:	75 54                	jne    802f9f <set_pgfault_handler+0x63>
		// First time through!
		// LAB 4: Your code here.
		if ((r = sys_page_alloc(0, (void*) (UXSTACKTOP - PGSIZE), PTE_U|PTE_P|PTE_W)) < 0)
  802f4b:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  802f52:	00 
  802f53:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  802f5a:	ee 
  802f5b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802f62:	e8 06 e8 ff ff       	call   80176d <sys_page_alloc>
  802f67:	85 c0                	test   %eax,%eax
  802f69:	79 20                	jns    802f8b <set_pgfault_handler+0x4f>
			panic ("set_pgfault_handler: %e", r);
  802f6b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  802f6f:	c7 44 24 08 4f 29 81 	movl   $0x81294f,0x8(%esp)
  802f76:	00 
  802f77:	c7 44 24 04 21 00 00 	movl   $0x21,0x4(%esp)
  802f7e:	00 
  802f7f:	c7 04 24 67 29 81 00 	movl   $0x812967,(%esp)
  802f86:	e8 89 d9 ff ff       	call   800914 <_panic>
		sys_env_set_pgfault_upcall (0, _pgfault_upcall);
  802f8b:	c7 44 24 04 ac 2f 80 	movl   $0x802fac,0x4(%esp)
  802f92:	00 
  802f93:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802f9a:	e8 b5 e6 ff ff       	call   801654 <sys_env_set_pgfault_upcall>

			//panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  802f9f:	8b 45 08             	mov    0x8(%ebp),%eax
  802fa2:	a3 00 f0 b3 00       	mov    %eax,0xb3f000
}
  802fa7:	c9                   	leave  
  802fa8:	c3                   	ret    
  802fa9:	00 00                	add    %al,(%eax)
	...

00802fac <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  802fac:	54                   	push   %esp
	movl _pgfault_handler, %eax
  802fad:	a1 00 f0 b3 00       	mov    0xb3f000,%eax
	call *%eax
  802fb2:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  802fb4:	83 c4 04             	add    $0x4,%esp
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.

	movl 0x30(%esp), %eax
  802fb7:	8b 44 24 30          	mov    0x30(%esp),%eax
	subl $0x4, %eax
  802fbb:	83 e8 04             	sub    $0x4,%eax
	movl %eax, 0x30(%esp)
  802fbe:	89 44 24 30          	mov    %eax,0x30(%esp)
	# put old eip in the pre-reserved 4 bytes space
	movl 0x28(%esp), %ebx
  802fc2:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	movl %ebx, (%eax)
  802fc6:	89 18                	mov    %ebx,(%eax)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	
	addl $0x8, %esp
  802fc8:	83 c4 08             	add    $0x8,%esp
	popal
  802fcb:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.

	addl $0x4, %esp
  802fcc:	83 c4 04             	add    $0x4,%esp
	popfl
  802fcf:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	pop %esp
  802fd0:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	ret
  802fd1:	c3                   	ret    
	...

00802fd4 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  802fd4:	55                   	push   %ebp
  802fd5:	89 e5                	mov    %esp,%ebp
	pte_t pte;

	if (!(vpd[PDX(v)] & PTE_P))
  802fd7:	8b 45 08             	mov    0x8(%ebp),%eax
  802fda:	89 c2                	mov    %eax,%edx
  802fdc:	c1 ea 16             	shr    $0x16,%edx
  802fdf:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  802fe6:	f6 c2 01             	test   $0x1,%dl
  802fe9:	74 20                	je     80300b <pageref+0x37>
		return 0;
	pte = vpt[PGNUM(v)];
  802feb:	c1 e8 0c             	shr    $0xc,%eax
  802fee:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if (!(pte & PTE_P))
  802ff5:	a8 01                	test   $0x1,%al
  802ff7:	74 12                	je     80300b <pageref+0x37>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  802ff9:	c1 e8 0c             	shr    $0xc,%eax
  802ffc:	ba 00 00 00 ef       	mov    $0xef000000,%edx
  803001:	0f b7 44 c2 04       	movzwl 0x4(%edx,%eax,8),%eax
  803006:	0f b7 c0             	movzwl %ax,%eax
  803009:	eb 05                	jmp    803010 <pageref+0x3c>
  80300b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803010:	5d                   	pop    %ebp
  803011:	c3                   	ret    
	...

00803020 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  803020:	55                   	push   %ebp
  803021:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  803023:	83 f8 1f             	cmp    $0x1f,%eax
  803026:	76 11                	jbe    803039 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  803028:	c7 05 20 c2 b3 00 09 	movl   $0x9,0xb3c220
  80302f:	00 00 00 
  803032:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  803037:	eb 1e                	jmp    803057 <get_socket+0x37>
  }

  sock = &sockets[s];
  803039:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80303c:	8d 04 85 a0 60 81 00 	lea    0x8160a0(,%eax,4),%eax

  if (!sock->conn) {
  803043:	83 38 00             	cmpl   $0x0,(%eax)
  803046:	75 0f                	jne    803057 <get_socket+0x37>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  803048:	c7 05 20 c2 b3 00 09 	movl   $0x9,0xb3c220
  80304f:	00 00 00 
  803052:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  }

  return sock;
}
  803057:	5d                   	pop    %ebp
  803058:	c3                   	ret    

00803059 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  803059:	55                   	push   %ebp
  80305a:	89 e5                	mov    %esp,%ebp
  80305c:	56                   	push   %esi
  80305d:	53                   	push   %ebx
  80305e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  803061:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  803064:	8b 45 08             	mov    0x8(%ebp),%eax
  803067:	e8 b4 ff ff ff       	call   803020 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  80306c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  803071:	85 c0                	test   %eax,%eax
  803073:	0f 84 a6 00 00 00    	je     80311f <lwip_ioctl+0xc6>
    return -1;

  switch (cmd) {
  803079:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  80307f:	74 59                	je     8030da <lwip_ioctl+0x81>
  803081:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  803087:	0f 85 7c 00 00 00    	jne    803109 <lwip_ioctl+0xb0>
  case FIONREAD:
    if (!argp) {
  80308d:	85 f6                	test   %esi,%esi
  80308f:	90                   	nop
  803090:	75 13                	jne    8030a5 <lwip_ioctl+0x4c>
      sock_set_errno(sock, EINVAL);
  803092:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  803099:	c7 05 20 c2 b3 00 16 	movl   $0x16,0xb3c220
  8030a0:	00 00 00 
      return -1;
  8030a3:	eb 7a                	jmp    80311f <lwip_ioctl+0xc6>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  8030a5:	8b 10                	mov    (%eax),%edx
  8030a7:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  8030ab:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  8030ae:	8b 48 04             	mov    0x4(%eax),%ecx
  8030b1:	85 c9                	test   %ecx,%ecx
  8030b3:	74 0d                	je     8030c2 <lwip_ioctl+0x69>
      buflen = netbuf_len(sock->lastdata);
  8030b5:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  8030b7:	66 03 51 08          	add    0x8(%ecx),%dx
  8030bb:	66 2b 50 08          	sub    0x8(%eax),%dx
  8030bf:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  8030c2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  8030c9:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8030d0:	00 00 00 
  8030d3:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  8030d8:	eb 45                	jmp    80311f <lwip_ioctl+0xc6>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8030da:	85 f6                	test   %esi,%esi
  8030dc:	74 0d                	je     8030eb <lwip_ioctl+0x92>
  8030de:	83 3e 00             	cmpl   $0x0,(%esi)
  8030e1:	74 08                	je     8030eb <lwip_ioctl+0x92>
      sock->flags |= O_NONBLOCK;
  8030e3:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
    return 0;

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8030e9:	eb 06                	jmp    8030f1 <lwip_ioctl+0x98>
      sock->flags |= O_NONBLOCK;
    else
      sock->flags &= ~O_NONBLOCK;
  8030eb:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  8030f1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  8030f8:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8030ff:	00 00 00 
  803102:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  803107:	eb 16                	jmp    80311f <lwip_ioctl+0xc6>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  803109:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  803110:	c7 05 20 c2 b3 00 26 	movl   $0x26,0xb3c220
  803117:	00 00 00 
  80311a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    return -1;
  } /* switch (cmd) */
}
  80311f:	89 d0                	mov    %edx,%eax
  803121:	5b                   	pop    %ebx
  803122:	5e                   	pop    %esi
  803123:	5d                   	pop    %ebp
  803124:	c3                   	ret    

00803125 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  803125:	55                   	push   %ebp
  803126:	89 e5                	mov    %esp,%ebp
  803128:	83 ec 48             	sub    $0x48,%esp
  80312b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80312e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803131:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803134:	8b 75 0c             	mov    0xc(%ebp),%esi
  803137:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  80313a:	8b 45 08             	mov    0x8(%ebp),%eax
  80313d:	e8 de fe ff ff       	call   803020 <get_socket>
  803142:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  803144:	85 c0                	test   %eax,%eax
  803146:	0f 84 52 01 00 00    	je     80329e <lwip_setsockopt+0x179>
    return -1;

  if (NULL == optval) {
  80314c:	85 ff                	test   %edi,%edi
  80314e:	75 1b                	jne    80316b <lwip_setsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  803150:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  803157:	c7 05 20 c2 b3 00 0e 	movl   $0xe,0xb3c220
  80315e:	00 00 00 
  803161:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  803166:	e9 3f 01 00 00       	jmp    8032aa <lwip_setsockopt+0x185>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  80316b:	83 fe 06             	cmp    $0x6,%esi
  80316e:	0f 84 8e 00 00 00    	je     803202 <lwip_setsockopt+0xdd>
  803174:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  80317a:	74 11                	je     80318d <lwip_setsockopt+0x68>
  80317c:	85 f6                	test   %esi,%esi
  80317e:	66 90                	xchg   %ax,%ax
  803180:	74 66                	je     8031e8 <lwip_setsockopt+0xc3>
  803182:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  803188:	e9 a0 00 00 00       	jmp    80322d <lwip_setsockopt+0x108>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80318d:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  803191:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803198:	74 1c                	je     8031b6 <lwip_setsockopt+0x91>
  80319a:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8031a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8031a8:	74 1b                	je     8031c5 <lwip_setsockopt+0xa0>
  8031aa:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8031ae:	66 90                	xchg   %ax,%ax
  8031b0:	0f 85 77 00 00 00    	jne    80322d <lwip_setsockopt+0x108>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  8031b6:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8031ba:	0f 86 f7 00 00 00    	jbe    8032b7 <lwip_setsockopt+0x192>
  8031c0:	e9 80 00 00 00       	jmp    803245 <lwip_setsockopt+0x120>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  8031c5:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  8031c9:	19 c0                	sbb    %eax,%eax
  8031cb:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8031ce:	8b 13                	mov    (%ebx),%edx
  8031d0:	83 3a 20             	cmpl   $0x20,(%edx)
  8031d3:	0f 85 e8 00 00 00    	jne    8032c1 <lwip_setsockopt+0x19c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  8031d9:	8b 52 08             	mov    0x8(%edx),%edx
  8031dc:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  8031e0:	0f 85 db 00 00 00    	jne    8032c1 <lwip_setsockopt+0x19c>
  8031e6:	eb 4a                	jmp    803232 <lwip_setsockopt+0x10d>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8031e8:	8b 45 10             	mov    0x10(%ebp),%eax
  8031eb:	83 e8 01             	sub    $0x1,%eax
  8031ee:	83 f8 01             	cmp    $0x1,%eax
  8031f1:	77 3a                	ja     80322d <lwip_setsockopt+0x108>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  8031f3:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8031f7:	0f 86 ba 00 00 00    	jbe    8032b7 <lwip_setsockopt+0x192>
  8031fd:	8d 76 00             	lea    0x0(%esi),%esi
  803200:	eb 43                	jmp    803245 <lwip_setsockopt+0x120>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  803202:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  803206:	66 90                	xchg   %ax,%ax
  803208:	0f 86 a9 00 00 00    	jbe    8032b7 <lwip_setsockopt+0x192>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  80320e:	8b 00                	mov    (%eax),%eax
  803210:	83 38 10             	cmpl   $0x10,(%eax)
  803213:	0f 85 8c 00 00 00    	jne    8032a5 <lwip_setsockopt+0x180>
      return 0;

    switch (optname) {
  803219:	8b 55 10             	mov    0x10(%ebp),%edx
  80321c:	83 ea 01             	sub    $0x1,%edx
  80321f:	b8 5c 00 00 00       	mov    $0x5c,%eax
  803224:	83 fa 01             	cmp    $0x1,%edx
  803227:	77 0d                	ja     803236 <lwip_setsockopt+0x111>
  803229:	b0 00                	mov    $0x0,%al
  80322b:	eb 05                	jmp    803232 <lwip_setsockopt+0x10d>
  80322d:	b8 5c 00 00 00       	mov    $0x5c,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  803232:	85 c0                	test   %eax,%eax
  803234:	74 0f                	je     803245 <lwip_setsockopt+0x120>
    sock_set_errno(sock, err);
  803236:	89 43 10             	mov    %eax,0x10(%ebx)
  803239:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  80323e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  803243:	eb 65                	jmp    8032aa <lwip_setsockopt+0x185>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  803245:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  803248:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  80324b:	8b 45 10             	mov    0x10(%ebp),%eax
  80324e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  803251:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  803254:	8d 45 18             	lea    0x18(%ebp),%eax
  803257:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  80325a:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  80325e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  803265:	00 
  803266:	8d 45 cc             	lea    -0x34(%ebp),%eax
  803269:	89 44 24 04          	mov    %eax,0x4(%esp)
  80326d:	c7 04 24 ad 34 80 00 	movl   $0x8034ad,(%esp)
  803274:	e8 bd 1a 00 00       	call   804d36 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  803279:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803280:	00 
  803281:	8b 03                	mov    (%ebx),%eax
  803283:	8b 40 10             	mov    0x10(%eax),%eax
  803286:	89 04 24             	mov    %eax,(%esp)
  803289:	e8 e8 a0 00 00       	call   80d376 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  80328e:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  803292:	89 43 10             	mov    %eax,0x10(%ebx)
  803295:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  return err ? -1 : 0;
  80329a:	85 c0                	test   %eax,%eax
  80329c:	74 07                	je     8032a5 <lwip_setsockopt+0x180>
  80329e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8032a3:	eb 05                	jmp    8032aa <lwip_setsockopt+0x185>
  8032a5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8032aa:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8032ad:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8032b0:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8032b3:	89 ec                	mov    %ebp,%esp
  8032b5:	5d                   	pop    %ebp
  8032b6:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  8032b7:	b8 16 00 00 00       	mov    $0x16,%eax
  8032bc:	e9 75 ff ff ff       	jmp    803236 <lwip_setsockopt+0x111>
  8032c1:	b8 61 00 00 00       	mov    $0x61,%eax
  8032c6:	e9 6b ff ff ff       	jmp    803236 <lwip_setsockopt+0x111>

008032cb <lwip_getsockopt>:
  return lwip_getaddrname(s, name, namelen, 1);
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  8032cb:	55                   	push   %ebp
  8032cc:	89 e5                	mov    %esp,%ebp
  8032ce:	57                   	push   %edi
  8032cf:	56                   	push   %esi
  8032d0:	53                   	push   %ebx
  8032d1:	83 ec 3c             	sub    $0x3c,%esp
  8032d4:	8b 75 0c             	mov    0xc(%ebp),%esi
  8032d7:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  8032da:	8b 45 08             	mov    0x8(%ebp),%eax
  8032dd:	e8 3e fd ff ff       	call   803020 <get_socket>
  8032e2:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8032e4:	85 c0                	test   %eax,%eax
  8032e6:	0f 84 99 01 00 00    	je     803485 <lwip_getsockopt+0x1ba>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  8032ec:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  8032f0:	74 04                	je     8032f6 <lwip_getsockopt+0x2b>
  8032f2:	85 ff                	test   %edi,%edi
  8032f4:	75 1b                	jne    803311 <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  8032f6:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  8032fd:	c7 05 20 c2 b3 00 0e 	movl   $0xe,0xb3c220
  803304:	00 00 00 
  803307:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  80330c:	e9 80 01 00 00       	jmp    803491 <lwip_getsockopt+0x1c6>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  803311:	83 fe 06             	cmp    $0x6,%esi
  803314:	0f 84 c3 00 00 00    	je     8033dd <lwip_getsockopt+0x112>
  80331a:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  803320:	74 13                	je     803335 <lwip_getsockopt+0x6a>
  803322:	85 f6                	test   %esi,%esi
  803324:	0f 84 9d 00 00 00    	je     8033c7 <lwip_getsockopt+0xfc>
  80332a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  803330:	e9 d8 00 00 00       	jmp    80340d <lwip_getsockopt+0x142>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  803335:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  803339:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803340:	74 50                	je     803392 <lwip_getsockopt+0xc7>
  803342:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  803346:	66 90                	xchg   %ax,%ax
  803348:	7f 18                	jg     803362 <lwip_getsockopt+0x97>
  80334a:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  80334e:	66 90                	xchg   %ax,%ax
  803350:	74 40                	je     803392 <lwip_getsockopt+0xc7>
  803352:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  803356:	0f 85 b1 00 00 00    	jne    80340d <lwip_getsockopt+0x142>
  80335c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803360:	eb 30                	jmp    803392 <lwip_getsockopt+0xc7>
  803362:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  803369:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803370:	0f 8c 97 00 00 00    	jl     80340d <lwip_getsockopt+0x142>
  803376:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  80337d:	8d 76 00             	lea    0x0(%esi),%esi
  803380:	7e 10                	jle    803392 <lwip_getsockopt+0xc7>
  803382:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  803389:	0f 85 7e 00 00 00    	jne    80340d <lwip_getsockopt+0x142>
  80338f:	90                   	nop
  803390:	eb 13                	jmp    8033a5 <lwip_getsockopt+0xda>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  803392:	83 3f 03             	cmpl   $0x3,(%edi)
  803395:	8d 76 00             	lea    0x0(%esi),%esi
  803398:	0f 86 fb 00 00 00    	jbe    803499 <lwip_getsockopt+0x1ce>
  80339e:	66 90                	xchg   %ax,%ax
  8033a0:	e9 83 00 00 00       	jmp    803428 <lwip_getsockopt+0x15d>
        err = EINVAL;
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  8033a5:	83 3f 04             	cmpl   $0x4,(%edi)
  8033a8:	19 c0                	sbb    %eax,%eax
  8033aa:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8033ad:	8b 13                	mov    (%ebx),%edx
  8033af:	83 3a 20             	cmpl   $0x20,(%edx)
  8033b2:	0f 85 eb 00 00 00    	jne    8034a3 <lwip_getsockopt+0x1d8>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  8033b8:	8b 52 08             	mov    0x8(%edx),%edx
  8033bb:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  8033bf:	0f 85 de 00 00 00    	jne    8034a3 <lwip_getsockopt+0x1d8>
  8033c5:	eb 4b                	jmp    803412 <lwip_getsockopt+0x147>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8033c7:	8b 45 10             	mov    0x10(%ebp),%eax
  8033ca:	83 e8 01             	sub    $0x1,%eax
  8033cd:	83 f8 01             	cmp    $0x1,%eax
  8033d0:	77 3b                	ja     80340d <lwip_getsockopt+0x142>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  8033d2:	83 3f 03             	cmpl   $0x3,(%edi)
  8033d5:	0f 86 be 00 00 00    	jbe    803499 <lwip_getsockopt+0x1ce>
  8033db:	eb 4b                	jmp    803428 <lwip_getsockopt+0x15d>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  8033dd:	83 3f 03             	cmpl   $0x3,(%edi)
  8033e0:	0f 86 b3 00 00 00    	jbe    803499 <lwip_getsockopt+0x1ce>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  8033e6:	8b 00                	mov    (%eax),%eax
  8033e8:	83 38 10             	cmpl   $0x10,(%eax)
  8033eb:	90                   	nop
  8033ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8033f0:	0f 85 96 00 00 00    	jne    80348c <lwip_getsockopt+0x1c1>
      return 0;

    switch (optname) {
  8033f6:	8b 55 10             	mov    0x10(%ebp),%edx
  8033f9:	83 ea 01             	sub    $0x1,%edx
  8033fc:	b8 5c 00 00 00       	mov    $0x5c,%eax
  803401:	83 fa 01             	cmp    $0x1,%edx
  803404:	77 10                	ja     803416 <lwip_getsockopt+0x14b>
  803406:	b8 00 00 00 00       	mov    $0x0,%eax
  80340b:	eb 05                	jmp    803412 <lwip_getsockopt+0x147>
  80340d:	b8 5c 00 00 00       	mov    $0x5c,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  803412:	84 c0                	test   %al,%al
  803414:	74 12                	je     803428 <lwip_getsockopt+0x15d>
    sock_set_errno(sock, err);
  803416:	0f be c0             	movsbl %al,%eax
  803419:	89 43 10             	mov    %eax,0x10(%ebx)
  80341c:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  803421:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  803426:	eb 69                	jmp    803491 <lwip_getsockopt+0x1c6>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  803428:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  80342b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  80342e:	8b 45 10             	mov    0x10(%ebp),%eax
  803431:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  803434:	8b 45 14             	mov    0x14(%ebp),%eax
  803437:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  80343a:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  80343d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  803441:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  803448:	00 
  803449:	8d 45 cc             	lea    -0x34(%ebp),%eax
  80344c:	89 44 24 04          	mov    %eax,0x4(%esp)
  803450:	c7 04 24 c0 35 80 00 	movl   $0x8035c0,(%esp)
  803457:	e8 da 18 00 00       	call   804d36 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  80345c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803463:	00 
  803464:	8b 03                	mov    (%ebx),%eax
  803466:	8b 40 10             	mov    0x10(%eax),%eax
  803469:	89 04 24             	mov    %eax,(%esp)
  80346c:	e8 05 9f 00 00       	call   80d376 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  803471:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  803475:	0f be d0             	movsbl %al,%edx
  803478:	89 53 10             	mov    %edx,0x10(%ebx)
  80347b:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  return err ? -1 : 0;
  803481:	84 c0                	test   %al,%al
  803483:	74 07                	je     80348c <lwip_getsockopt+0x1c1>
  803485:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80348a:	eb 05                	jmp    803491 <lwip_getsockopt+0x1c6>
  80348c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803491:	83 c4 3c             	add    $0x3c,%esp
  803494:	5b                   	pop    %ebx
  803495:	5e                   	pop    %esi
  803496:	5f                   	pop    %edi
  803497:	5d                   	pop    %ebp
  803498:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  803499:	b8 16 00 00 00       	mov    $0x16,%eax
  80349e:	e9 73 ff ff ff       	jmp    803416 <lwip_getsockopt+0x14b>
  8034a3:	b8 61 00 00 00       	mov    $0x61,%eax
  8034a8:	e9 69 ff ff ff       	jmp    803416 <lwip_getsockopt+0x14b>

008034ad <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  8034ad:	55                   	push   %ebp
  8034ae:	89 e5                	mov    %esp,%ebp
  8034b0:	53                   	push   %ebx
  8034b1:	83 ec 14             	sub    $0x14,%esp
  8034b4:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8034b7:	85 c0                	test   %eax,%eax
  8034b9:	75 1c                	jne    8034d7 <lwip_setsockopt_internal+0x2a>
  8034bb:	c7 44 24 08 75 29 81 	movl   $0x812975,0x8(%esp)
  8034c2:	00 
  8034c3:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  8034ca:	00 
  8034cb:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  8034d2:	e8 3d d4 ff ff       	call   800914 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  8034d7:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  8034d9:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  8034dc:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  8034df:	8b 40 08             	mov    0x8(%eax),%eax
  8034e2:	83 f8 06             	cmp    $0x6,%eax
  8034e5:	0f 84 88 00 00 00    	je     803573 <lwip_setsockopt_internal+0xc6>
  8034eb:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  8034f0:	74 0b                	je     8034fd <lwip_setsockopt_internal+0x50>
  8034f2:	85 c0                	test   %eax,%eax
  8034f4:	74 5b                	je     803551 <lwip_setsockopt_internal+0xa4>
  8034f6:	66 90                	xchg   %ax,%ax
  8034f8:	e9 b0 00 00 00       	jmp    8035ad <lwip_setsockopt_internal+0x100>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8034fd:	83 f9 20             	cmp    $0x20,%ecx
  803500:	74 14                	je     803516 <lwip_setsockopt_internal+0x69>
  803502:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  803508:	74 2c                	je     803536 <lwip_setsockopt_internal+0x89>
  80350a:	83 f9 08             	cmp    $0x8,%ecx
  80350d:	8d 76 00             	lea    0x0(%esi),%esi
  803510:	0f 85 97 00 00 00    	jne    8035ad <lwip_setsockopt_internal+0x100>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  803516:	83 3b 00             	cmpl   $0x0,(%ebx)
  803519:	74 0e                	je     803529 <lwip_setsockopt_internal+0x7c>
        sock->conn->pcb.ip->so_options |= optname;
  80351b:	8b 02                	mov    (%edx),%eax
  80351d:	8b 40 08             	mov    0x8(%eax),%eax
  803520:	66 09 48 08          	or     %cx,0x8(%eax)
  803524:	e9 84 00 00 00       	jmp    8035ad <lwip_setsockopt_internal+0x100>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  803529:	8b 02                	mov    (%edx),%eax
  80352b:	8b 40 08             	mov    0x8(%eax),%eax
  80352e:	f7 d1                	not    %ecx
  803530:	66 21 48 08          	and    %cx,0x8(%eax)
  803534:	eb 77                	jmp    8035ad <lwip_setsockopt_internal+0x100>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  803536:	83 3b 00             	cmpl   $0x0,(%ebx)
  803539:	74 0b                	je     803546 <lwip_setsockopt_internal+0x99>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  80353b:	8b 02                	mov    (%edx),%eax
  80353d:	8b 40 08             	mov    0x8(%eax),%eax
  803540:	80 48 10 01          	orb    $0x1,0x10(%eax)
  803544:	eb 67                	jmp    8035ad <lwip_setsockopt_internal+0x100>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  803546:	8b 02                	mov    (%edx),%eax
  803548:	8b 40 08             	mov    0x8(%eax),%eax
  80354b:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  80354f:	eb 5c                	jmp    8035ad <lwip_setsockopt_internal+0x100>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803551:	83 f9 01             	cmp    $0x1,%ecx
  803554:	74 11                	je     803567 <lwip_setsockopt_internal+0xba>
  803556:	83 f9 02             	cmp    $0x2,%ecx
  803559:	75 52                	jne    8035ad <lwip_setsockopt_internal+0x100>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  80355b:	8b 02                	mov    (%edx),%eax
  80355d:	8b 40 08             	mov    0x8(%eax),%eax
  803560:	8b 0b                	mov    (%ebx),%ecx
  803562:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  803565:	eb 46                	jmp    8035ad <lwip_setsockopt_internal+0x100>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  803567:	8b 02                	mov    (%edx),%eax
  803569:	8b 40 08             	mov    0x8(%eax),%eax
  80356c:	8b 0b                	mov    (%ebx),%ecx
  80356e:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
  803571:	eb 3a                	jmp    8035ad <lwip_setsockopt_internal+0x100>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  803573:	83 f9 01             	cmp    $0x1,%ecx
  803576:	74 0a                	je     803582 <lwip_setsockopt_internal+0xd5>
  803578:	83 f9 02             	cmp    $0x2,%ecx
  80357b:	75 30                	jne    8035ad <lwip_setsockopt_internal+0x100>
  80357d:	8d 76 00             	lea    0x0(%esi),%esi
  803580:	eb 1e                	jmp    8035a0 <lwip_setsockopt_internal+0xf3>
    case TCP_NODELAY:
      if (*(int*)optval) {
  803582:	83 3b 00             	cmpl   $0x0,(%ebx)
  803585:	8d 76 00             	lea    0x0(%esi),%esi
  803588:	74 0b                	je     803595 <lwip_setsockopt_internal+0xe8>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  80358a:	8b 02                	mov    (%edx),%eax
  80358c:	8b 40 08             	mov    0x8(%eax),%eax
  80358f:	80 48 20 40          	orb    $0x40,0x20(%eax)
  803593:	eb 18                	jmp    8035ad <lwip_setsockopt_internal+0x100>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  803595:	8b 02                	mov    (%edx),%eax
  803597:	8b 40 08             	mov    0x8(%eax),%eax
  80359a:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  80359e:	eb 0d                	jmp    8035ad <lwip_setsockopt_internal+0x100>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  8035a0:	8b 02                	mov    (%edx),%eax
  8035a2:	8b 40 08             	mov    0x8(%eax),%eax
  8035a5:	8b 0b                	mov    (%ebx),%ecx
  8035a7:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  8035ad:	8b 02                	mov    (%edx),%eax
  8035af:	8b 40 10             	mov    0x10(%eax),%eax
  8035b2:	89 04 24             	mov    %eax,(%esp)
  8035b5:	e8 ad a0 00 00       	call   80d667 <sys_sem_signal>
}
  8035ba:	83 c4 14             	add    $0x14,%esp
  8035bd:	5b                   	pop    %ebx
  8035be:	5d                   	pop    %ebp
  8035bf:	c3                   	ret    

008035c0 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  8035c0:	55                   	push   %ebp
  8035c1:	89 e5                	mov    %esp,%ebp
  8035c3:	53                   	push   %ebx
  8035c4:	83 ec 14             	sub    $0x14,%esp
  8035c7:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8035ca:	85 c0                	test   %eax,%eax
  8035cc:	75 1c                	jne    8035ea <lwip_getsockopt_internal+0x2a>
  8035ce:	c7 44 24 08 75 29 81 	movl   $0x812975,0x8(%esp)
  8035d5:	00 
  8035d6:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  8035dd:	00 
  8035de:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  8035e5:	e8 2a d3 ff ff       	call   800914 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  8035ea:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  8035ec:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  8035ef:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  8035f2:	8b 40 08             	mov    0x8(%eax),%eax
  8035f5:	83 f8 06             	cmp    $0x6,%eax
  8035f8:	0f 84 17 01 00 00    	je     803715 <lwip_getsockopt_internal+0x155>
  8035fe:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  803603:	74 10                	je     803615 <lwip_getsockopt_internal+0x55>
  803605:	85 c0                	test   %eax,%eax
  803607:	0f 84 e4 00 00 00    	je     8036f1 <lwip_getsockopt_internal+0x131>
  80360d:	8d 76 00             	lea    0x0(%esi),%esi
  803610:	e9 2a 01 00 00       	jmp    80373f <lwip_getsockopt_internal+0x17f>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  803615:	83 f9 20             	cmp    $0x20,%ecx
  803618:	74 40                	je     80365a <lwip_getsockopt_internal+0x9a>
  80361a:	83 f9 20             	cmp    $0x20,%ecx
  80361d:	8d 76 00             	lea    0x0(%esi),%esi
  803620:	7f 10                	jg     803632 <lwip_getsockopt_internal+0x72>
  803622:	83 f9 02             	cmp    $0x2,%ecx
  803625:	74 33                	je     80365a <lwip_getsockopt_internal+0x9a>
  803627:	83 f9 08             	cmp    $0x8,%ecx
  80362a:	0f 85 0f 01 00 00    	jne    80373f <lwip_getsockopt_internal+0x17f>
  803630:	eb 28                	jmp    80365a <lwip_getsockopt_internal+0x9a>
  803632:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  803638:	74 32                	je     80366c <lwip_getsockopt_internal+0xac>
  80363a:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  803640:	0f 84 9b 00 00 00    	je     8036e1 <lwip_getsockopt_internal+0x121>
  803646:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  80364c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803650:	0f 85 e9 00 00 00    	jne    80373f <lwip_getsockopt_internal+0x17f>
  803656:	66 90                	xchg   %ax,%ax
  803658:	eb 4f                	jmp    8036a9 <lwip_getsockopt_internal+0xe9>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  80365a:	8b 02                	mov    (%edx),%eax
  80365c:	8b 40 08             	mov    0x8(%eax),%eax
  80365f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  803663:	21 c1                	and    %eax,%ecx
  803665:	89 0b                	mov    %ecx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  803667:	e9 d3 00 00 00       	jmp    80373f <lwip_getsockopt_internal+0x17f>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  80366c:	8b 02                	mov    (%edx),%eax
  80366e:	8b 08                	mov    (%eax),%ecx
  803670:	89 c8                	mov    %ecx,%eax
  803672:	25 f0 00 00 00       	and    $0xf0,%eax
  803677:	83 f8 20             	cmp    $0x20,%eax
  80367a:	74 22                	je     80369e <lwip_getsockopt_internal+0xde>
  80367c:	83 f8 40             	cmp    $0x40,%eax
  80367f:	74 12                	je     803693 <lwip_getsockopt_internal+0xd3>
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  803681:	83 f8 10             	cmp    $0x10,%eax
  803684:	b8 01 00 00 00       	mov    $0x1,%eax
  803689:	0f 44 c8             	cmove  %eax,%ecx
  80368c:	89 0b                	mov    %ecx,(%ebx)
  80368e:	e9 ac 00 00 00       	jmp    80373f <lwip_getsockopt_internal+0x17f>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  803693:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  803699:	e9 a1 00 00 00       	jmp    80373f <lwip_getsockopt_internal+0x17f>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  80369e:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  8036a4:	e9 96 00 00 00       	jmp    80373f <lwip_getsockopt_internal+0x17f>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  8036a9:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  8036ad:	8d 76 00             	lea    0x0(%esi),%esi
  8036b0:	75 21                	jne    8036d3 <lwip_getsockopt_internal+0x113>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  8036b2:	8b 02                	mov    (%edx),%eax
  8036b4:	0f be 48 0c          	movsbl 0xc(%eax),%ecx
  8036b8:	f7 d9                	neg    %ecx
  8036ba:	b8 05 00 00 00       	mov    $0x5,%eax
  8036bf:	83 f9 0e             	cmp    $0xe,%ecx
  8036c2:	77 07                	ja     8036cb <lwip_getsockopt_internal+0x10b>
  8036c4:	8b 04 8d 60 2a 81 00 	mov    0x812a60(,%ecx,4),%eax
  8036cb:	89 42 10             	mov    %eax,0x10(%edx)
  8036ce:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
      } 
      *(int *)optval = sock->err;
  8036d3:	8b 42 10             	mov    0x10(%edx),%eax
  8036d6:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  8036d8:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  8036df:	eb 5e                	jmp    80373f <lwip_getsockopt_internal+0x17f>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  8036e1:	8b 02                	mov    (%edx),%eax
  8036e3:	8b 40 08             	mov    0x8(%eax),%eax
  8036e6:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  8036ea:	83 e0 01             	and    $0x1,%eax
  8036ed:	89 03                	mov    %eax,(%ebx)
  8036ef:	eb 4e                	jmp    80373f <lwip_getsockopt_internal+0x17f>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8036f1:	83 f9 01             	cmp    $0x1,%ecx
  8036f4:	74 12                	je     803708 <lwip_getsockopt_internal+0x148>
  8036f6:	83 f9 02             	cmp    $0x2,%ecx
  8036f9:	75 44                	jne    80373f <lwip_getsockopt_internal+0x17f>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  8036fb:	8b 02                	mov    (%edx),%eax
  8036fd:	8b 40 08             	mov    0x8(%eax),%eax
  803700:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  803704:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  803706:	eb 37                	jmp    80373f <lwip_getsockopt_internal+0x17f>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  803708:	8b 02                	mov    (%edx),%eax
  80370a:	8b 40 08             	mov    0x8(%eax),%eax
  80370d:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  803711:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
  803713:	eb 2a                	jmp    80373f <lwip_getsockopt_internal+0x17f>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  803715:	83 f9 01             	cmp    $0x1,%ecx
  803718:	74 08                	je     803722 <lwip_getsockopt_internal+0x162>
  80371a:	83 f9 02             	cmp    $0x2,%ecx
  80371d:	75 20                	jne    80373f <lwip_getsockopt_internal+0x17f>
  80371f:	90                   	nop
  803720:	eb 10                	jmp    803732 <lwip_getsockopt_internal+0x172>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  803722:	8b 02                	mov    (%edx),%eax
  803724:	8b 40 08             	mov    0x8(%eax),%eax
  803727:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  80372b:	83 e0 40             	and    $0x40,%eax
  80372e:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  803730:	eb 0d                	jmp    80373f <lwip_getsockopt_internal+0x17f>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  803732:	8b 02                	mov    (%edx),%eax
  803734:	8b 40 08             	mov    0x8(%eax),%eax
  803737:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  80373d:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  80373f:	8b 02                	mov    (%edx),%eax
  803741:	8b 40 10             	mov    0x10(%eax),%eax
  803744:	89 04 24             	mov    %eax,(%esp)
  803747:	e8 1b 9f 00 00       	call   80d667 <sys_sem_signal>
}
  80374c:	83 c4 14             	add    $0x14,%esp
  80374f:	5b                   	pop    %ebx
  803750:	5d                   	pop    %ebp
  803751:	c3                   	ret    

00803752 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  803752:	55                   	push   %ebp
  803753:	89 e5                	mov    %esp,%ebp
  803755:	57                   	push   %edi
  803756:	56                   	push   %esi
  803757:	53                   	push   %ebx
  803758:	83 ec 3c             	sub    $0x3c,%esp
  80375b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80375e:	89 55 d0             	mov    %edx,-0x30(%ebp)
  803761:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  803764:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80376b:	00 
  80376c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803773:	00 
  803774:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803777:	89 04 24             	mov    %eax,(%esp)
  80377a:	e8 17 db ff ff       	call   801296 <memset>
  FD_ZERO(&lwriteset);
  80377f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803786:	00 
  803787:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80378e:	00 
  80378f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803792:	89 04 24             	mov    %eax,(%esp)
  803795:	e8 fc da ff ff       	call   801296 <memset>
  FD_ZERO(&lexceptset);
  80379a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8037a1:	00 
  8037a2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8037a9:	00 
  8037aa:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8037ad:	89 04 24             	mov    %eax,(%esp)
  8037b0:	e8 e1 da ff ff       	call   801296 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8037b5:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  8037bc:	bb 00 00 00 00       	mov    $0x0,%ebx
  8037c1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  8037c5:	7e 7c                	jle    803843 <lwip_selscan+0xf1>
    if (FD_ISSET(i, readset)) {
  8037c7:	8d 73 07             	lea    0x7(%ebx),%esi
  8037ca:	85 db                	test   %ebx,%ebx
  8037cc:	0f 49 f3             	cmovns %ebx,%esi
  8037cf:	c1 fe 03             	sar    $0x3,%esi
  8037d2:	89 df                	mov    %ebx,%edi
  8037d4:	83 e7 07             	and    $0x7,%edi
  8037d7:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8037da:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  8037de:	0f a3 f8             	bt     %edi,%eax
  8037e1:	73 29                	jae    80380c <lwip_selscan+0xba>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8037e3:	89 d8                	mov    %ebx,%eax
  8037e5:	e8 36 f8 ff ff       	call   803020 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8037ea:	85 c0                	test   %eax,%eax
  8037ec:	74 1e                	je     80380c <lwip_selscan+0xba>
  8037ee:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8037f2:	75 07                	jne    8037fb <lwip_selscan+0xa9>
  8037f4:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  8037f9:	74 11                	je     80380c <lwip_selscan+0xba>
        FD_SET(i, &lreadset);
  8037fb:	b8 01 00 00 00       	mov    $0x1,%eax
  803800:	89 f9                	mov    %edi,%ecx
  803802:	d3 e0                	shl    %cl,%eax
  803804:	08 44 35 e4          	or     %al,-0x1c(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  803808:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  80380c:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80380f:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  803813:	0f a3 f8             	bt     %edi,%eax
  803816:	73 23                	jae    80383b <lwip_selscan+0xe9>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  803818:	89 d8                	mov    %ebx,%eax
  80381a:	e8 01 f8 ff ff       	call   803020 <get_socket>
      if (p_sock && p_sock->sendevent) {
  80381f:	85 c0                	test   %eax,%eax
  803821:	74 18                	je     80383b <lwip_selscan+0xe9>
  803823:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  803828:	74 11                	je     80383b <lwip_selscan+0xe9>
        FD_SET(i, &lwriteset);
  80382a:	b8 01 00 00 00       	mov    $0x1,%eax
  80382f:	89 f9                	mov    %edi,%ecx
  803831:	d3 e0                	shl    %cl,%eax
  803833:	08 44 35 e0          	or     %al,-0x20(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  803837:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  80383b:	83 c3 01             	add    $0x1,%ebx
  80383e:	39 5d d4             	cmp    %ebx,-0x2c(%ebp)
  803841:	7f 84                	jg     8037c7 <lwip_selscan+0x75>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  803843:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803846:	8b 55 d0             	mov    -0x30(%ebp),%edx
  803849:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  80384b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80384e:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  803851:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  803853:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80385a:	00 
  80385b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803862:	00 
  803863:	8b 45 08             	mov    0x8(%ebp),%eax
  803866:	89 04 24             	mov    %eax,(%esp)
  803869:	e8 28 da ff ff       	call   801296 <memset>
  
  return nready;
}
  80386e:	8b 45 c8             	mov    -0x38(%ebp),%eax
  803871:	83 c4 3c             	add    $0x3c,%esp
  803874:	5b                   	pop    %ebx
  803875:	5e                   	pop    %esi
  803876:	5f                   	pop    %edi
  803877:	5d                   	pop    %ebp
  803878:	c3                   	ret    

00803879 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  803879:	55                   	push   %ebp
  80387a:	89 e5                	mov    %esp,%ebp
  80387c:	83 ec 58             	sub    $0x58,%esp
  80387f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803882:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803885:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803888:	89 d7                	mov    %edx,%edi
  80388a:	89 ce                	mov    %ecx,%esi
  80388c:	0f b6 55 08          	movzbl 0x8(%ebp),%edx
  803890:	88 55 c7             	mov    %dl,-0x39(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  803893:	e8 88 f7 ff ff       	call   803020 <get_socket>
  803898:	89 c3                	mov    %eax,%ebx
  if (!sock)
  80389a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80389f:	85 db                	test   %ebx,%ebx
  8038a1:	0f 84 8f 00 00 00    	je     803936 <lwip_getaddrname+0xbd>
    return -1;

  memset(&sin, 0, sizeof(sin));
  8038a7:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  8038ae:	00 
  8038af:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8038b6:	00 
  8038b7:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8038ba:	89 04 24             	mov    %eax,(%esp)
  8038bd:	e8 d4 d9 ff ff       	call   801296 <memset>
  sin.sin_len = sizeof(sin);
  8038c2:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  8038c6:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  8038ca:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  8038ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8038d2:	8d 45 da             	lea    -0x26(%ebp),%eax
  8038d5:	89 44 24 08          	mov    %eax,0x8(%esp)
  8038d9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8038dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  8038e0:	8b 03                	mov    (%ebx),%eax
  8038e2:	89 04 24             	mov    %eax,(%esp)
  8038e5:	e8 39 aa 00 00       	call   80e323 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  8038ea:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  8038ee:	89 04 24             	mov    %eax,(%esp)
  8038f1:	e8 7d 6e 00 00       	call   80a773 <htons>
  8038f6:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8038fa:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8038fd:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  803900:	83 3e 10             	cmpl   $0x10,(%esi)
  803903:	76 06                	jbe    80390b <lwip_getaddrname+0x92>
    *namelen = sizeof(sin);
  803905:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  80390b:	8b 06                	mov    (%esi),%eax
  80390d:	89 44 24 08          	mov    %eax,0x8(%esp)
  803911:	8d 45 d8             	lea    -0x28(%ebp),%eax
  803914:	89 44 24 04          	mov    %eax,0x4(%esp)
  803918:	89 3c 24             	mov    %edi,(%esp)
  80391b:	e8 51 da ff ff       	call   801371 <memcpy>
  sock_set_errno(sock, 0);
  803920:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  803927:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  80392e:	00 00 00 
  803931:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  803936:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803939:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80393c:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80393f:	89 ec                	mov    %ebp,%esp
  803941:	5d                   	pop    %ebp
  803942:	c3                   	ret    

00803943 <lwip_getsockname>:
  return lwip_getaddrname(s, name, namelen, 0);
}

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  803943:	55                   	push   %ebp
  803944:	89 e5                	mov    %esp,%ebp
  803946:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  803949:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803950:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803953:	8b 55 0c             	mov    0xc(%ebp),%edx
  803956:	8b 45 08             	mov    0x8(%ebp),%eax
  803959:	e8 1b ff ff ff       	call   803879 <lwip_getaddrname>
}
  80395e:	c9                   	leave  
  80395f:	c3                   	ret    

00803960 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  803960:	55                   	push   %ebp
  803961:	89 e5                	mov    %esp,%ebp
  803963:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  803966:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80396d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803970:	8b 55 0c             	mov    0xc(%ebp),%edx
  803973:	8b 45 08             	mov    0x8(%ebp),%eax
  803976:	e8 fe fe ff ff       	call   803879 <lwip_getaddrname>
}
  80397b:	c9                   	leave  
  80397c:	c3                   	ret    

0080397d <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  80397d:	55                   	push   %ebp
  80397e:	89 e5                	mov    %esp,%ebp
  803980:	56                   	push   %esi
  803981:	53                   	push   %ebx
  803982:	83 ec 10             	sub    $0x10,%esp
  803985:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  803987:	a1 24 63 81 00       	mov    0x816324,%eax
  80398c:	89 04 24             	mov    %eax,(%esp)
  80398f:	e8 b6 46 00 00       	call   80804a <sys_sem_wait>

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
    if (!sockets[i].conn) {
  803994:	b8 b4 60 81 00       	mov    $0x8160b4,%eax
  803999:	bb 01 00 00 00       	mov    $0x1,%ebx
  80399e:	83 3d a0 60 81 00 00 	cmpl   $0x0,0x8160a0
  8039a5:	75 04                	jne    8039ab <alloc_socket+0x2e>
  8039a7:	b3 00                	mov    $0x0,%bl
  8039a9:	eb 05                	jmp    8039b0 <alloc_socket+0x33>
  8039ab:	83 38 00             	cmpl   $0x0,(%eax)
  8039ae:	75 50                	jne    803a00 <alloc_socket+0x83>
      sockets[i].conn       = newconn;
  8039b0:	ba a0 60 81 00       	mov    $0x8160a0,%edx
  8039b5:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
  8039bc:	8d 0c 18             	lea    (%eax,%ebx,1),%ecx
  8039bf:	89 34 8a             	mov    %esi,(%edx,%ecx,4)
      sockets[i].lastdata   = NULL;
  8039c2:	c7 44 8a 04 00 00 00 	movl   $0x0,0x4(%edx,%ecx,4)
  8039c9:	00 
      sockets[i].lastoffset = 0;
  8039ca:	66 c7 44 8a 08 00 00 	movw   $0x0,0x8(%edx,%ecx,4)
      sockets[i].rcvevent   = 0;
  8039d1:	66 c7 44 8a 0a 00 00 	movw   $0x0,0xa(%edx,%ecx,4)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  8039d8:	66 c7 44 8a 0c 01 00 	movw   $0x1,0xc(%edx,%ecx,4)
      sockets[i].flags      = 0;
  8039df:	66 c7 44 8a 0e 00 00 	movw   $0x0,0xe(%edx,%ecx,4)
      sockets[i].err        = 0;
  8039e6:	c7 04 8d b0 60 81 00 	movl   $0x0,0x8160b0(,%ecx,4)
  8039ed:	00 00 00 00 
      sys_sem_signal(socksem);
  8039f1:	a1 24 63 81 00       	mov    0x816324,%eax
  8039f6:	89 04 24             	mov    %eax,(%esp)
  8039f9:	e8 69 9c 00 00       	call   80d667 <sys_sem_signal>
      return i;
  8039fe:	eb 1d                	jmp    803a1d <alloc_socket+0xa0>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  803a00:	83 c3 01             	add    $0x1,%ebx
  803a03:	83 c0 14             	add    $0x14,%eax
  803a06:	83 fb 20             	cmp    $0x20,%ebx
  803a09:	75 a0                	jne    8039ab <alloc_socket+0x2e>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  803a0b:	a1 24 63 81 00       	mov    0x816324,%eax
  803a10:	89 04 24             	mov    %eax,(%esp)
  803a13:	e8 4f 9c 00 00       	call   80d667 <sys_sem_signal>
  803a18:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return -1;
}
  803a1d:	89 d8                	mov    %ebx,%eax
  803a1f:	83 c4 10             	add    $0x10,%esp
  803a22:	5b                   	pop    %ebx
  803a23:	5e                   	pop    %esi
  803a24:	5d                   	pop    %ebp
  803a25:	c3                   	ret    

00803a26 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  803a26:	55                   	push   %ebp
  803a27:	89 e5                	mov    %esp,%ebp
  803a29:	57                   	push   %edi
  803a2a:	56                   	push   %esi
  803a2b:	53                   	push   %ebx
  803a2c:	83 ec 2c             	sub    $0x2c,%esp
  803a2f:	8b 75 08             	mov    0x8(%ebp),%esi
  803a32:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  803a35:	85 f6                	test   %esi,%esi
  803a37:	0f 84 73 01 00 00    	je     803bb0 <event_callback+0x18a>
    s = conn->socket;
  803a3d:	8b 5e 1c             	mov    0x1c(%esi),%ebx
    if (s < 0) {
  803a40:	85 db                	test   %ebx,%ebx
  803a42:	79 3d                	jns    803a81 <event_callback+0x5b>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  803a44:	a1 24 63 81 00       	mov    0x816324,%eax
  803a49:	89 04 24             	mov    %eax,(%esp)
  803a4c:	e8 f9 45 00 00       	call   80804a <sys_sem_wait>
      if (conn->socket < 0) {
  803a51:	8b 46 1c             	mov    0x1c(%esi),%eax
  803a54:	85 c0                	test   %eax,%eax
  803a56:	79 1c                	jns    803a74 <event_callback+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  803a58:	85 ff                	test   %edi,%edi
  803a5a:	75 06                	jne    803a62 <event_callback+0x3c>
          conn->socket--;
  803a5c:	83 e8 01             	sub    $0x1,%eax
  803a5f:	89 46 1c             	mov    %eax,0x1c(%esi)
        }
        sys_sem_signal(socksem);
  803a62:	a1 24 63 81 00       	mov    0x816324,%eax
  803a67:	89 04 24             	mov    %eax,(%esp)
  803a6a:	e8 f8 9b 00 00       	call   80d667 <sys_sem_signal>
        return;
  803a6f:	e9 3c 01 00 00       	jmp    803bb0 <event_callback+0x18a>
      }
      sys_sem_signal(socksem);
  803a74:	a1 24 63 81 00       	mov    0x816324,%eax
  803a79:	89 04 24             	mov    %eax,(%esp)
  803a7c:	e8 e6 9b 00 00       	call   80d667 <sys_sem_signal>
    }

    sock = get_socket(s);
  803a81:	89 d8                	mov    %ebx,%eax
  803a83:	e8 98 f5 ff ff       	call   803020 <get_socket>
  803a88:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  803a8b:	85 c0                	test   %eax,%eax
  803a8d:	0f 84 1d 01 00 00    	je     803bb0 <event_callback+0x18a>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  803a93:	a1 28 63 81 00       	mov    0x816328,%eax
  803a98:	89 04 24             	mov    %eax,(%esp)
  803a9b:	e8 aa 45 00 00       	call   80804a <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  803aa0:	83 ff 01             	cmp    $0x1,%edi
  803aa3:	74 1f                	je     803ac4 <event_callback+0x9e>
  803aa5:	83 ff 01             	cmp    $0x1,%edi
  803aa8:	72 10                	jb     803aba <event_callback+0x94>
  803aaa:	83 ff 02             	cmp    $0x2,%edi
  803aad:	8d 76 00             	lea    0x0(%esi),%esi
  803ab0:	74 1c                	je     803ace <event_callback+0xa8>
  803ab2:	83 ff 03             	cmp    $0x3,%edi
  803ab5:	75 2d                	jne    803ae4 <event_callback+0xbe>
  803ab7:	90                   	nop
  803ab8:	eb 1f                	jmp    803ad9 <event_callback+0xb3>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  803aba:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803abd:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  803ac2:	eb 3c                	jmp    803b00 <event_callback+0xda>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  803ac4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803ac7:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  803acc:	eb 32                	jmp    803b00 <event_callback+0xda>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  803ace:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803ad1:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  803ad7:	eb 27                	jmp    803b00 <event_callback+0xda>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  803ad9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803adc:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  803ae2:	eb 1c                	jmp    803b00 <event_callback+0xda>
    default:
      LWIP_ASSERT("unknown event", 0);
  803ae4:	c7 44 24 08 98 29 81 	movl   $0x812998,0x8(%esp)
  803aeb:	00 
  803aec:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  803af3:	00 
  803af4:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  803afb:	e8 14 ce ff ff       	call   800914 <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  803b00:	a1 28 63 81 00       	mov    0x816328,%eax
  803b05:	89 04 24             	mov    %eax,(%esp)
  803b08:	e8 5a 9b 00 00       	call   80d667 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  803b0d:	8d 73 07             	lea    0x7(%ebx),%esi
  803b10:	85 db                	test   %ebx,%ebx
  803b12:	0f 49 f3             	cmovns %ebx,%esi
  803b15:	c1 fe 03             	sar    $0x3,%esi
  803b18:	89 d9                	mov    %ebx,%ecx
  803b1a:	83 e1 07             	and    $0x7,%ecx
  803b1d:	b8 01 00 00 00       	mov    $0x1,%eax
  803b22:	89 c7                	mov    %eax,%edi
  803b24:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  803b26:	a1 28 63 81 00       	mov    0x816328,%eax
  803b2b:	89 04 24             	mov    %eax,(%esp)
  803b2e:	e8 17 45 00 00       	call   80804a <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  803b33:	8b 1d 20 63 81 00    	mov    0x816320,%ebx
  803b39:	85 db                	test   %ebx,%ebx
  803b3b:	74 66                	je     803ba3 <event_callback+0x17d>
      if (scb->sem_signalled == 0) {
  803b3d:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  803b41:	75 32                	jne    803b75 <event_callback+0x14f>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  803b43:	8b 43 04             	mov    0x4(%ebx),%eax
  803b46:	85 c0                	test   %eax,%eax
  803b48:	74 12                	je     803b5c <event_callback+0x136>
  803b4a:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  803b4e:	85 f8                	test   %edi,%eax
  803b50:	74 0a                	je     803b5c <event_callback+0x136>
          if (sock->rcvevent)
  803b52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803b55:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  803b5a:	75 21                	jne    803b7d <event_callback+0x157>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  803b5c:	8b 43 08             	mov    0x8(%ebx),%eax
  803b5f:	85 c0                	test   %eax,%eax
  803b61:	74 12                	je     803b75 <event_callback+0x14f>
  803b63:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  803b67:	85 f8                	test   %edi,%eax
  803b69:	74 0a                	je     803b75 <event_callback+0x14f>
          if (sock->sendevent)
  803b6b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803b6e:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  803b73:	75 08                	jne    803b7d <event_callback+0x157>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  803b75:	8b 1b                	mov    (%ebx),%ebx
  803b77:	85 db                	test   %ebx,%ebx
  803b79:	75 c2                	jne    803b3d <event_callback+0x117>
  803b7b:	eb 26                	jmp    803ba3 <event_callback+0x17d>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
  803b7d:	85 db                	test   %ebx,%ebx
  803b7f:	90                   	nop
  803b80:	74 21                	je     803ba3 <event_callback+0x17d>
      scb->sem_signalled = 1;
  803b82:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  803b89:	a1 28 63 81 00       	mov    0x816328,%eax
  803b8e:	89 04 24             	mov    %eax,(%esp)
  803b91:	e8 d1 9a 00 00       	call   80d667 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  803b96:	8b 43 14             	mov    0x14(%ebx),%eax
  803b99:	89 04 24             	mov    %eax,(%esp)
  803b9c:	e8 c6 9a 00 00       	call   80d667 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  803ba1:	eb 83                	jmp    803b26 <event_callback+0x100>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  803ba3:	a1 28 63 81 00       	mov    0x816328,%eax
  803ba8:	89 04 24             	mov    %eax,(%esp)
  803bab:	e8 b7 9a 00 00       	call   80d667 <sys_sem_signal>
      break;
    }
  }
}
  803bb0:	83 c4 2c             	add    $0x2c,%esp
  803bb3:	5b                   	pop    %ebx
  803bb4:	5e                   	pop    %esi
  803bb5:	5f                   	pop    %edi
  803bb6:	5d                   	pop    %ebp
  803bb7:	c3                   	ret    

00803bb8 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  803bb8:	55                   	push   %ebp
  803bb9:	89 e5                	mov    %esp,%ebp
  803bbb:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  803bbe:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803bc5:	e8 fb 98 00 00       	call   80d4c5 <sys_sem_new>
  803bca:	a3 24 63 81 00       	mov    %eax,0x816324
  selectsem = sys_sem_new(1);
  803bcf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803bd6:	e8 ea 98 00 00       	call   80d4c5 <sys_sem_new>
  803bdb:	a3 28 63 81 00       	mov    %eax,0x816328
}
  803be0:	c9                   	leave  
  803be1:	c3                   	ret    

00803be2 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  803be2:	55                   	push   %ebp
  803be3:	89 e5                	mov    %esp,%ebp
  803be5:	57                   	push   %edi
  803be6:	56                   	push   %esi
  803be7:	53                   	push   %ebx
  803be8:	83 ec 5c             	sub    $0x5c,%esp
  803beb:	8b 7d 0c             	mov    0xc(%ebp),%edi
  803bee:	8b 75 10             	mov    0x10(%ebp),%esi
  803bf1:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  803bf4:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  803bfb:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  803bfe:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  803c01:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  803c04:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  803c0b:	a1 28 63 81 00       	mov    0x816328,%eax
  803c10:	89 04 24             	mov    %eax,(%esp)
  803c13:	e8 32 44 00 00       	call   80804a <sys_sem_wait>

  if (readset)
  803c18:	85 ff                	test   %edi,%edi
  803c1a:	74 07                	je     803c23 <lwip_select+0x41>
    lreadset = *readset;
  803c1c:	8b 07                	mov    (%edi),%eax
  803c1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803c21:	eb 1b                	jmp    803c3e <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  803c23:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803c2a:	00 
  803c2b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c32:	00 
  803c33:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803c36:	89 04 24             	mov    %eax,(%esp)
  803c39:	e8 58 d6 ff ff       	call   801296 <memset>
  if (writeset)
  803c3e:	85 f6                	test   %esi,%esi
  803c40:	74 07                	je     803c49 <lwip_select+0x67>
    lwriteset = *writeset;
  803c42:	8b 06                	mov    (%esi),%eax
  803c44:	89 45 e0             	mov    %eax,-0x20(%ebp)
  803c47:	eb 1b                	jmp    803c64 <lwip_select+0x82>
  else
    FD_ZERO(&lwriteset);
  803c49:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803c50:	00 
  803c51:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c58:	00 
  803c59:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803c5c:	89 04 24             	mov    %eax,(%esp)
  803c5f:	e8 32 d6 ff ff       	call   801296 <memset>
  if (exceptset)
  803c64:	85 db                	test   %ebx,%ebx
  803c66:	74 07                	je     803c6f <lwip_select+0x8d>
    lexceptset = *exceptset;
  803c68:	8b 03                	mov    (%ebx),%eax
  803c6a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  803c6d:	eb 1b                	jmp    803c8a <lwip_select+0xa8>
  else
    FD_ZERO(&lexceptset);
  803c6f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803c76:	00 
  803c77:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c7e:	00 
  803c7f:	8d 45 dc             	lea    -0x24(%ebp),%eax
  803c82:	89 04 24             	mov    %eax,(%esp)
  803c85:	e8 0c d6 ff ff       	call   801296 <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  803c8a:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  803c8d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  803c90:	8d 45 dc             	lea    -0x24(%ebp),%eax
  803c93:	89 04 24             	mov    %eax,(%esp)
  803c96:	8b 45 08             	mov    0x8(%ebp),%eax
  803c99:	e8 b4 fa ff ff       	call   803752 <lwip_selscan>
  803c9e:	89 45 b0             	mov    %eax,-0x50(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  803ca1:	85 c0                	test   %eax,%eax
  803ca3:	0f 85 28 02 00 00    	jne    803ed1 <lwip_select+0x2ef>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  803ca9:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  803cad:	0f 84 86 00 00 00    	je     803d39 <lwip_select+0x157>
  803cb3:	8b 45 18             	mov    0x18(%ebp),%eax
  803cb6:	83 38 00             	cmpl   $0x0,(%eax)
  803cb9:	0f 85 4f 02 00 00    	jne    803f0e <lwip_select+0x32c>
  803cbf:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  803cc3:	0f 85 45 02 00 00    	jne    803f0e <lwip_select+0x32c>
      sys_sem_signal(selectsem);
  803cc9:	a1 28 63 81 00       	mov    0x816328,%eax
  803cce:	89 04 24             	mov    %eax,(%esp)
  803cd1:	e8 91 99 00 00       	call   80d667 <sys_sem_signal>
      if (readset)
  803cd6:	85 ff                	test   %edi,%edi
  803cd8:	74 18                	je     803cf2 <lwip_select+0x110>
        FD_ZERO(readset);
  803cda:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803ce1:	00 
  803ce2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803ce9:	00 
  803cea:	89 3c 24             	mov    %edi,(%esp)
  803ced:	e8 a4 d5 ff ff       	call   801296 <memset>
      if (writeset)
  803cf2:	85 f6                	test   %esi,%esi
  803cf4:	74 18                	je     803d0e <lwip_select+0x12c>
        FD_ZERO(writeset);
  803cf6:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803cfd:	00 
  803cfe:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d05:	00 
  803d06:	89 34 24             	mov    %esi,(%esp)
  803d09:	e8 88 d5 ff ff       	call   801296 <memset>
      if (exceptset)
  803d0e:	85 db                	test   %ebx,%ebx
  803d10:	74 18                	je     803d2a <lwip_select+0x148>
        FD_ZERO(exceptset);
  803d12:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803d19:	00 
  803d1a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d21:	00 
  803d22:	89 1c 24             	mov    %ebx,(%esp)
  803d25:	e8 6c d5 ff ff       	call   801296 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  803d2a:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  803d31:	00 00 00 
  
      return 0;
  803d34:	e9 ca 01 00 00       	jmp    803f03 <lwip_select+0x321>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  803d39:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803d40:	e8 80 97 00 00       	call   80d4c5 <sys_sem_new>
  803d45:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  803d48:	a1 20 63 81 00       	mov    0x816320,%eax
  803d4d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  803d50:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  803d53:	a3 20 63 81 00       	mov    %eax,0x816320
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  803d58:	a1 28 63 81 00       	mov    0x816328,%eax
  803d5d:	89 04 24             	mov    %eax,(%esp)
  803d60:	e8 02 99 00 00       	call   80d667 <sys_sem_signal>
  803d65:	ba 00 00 00 00       	mov    $0x0,%edx
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  803d6a:	89 54 24 04          	mov    %edx,0x4(%esp)
  803d6e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  803d71:	89 04 24             	mov    %eax,(%esp)
  803d74:	e8 60 43 00 00       	call   8080d9 <sys_sem_wait_timeout>
  803d79:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  803d7c:	a1 28 63 81 00       	mov    0x816328,%eax
  803d81:	89 04 24             	mov    %eax,(%esp)
  803d84:	e8 c1 42 00 00       	call   80804a <sys_sem_wait>
    if (select_cb_list == &select_cb)
  803d89:	a1 20 63 81 00       	mov    0x816320,%eax
  803d8e:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  803d91:	39 c2                	cmp    %eax,%edx
  803d93:	75 1f                	jne    803db4 <lwip_select+0x1d2>
      select_cb_list = select_cb.next;
  803d95:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  803d98:	a3 20 63 81 00       	mov    %eax,0x816320
  803d9d:	eb 26                	jmp    803dc5 <lwip_select+0x1e3>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  803d9f:	8b 10                	mov    (%eax),%edx
  803da1:	39 d1                	cmp    %edx,%ecx
  803da3:	74 08                	je     803dad <lwip_select+0x1cb>
  803da5:	89 d0                	mov    %edx,%eax
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  803da7:	85 c0                	test   %eax,%eax
  803da9:	75 f4                	jne    803d9f <lwip_select+0x1bd>
  803dab:	eb 18                	jmp    803dc5 <lwip_select+0x1e3>
        if (p_selcb->next == &select_cb) {
          p_selcb->next = select_cb.next;
  803dad:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  803db0:	89 10                	mov    %edx,(%eax)
          break;
  803db2:	eb 11                	jmp    803dc5 <lwip_select+0x1e3>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  803db4:	85 c0                	test   %eax,%eax
  803db6:	74 0d                	je     803dc5 <lwip_select+0x1e3>
        if (p_selcb->next == &select_cb) {
  803db8:	8b 10                	mov    (%eax),%edx
  803dba:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
  803dbd:	39 d1                	cmp    %edx,%ecx
  803dbf:	74 ec                	je     803dad <lwip_select+0x1cb>
  803dc1:	89 d0                	mov    %edx,%eax
  803dc3:	eb e2                	jmp    803da7 <lwip_select+0x1c5>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  803dc5:	a1 28 63 81 00       	mov    0x816328,%eax
  803dca:	89 04 24             	mov    %eax,(%esp)
  803dcd:	e8 95 98 00 00       	call   80d667 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  803dd2:	8b 45 d8             	mov    -0x28(%ebp),%eax
  803dd5:	89 04 24             	mov    %eax,(%esp)
  803dd8:	e8 26 92 00 00       	call   80d003 <sys_sem_free>
    if (i == 0)  {
  803ddd:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  803de1:	75 63                	jne    803e46 <lwip_select+0x264>
      /* Timeout */
      if (readset)
  803de3:	85 ff                	test   %edi,%edi
  803de5:	74 18                	je     803dff <lwip_select+0x21d>
        FD_ZERO(readset);
  803de7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803dee:	00 
  803def:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803df6:	00 
  803df7:	89 3c 24             	mov    %edi,(%esp)
  803dfa:	e8 97 d4 ff ff       	call   801296 <memset>
      if (writeset)
  803dff:	85 f6                	test   %esi,%esi
  803e01:	74 18                	je     803e1b <lwip_select+0x239>
        FD_ZERO(writeset);
  803e03:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803e0a:	00 
  803e0b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e12:	00 
  803e13:	89 34 24             	mov    %esi,(%esp)
  803e16:	e8 7b d4 ff ff       	call   801296 <memset>
      if (exceptset)
  803e1b:	85 db                	test   %ebx,%ebx
  803e1d:	74 18                	je     803e37 <lwip_select+0x255>
        FD_ZERO(exceptset);
  803e1f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803e26:	00 
  803e27:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e2e:	00 
  803e2f:	89 1c 24             	mov    %ebx,(%esp)
  803e32:	e8 5f d4 ff ff       	call   801296 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  803e37:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  803e3e:	00 00 00 
  
      return 0;
  803e41:	e9 bd 00 00 00       	jmp    803f03 <lwip_select+0x321>
    }
    
    if (readset)
  803e46:	85 ff                	test   %edi,%edi
  803e48:	74 07                	je     803e51 <lwip_select+0x26f>
      lreadset = *readset;
  803e4a:	8b 07                	mov    (%edi),%eax
  803e4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803e4f:	eb 1b                	jmp    803e6c <lwip_select+0x28a>
    else
      FD_ZERO(&lreadset);
  803e51:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803e58:	00 
  803e59:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e60:	00 
  803e61:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803e64:	89 04 24             	mov    %eax,(%esp)
  803e67:	e8 2a d4 ff ff       	call   801296 <memset>
    if (writeset)
  803e6c:	85 f6                	test   %esi,%esi
  803e6e:	74 07                	je     803e77 <lwip_select+0x295>
      lwriteset = *writeset;
  803e70:	8b 06                	mov    (%esi),%eax
  803e72:	89 45 e0             	mov    %eax,-0x20(%ebp)
  803e75:	eb 1b                	jmp    803e92 <lwip_select+0x2b0>
    else
      FD_ZERO(&lwriteset);
  803e77:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803e7e:	00 
  803e7f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e86:	00 
  803e87:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803e8a:	89 04 24             	mov    %eax,(%esp)
  803e8d:	e8 04 d4 ff ff       	call   801296 <memset>
    if (exceptset)
  803e92:	85 db                	test   %ebx,%ebx
  803e94:	74 07                	je     803e9d <lwip_select+0x2bb>
      lexceptset = *exceptset;
  803e96:	8b 03                	mov    (%ebx),%eax
  803e98:	89 45 dc             	mov    %eax,-0x24(%ebp)
  803e9b:	eb 1b                	jmp    803eb8 <lwip_select+0x2d6>
    else
      FD_ZERO(&lexceptset);
  803e9d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803ea4:	00 
  803ea5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803eac:	00 
  803ead:	8d 45 dc             	lea    -0x24(%ebp),%eax
  803eb0:	89 04 24             	mov    %eax,(%esp)
  803eb3:	e8 de d3 ff ff       	call   801296 <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  803eb8:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  803ebb:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  803ebe:	8d 45 dc             	lea    -0x24(%ebp),%eax
  803ec1:	89 04 24             	mov    %eax,(%esp)
  803ec4:	8b 45 08             	mov    0x8(%ebp),%eax
  803ec7:	e8 86 f8 ff ff       	call   803752 <lwip_selscan>
  803ecc:	89 45 b0             	mov    %eax,-0x50(%ebp)
  803ecf:	eb 0d                	jmp    803ede <lwip_select+0x2fc>
  } else
    sys_sem_signal(selectsem);
  803ed1:	a1 28 63 81 00       	mov    0x816328,%eax
  803ed6:	89 04 24             	mov    %eax,(%esp)
  803ed9:	e8 89 97 00 00       	call   80d667 <sys_sem_signal>
  
  if (readset)
  803ede:	85 ff                	test   %edi,%edi
  803ee0:	74 05                	je     803ee7 <lwip_select+0x305>
    *readset = lreadset;
  803ee2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803ee5:	89 07                	mov    %eax,(%edi)
  if (writeset)
  803ee7:	85 f6                	test   %esi,%esi
  803ee9:	74 05                	je     803ef0 <lwip_select+0x30e>
    *writeset = lwriteset;
  803eeb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803eee:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  803ef0:	85 db                	test   %ebx,%ebx
  803ef2:	74 05                	je     803ef9 <lwip_select+0x317>
    *exceptset = lexceptset;
  803ef4:	8b 45 dc             	mov    -0x24(%ebp),%eax
  803ef7:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  803ef9:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  803f00:	00 00 00 
  
  return nready;
}
  803f03:	8b 45 b0             	mov    -0x50(%ebp),%eax
  803f06:	83 c4 5c             	add    $0x5c,%esp
  803f09:	5b                   	pop    %ebx
  803f0a:	5e                   	pop    %esi
  803f0b:	5f                   	pop    %edi
  803f0c:	5d                   	pop    %ebp
  803f0d:	c3                   	ret    
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  803f0e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803f15:	e8 ab 95 00 00       	call   80d4c5 <sys_sem_new>
  803f1a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  803f1d:	a1 20 63 81 00       	mov    0x816320,%eax
  803f22:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  803f25:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  803f28:	a3 20 63 81 00       	mov    %eax,0x816320
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  803f2d:	a1 28 63 81 00       	mov    0x816328,%eax
  803f32:	89 04 24             	mov    %eax,(%esp)
  803f35:	e8 2d 97 00 00       	call   80d667 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  803f3a:	8b 45 18             	mov    0x18(%ebp),%eax
  803f3d:	8b 48 04             	mov    0x4(%eax),%ecx
  803f40:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  803f46:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803f4b:	89 c8                	mov    %ecx,%eax
  803f4d:	f7 ea                	imul   %edx
  803f4f:	c1 fa 06             	sar    $0x6,%edx
  803f52:	c1 f9 1f             	sar    $0x1f,%ecx
  803f55:	29 ca                	sub    %ecx,%edx
  803f57:	8b 45 18             	mov    0x18(%ebp),%eax
  803f5a:	69 08 e8 03 00 00    	imul   $0x3e8,(%eax),%ecx
      if(msectimeout == 0)
  803f60:	01 ca                	add    %ecx,%edx
  803f62:	b8 01 00 00 00       	mov    $0x1,%eax
  803f67:	0f 44 d0             	cmove  %eax,%edx
  803f6a:	e9 fb fd ff ff       	jmp    803d6a <lwip_select+0x188>

00803f6f <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  803f6f:	55                   	push   %ebp
  803f70:	89 e5                	mov    %esp,%ebp
  803f72:	56                   	push   %esi
  803f73:	53                   	push   %ebx
  803f74:	83 ec 10             	sub    $0x10,%esp
  803f77:	8b 45 0c             	mov    0xc(%ebp),%eax
  803f7a:	8b 55 10             	mov    0x10(%ebp),%edx
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  803f7d:	83 f8 02             	cmp    $0x2,%eax
  803f80:	74 2f                	je     803fb1 <lwip_socket+0x42>
  803f82:	83 f8 03             	cmp    $0x3,%eax
  803f85:	74 0b                	je     803f92 <lwip_socket+0x23>
  803f87:	83 f8 01             	cmp    $0x1,%eax
  803f8a:	75 70                	jne    803ffc <lwip_socket+0x8d>
  803f8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803f90:	eb 4a                	jmp    803fdc <lwip_socket+0x6d>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  803f92:	c7 44 24 08 26 3a 80 	movl   $0x803a26,0x8(%esp)
  803f99:	00 
  803f9a:	0f b6 d2             	movzbl %dl,%edx
  803f9d:	89 54 24 04          	mov    %edx,0x4(%esp)
  803fa1:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  803fa8:	e8 8b a6 00 00       	call   80e638 <netconn_new_with_proto_and_callback>
  803fad:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  803faf:	eb 5c                	jmp    80400d <lwip_socket+0x9e>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  803fb1:	81 fa 88 00 00 00    	cmp    $0x88,%edx
  803fb7:	0f 94 c0             	sete   %al
  803fba:	0f b6 c0             	movzbl %al,%eax
  803fbd:	83 c0 20             	add    $0x20,%eax
  803fc0:	c7 44 24 08 26 3a 80 	movl   $0x803a26,0x8(%esp)
  803fc7:	00 
  803fc8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803fcf:	00 
  803fd0:	89 04 24             	mov    %eax,(%esp)
  803fd3:	e8 60 a6 00 00       	call   80e638 <netconn_new_with_proto_and_callback>
  803fd8:	89 c6                	mov    %eax,%esi
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  803fda:	eb 31                	jmp    80400d <lwip_socket+0x9e>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  803fdc:	c7 44 24 08 26 3a 80 	movl   $0x803a26,0x8(%esp)
  803fe3:	00 
  803fe4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803feb:	00 
  803fec:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  803ff3:	e8 40 a6 00 00       	call   80e638 <netconn_new_with_proto_and_callback>
  803ff8:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  803ffa:	eb 11                	jmp    80400d <lwip_socket+0x9e>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  803ffc:	c7 05 20 c2 b3 00 16 	movl   $0x16,0xb3c220
  804003:	00 00 00 
  804006:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  80400b:	eb 44                	jmp    804051 <lwip_socket+0xe2>
  }

  if (!conn) {
  80400d:	85 f6                	test   %esi,%esi
  80400f:	75 11                	jne    804022 <lwip_socket+0xb3>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  804011:	c7 05 20 c2 b3 00 69 	movl   $0x69,0xb3c220
  804018:	00 00 00 
  80401b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  804020:	eb 2f                	jmp    804051 <lwip_socket+0xe2>
  }

  i = alloc_socket(conn);
  804022:	89 f0                	mov    %esi,%eax
  804024:	e8 54 f9 ff ff       	call   80397d <alloc_socket>
  804029:	89 c3                	mov    %eax,%ebx

  if (i == -1) {
  80402b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80402e:	75 14                	jne    804044 <lwip_socket+0xd5>
    netconn_delete(conn);
  804030:	89 34 24             	mov    %esi,(%esp)
  804033:	e8 c3 a5 00 00       	call   80e5fb <netconn_delete>
    set_errno(ENFILE);
  804038:	c7 05 20 c2 b3 00 17 	movl   $0x17,0xb3c220
  80403f:	00 00 00 
    return -1;
  804042:	eb 0d                	jmp    804051 <lwip_socket+0xe2>
  }
  conn->socket = i;
  804044:	89 46 1c             	mov    %eax,0x1c(%esi)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  804047:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  80404e:	00 00 00 
  return i;
}
  804051:	89 d8                	mov    %ebx,%eax
  804053:	83 c4 10             	add    $0x10,%esp
  804056:	5b                   	pop    %ebx
  804057:	5e                   	pop    %esi
  804058:	5d                   	pop    %ebp
  804059:	c3                   	ret    

0080405a <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  80405a:	55                   	push   %ebp
  80405b:	89 e5                	mov    %esp,%ebp
  80405d:	83 ec 38             	sub    $0x38,%esp
  804060:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  804063:	89 75 f8             	mov    %esi,-0x8(%ebp)
  804066:	89 7d fc             	mov    %edi,-0x4(%ebp)
  804069:	8b 7d 08             	mov    0x8(%ebp),%edi
  80406c:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  80406f:	89 f8                	mov    %edi,%eax
  804071:	e8 aa ef ff ff       	call   803020 <get_socket>
  804076:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804078:	85 c0                	test   %eax,%eax
  80407a:	0f 84 80 00 00 00    	je     804100 <lwip_send+0xa6>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  804080:	8b 00                	mov    (%eax),%eax
  804082:	83 38 10             	cmpl   $0x10,(%eax)
  804085:	74 2e                	je     8040b5 <lwip_send+0x5b>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  804087:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80408e:	00 
  80408f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  804096:	00 
  804097:	8b 45 14             	mov    0x14(%ebp),%eax
  80409a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80409e:	89 74 24 08          	mov    %esi,0x8(%esp)
  8040a2:	8b 55 0c             	mov    0xc(%ebp),%edx
  8040a5:	89 54 24 04          	mov    %edx,0x4(%esp)
  8040a9:	89 3c 24             	mov    %edi,(%esp)
  8040ac:	e8 8c 00 00 00       	call   80413d <lwip_sendto>
  8040b1:	89 c6                	mov    %eax,%esi
  8040b3:	eb 50                	jmp    804105 <lwip_send+0xab>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  8040b5:	8b 55 14             	mov    0x14(%ebp),%edx
  8040b8:	83 e2 10             	and    $0x10,%edx
  8040bb:	83 fa 01             	cmp    $0x1,%edx
  8040be:	19 d2                	sbb    %edx,%edx
  8040c0:	83 e2 fe             	and    $0xfffffffe,%edx
  8040c3:	83 c2 03             	add    $0x3,%edx
  8040c6:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8040ca:	89 74 24 08          	mov    %esi,0x8(%esp)
  8040ce:	8b 55 0c             	mov    0xc(%ebp),%edx
  8040d1:	89 54 24 04          	mov    %edx,0x4(%esp)
  8040d5:	89 04 24             	mov    %eax,(%esp)
  8040d8:	e8 09 a0 00 00       	call   80e0e6 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  8040dd:	0f be c8             	movsbl %al,%ecx
  8040e0:	f7 d9                	neg    %ecx
  8040e2:	ba 05 00 00 00       	mov    $0x5,%edx
  8040e7:	83 f9 0e             	cmp    $0xe,%ecx
  8040ea:	77 07                	ja     8040f3 <lwip_send+0x99>
  8040ec:	8b 14 8d 60 2a 81 00 	mov    0x812a60(,%ecx,4),%edx
  8040f3:	89 53 10             	mov    %edx,0x10(%ebx)
  8040f6:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  return (err==ERR_OK?size:-1);
  8040fc:	84 c0                	test   %al,%al
  8040fe:	74 05                	je     804105 <lwip_send+0xab>
  804100:	be ff ff ff ff       	mov    $0xffffffff,%esi
}
  804105:	89 f0                	mov    %esi,%eax
  804107:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80410a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80410d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  804110:	89 ec                	mov    %ebp,%esp
  804112:	5d                   	pop    %ebp
  804113:	c3                   	ret    

00804114 <lwip_write>:
  return i;
}

int
lwip_write(int s, const void *data, int size)
{
  804114:	55                   	push   %ebp
  804115:	89 e5                	mov    %esp,%ebp
  804117:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  80411a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804121:	00 
  804122:	8b 45 10             	mov    0x10(%ebp),%eax
  804125:	89 44 24 08          	mov    %eax,0x8(%esp)
  804129:	8b 45 0c             	mov    0xc(%ebp),%eax
  80412c:	89 44 24 04          	mov    %eax,0x4(%esp)
  804130:	8b 45 08             	mov    0x8(%ebp),%eax
  804133:	89 04 24             	mov    %eax,(%esp)
  804136:	e8 1f ff ff ff       	call   80405a <lwip_send>
}
  80413b:	c9                   	leave  
  80413c:	c3                   	ret    

0080413d <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  80413d:	55                   	push   %ebp
  80413e:	89 e5                	mov    %esp,%ebp
  804140:	57                   	push   %edi
  804141:	56                   	push   %esi
  804142:	53                   	push   %ebx
  804143:	83 ec 3c             	sub    $0x3c,%esp
  804146:	8b 7d 10             	mov    0x10(%ebp),%edi
  804149:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  80414c:	8b 45 08             	mov    0x8(%ebp),%eax
  80414f:	e8 cc ee ff ff       	call   803020 <get_socket>
  804154:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804156:	85 c0                	test   %eax,%eax
  804158:	0f 84 2e 01 00 00    	je     80428c <lwip_sendto+0x14f>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  80415e:	8b 00                	mov    (%eax),%eax
  804160:	83 38 10             	cmpl   $0x10,(%eax)
  804163:	75 24                	jne    804189 <lwip_sendto+0x4c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  804165:	8b 45 14             	mov    0x14(%ebp),%eax
  804168:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80416c:	89 7c 24 08          	mov    %edi,0x8(%esp)
  804170:	8b 45 0c             	mov    0xc(%ebp),%eax
  804173:	89 44 24 04          	mov    %eax,0x4(%esp)
  804177:	8b 45 08             	mov    0x8(%ebp),%eax
  80417a:	89 04 24             	mov    %eax,(%esp)
  80417d:	e8 d8 fe ff ff       	call   80405a <lwip_send>
  804182:	89 c7                	mov    %eax,%edi
  804184:	e9 08 01 00 00       	jmp    804291 <lwip_sendto+0x154>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  804189:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  80418f:	76 1c                	jbe    8041ad <lwip_sendto+0x70>
  804191:	c7 44 24 08 28 2a 81 	movl   $0x812a28,0x8(%esp)
  804198:	00 
  804199:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  8041a0:	00 
  8041a1:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  8041a8:	e8 67 c7 ff ff       	call   800914 <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8041ad:	85 f6                	test   %esi,%esi
  8041af:	0f 95 c0             	setne  %al
  8041b2:	75 06                	jne    8041ba <lwip_sendto+0x7d>
  8041b4:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8041b8:	74 2a                	je     8041e4 <lwip_sendto+0xa7>
  8041ba:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8041be:	66 90                	xchg   %ax,%ax
  8041c0:	75 06                	jne    8041c8 <lwip_sendto+0x8b>
  8041c2:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8041c6:	74 1c                	je     8041e4 <lwip_sendto+0xa7>
  8041c8:	c7 44 24 08 a6 29 81 	movl   $0x8129a6,0x8(%esp)
  8041cf:	00 
  8041d0:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  8041d7:	00 
  8041d8:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  8041df:	e8 30 c7 ff ff       	call   800914 <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  8041e4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8041eb:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  8041f2:	84 c0                	test   %al,%al
  8041f4:	74 1e                	je     804214 <lwip_sendto+0xd7>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  8041f6:	8b 46 04             	mov    0x4(%esi),%eax
  8041f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  8041fc:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  804200:	89 04 24             	mov    %eax,(%esp)
  804203:	e8 78 65 00 00       	call   80a780 <ntohs>
    buf.addr         = &remote_addr;
  804208:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80420b:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  80420e:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  804212:	eb 14                	jmp    804228 <lwip_sendto+0xeb>
  } else {
    remote_addr.addr = 0;
  804214:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  80421b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  804222:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  804228:	0f b7 c7             	movzwl %di,%eax
  80422b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80422f:	8b 45 0c             	mov    0xc(%ebp),%eax
  804232:	89 44 24 04          	mov    %eax,0x4(%esp)
  804236:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  804239:	89 04 24             	mov    %eax,(%esp)
  80423c:	e8 9c 0e 00 00       	call   8050dd <netbuf_ref>
  804241:	0f be f0             	movsbl %al,%esi
  804244:	85 f6                	test   %esi,%esi
  804246:	75 14                	jne    80425c <lwip_sendto+0x11f>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  804248:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80424b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80424f:	8b 03                	mov    (%ebx),%eax
  804251:	89 04 24             	mov    %eax,(%esp)
  804254:	e8 0a 9f 00 00       	call   80e163 <netconn_send>
  804259:	0f be f0             	movsbl %al,%esi
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  80425c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80425f:	85 c0                	test   %eax,%eax
  804261:	74 08                	je     80426b <lwip_sendto+0x12e>
    pbuf_free(buf.p);
  804263:	89 04 24             	mov    %eax,(%esp)
  804266:	e8 12 37 00 00       	call   80797d <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  80426b:	89 f2                	mov    %esi,%edx
  80426d:	f7 da                	neg    %edx
  80426f:	b8 05 00 00 00       	mov    $0x5,%eax
  804274:	83 fa 0e             	cmp    $0xe,%edx
  804277:	77 07                	ja     804280 <lwip_sendto+0x143>
  804279:	8b 04 95 60 2a 81 00 	mov    0x812a60(,%edx,4),%eax
  804280:	89 43 10             	mov    %eax,0x10(%ebx)
  804283:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  return (err==ERR_OK?size:-1);
  804288:	85 f6                	test   %esi,%esi
  80428a:	74 05                	je     804291 <lwip_sendto+0x154>
  80428c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  804291:	89 f8                	mov    %edi,%eax
  804293:	83 c4 3c             	add    $0x3c,%esp
  804296:	5b                   	pop    %ebx
  804297:	5e                   	pop    %esi
  804298:	5f                   	pop    %edi
  804299:	5d                   	pop    %ebp
  80429a:	c3                   	ret    

0080429b <lwip_recvfrom>:
}

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  80429b:	55                   	push   %ebp
  80429c:	89 e5                	mov    %esp,%ebp
  80429e:	57                   	push   %edi
  80429f:	56                   	push   %esi
  8042a0:	53                   	push   %ebx
  8042a1:	83 ec 5c             	sub    $0x5c,%esp
  8042a4:	8b 75 14             	mov    0x14(%ebp),%esi
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8042a7:	8b 45 08             	mov    0x8(%ebp),%eax
  8042aa:	e8 71 ed ff ff       	call   803020 <get_socket>
  8042af:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8042b1:	66 c7 45 c6 00 00    	movw   $0x0,-0x3a(%ebp)
  8042b7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8042bc:	85 db                	test   %ebx,%ebx
  8042be:	0f 84 0b 02 00 00    	je     8044cf <lwip_recvfrom+0x234>
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8042c4:	89 f0                	mov    %esi,%eax
  8042c6:	83 e0 08             	and    $0x8,%eax
  8042c9:	89 45 b0             	mov    %eax,-0x50(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8042cc:	83 e6 01             	and    $0x1,%esi
  8042cf:	89 75 b4             	mov    %esi,-0x4c(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  8042d2:	8b 73 04             	mov    0x4(%ebx),%esi
  8042d5:	85 f6                	test   %esi,%esi
  8042d7:	75 7d                	jne    804356 <lwip_recvfrom+0xbb>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8042d9:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  8042dd:	75 06                	jne    8042e5 <lwip_recvfrom+0x4a>
  8042df:	f6 43 0f 08          	testb  $0x8,0xf(%ebx)
  8042e3:	74 22                	je     804307 <lwip_recvfrom+0x6c>
  8042e5:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8042ea:	75 1b                	jne    804307 <lwip_recvfrom+0x6c>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  8042ec:	c7 43 10 0b 00 00 00 	movl   $0xb,0x10(%ebx)
  8042f3:	c7 05 20 c2 b3 00 0b 	movl   $0xb,0xb3c220
  8042fa:	00 00 00 
  8042fd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
        return -1;
  804302:	e9 c8 01 00 00       	jmp    8044cf <lwip_recvfrom+0x234>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  804307:	8b 03                	mov    (%ebx),%eax
  804309:	89 04 24             	mov    %eax,(%esp)
  80430c:	e8 38 a1 00 00       	call   80e449 <netconn_recv>
  804311:	89 c6                	mov    %eax,%esi
  804313:	89 43 04             	mov    %eax,0x4(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  804316:	85 c0                	test   %eax,%eax
  804318:	75 3c                	jne    804356 <lwip_recvfrom+0xbb>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  80431a:	8b 13                	mov    (%ebx),%edx
  80431c:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  804320:	74 0b                	je     80432d <lwip_recvfrom+0x92>
  804322:	b8 6e 00 00 00       	mov    $0x6e,%eax
  804327:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  80432b:	74 17                	je     804344 <lwip_recvfrom+0xa9>
  80432d:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  804331:	f7 da                	neg    %edx
  804333:	b8 05 00 00 00       	mov    $0x5,%eax
  804338:	83 fa 0e             	cmp    $0xe,%edx
  80433b:	77 07                	ja     804344 <lwip_recvfrom+0xa9>
  80433d:	8b 04 95 60 2a 81 00 	mov    0x812a60(,%edx,4),%eax
  804344:	89 43 10             	mov    %eax,0x10(%ebx)
  804347:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  80434c:	b8 00 00 00 00       	mov    $0x0,%eax
        return 0;
  804351:	e9 79 01 00 00       	jmp    8044cf <lwip_recvfrom+0x234>
      }
    }

    buflen = netbuf_len(buf);
  804356:	8b 06                	mov    (%esi),%eax
  804358:	0f b7 78 08          	movzwl 0x8(%eax),%edi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  80435c:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  804360:	66 29 d7             	sub    %dx,%di

    if (len > buflen) {
  804363:	0f b7 cf             	movzwl %di,%ecx
  804366:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  804369:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  80436c:	0f 4e 7d 10          	cmovle 0x10(%ebp),%edi
      copylen = len;
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  804370:	0f b7 cf             	movzwl %di,%ecx
  804373:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  804376:	0f b7 d2             	movzwl %dx,%edx
  804379:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80437d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  804381:	0f b7 55 c6          	movzwl -0x3a(%ebp),%edx
  804385:	03 55 0c             	add    0xc(%ebp),%edx
  804388:	89 54 24 04          	mov    %edx,0x4(%esp)
  80438c:	89 04 24             	mov    %eax,(%esp)
  80438f:	e8 72 33 00 00       	call   807706 <pbuf_copy_partial>

    off += copylen;
  804394:	66 01 7d c6          	add    %di,-0x3a(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  804398:	8b 03                	mov    (%ebx),%eax
  80439a:	89 04 24             	mov    %eax,(%esp)
  80439d:	e8 ce 9c 00 00       	call   80e070 <netconn_type>
  8043a2:	83 f8 10             	cmp    $0x10,%eax
  8043a5:	75 1f                	jne    8043c6 <lwip_recvfrom+0x12b>
      len -= copylen;
  8043a7:	8b 45 c0             	mov    -0x40(%ebp),%eax
  8043aa:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8043ad:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8043b1:	7e 13                	jle    8043c6 <lwip_recvfrom+0x12b>
  8043b3:	8b 06                	mov    (%esi),%eax
  8043b5:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8043b9:	75 0b                	jne    8043c6 <lwip_recvfrom+0x12b>
  8043bb:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
  8043bf:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8043c4:	75 04                	jne    8043ca <lwip_recvfrom+0x12f>
  8043c6:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8043ca:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8043ce:	75 39                	jne    804409 <lwip_recvfrom+0x16e>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8043d0:	8b 03                	mov    (%ebx),%eax
  8043d2:	83 38 10             	cmpl   $0x10,(%eax)
  8043d5:	75 13                	jne    8043ea <lwip_recvfrom+0x14f>
  8043d7:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8043da:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8043dd:	85 c0                	test   %eax,%eax
  8043df:	7e 09                	jle    8043ea <lwip_recvfrom+0x14f>
        sock->lastdata = buf;
  8043e1:	89 73 04             	mov    %esi,0x4(%ebx)
        sock->lastoffset += copylen;
  8043e4:	66 01 7b 08          	add    %di,0x8(%ebx)
    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8043e8:	eb 15                	jmp    8043ff <lwip_recvfrom+0x164>
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
      } else {
        sock->lastdata = NULL;
  8043ea:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
        sock->lastoffset = 0;
  8043f1:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  8043f7:	89 34 24             	mov    %esi,(%esp)
  8043fa:	e8 9f 0c 00 00       	call   80509e <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  8043ff:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
  804403:	0f 84 c9 fe ff ff    	je     8042d2 <lwip_recvfrom+0x37>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  804409:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  80440d:	0f 84 a7 00 00 00    	je     8044ba <lwip_recvfrom+0x21f>
  804413:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  804417:	0f 84 9d 00 00 00    	je     8044ba <lwip_recvfrom+0x21f>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80441d:	8b 03                	mov    (%ebx),%eax
  80441f:	89 04 24             	mov    %eax,(%esp)
  804422:	e8 49 9c 00 00       	call   80e070 <netconn_type>
  804427:	83 f8 10             	cmp    $0x10,%eax
  80442a:	75 22                	jne    80444e <lwip_recvfrom+0x1b3>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  80442c:	8d 7d d8             	lea    -0x28(%ebp),%edi
      netconn_getaddr(sock->conn, addr, &port, 0);
  80442f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804436:	00 
  804437:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  80443a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80443e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  804442:	8b 03                	mov    (%ebx),%eax
  804444:	89 04 24             	mov    %eax,(%esp)
  804447:	e8 d7 9e 00 00       	call   80e323 <netconn_getaddr>
  80444c:	eb 0b                	jmp    804459 <lwip_recvfrom+0x1be>
    } else {
      addr = netbuf_fromaddr(buf);
  80444e:	8b 7e 08             	mov    0x8(%esi),%edi
      port = netbuf_fromport(buf);
  804451:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  804455:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  804459:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  804460:	00 
  804461:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804468:	00 
  804469:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80446c:	89 04 24             	mov    %eax,(%esp)
  80446f:	e8 22 ce ff ff       	call   801296 <memset>
    sin.sin_len = sizeof(sin);
  804474:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  804478:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  80447c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804480:	89 04 24             	mov    %eax,(%esp)
  804483:	e8 eb 62 00 00       	call   80a773 <htons>
  804488:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  80448c:	8b 07                	mov    (%edi),%eax
  80448e:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  804491:	8b 55 1c             	mov    0x1c(%ebp),%edx
  804494:	83 3a 10             	cmpl   $0x10,(%edx)
  804497:	76 06                	jbe    80449f <lwip_recvfrom+0x204>
      *fromlen = sizeof(sin);
  804499:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

    SMEMCPY(from, &sin, *fromlen);
  80449f:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  8044a2:	8b 01                	mov    (%ecx),%eax
  8044a4:	89 44 24 08          	mov    %eax,0x8(%esp)
  8044a8:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8044ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  8044af:	8b 45 18             	mov    0x18(%ebp),%eax
  8044b2:	89 04 24             	mov    %eax,(%esp)
  8044b5:	e8 b7 ce ff ff       	call   801371 <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  8044ba:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8044c1:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8044c8:	00 00 00 
  return off;
  8044cb:	0f b7 45 c6          	movzwl -0x3a(%ebp),%eax
}
  8044cf:	83 c4 5c             	add    $0x5c,%esp
  8044d2:	5b                   	pop    %ebx
  8044d3:	5e                   	pop    %esi
  8044d4:	5f                   	pop    %edi
  8044d5:	5d                   	pop    %ebp
  8044d6:	c3                   	ret    

008044d7 <lwip_recv>:
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
}

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  8044d7:	55                   	push   %ebp
  8044d8:	89 e5                	mov    %esp,%ebp
  8044da:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8044dd:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8044e4:	00 
  8044e5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8044ec:	00 
  8044ed:	8b 45 14             	mov    0x14(%ebp),%eax
  8044f0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8044f4:	8b 45 10             	mov    0x10(%ebp),%eax
  8044f7:	89 44 24 08          	mov    %eax,0x8(%esp)
  8044fb:	8b 45 0c             	mov    0xc(%ebp),%eax
  8044fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  804502:	8b 45 08             	mov    0x8(%ebp),%eax
  804505:	89 04 24             	mov    %eax,(%esp)
  804508:	e8 8e fd ff ff       	call   80429b <lwip_recvfrom>
}
  80450d:	c9                   	leave  
  80450e:	c3                   	ret    

0080450f <lwip_read>:
  return off;
}

int
lwip_read(int s, void *mem, int len)
{
  80450f:	55                   	push   %ebp
  804510:	89 e5                	mov    %esp,%ebp
  804512:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  804515:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80451c:	00 
  80451d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  804524:	00 
  804525:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80452c:	00 
  80452d:	8b 45 10             	mov    0x10(%ebp),%eax
  804530:	89 44 24 08          	mov    %eax,0x8(%esp)
  804534:	8b 45 0c             	mov    0xc(%ebp),%eax
  804537:	89 44 24 04          	mov    %eax,0x4(%esp)
  80453b:	8b 45 08             	mov    0x8(%ebp),%eax
  80453e:	89 04 24             	mov    %eax,(%esp)
  804541:	e8 55 fd ff ff       	call   80429b <lwip_recvfrom>
}
  804546:	c9                   	leave  
  804547:	c3                   	ret    

00804548 <lwip_close>:
  return 0;
}

int
lwip_close(int s)
{
  804548:	55                   	push   %ebp
  804549:	89 e5                	mov    %esp,%ebp
  80454b:	53                   	push   %ebx
  80454c:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  80454f:	8b 45 08             	mov    0x8(%ebp),%eax
  804552:	e8 c9 ea ff ff       	call   803020 <get_socket>
  804557:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  804559:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80455e:	85 db                	test   %ebx,%ebx
  804560:	74 5c                	je     8045be <lwip_close+0x76>
    return -1;
  }

  netconn_delete(sock->conn);
  804562:	8b 03                	mov    (%ebx),%eax
  804564:	89 04 24             	mov    %eax,(%esp)
  804567:	e8 8f a0 00 00       	call   80e5fb <netconn_delete>

  sys_sem_wait(socksem);
  80456c:	a1 24 63 81 00       	mov    0x816324,%eax
  804571:	89 04 24             	mov    %eax,(%esp)
  804574:	e8 d1 3a 00 00       	call   80804a <sys_sem_wait>
  if (sock->lastdata) {
  804579:	8b 43 04             	mov    0x4(%ebx),%eax
  80457c:	85 c0                	test   %eax,%eax
  80457e:	74 08                	je     804588 <lwip_close+0x40>
    netbuf_delete(sock->lastdata);
  804580:	89 04 24             	mov    %eax,(%esp)
  804583:	e8 16 0b 00 00       	call   80509e <netbuf_delete>
  }
  sock->lastdata   = NULL;
  804588:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  80458f:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  804595:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  80459b:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8045a2:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8045a9:	00 00 00 
  sys_sem_signal(socksem);
  8045ac:	a1 24 63 81 00       	mov    0x816324,%eax
  8045b1:	89 04 24             	mov    %eax,(%esp)
  8045b4:	e8 ae 90 00 00       	call   80d667 <sys_sem_signal>
  8045b9:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  8045be:	83 c4 14             	add    $0x14,%esp
  8045c1:	5b                   	pop    %ebx
  8045c2:	5d                   	pop    %ebp
  8045c3:	c3                   	ret    

008045c4 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  8045c4:	55                   	push   %ebp
  8045c5:	89 e5                	mov    %esp,%ebp
  8045c7:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  8045ca:	8b 45 08             	mov    0x8(%ebp),%eax
  8045cd:	89 04 24             	mov    %eax,(%esp)
  8045d0:	e8 73 ff ff ff       	call   804548 <lwip_close>
}
  8045d5:	c9                   	leave  
  8045d6:	c3                   	ret    

008045d7 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  8045d7:	55                   	push   %ebp
  8045d8:	89 e5                	mov    %esp,%ebp
  8045da:	56                   	push   %esi
  8045db:	53                   	push   %ebx
  8045dc:	83 ec 10             	sub    $0x10,%esp
  8045df:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  8045e2:	8b 45 08             	mov    0x8(%ebp),%eax
  8045e5:	e8 36 ea ff ff       	call   803020 <get_socket>
  8045ea:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8045ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8045f1:	85 db                	test   %ebx,%ebx
  8045f3:	74 69                	je     80465e <lwip_listen+0x87>
  8045f5:	85 f6                	test   %esi,%esi
  8045f7:	b8 00 00 00 00       	mov    $0x0,%eax
  8045fc:	0f 48 f0             	cmovs  %eax,%esi
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  8045ff:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  804605:	b0 ff                	mov    $0xff,%al
  804607:	0f 4f f0             	cmovg  %eax,%esi
  80460a:	81 e6 ff 00 00 00    	and    $0xff,%esi
  804610:	89 74 24 04          	mov    %esi,0x4(%esp)
  804614:	8b 03                	mov    (%ebx),%eax
  804616:	89 04 24             	mov    %eax,(%esp)
  804619:	e8 c5 9b 00 00       	call   80e1e3 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  80461e:	84 c0                	test   %al,%al
  804620:	74 26                	je     804648 <lwip_listen+0x71>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804622:	0f be c0             	movsbl %al,%eax
  804625:	f7 d8                	neg    %eax
  804627:	ba 05 00 00 00       	mov    $0x5,%edx
  80462c:	83 f8 0e             	cmp    $0xe,%eax
  80462f:	77 07                	ja     804638 <lwip_listen+0x61>
  804631:	8b 14 85 60 2a 81 00 	mov    0x812a60(,%eax,4),%edx
  804638:	89 53 10             	mov    %edx,0x10(%ebx)
  80463b:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  804641:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804646:	eb 16                	jmp    80465e <lwip_listen+0x87>
  }

  sock_set_errno(sock, 0);
  804648:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80464f:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  804656:	00 00 00 
  804659:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  80465e:	83 c4 10             	add    $0x10,%esp
  804661:	5b                   	pop    %ebx
  804662:	5e                   	pop    %esi
  804663:	5d                   	pop    %ebp
  804664:	c3                   	ret    

00804665 <lwip_connect>:
  return 0;
}

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804665:	55                   	push   %ebp
  804666:	89 e5                	mov    %esp,%ebp
  804668:	53                   	push   %ebx
  804669:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  80466c:	8b 45 08             	mov    0x8(%ebp),%eax
  80466f:	e8 ac e9 ff ff       	call   803020 <get_socket>
  804674:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804676:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80467b:	85 db                	test   %ebx,%ebx
  80467d:	0f 84 95 00 00 00    	je     804718 <lwip_connect+0xb3>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  804683:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  804687:	75 09                	jne    804692 <lwip_connect+0x2d>
  804689:	8b 45 0c             	mov    0xc(%ebp),%eax
  80468c:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  804690:	74 1c                	je     8046ae <lwip_connect+0x49>
  804692:	c7 44 24 08 c3 29 81 	movl   $0x8129c3,0x8(%esp)
  804699:	00 
  80469a:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  8046a1:	00 
  8046a2:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  8046a9:	e8 66 c2 ff ff       	call   800914 <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8046ae:	8b 50 04             	mov    0x4(%eax),%edx
  8046b1:	89 55 f4             	mov    %edx,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8046b4:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  8046b8:	89 04 24             	mov    %eax,(%esp)
  8046bb:	e8 c0 60 00 00       	call   80a780 <ntohs>
  8046c0:	0f b7 c0             	movzwl %ax,%eax
  8046c3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8046c7:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8046ca:	89 44 24 04          	mov    %eax,0x4(%esp)
  8046ce:	8b 03                	mov    (%ebx),%eax
  8046d0:	89 04 24             	mov    %eax,(%esp)
  8046d3:	e8 9d 9b 00 00       	call   80e275 <netconn_connect>
  }

  if (err != ERR_OK) {
  8046d8:	84 c0                	test   %al,%al
  8046da:	74 26                	je     804702 <lwip_connect+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8046dc:	0f be c0             	movsbl %al,%eax
  8046df:	f7 d8                	neg    %eax
  8046e1:	ba 05 00 00 00       	mov    $0x5,%edx
  8046e6:	83 f8 0e             	cmp    $0xe,%eax
  8046e9:	77 07                	ja     8046f2 <lwip_connect+0x8d>
  8046eb:	8b 14 85 60 2a 81 00 	mov    0x812a60(,%eax,4),%edx
  8046f2:	89 53 10             	mov    %edx,0x10(%ebx)
  8046f5:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  8046fb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804700:	eb 16                	jmp    804718 <lwip_connect+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  804702:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804709:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  804710:	00 00 00 
  804713:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804718:	83 c4 24             	add    $0x24,%esp
  80471b:	5b                   	pop    %ebx
  80471c:	5d                   	pop    %ebp
  80471d:	c3                   	ret    

0080471e <lwip_bind>:
  return newsock;
}

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80471e:	55                   	push   %ebp
  80471f:	89 e5                	mov    %esp,%ebp
  804721:	53                   	push   %ebx
  804722:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  804725:	8b 45 08             	mov    0x8(%ebp),%eax
  804728:	e8 f3 e8 ff ff       	call   803020 <get_socket>
  80472d:	89 c3                	mov    %eax,%ebx
  if (!sock)
  80472f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804734:	85 db                	test   %ebx,%ebx
  804736:	0f 84 95 00 00 00    	je     8047d1 <lwip_bind+0xb3>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80473c:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  804740:	75 09                	jne    80474b <lwip_bind+0x2d>
  804742:	8b 45 0c             	mov    0xc(%ebp),%eax
  804745:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  804749:	74 1c                	je     804767 <lwip_bind+0x49>
  80474b:	c7 44 24 08 e1 29 81 	movl   $0x8129e1,0x8(%esp)
  804752:	00 
  804753:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  80475a:	00 
  80475b:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  804762:	e8 ad c1 ff ff       	call   800914 <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  804767:	8b 50 04             	mov    0x4(%eax),%edx
  80476a:	89 55 f4             	mov    %edx,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  80476d:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  804771:	89 04 24             	mov    %eax,(%esp)
  804774:	e8 07 60 00 00       	call   80a780 <ntohs>
  804779:	0f b7 c0             	movzwl %ax,%eax
  80477c:	89 44 24 08          	mov    %eax,0x8(%esp)
  804780:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804783:	89 44 24 04          	mov    %eax,0x4(%esp)
  804787:	8b 03                	mov    (%ebx),%eax
  804789:	89 04 24             	mov    %eax,(%esp)
  80478c:	e8 3b 9b 00 00       	call   80e2cc <netconn_bind>

  if (err != ERR_OK) {
  804791:	84 c0                	test   %al,%al
  804793:	74 26                	je     8047bb <lwip_bind+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804795:	0f be c0             	movsbl %al,%eax
  804798:	f7 d8                	neg    %eax
  80479a:	ba 05 00 00 00       	mov    $0x5,%edx
  80479f:	83 f8 0e             	cmp    $0xe,%eax
  8047a2:	77 07                	ja     8047ab <lwip_bind+0x8d>
  8047a4:	8b 14 85 60 2a 81 00 	mov    0x812a60(,%eax,4),%edx
  8047ab:	89 53 10             	mov    %edx,0x10(%ebx)
  8047ae:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  8047b4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  8047b9:	eb 16                	jmp    8047d1 <lwip_bind+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8047bb:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8047c2:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8047c9:	00 00 00 
  8047cc:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  8047d1:	83 c4 24             	add    $0x24,%esp
  8047d4:	5b                   	pop    %ebx
  8047d5:	5d                   	pop    %ebp
  8047d6:	c3                   	ret    

008047d7 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8047d7:	55                   	push   %ebp
  8047d8:	89 e5                	mov    %esp,%ebp
  8047da:	57                   	push   %edi
  8047db:	56                   	push   %esi
  8047dc:	53                   	push   %ebx
  8047dd:	83 ec 4c             	sub    $0x4c,%esp
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  8047e0:	8b 45 08             	mov    0x8(%ebp),%eax
  8047e3:	e8 38 e8 ff ff       	call   803020 <get_socket>
  8047e8:	89 c7                	mov    %eax,%edi
  if (!sock)
  8047ea:	be ff ff ff ff       	mov    $0xffffffff,%esi
  8047ef:	85 c0                	test   %eax,%eax
  8047f1:	0f 84 ae 01 00 00    	je     8049a5 <lwip_accept+0x1ce>
    return -1;

  newconn = netconn_accept(sock->conn);
  8047f7:	8b 00                	mov    (%eax),%eax
  8047f9:	89 04 24             	mov    %eax,(%esp)
  8047fc:	e8 be 9b 00 00       	call   80e3bf <netconn_accept>
  804801:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  804803:	85 c0                	test   %eax,%eax
  804805:	75 2b                	jne    804832 <lwip_accept+0x5b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  804807:	8b 07                	mov    (%edi),%eax
  804809:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  80480d:	f7 da                	neg    %edx
  80480f:	b8 05 00 00 00       	mov    $0x5,%eax
  804814:	83 fa 0e             	cmp    $0xe,%edx
  804817:	77 07                	ja     804820 <lwip_accept+0x49>
  804819:	8b 04 95 60 2a 81 00 	mov    0x812a60(,%edx,4),%eax
  804820:	89 47 10             	mov    %eax,0x10(%edi)
  804823:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  804828:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  80482d:	e9 73 01 00 00       	jmp    8049a5 <lwip_accept+0x1ce>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  804832:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804839:	00 
  80483a:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  80483d:	89 44 24 08          	mov    %eax,0x8(%esp)
  804841:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  804844:	89 44 24 04          	mov    %eax,0x4(%esp)
  804848:	89 1c 24             	mov    %ebx,(%esp)
  80484b:	e8 d3 9a 00 00       	call   80e323 <netconn_getaddr>
  804850:	89 c6                	mov    %eax,%esi
  if (err != ERR_OK) {
  804852:	84 c0                	test   %al,%al
  804854:	74 32                	je     804888 <lwip_accept+0xb1>
    netconn_delete(newconn);
  804856:	89 1c 24             	mov    %ebx,(%esp)
  804859:	e8 9d 9d 00 00       	call   80e5fb <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  80485e:	89 f0                	mov    %esi,%eax
  804860:	0f be f0             	movsbl %al,%esi
  804863:	f7 de                	neg    %esi
  804865:	b8 05 00 00 00       	mov    $0x5,%eax
  80486a:	83 fe 0e             	cmp    $0xe,%esi
  80486d:	77 07                	ja     804876 <lwip_accept+0x9f>
  80486f:	8b 04 b5 60 2a 81 00 	mov    0x812a60(,%esi,4),%eax
  804876:	89 47 10             	mov    %eax,0x10(%edi)
  804879:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  80487e:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  804883:	e9 1d 01 00 00       	jmp    8049a5 <lwip_accept+0x1ce>
  }

  memset(&sin, 0, sizeof(sin));
  804888:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  80488f:	00 
  804890:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804897:	00 
  804898:	8d 45 d0             	lea    -0x30(%ebp),%eax
  80489b:	89 04 24             	mov    %eax,(%esp)
  80489e:	e8 f3 c9 ff ff       	call   801296 <memset>
  sin.sin_len = sizeof(sin);
  8048a3:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  8048a7:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  8048ab:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8048af:	89 04 24             	mov    %eax,(%esp)
  8048b2:	e8 bc 5e 00 00       	call   80a773 <htons>
  8048b7:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8048bb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8048be:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  8048c1:	8b 55 10             	mov    0x10(%ebp),%edx
  8048c4:	83 3a 10             	cmpl   $0x10,(%edx)
  8048c7:	76 06                	jbe    8048cf <lwip_accept+0xf8>
    *addrlen = sizeof(sin);
  8048c9:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

  SMEMCPY(addr, &sin, *addrlen);
  8048cf:	8b 55 10             	mov    0x10(%ebp),%edx
  8048d2:	8b 02                	mov    (%edx),%eax
  8048d4:	89 44 24 08          	mov    %eax,0x8(%esp)
  8048d8:	8d 45 d0             	lea    -0x30(%ebp),%eax
  8048db:	89 44 24 04          	mov    %eax,0x4(%esp)
  8048df:	8b 45 0c             	mov    0xc(%ebp),%eax
  8048e2:	89 04 24             	mov    %eax,(%esp)
  8048e5:	e8 87 ca ff ff       	call   801371 <memcpy>

  newsock = alloc_socket(newconn);
  8048ea:	89 d8                	mov    %ebx,%eax
  8048ec:	e8 8c f0 ff ff       	call   80397d <alloc_socket>
  8048f1:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  8048f3:	83 f8 ff             	cmp    $0xffffffff,%eax
  8048f6:	75 1e                	jne    804916 <lwip_accept+0x13f>
    netconn_delete(newconn);
  8048f8:	89 1c 24             	mov    %ebx,(%esp)
  8048fb:	e8 fb 9c 00 00       	call   80e5fb <netconn_delete>
    sock_set_errno(sock, ENFILE);
  804900:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  804907:	c7 05 20 c2 b3 00 17 	movl   $0x17,0xb3c220
  80490e:	00 00 00 
    return -1;
  804911:	e9 8f 00 00 00       	jmp    8049a5 <lwip_accept+0x1ce>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  804916:	83 fe 1f             	cmp    $0x1f,%esi
  804919:	76 1c                	jbe    804937 <lwip_accept+0x160>
  80491b:	c7 44 24 08 fc 29 81 	movl   $0x8129fc,0x8(%esp)
  804922:	00 
  804923:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  80492a:	00 
  80492b:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  804932:	e8 dd bf ff ff       	call   800914 <_panic>
  newconn->callback = event_callback;
  804937:	c7 43 2c 26 3a 80 00 	movl   $0x803a26,0x2c(%ebx)
  nsock = &sockets[newsock];
  80493e:	8d 04 80             	lea    (%eax,%eax,4),%eax
  804941:	8d 04 85 a0 60 81 00 	lea    0x8160a0(,%eax,4),%eax
  804948:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  80494b:	85 c0                	test   %eax,%eax
  80494d:	75 1c                	jne    80496b <lwip_accept+0x194>
  80494f:	c7 44 24 08 11 2a 81 	movl   $0x812a11,0x8(%esp)
  804956:	00 
  804957:	c7 44 24 04 28 01 00 	movl   $0x128,0x4(%esp)
  80495e:	00 
  80495f:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  804966:	e8 a9 bf ff ff       	call   800914 <_panic>

  sys_sem_wait(socksem);
  80496b:	a1 24 63 81 00       	mov    0x816324,%eax
  804970:	89 04 24             	mov    %eax,(%esp)
  804973:	e8 d2 36 00 00       	call   80804a <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  804978:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80497b:	f7 d0                	not    %eax
  80497d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  804980:	66 01 42 0a          	add    %ax,0xa(%edx)
  newconn->socket = newsock;
  804984:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  804987:	a1 24 63 81 00       	mov    0x816324,%eax
  80498c:	89 04 24             	mov    %eax,(%esp)
  80498f:	e8 d3 8c 00 00       	call   80d667 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  804994:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  80499b:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8049a2:	00 00 00 
  return newsock;
}
  8049a5:	89 f0                	mov    %esi,%eax
  8049a7:	83 c4 4c             	add    $0x4c,%esp
  8049aa:	5b                   	pop    %ebx
  8049ab:	5e                   	pop    %esi
  8049ac:	5f                   	pop    %edi
  8049ad:	5d                   	pop    %ebp
  8049ae:	c3                   	ret    
	...

008049b0 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8049b0:	55                   	push   %ebp
  8049b1:	89 e5                	mov    %esp,%ebp
  8049b3:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  8049b6:	8b 45 08             	mov    0x8(%ebp),%eax
  8049b9:	89 04 24             	mov    %eax,(%esp)
  8049bc:	e8 bc 2f 00 00       	call   80797d <pbuf_free>
}
  8049c1:	c9                   	leave  
  8049c2:	c3                   	ret    

008049c3 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  8049c3:	55                   	push   %ebp
  8049c4:	89 e5                	mov    %esp,%ebp
  8049c6:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  8049c9:	e8 62 08 00 00       	call   805230 <lwip_init>

  tcpip_init_done = initfunc;
  8049ce:	8b 45 08             	mov    0x8(%ebp),%eax
  8049d1:	a3 2c 63 81 00       	mov    %eax,0x81632c
  tcpip_init_done_arg = arg;
  8049d6:	8b 45 0c             	mov    0xc(%ebp),%eax
  8049d9:	a3 30 63 81 00       	mov    %eax,0x816330
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  8049de:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8049e5:	e8 65 8b 00 00       	call   80d54f <sys_mbox_new>
  8049ea:	a3 3c 50 81 00       	mov    %eax,0x81503c
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8049ef:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  8049f6:	00 
  8049f7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8049fe:	00 
  8049ff:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804a06:	00 
  804a07:	c7 44 24 04 66 4a 80 	movl   $0x804a66,0x4(%esp)
  804a0e:	00 
  804a0f:	c7 04 24 9c 2a 81 00 	movl   $0x812a9c,(%esp)
  804a16:	e8 9f 88 00 00       	call   80d2ba <sys_thread_new>
}
  804a1b:	c9                   	leave  
  804a1c:	c3                   	ret    

00804a1d <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  804a1d:	55                   	push   %ebp
  804a1e:	89 e5                	mov    %esp,%ebp
  804a20:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  804a23:	83 3d 34 63 81 00 00 	cmpl   $0x0,0x816334
  804a2a:	75 38                	jne    804a64 <tcp_timer_needed+0x47>
  804a2c:	83 3d 0c f0 b3 00 00 	cmpl   $0x0,0xb3f00c
  804a33:	75 09                	jne    804a3e <tcp_timer_needed+0x21>
  804a35:	83 3d 20 f0 b3 00 00 	cmpl   $0x0,0xb3f020
  804a3c:	74 26                	je     804a64 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  804a3e:	c7 05 34 63 81 00 01 	movl   $0x1,0x816334
  804a45:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  804a48:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804a4f:	00 
  804a50:	c7 44 24 04 81 4e 80 	movl   $0x804e81,0x4(%esp)
  804a57:	00 
  804a58:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  804a5f:	e8 16 35 00 00       	call   807f7a <sys_timeout>
  }
}
  804a64:	c9                   	leave  
  804a65:	c3                   	ret    

00804a66 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  804a66:	55                   	push   %ebp
  804a67:	89 e5                	mov    %esp,%ebp
  804a69:	53                   	push   %ebx
  804a6a:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  804a6d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804a74:	00 
  804a75:	c7 44 24 04 5e 4c 80 	movl   $0x804c5e,0x4(%esp)
  804a7c:	00 
  804a7d:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  804a84:	e8 f1 34 00 00       	call   807f7a <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  804a89:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804a90:	00 
  804a91:	c7 44 24 04 35 4c 80 	movl   $0x804c35,0x4(%esp)
  804a98:	00 
  804a99:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  804aa0:	e8 d5 34 00 00       	call   807f7a <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  804aa5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804aac:	00 
  804aad:	c7 44 24 04 0c 4c 80 	movl   $0x804c0c,0x4(%esp)
  804ab4:	00 
  804ab5:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  804abc:	e8 b9 34 00 00       	call   807f7a <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  804ac1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804ac8:	00 
  804ac9:	c7 44 24 04 e3 4b 80 	movl   $0x804be3,0x4(%esp)
  804ad0:	00 
  804ad1:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  804ad8:	e8 9d 34 00 00       	call   807f7a <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  804add:	a1 2c 63 81 00       	mov    0x81632c,%eax
  804ae2:	85 c0                	test   %eax,%eax
  804ae4:	74 0b                	je     804af1 <tcpip_thread+0x8b>
    tcpip_init_done(tcpip_init_done_arg);
  804ae6:	8b 15 30 63 81 00    	mov    0x816330,%edx
  804aec:	89 14 24             	mov    %edx,(%esp)
  804aef:	ff d0                	call   *%eax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  804af1:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  804af4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804af8:	a1 3c 50 81 00       	mov    0x81503c,%eax
  804afd:	89 04 24             	mov    %eax,(%esp)
  804b00:	e8 67 36 00 00       	call   80816c <sys_mbox_fetch>
    switch (msg->type) {
  804b05:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804b08:	8b 10                	mov    (%eax),%edx
  804b0a:	83 fa 01             	cmp    $0x1,%edx
  804b0d:	74 28                	je     804b37 <tcpip_thread+0xd1>
  804b0f:	83 fa 01             	cmp    $0x1,%edx
  804b12:	72 16                	jb     804b2a <tcpip_thread+0xc4>
  804b14:	83 fa 02             	cmp    $0x2,%edx
  804b17:	74 5f                	je     804b78 <tcpip_thread+0x112>
  804b19:	83 fa 03             	cmp    $0x3,%edx
  804b1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  804b20:	75 d2                	jne    804af4 <tcpip_thread+0x8e>
  804b22:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  804b28:	eb 6f                	jmp    804b99 <tcpip_thread+0x133>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  804b2a:	8b 40 08             	mov    0x8(%eax),%eax
  804b2d:	8d 50 04             	lea    0x4(%eax),%edx
  804b30:	89 14 24             	mov    %edx,(%esp)
  804b33:	ff 10                	call   *(%eax)
      break;
  804b35:	eb bd                	jmp    804af4 <tcpip_thread+0x8e>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  804b37:	8b 50 0c             	mov    0xc(%eax),%edx
  804b3a:	f6 42 2e 20          	testb  $0x20,0x2e(%edx)
  804b3e:	74 11                	je     804b51 <tcpip_thread+0xeb>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  804b40:	89 54 24 04          	mov    %edx,0x4(%esp)
  804b44:	8b 40 08             	mov    0x8(%eax),%eax
  804b47:	89 04 24             	mov    %eax,(%esp)
  804b4a:	e8 78 83 00 00       	call   80cec7 <ethernet_input>
  804b4f:	eb 0f                	jmp    804b60 <tcpip_thread+0xfa>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  804b51:	89 54 24 04          	mov    %edx,0x4(%esp)
  804b55:	8b 40 08             	mov    0x8(%eax),%eax
  804b58:	89 04 24             	mov    %eax,(%esp)
  804b5b:	e8 d4 4a 00 00       	call   809634 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  804b60:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804b63:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b67:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  804b6e:	e8 81 26 00 00       	call   8071f4 <memp_free>
      break;
  804b73:	e9 7c ff ff ff       	jmp    804af4 <tcpip_thread+0x8e>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  804b78:	8b 50 0c             	mov    0xc(%eax),%edx
  804b7b:	89 14 24             	mov    %edx,(%esp)
  804b7e:	ff 50 08             	call   *0x8(%eax)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  804b81:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804b84:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b88:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804b8f:	e8 60 26 00 00       	call   8071f4 <memp_free>
      break;
  804b94:	e9 5b ff ff ff       	jmp    804af4 <tcpip_thread+0x8e>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  804b99:	8b 50 08             	mov    0x8(%eax),%edx
  804b9c:	83 fa ff             	cmp    $0xffffffff,%edx
  804b9f:	74 18                	je     804bb9 <tcpip_thread+0x153>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  804ba1:	8b 48 10             	mov    0x10(%eax),%ecx
  804ba4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  804ba8:	8b 40 0c             	mov    0xc(%eax),%eax
  804bab:	89 44 24 04          	mov    %eax,0x4(%esp)
  804baf:	89 14 24             	mov    %edx,(%esp)
  804bb2:	e8 c3 33 00 00       	call   807f7a <sys_timeout>
  804bb7:	eb 12                	jmp    804bcb <tcpip_thread+0x165>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  804bb9:	8b 50 10             	mov    0x10(%eax),%edx
  804bbc:	89 54 24 04          	mov    %edx,0x4(%esp)
  804bc0:	8b 40 0c             	mov    0xc(%eax),%eax
  804bc3:	89 04 24             	mov    %eax,(%esp)
  804bc6:	e8 22 33 00 00       	call   807eed <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  804bcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804bce:	89 44 24 04          	mov    %eax,0x4(%esp)
  804bd2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804bd9:	e8 16 26 00 00       	call   8071f4 <memp_free>
  804bde:	e9 11 ff ff ff       	jmp    804af4 <tcpip_thread+0x8e>

00804be3 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  804be3:	55                   	push   %ebp
  804be4:	89 e5                	mov    %esp,%ebp
  804be6:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  804be9:	e8 f4 1e 00 00       	call   806ae2 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  804bee:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804bf5:	00 
  804bf6:	c7 44 24 04 e3 4b 80 	movl   $0x804be3,0x4(%esp)
  804bfd:	00 
  804bfe:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  804c05:	e8 70 33 00 00       	call   807f7a <sys_timeout>
}
  804c0a:	c9                   	leave  
  804c0b:	c3                   	ret    

00804c0c <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  804c0c:	55                   	push   %ebp
  804c0d:	89 e5                	mov    %esp,%ebp
  804c0f:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  804c12:	e8 92 12 00 00       	call   805ea9 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  804c17:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804c1e:	00 
  804c1f:	c7 44 24 04 0c 4c 80 	movl   $0x804c0c,0x4(%esp)
  804c26:	00 
  804c27:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  804c2e:	e8 47 33 00 00       	call   807f7a <sys_timeout>
}
  804c33:	c9                   	leave  
  804c34:	c3                   	ret    

00804c35 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  804c35:	55                   	push   %ebp
  804c36:	89 e5                	mov    %esp,%ebp
  804c38:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  804c3b:	e8 59 7e 00 00       	call   80ca99 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  804c40:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804c47:	00 
  804c48:	c7 44 24 04 35 4c 80 	movl   $0x804c35,0x4(%esp)
  804c4f:	00 
  804c50:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  804c57:	e8 1e 33 00 00       	call   807f7a <sys_timeout>
}
  804c5c:	c9                   	leave  
  804c5d:	c3                   	ret    

00804c5e <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  804c5e:	55                   	push   %ebp
  804c5f:	89 e5                	mov    %esp,%ebp
  804c61:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  804c64:	e8 a8 50 00 00       	call   809d11 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  804c69:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804c70:	00 
  804c71:	c7 44 24 04 5e 4c 80 	movl   $0x804c5e,0x4(%esp)
  804c78:	00 
  804c79:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  804c80:	e8 f5 32 00 00       	call   807f7a <sys_timeout>
}
  804c85:	c9                   	leave  
  804c86:	c3                   	ret    

00804c87 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  804c87:	55                   	push   %ebp
  804c88:	89 e5                	mov    %esp,%ebp
  804c8a:	53                   	push   %ebx
  804c8b:	83 ec 34             	sub    $0x34,%esp
  804c8e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  804c91:	8b 15 3c 50 81 00    	mov    0x81503c,%edx
  804c97:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804c9c:	83 fa ff             	cmp    $0xffffffff,%edx
  804c9f:	74 34                	je     804cd5 <tcpip_apimsg+0x4e>
    msg.type = TCPIP_MSG_API;
  804ca1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  804ca8:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  804cab:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  804cae:	89 44 24 04          	mov    %eax,0x4(%esp)
  804cb2:	89 14 24             	mov    %edx,(%esp)
  804cb5:	e8 2b 8c 00 00       	call   80d8e5 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  804cba:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804cc1:	00 
  804cc2:	8b 43 04             	mov    0x4(%ebx),%eax
  804cc5:	8b 40 10             	mov    0x10(%eax),%eax
  804cc8:	89 04 24             	mov    %eax,(%esp)
  804ccb:	e8 a6 86 00 00       	call   80d376 <sys_arch_sem_wait>
  804cd0:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  804cd5:	83 c4 34             	add    $0x34,%esp
  804cd8:	5b                   	pop    %ebx
  804cd9:	5d                   	pop    %ebp
  804cda:	c3                   	ret    

00804cdb <tcpip_timeout>:
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  804cdb:	55                   	push   %ebp
  804cdc:	89 e5                	mov    %esp,%ebp
  804cde:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  804ce1:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804ce6:	83 3d 3c 50 81 00 ff 	cmpl   $0xffffffff,0x81503c
  804ced:	74 45                	je     804d34 <tcpip_timeout+0x59>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  804cef:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804cf6:	e8 3d 25 00 00       	call   807238 <memp_malloc>
  804cfb:	89 c2                	mov    %eax,%edx
    if (msg == NULL) {
  804cfd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804d02:	85 d2                	test   %edx,%edx
  804d04:	74 2e                	je     804d34 <tcpip_timeout+0x59>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  804d06:	c7 02 03 00 00 00    	movl   $0x3,(%edx)
    msg->msg.tmo.msecs = msecs;
  804d0c:	8b 45 08             	mov    0x8(%ebp),%eax
  804d0f:	89 42 08             	mov    %eax,0x8(%edx)
    msg->msg.tmo.h = h;
  804d12:	8b 45 0c             	mov    0xc(%ebp),%eax
  804d15:	89 42 0c             	mov    %eax,0xc(%edx)
    msg->msg.tmo.arg = arg;
  804d18:	8b 45 10             	mov    0x10(%ebp),%eax
  804d1b:	89 42 10             	mov    %eax,0x10(%edx)
    sys_mbox_post(mbox, msg);
  804d1e:	89 54 24 04          	mov    %edx,0x4(%esp)
  804d22:	a1 3c 50 81 00       	mov    0x81503c,%eax
  804d27:	89 04 24             	mov    %eax,(%esp)
  804d2a:	e8 b6 8b 00 00       	call   80d8e5 <sys_mbox_post>
  804d2f:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  804d34:	c9                   	leave  
  804d35:	c3                   	ret    

00804d36 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  804d36:	55                   	push   %ebp
  804d37:	89 e5                	mov    %esp,%ebp
  804d39:	83 ec 18             	sub    $0x18,%esp
  804d3c:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  804d3f:	89 75 fc             	mov    %esi,-0x4(%ebp)
  804d42:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  804d46:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804d4b:	83 3d 3c 50 81 00 ff 	cmpl   $0xffffffff,0x81503c
  804d52:	74 6f                	je     804dc3 <tcpip_callback_with_block+0x8d>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  804d54:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804d5b:	e8 d8 24 00 00       	call   807238 <memp_malloc>
  804d60:	89 c6                	mov    %eax,%esi
    if (msg == NULL) {
  804d62:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804d67:	85 f6                	test   %esi,%esi
  804d69:	74 58                	je     804dc3 <tcpip_callback_with_block+0x8d>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  804d6b:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
    msg->msg.cb.f = f;
  804d71:	8b 45 08             	mov    0x8(%ebp),%eax
  804d74:	89 46 08             	mov    %eax,0x8(%esi)
    msg->msg.cb.ctx = ctx;
  804d77:	8b 45 0c             	mov    0xc(%ebp),%eax
  804d7a:	89 46 0c             	mov    %eax,0xc(%esi)
    if (block) {
  804d7d:	84 db                	test   %bl,%bl
  804d7f:	74 18                	je     804d99 <tcpip_callback_with_block+0x63>
      sys_mbox_post(mbox, msg);
  804d81:	89 74 24 04          	mov    %esi,0x4(%esp)
  804d85:	a1 3c 50 81 00       	mov    0x81503c,%eax
  804d8a:	89 04 24             	mov    %eax,(%esp)
  804d8d:	e8 53 8b 00 00       	call   80d8e5 <sys_mbox_post>
  804d92:	b8 00 00 00 00       	mov    $0x0,%eax
  804d97:	eb 2a                	jmp    804dc3 <tcpip_callback_with_block+0x8d>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  804d99:	89 74 24 04          	mov    %esi,0x4(%esp)
  804d9d:	a1 3c 50 81 00       	mov    0x81503c,%eax
  804da2:	89 04 24             	mov    %eax,(%esp)
  804da5:	e8 6d 8a 00 00       	call   80d817 <sys_mbox_trypost>
  804daa:	84 c0                	test   %al,%al
  804dac:	74 15                	je     804dc3 <tcpip_callback_with_block+0x8d>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  804dae:	89 74 24 04          	mov    %esi,0x4(%esp)
  804db2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804db9:	e8 36 24 00 00       	call   8071f4 <memp_free>
  804dbe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  804dc3:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  804dc6:	8b 75 fc             	mov    -0x4(%ebp),%esi
  804dc9:	89 ec                	mov    %ebp,%esp
  804dcb:	5d                   	pop    %ebp
  804dcc:	c3                   	ret    

00804dcd <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  804dcd:	55                   	push   %ebp
  804dce:	89 e5                	mov    %esp,%ebp
  804dd0:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  804dd3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804dda:	00 
  804ddb:	8b 45 08             	mov    0x8(%ebp),%eax
  804dde:	89 44 24 04          	mov    %eax,0x4(%esp)
  804de2:	c7 04 24 75 6f 80 00 	movl   $0x806f75,(%esp)
  804de9:	e8 48 ff ff ff       	call   804d36 <tcpip_callback_with_block>
}
  804dee:	c9                   	leave  
  804def:	c3                   	ret    

00804df0 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  804df0:	55                   	push   %ebp
  804df1:	89 e5                	mov    %esp,%ebp
  804df3:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  804df6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804dfd:	00 
  804dfe:	8b 45 08             	mov    0x8(%ebp),%eax
  804e01:	89 44 24 04          	mov    %eax,0x4(%esp)
  804e05:	c7 04 24 b0 49 80 00 	movl   $0x8049b0,(%esp)
  804e0c:	e8 25 ff ff ff       	call   804d36 <tcpip_callback_with_block>
}
  804e11:	c9                   	leave  
  804e12:	c3                   	ret    

00804e13 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  804e13:	55                   	push   %ebp
  804e14:	89 e5                	mov    %esp,%ebp
  804e16:	53                   	push   %ebx
  804e17:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  804e1a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804e1f:	83 3d 3c 50 81 00 ff 	cmpl   $0xffffffff,0x81503c
  804e26:	74 53                	je     804e7b <tcpip_input+0x68>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  804e28:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  804e2f:	e8 04 24 00 00       	call   807238 <memp_malloc>
  804e34:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  804e36:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804e3b:	85 db                	test   %ebx,%ebx
  804e3d:	74 3c                	je     804e7b <tcpip_input+0x68>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  804e3f:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
    msg->msg.inp.p = p;
  804e45:	8b 45 08             	mov    0x8(%ebp),%eax
  804e48:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  804e4b:	8b 45 0c             	mov    0xc(%ebp),%eax
  804e4e:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  804e51:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804e55:	a1 3c 50 81 00       	mov    0x81503c,%eax
  804e5a:	89 04 24             	mov    %eax,(%esp)
  804e5d:	e8 b5 89 00 00       	call   80d817 <sys_mbox_trypost>
  804e62:	84 c0                	test   %al,%al
  804e64:	74 15                	je     804e7b <tcpip_input+0x68>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  804e66:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804e6a:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  804e71:	e8 7e 23 00 00       	call   8071f4 <memp_free>
  804e76:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  804e7b:	83 c4 14             	add    $0x14,%esp
  804e7e:	5b                   	pop    %ebx
  804e7f:	5d                   	pop    %ebp
  804e80:	c3                   	ret    

00804e81 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  804e81:	55                   	push   %ebp
  804e82:	89 e5                	mov    %esp,%ebp
  804e84:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  804e87:	e8 2a 43 00 00       	call   8091b6 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  804e8c:	83 3d 0c f0 b3 00 00 	cmpl   $0x0,0xb3f00c
  804e93:	75 09                	jne    804e9e <tcpip_tcp_timer+0x1d>
  804e95:	83 3d 20 f0 b3 00 00 	cmpl   $0x0,0xb3f020
  804e9c:	74 1e                	je     804ebc <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  804e9e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804ea5:	00 
  804ea6:	c7 44 24 04 81 4e 80 	movl   $0x804e81,0x4(%esp)
  804ead:	00 
  804eae:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  804eb5:	e8 c0 30 00 00       	call   807f7a <sys_timeout>
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  804eba:	eb 0a                	jmp    804ec6 <tcpip_tcp_timer+0x45>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  804ebc:	c7 05 34 63 81 00 00 	movl   $0x0,0x816334
  804ec3:	00 00 00 
  }
}
  804ec6:	c9                   	leave  
  804ec7:	c3                   	ret    

00804ec8 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  804ec8:	55                   	push   %ebp
  804ec9:	89 e5                	mov    %esp,%ebp
  804ecb:	83 ec 18             	sub    $0x18,%esp
  804ece:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  804ed1:	85 c0                	test   %eax,%eax
  804ed3:	75 1c                	jne    804ef1 <netbuf_first+0x29>
  804ed5:	c7 44 24 08 a9 2a 81 	movl   $0x812aa9,0x8(%esp)
  804edc:	00 
  804edd:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  804ee4:	00 
  804ee5:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  804eec:	e8 23 ba ff ff       	call   800914 <_panic>
  buf->ptr = buf->p;
  804ef1:	8b 10                	mov    (%eax),%edx
  804ef3:	89 50 04             	mov    %edx,0x4(%eax)
}
  804ef6:	c9                   	leave  
  804ef7:	c3                   	ret    

00804ef8 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  804ef8:	55                   	push   %ebp
  804ef9:	89 e5                	mov    %esp,%ebp
  804efb:	83 ec 18             	sub    $0x18,%esp
  804efe:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  804f01:	85 d2                	test   %edx,%edx
  804f03:	75 1c                	jne    804f21 <netbuf_next+0x29>
  804f05:	c7 44 24 08 a9 2a 81 	movl   $0x812aa9,0x8(%esp)
  804f0c:	00 
  804f0d:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  804f14:	00 
  804f15:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  804f1c:	e8 f3 b9 ff ff       	call   800914 <_panic>
  if (buf->ptr->next == NULL) {
  804f21:	8b 42 04             	mov    0x4(%edx),%eax
  804f24:	8b 08                	mov    (%eax),%ecx
  804f26:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804f2b:	85 c9                	test   %ecx,%ecx
  804f2d:	74 09                	je     804f38 <netbuf_next+0x40>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  804f2f:	89 4a 04             	mov    %ecx,0x4(%edx)
  804f32:	83 39 00             	cmpl   $0x0,(%ecx)
  804f35:	0f 94 c0             	sete   %al
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  804f38:	c9                   	leave  
  804f39:	c3                   	ret    

00804f3a <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  804f3a:	55                   	push   %ebp
  804f3b:	89 e5                	mov    %esp,%ebp
  804f3d:	56                   	push   %esi
  804f3e:	53                   	push   %ebx
  804f3f:	83 ec 10             	sub    $0x10,%esp
  804f42:	8b 55 08             	mov    0x8(%ebp),%edx
  804f45:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  804f48:	8b 4d 10             	mov    0x10(%ebp),%ecx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  804f4b:	85 d2                	test   %edx,%edx
  804f4d:	75 1c                	jne    804f6b <netbuf_data+0x31>
  804f4f:	c7 44 24 08 d8 2a 81 	movl   $0x812ad8,0x8(%esp)
  804f56:	00 
  804f57:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  804f5e:	00 
  804f5f:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  804f66:	e8 a9 b9 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  804f6b:	85 db                	test   %ebx,%ebx
  804f6d:	75 1c                	jne    804f8b <netbuf_data+0x51>
  804f6f:	c7 44 24 08 f1 2a 81 	movl   $0x812af1,0x8(%esp)
  804f76:	00 
  804f77:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  804f7e:	00 
  804f7f:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  804f86:	e8 89 b9 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  804f8b:	85 c9                	test   %ecx,%ecx
  804f8d:	75 1c                	jne    804fab <netbuf_data+0x71>
  804f8f:	c7 44 24 08 0e 2b 81 	movl   $0x812b0e,0x8(%esp)
  804f96:	00 
  804f97:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  804f9e:	00 
  804f9f:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  804fa6:	e8 69 b9 ff ff       	call   800914 <_panic>

  if (buf->ptr == NULL) {
  804fab:	8b 72 04             	mov    0x4(%edx),%esi
  804fae:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  804fb3:	85 f6                	test   %esi,%esi
  804fb5:	74 14                	je     804fcb <netbuf_data+0x91>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  804fb7:	8b 46 04             	mov    0x4(%esi),%eax
  804fba:	89 03                	mov    %eax,(%ebx)
  *len = buf->ptr->len;
  804fbc:	8b 42 04             	mov    0x4(%edx),%eax
  804fbf:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  804fc3:	66 89 01             	mov    %ax,(%ecx)
  804fc6:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  804fcb:	83 c4 10             	add    $0x10,%esp
  804fce:	5b                   	pop    %ebx
  804fcf:	5e                   	pop    %esi
  804fd0:	5d                   	pop    %ebp
  804fd1:	c3                   	ret    

00804fd2 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  804fd2:	55                   	push   %ebp
  804fd3:	89 e5                	mov    %esp,%ebp
  804fd5:	83 ec 18             	sub    $0x18,%esp
  804fd8:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  804fdb:	89 75 fc             	mov    %esi,-0x4(%ebp)
  804fde:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804fe1:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  804fe4:	85 db                	test   %ebx,%ebx
  804fe6:	75 1c                	jne    805004 <netbuf_chain+0x32>
  804fe8:	c7 44 24 08 27 2b 81 	movl   $0x812b27,0x8(%esp)
  804fef:	00 
  804ff0:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  804ff7:	00 
  804ff8:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  804fff:	e8 10 b9 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  805004:	85 f6                	test   %esi,%esi
  805006:	75 1c                	jne    805024 <netbuf_chain+0x52>
  805008:	c7 44 24 08 40 2b 81 	movl   $0x812b40,0x8(%esp)
  80500f:	00 
  805010:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  805017:	00 
  805018:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  80501f:	e8 f0 b8 ff ff       	call   800914 <_panic>
  pbuf_chain(head->p, tail->p);
  805024:	8b 06                	mov    (%esi),%eax
  805026:	89 44 24 04          	mov    %eax,0x4(%esp)
  80502a:	8b 03                	mov    (%ebx),%eax
  80502c:	89 04 24             	mov    %eax,(%esp)
  80502f:	e8 b8 25 00 00       	call   8075ec <pbuf_chain>
  head->ptr = head->p;
  805034:	8b 03                	mov    (%ebx),%eax
  805036:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  805039:	89 74 24 04          	mov    %esi,0x4(%esp)
  80503d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  805044:	e8 ab 21 00 00       	call   8071f4 <memp_free>
}
  805049:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80504c:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80504f:	89 ec                	mov    %ebp,%esp
  805051:	5d                   	pop    %ebp
  805052:	c3                   	ret    

00805053 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  805053:	55                   	push   %ebp
  805054:	89 e5                	mov    %esp,%ebp
  805056:	53                   	push   %ebx
  805057:	83 ec 14             	sub    $0x14,%esp
  80505a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80505d:	85 db                	test   %ebx,%ebx
  80505f:	75 1c                	jne    80507d <netbuf_free+0x2a>
  805061:	c7 44 24 08 a9 2a 81 	movl   $0x812aa9,0x8(%esp)
  805068:	00 
  805069:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  805070:	00 
  805071:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  805078:	e8 97 b8 ff ff       	call   800914 <_panic>
  if (buf->p != NULL) {
  80507d:	8b 03                	mov    (%ebx),%eax
  80507f:	85 c0                	test   %eax,%eax
  805081:	74 08                	je     80508b <netbuf_free+0x38>
    pbuf_free(buf->p);
  805083:	89 04 24             	mov    %eax,(%esp)
  805086:	e8 f2 28 00 00       	call   80797d <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  80508b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  805092:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  805098:	83 c4 14             	add    $0x14,%esp
  80509b:	5b                   	pop    %ebx
  80509c:	5d                   	pop    %ebp
  80509d:	c3                   	ret    

0080509e <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  80509e:	55                   	push   %ebp
  80509f:	89 e5                	mov    %esp,%ebp
  8050a1:	53                   	push   %ebx
  8050a2:	83 ec 14             	sub    $0x14,%esp
  8050a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  8050a8:	85 db                	test   %ebx,%ebx
  8050aa:	74 2b                	je     8050d7 <netbuf_delete+0x39>
    if (buf->p != NULL) {
  8050ac:	8b 03                	mov    (%ebx),%eax
  8050ae:	85 c0                	test   %eax,%eax
  8050b0:	74 15                	je     8050c7 <netbuf_delete+0x29>
      pbuf_free(buf->p);
  8050b2:	89 04 24             	mov    %eax,(%esp)
  8050b5:	e8 c3 28 00 00       	call   80797d <pbuf_free>
      buf->p = buf->ptr = NULL;
  8050ba:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8050c1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  8050c7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8050cb:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8050d2:	e8 1d 21 00 00       	call   8071f4 <memp_free>
  }
}
  8050d7:	83 c4 14             	add    $0x14,%esp
  8050da:	5b                   	pop    %ebx
  8050db:	5d                   	pop    %ebp
  8050dc:	c3                   	ret    

008050dd <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8050dd:	55                   	push   %ebp
  8050de:	89 e5                	mov    %esp,%ebp
  8050e0:	56                   	push   %esi
  8050e1:	53                   	push   %ebx
  8050e2:	83 ec 10             	sub    $0x10,%esp
  8050e5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8050e8:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8050ec:	85 db                	test   %ebx,%ebx
  8050ee:	75 1c                	jne    80510c <netbuf_ref+0x2f>
  8050f0:	c7 44 24 08 5b 2b 81 	movl   $0x812b5b,0x8(%esp)
  8050f7:	00 
  8050f8:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  8050ff:	00 
  805100:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  805107:	e8 08 b8 ff ff       	call   800914 <_panic>
  if (buf->p != NULL) {
  80510c:	8b 03                	mov    (%ebx),%eax
  80510e:	85 c0                	test   %eax,%eax
  805110:	74 08                	je     80511a <netbuf_ref+0x3d>
    pbuf_free(buf->p);
  805112:	89 04 24             	mov    %eax,(%esp)
  805115:	e8 63 28 00 00       	call   80797d <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80511a:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  805121:	00 
  805122:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805129:	00 
  80512a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805131:	e8 03 2b 00 00       	call   807c39 <pbuf_alloc>
  805136:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  805138:	85 c0                	test   %eax,%eax
  80513a:	75 0e                	jne    80514a <netbuf_ref+0x6d>
    buf->ptr = NULL;
  80513c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  805143:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  805148:	eb 1a                	jmp    805164 <netbuf_ref+0x87>
  }
  buf->p->payload = (void*)dataptr;
  80514a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80514d:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  805150:	8b 03                	mov    (%ebx),%eax
  805152:	66 89 70 08          	mov    %si,0x8(%eax)
  805156:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  80515a:	8b 03                	mov    (%ebx),%eax
  80515c:	89 43 04             	mov    %eax,0x4(%ebx)
  80515f:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  805164:	83 c4 10             	add    $0x10,%esp
  805167:	5b                   	pop    %ebx
  805168:	5e                   	pop    %esi
  805169:	5d                   	pop    %ebp
  80516a:	c3                   	ret    

0080516b <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  80516b:	55                   	push   %ebp
  80516c:	89 e5                	mov    %esp,%ebp
  80516e:	56                   	push   %esi
  80516f:	53                   	push   %ebx
  805170:	83 ec 10             	sub    $0x10,%esp
  805173:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805176:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80517a:	85 db                	test   %ebx,%ebx
  80517c:	75 1c                	jne    80519a <netbuf_alloc+0x2f>
  80517e:	c7 44 24 08 73 2b 81 	movl   $0x812b73,0x8(%esp)
  805185:	00 
  805186:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  80518d:	00 
  80518e:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  805195:	e8 7a b7 ff ff       	call   800914 <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  80519a:	8b 03                	mov    (%ebx),%eax
  80519c:	85 c0                	test   %eax,%eax
  80519e:	74 08                	je     8051a8 <netbuf_alloc+0x3d>
    pbuf_free(buf->p);
  8051a0:	89 04 24             	mov    %eax,(%esp)
  8051a3:	e8 d5 27 00 00       	call   80797d <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8051a8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8051af:	00 
  8051b0:	0f b7 c6             	movzwl %si,%eax
  8051b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8051b7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8051be:	e8 76 2a 00 00       	call   807c39 <pbuf_alloc>
  8051c3:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8051c5:	ba 00 00 00 00       	mov    $0x0,%edx
  8051ca:	85 c0                	test   %eax,%eax
  8051cc:	74 28                	je     8051f6 <netbuf_alloc+0x8b>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8051ce:	66 3b 70 0a          	cmp    0xa(%eax),%si
  8051d2:	76 1c                	jbe    8051f0 <netbuf_alloc+0x85>
  8051d4:	c7 44 24 08 90 2b 81 	movl   $0x812b90,0x8(%esp)
  8051db:	00 
  8051dc:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  8051e3:	00 
  8051e4:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  8051eb:	e8 24 b7 ff ff       	call   800914 <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8051f0:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  8051f3:	8b 50 04             	mov    0x4(%eax),%edx
}
  8051f6:	89 d0                	mov    %edx,%eax
  8051f8:	83 c4 10             	add    $0x10,%esp
  8051fb:	5b                   	pop    %ebx
  8051fc:	5e                   	pop    %esi
  8051fd:	5d                   	pop    %ebp
  8051fe:	c3                   	ret    

008051ff <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8051ff:	55                   	push   %ebp
  805200:	89 e5                	mov    %esp,%ebp
  805202:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  805205:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80520c:	e8 27 20 00 00       	call   807238 <memp_malloc>
  if (buf != NULL) {
  805211:	85 c0                	test   %eax,%eax
  805213:	74 14                	je     805229 <netbuf_new+0x2a>
    buf->p = NULL;
  805215:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  80521b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  805222:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  805229:	c9                   	leave  
  80522a:	c3                   	ret    
  80522b:	00 00                	add    %al,(%eax)
  80522d:	00 00                	add    %al,(%eax)
	...

00805230 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  805230:	55                   	push   %ebp
  805231:	89 e5                	mov    %esp,%ebp
  805233:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  805236:	e8 35 7d 00 00       	call   80cf70 <sys_init>
  mem_init();
  80523b:	e8 d3 1e 00 00       	call   807113 <mem_init>
  memp_init();
  805240:	e8 2b 1f 00 00       	call   807170 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  805245:	e8 6e e9 ff ff       	call   803bb8 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  80524a:	c9                   	leave  
  80524b:	c3                   	ret    
  80524c:	00 00                	add    %al,(%eax)
	...

00805250 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  805250:	55                   	push   %ebp
  805251:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  805253:	38 10                	cmp    %dl,(%eax)
  805255:	74 06                	je     80525d <dhcp_set_state+0xd>
    dhcp->state = new_state;
  805257:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  805259:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  80525d:	5d                   	pop    %ebp
  80525e:	c3                   	ret    

0080525f <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80525f:	55                   	push   %ebp
  805260:	89 e5                	mov    %esp,%ebp
  805262:	57                   	push   %edi
  805263:	56                   	push   %esi
  805264:	53                   	push   %ebx
  805265:	83 ec 08             	sub    $0x8,%esp
  805268:	88 55 f3             	mov    %dl,-0xd(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80526b:	8b 70 14             	mov    0x14(%eax),%esi
  80526e:	85 f6                	test   %esi,%esi
  805270:	0f 84 e6 00 00 00    	je     80535c <dhcp_get_option_ptr+0xfd>
  805276:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  80527a:	66 85 ff             	test   %di,%di
  80527d:	0f 84 d9 00 00 00    	je     80535c <dhcp_get_option_ptr+0xfd>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  805283:	0f b6 0e             	movzbl (%esi),%ecx
  805286:	80 f9 ff             	cmp    $0xff,%cl
  805289:	0f 84 cd 00 00 00    	je     80535c <dhcp_get_option_ptr+0xfd>
  80528f:	89 f3                	mov    %esi,%ebx
  805291:	c6 45 f2 00          	movb   $0x0,-0xe(%ebp)
  805295:	ba 00 00 00 00       	mov    $0x0,%edx
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80529a:	80 f9 34             	cmp    $0x34,%cl
  80529d:	75 12                	jne    8052b1 <dhcp_get_option_ptr+0x52>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80529f:	8d 4a 02             	lea    0x2(%edx),%ecx
        overload = options[offset++];
  8052a2:	0f b7 c9             	movzwl %cx,%ecx
  8052a5:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  8052a9:	88 4d f2             	mov    %cl,-0xe(%ebp)
  8052ac:	83 c2 03             	add    $0x3,%edx
  8052af:	eb 17                	jmp    8052c8 <dhcp_get_option_ptr+0x69>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  8052b1:	3a 4d f3             	cmp    -0xd(%ebp),%cl
  8052b4:	0f 84 a7 00 00 00    	je     805361 <dhcp_get_option_ptr+0x102>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  8052ba:	8d 4a 01             	lea    0x1(%edx),%ecx
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  8052bd:	0f b7 c9             	movzwl %cx,%ecx
  8052c0:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  8052c4:	8d 54 0a 02          	lea    0x2(%edx,%ecx,1),%edx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8052c8:	66 39 d7             	cmp    %dx,%di
  8052cb:	76 0e                	jbe    8052db <dhcp_get_option_ptr+0x7c>
  8052cd:	0f b7 da             	movzwl %dx,%ebx
  8052d0:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  8052d3:	0f b6 0b             	movzbl (%ebx),%ecx
  8052d6:	80 f9 ff             	cmp    $0xff,%cl
  8052d9:	75 bf                	jne    80529a <dhcp_get_option_ptr+0x3b>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  8052db:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
  8052df:	74 7b                	je     80535c <dhcp_get_option_ptr+0xfd>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  8052e1:	80 7d f2 01          	cmpb   $0x1,-0xe(%ebp)
  8052e5:	75 0d                	jne    8052f4 <dhcp_get_option_ptr+0x95>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  8052e7:	8b 58 10             	mov    0x10(%eax),%ebx
  8052ea:	83 c3 6c             	add    $0x6c,%ebx
  8052ed:	b9 80 00 00 00       	mov    $0x80,%ecx
  8052f2:	eb 1e                	jmp    805312 <dhcp_get_option_ptr+0xb3>
        field_len = DHCP_FILE_LEN;
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8052f4:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  8052f8:	75 0d                	jne    805307 <dhcp_get_option_ptr+0xa8>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  8052fa:	8b 58 10             	mov    0x10(%eax),%ebx
  8052fd:	83 c3 2c             	add    $0x2c,%ebx
  805300:	b9 40 00 00 00       	mov    $0x40,%ecx
  805305:	eb 0b                	jmp    805312 <dhcp_get_option_ptr+0xb3>
        field_len = DHCP_SNAME_LEN;
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  805307:	8b 58 10             	mov    0x10(%eax),%ebx
  80530a:	83 c3 2c             	add    $0x2c,%ebx
  80530d:	b9 c0 00 00 00       	mov    $0xc0,%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  805312:	0f b6 13             	movzbl (%ebx),%edx
  805315:	80 fa ff             	cmp    $0xff,%dl
  805318:	74 42                	je     80535c <dhcp_get_option_ptr+0xfd>
        if (options[offset] == option_type) {
  80531a:	b8 00 00 00 00       	mov    $0x0,%eax
  80531f:	38 55 f3             	cmp    %dl,-0xd(%ebp)
  805322:	75 0e                	jne    805332 <dhcp_get_option_ptr+0xd3>
  805324:	eb 3b                	jmp    805361 <dhcp_get_option_ptr+0x102>
  805326:	89 f9                	mov    %edi,%ecx
  805328:	38 d1                	cmp    %dl,%cl
  80532a:	75 0e                	jne    80533a <dhcp_get_option_ptr+0xdb>
  80532c:	89 f3                	mov    %esi,%ebx
  80532e:	66 90                	xchg   %ax,%ax
  805330:	eb 2f                	jmp    805361 <dhcp_get_option_ptr+0x102>
  805332:	66 89 4d ee          	mov    %cx,-0x12(%ebp)
  805336:	0f b6 7d f3          	movzbl -0xd(%ebp),%edi
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80533a:	8d 50 01             	lea    0x1(%eax),%edx
          offset += 1 + options[offset];
  80533d:	0f b7 d2             	movzwl %dx,%edx
  805340:	0f b6 14 13          	movzbl (%ebx,%edx,1),%edx
  805344:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  805348:	66 39 45 ee          	cmp    %ax,-0x12(%ebp)
  80534c:	76 0e                	jbe    80535c <dhcp_get_option_ptr+0xfd>
  80534e:	0f b7 f0             	movzwl %ax,%esi
  805351:	8d 34 33             	lea    (%ebx,%esi,1),%esi
  805354:	0f b6 16             	movzbl (%esi),%edx
  805357:	80 fa ff             	cmp    $0xff,%dl
  80535a:	75 ca                	jne    805326 <dhcp_get_option_ptr+0xc7>
  80535c:	bb 00 00 00 00       	mov    $0x0,%ebx
        }
      }
    }
  }
  return NULL;
}
  805361:	89 d8                	mov    %ebx,%eax
  805363:	83 c4 08             	add    $0x8,%esp
  805366:	5b                   	pop    %ebx
  805367:	5e                   	pop    %esi
  805368:	5f                   	pop    %edi
  805369:	5d                   	pop    %ebp
  80536a:	c3                   	ret    

0080536b <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80536b:	55                   	push   %ebp
  80536c:	89 e5                	mov    %esp,%ebp
  80536e:	0f b6 00             	movzbl (%eax),%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
}
  805371:	5d                   	pop    %ebp
  805372:	c3                   	ret    

00805373 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  805373:	55                   	push   %ebp
  805374:	89 e5                	mov    %esp,%ebp
  805376:	53                   	push   %ebx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  805377:	0f b6 10             	movzbl (%eax),%edx
  80537a:	c1 e2 18             	shl    $0x18,%edx
  value |= (u32_t)(*ptr++) << 16;
  80537d:	0f b6 58 01          	movzbl 0x1(%eax),%ebx
  805381:	c1 e3 10             	shl    $0x10,%ebx
  805384:	09 d3                	or     %edx,%ebx
  805386:	8d 50 02             	lea    0x2(%eax),%edx
  value |= (u32_t)(*ptr++) << 8;
  805389:	0f b6 0a             	movzbl (%edx),%ecx
  80538c:	c1 e1 08             	shl    $0x8,%ecx
  80538f:	89 d8                	mov    %ebx,%eax
  805391:	09 c8                	or     %ecx,%eax
  805393:	0f b6 52 01          	movzbl 0x1(%edx),%edx
  805397:	09 d0                	or     %edx,%eax
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  805399:	5b                   	pop    %ebx
  80539a:	5d                   	pop    %ebp
  80539b:	c3                   	ret    

0080539c <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80539c:	55                   	push   %ebp
  80539d:	89 e5                	mov    %esp,%ebp
  80539f:	83 ec 28             	sub    $0x28,%esp
  8053a2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8053a5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8053a8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  8053ab:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  8053af:	0f b7 fb             	movzwl %bx,%edi
  8053b2:	0f b6 f1             	movzbl %cl,%esi
  8053b5:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  8053b9:	83 fe 44             	cmp    $0x44,%esi
  8053bc:	76 1c                	jbe    8053da <dhcp_option+0x3e>
  8053be:	c7 44 24 08 b4 2b 81 	movl   $0x812bb4,0x8(%esp)
  8053c5:	00 
  8053c6:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  8053cd:	00 
  8053ce:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8053d5:	e8 3a b5 ff ff       	call   800914 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8053da:	8b 78 20             	mov    0x20(%eax),%edi
  8053dd:	0f b7 f3             	movzwl %bx,%esi
  8053e0:	88 94 37 f0 00 00 00 	mov    %dl,0xf0(%edi,%esi,1)
  8053e7:	8d 53 01             	lea    0x1(%ebx),%edx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8053ea:	8b 70 20             	mov    0x20(%eax),%esi
  8053ed:	0f b7 d2             	movzwl %dx,%edx
  8053f0:	88 8c 16 f0 00 00 00 	mov    %cl,0xf0(%esi,%edx,1)
  8053f7:	83 c3 02             	add    $0x2,%ebx
  8053fa:	66 89 58 24          	mov    %bx,0x24(%eax)
}
  8053fe:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805401:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805404:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805407:	89 ec                	mov    %ebp,%esp
  805409:	5d                   	pop    %ebp
  80540a:	c3                   	ret    

0080540b <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80540b:	55                   	push   %ebp
  80540c:	89 e5                	mov    %esp,%ebp
  80540e:	83 ec 18             	sub    $0x18,%esp
  805411:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  805414:	89 75 fc             	mov    %esi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  805417:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80541b:	66 83 f9 43          	cmp    $0x43,%cx
  80541f:	76 1c                	jbe    80543d <dhcp_option_byte+0x32>
  805421:	c7 44 24 08 fc 2b 81 	movl   $0x812bfc,0x8(%esp)
  805428:	00 
  805429:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  805430:	00 
  805431:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  805438:	e8 d7 b4 ff ff       	call   800914 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80543d:	8b 70 20             	mov    0x20(%eax),%esi
  805440:	0f b7 d9             	movzwl %cx,%ebx
  805443:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  80544a:	83 c1 01             	add    $0x1,%ecx
  80544d:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805451:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  805454:	8b 75 fc             	mov    -0x4(%ebp),%esi
  805457:	89 ec                	mov    %ebp,%esp
  805459:	5d                   	pop    %ebp
  80545a:	c3                   	ret    

0080545b <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  80545b:	55                   	push   %ebp
  80545c:	89 e5                	mov    %esp,%ebp
  80545e:	53                   	push   %ebx
  80545f:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  805462:	85 c0                	test   %eax,%eax
  805464:	75 1c                	jne    805482 <dhcp_option_trailer+0x27>
  805466:	c7 44 24 08 38 2c 81 	movl   $0x812c38,0x8(%esp)
  80546d:	00 
  80546e:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  805475:	00 
  805476:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80547d:	e8 92 b4 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  805482:	8b 48 20             	mov    0x20(%eax),%ecx
  805485:	85 c9                	test   %ecx,%ecx
  805487:	75 1c                	jne    8054a5 <dhcp_option_trailer+0x4a>
  805489:	c7 44 24 08 5c 2c 81 	movl   $0x812c5c,0x8(%esp)
  805490:	00 
  805491:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  805498:	00 
  805499:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8054a0:	e8 6f b4 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8054a5:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8054a9:	66 83 fa 43          	cmp    $0x43,%dx
  8054ad:	76 1c                	jbe    8054cb <dhcp_option_trailer+0x70>
  8054af:	c7 44 24 08 88 2c 81 	movl   $0x812c88,0x8(%esp)
  8054b6:	00 
  8054b7:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  8054be:	00 
  8054bf:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8054c6:	e8 49 b4 ff ff       	call   800914 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  8054cb:	0f b7 da             	movzwl %dx,%ebx
  8054ce:	c6 84 19 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%ebx,1)
  8054d5:	ff 
  8054d6:	83 c2 01             	add    $0x1,%edx
  8054d9:	66 89 50 24          	mov    %dx,0x24(%eax)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  8054dd:	eb 31                	jmp    805510 <dhcp_option_trailer+0xb5>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8054df:	c7 44 24 08 88 2c 81 	movl   $0x812c88,0x8(%esp)
  8054e6:	00 
  8054e7:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  8054ee:	00 
  8054ef:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8054f6:	e8 19 b4 ff ff       	call   800914 <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  8054fb:	8b 58 20             	mov    0x20(%eax),%ebx
  8054fe:	0f b7 ca             	movzwl %dx,%ecx
  805501:	c6 84 0b f0 00 00 00 	movb   $0x0,0xf0(%ebx,%ecx,1)
  805508:	00 
  805509:	83 c2 01             	add    $0x1,%edx
  80550c:	66 89 50 24          	mov    %dx,0x24(%eax)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  805510:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  805514:	66 83 fa 43          	cmp    $0x43,%dx
  805518:	76 e1                	jbe    8054fb <dhcp_option_trailer+0xa0>
  80551a:	f6 c2 03             	test   $0x3,%dl
  80551d:	75 c0                	jne    8054df <dhcp_option_trailer+0x84>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  80551f:	83 c4 14             	add    $0x14,%esp
  805522:	5b                   	pop    %ebx
  805523:	5d                   	pop    %ebp
  805524:	c3                   	ret    

00805525 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  805525:	55                   	push   %ebp
  805526:	89 e5                	mov    %esp,%ebp
  805528:	83 ec 48             	sub    $0x48,%esp
  80552b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80552e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805531:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  805534:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  805538:	0f b7 d9             	movzwl %cx,%ebx
  80553b:	83 c3 02             	add    $0x2,%ebx
  80553e:	83 fb 44             	cmp    $0x44,%ebx
  805541:	76 1c                	jbe    80555f <dhcp_option_short+0x3a>
  805543:	c7 44 24 08 c8 2c 81 	movl   $0x812cc8,0x8(%esp)
  80554a:	00 
  80554b:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  805552:	00 
  805553:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80555a:	e8 b5 b3 ff ff       	call   800914 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80555f:	0f b7 d9             	movzwl %cx,%ebx
  805562:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805565:	89 d6                	mov    %edx,%esi
  805567:	66 c1 ee 08          	shr    $0x8,%si
  80556b:	66 89 75 d6          	mov    %si,-0x2a(%ebp)
  80556f:	0f b6 5d d6          	movzbl -0x2a(%ebp),%ebx
  805573:	8b 78 20             	mov    0x20(%eax),%edi
  805576:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805579:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805580:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  805583:	8b 70 20             	mov    0x20(%eax),%esi
  805586:	0f b7 db             	movzwl %bx,%ebx
  805589:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  805590:	83 c1 02             	add    $0x2,%ecx
  805593:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805597:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80559a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80559d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8055a0:	89 ec                	mov    %ebp,%esp
  8055a2:	5d                   	pop    %ebp
  8055a3:	c3                   	ret    

008055a4 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  8055a4:	55                   	push   %ebp
  8055a5:	89 e5                	mov    %esp,%ebp
  8055a7:	83 ec 48             	sub    $0x48,%esp
  8055aa:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8055ad:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8055b0:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  8055b3:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8055b7:	0f b7 d9             	movzwl %cx,%ebx
  8055ba:	83 c3 04             	add    $0x4,%ebx
  8055bd:	83 fb 44             	cmp    $0x44,%ebx
  8055c0:	76 1c                	jbe    8055de <dhcp_option_long+0x3a>
  8055c2:	c7 44 24 08 0c 2d 81 	movl   $0x812d0c,0x8(%esp)
  8055c9:	00 
  8055ca:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  8055d1:	00 
  8055d2:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8055d9:	e8 36 b3 ff ff       	call   800914 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  8055de:	0f b7 d9             	movzwl %cx,%ebx
  8055e1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  8055e4:	89 d6                	mov    %edx,%esi
  8055e6:	c1 ee 18             	shr    $0x18,%esi
  8055e9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  8055ec:	0f b6 5d d4          	movzbl -0x2c(%ebp),%ebx
  8055f0:	8b 78 20             	mov    0x20(%eax),%edi
  8055f3:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8055f6:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  8055fd:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  805600:	0f b7 db             	movzwl %bx,%ebx
  805603:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805606:	89 d3                	mov    %edx,%ebx
  805608:	c1 eb 10             	shr    $0x10,%ebx
  80560b:	8b 78 20             	mov    0x20(%eax),%edi
  80560e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805611:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805618:	8d 59 02             	lea    0x2(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  80561b:	0f b7 db             	movzwl %bx,%ebx
  80561e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805621:	0f b6 de             	movzbl %dh,%ebx
  805624:	8b 78 20             	mov    0x20(%eax),%edi
  805627:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80562a:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805631:	8d 59 03             	lea    0x3(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  805634:	8b 70 20             	mov    0x20(%eax),%esi
  805637:	0f b7 db             	movzwl %bx,%ebx
  80563a:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  805641:	83 c1 04             	add    $0x4,%ecx
  805644:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805648:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80564b:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80564e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805651:	89 ec                	mov    %ebp,%esp
  805653:	5d                   	pop    %ebp
  805654:	c3                   	ret    

00805655 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  805655:	55                   	push   %ebp
  805656:	89 e5                	mov    %esp,%ebp
  805658:	53                   	push   %ebx
  805659:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80565c:	85 c0                	test   %eax,%eax
  80565e:	75 1c                	jne    80567c <dhcp_delete_request+0x27>
  805660:	c7 44 24 08 4c 2d 81 	movl   $0x812d4c,0x8(%esp)
  805667:	00 
  805668:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  80566f:	00 
  805670:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  805677:	e8 98 b2 ff ff       	call   800914 <_panic>
  dhcp = netif->dhcp;
  80567c:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  80567f:	85 db                	test   %ebx,%ebx
  805681:	75 1c                	jne    80569f <dhcp_delete_request+0x4a>
  805683:	c7 44 24 08 70 2d 81 	movl   $0x812d70,0x8(%esp)
  80568a:	00 
  80568b:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  805692:	00 
  805693:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80569a:	e8 75 b2 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  80569f:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8056a2:	85 c0                	test   %eax,%eax
  8056a4:	75 1c                	jne    8056c2 <dhcp_delete_request+0x6d>
  8056a6:	c7 44 24 08 94 2d 81 	movl   $0x812d94,0x8(%esp)
  8056ad:	00 
  8056ae:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  8056b5:	00 
  8056b6:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8056bd:	e8 52 b2 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  8056c2:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  8056c6:	75 1c                	jne    8056e4 <dhcp_delete_request+0x8f>
  8056c8:	c7 44 24 08 c0 2d 81 	movl   $0x812dc0,0x8(%esp)
  8056cf:	00 
  8056d0:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  8056d7:	00 
  8056d8:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8056df:	e8 30 b2 ff ff       	call   800914 <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  8056e4:	89 04 24             	mov    %eax,(%esp)
  8056e7:	e8 91 22 00 00       	call   80797d <pbuf_free>
  }
  dhcp->p_out = NULL;
  8056ec:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  8056f3:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  8056fa:	83 c4 14             	add    $0x14,%esp
  8056fd:	5b                   	pop    %ebx
  8056fe:	5d                   	pop    %ebp
  8056ff:	c3                   	ret    

00805700 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  805700:	55                   	push   %ebp
  805701:	89 e5                	mov    %esp,%ebp
  805703:	53                   	push   %ebx
  805704:	83 ec 14             	sub    $0x14,%esp
  805707:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  805709:	8b 40 10             	mov    0x10(%eax),%eax
  80570c:	85 c0                	test   %eax,%eax
  80570e:	74 0f                	je     80571f <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  805710:	89 04 24             	mov    %eax,(%esp)
  805713:	e8 5d 18 00 00       	call   806f75 <mem_free>
    dhcp->msg_in = NULL;
  805718:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  80571f:	8b 43 14             	mov    0x14(%ebx),%eax
  805722:	85 c0                	test   %eax,%eax
  805724:	74 15                	je     80573b <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  805726:	89 04 24             	mov    %eax,(%esp)
  805729:	e8 47 18 00 00       	call   806f75 <mem_free>
    dhcp->options_in = NULL;
  80572e:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  805735:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80573b:	83 c4 14             	add    $0x14,%esp
  80573e:	5b                   	pop    %ebx
  80573f:	5d                   	pop    %ebp
  805740:	c3                   	ret    

00805741 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  805741:	55                   	push   %ebp
  805742:	89 e5                	mov    %esp,%ebp
  805744:	56                   	push   %esi
  805745:	53                   	push   %ebx
  805746:	83 ec 10             	sub    $0x10,%esp
  805749:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  80574c:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  80574f:	85 f6                	test   %esi,%esi
  805751:	75 1c                	jne    80576f <dhcp_stop+0x2e>
  805753:	c7 44 24 08 17 2f 81 	movl   $0x812f17,0x8(%esp)
  80575a:	00 
  80575b:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  805762:	00 
  805763:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80576a:	e8 a5 b1 ff ff       	call   800914 <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80576f:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  805773:	85 db                	test   %ebx,%ebx
  805775:	74 42                	je     8057b9 <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  805777:	8b 43 08             	mov    0x8(%ebx),%eax
  80577a:	85 c0                	test   %eax,%eax
  80577c:	74 0f                	je     80578d <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  80577e:	89 04 24             	mov    %eax,(%esp)
  805781:	e8 e6 63 00 00       	call   80bb6c <udp_remove>
      dhcp->pcb = NULL;
  805786:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  80578d:	8b 43 0c             	mov    0xc(%ebx),%eax
  805790:	85 c0                	test   %eax,%eax
  805792:	74 0f                	je     8057a3 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  805794:	89 04 24             	mov    %eax,(%esp)
  805797:	e8 e1 21 00 00       	call   80797d <pbuf_free>
      dhcp->p = NULL;
  80579c:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  8057a3:	89 d8                	mov    %ebx,%eax
  8057a5:	e8 56 ff ff ff       	call   805700 <dhcp_free_reply>
    mem_free((void *)dhcp);
  8057aa:	89 1c 24             	mov    %ebx,(%esp)
  8057ad:	e8 c3 17 00 00       	call   806f75 <mem_free>
    netif->dhcp = NULL;
  8057b2:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  8057b9:	83 c4 10             	add    $0x10,%esp
  8057bc:	5b                   	pop    %ebx
  8057bd:	5e                   	pop    %esi
  8057be:	5d                   	pop    %ebp
  8057bf:	c3                   	ret    

008057c0 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  8057c0:	55                   	push   %ebp
  8057c1:	89 e5                	mov    %esp,%ebp
  8057c3:	57                   	push   %edi
  8057c4:	56                   	push   %esi
  8057c5:	53                   	push   %ebx
  8057c6:	83 ec 2c             	sub    $0x2c,%esp
  8057c9:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  8057cb:	85 c0                	test   %eax,%eax
  8057cd:	75 1c                	jne    8057eb <dhcp_create_request+0x2b>
  8057cf:	c7 44 24 08 ec 2d 81 	movl   $0x812dec,0x8(%esp)
  8057d6:	00 
  8057d7:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  8057de:	00 
  8057df:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8057e6:	e8 29 b1 ff ff       	call   800914 <_panic>
  dhcp = netif->dhcp;
  8057eb:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  8057ee:	85 db                	test   %ebx,%ebx
  8057f0:	75 1c                	jne    80580e <dhcp_create_request+0x4e>
  8057f2:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  8057f9:	00 
  8057fa:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  805801:	00 
  805802:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  805809:	e8 06 b1 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80580e:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  805812:	74 1c                	je     805830 <dhcp_create_request+0x70>
  805814:	c7 44 24 08 34 2e 81 	movl   $0x812e34,0x8(%esp)
  80581b:	00 
  80581c:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  805823:	00 
  805824:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80582b:	e8 e4 b0 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  805830:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  805834:	74 1c                	je     805852 <dhcp_create_request+0x92>
  805836:	c7 44 24 08 60 2e 81 	movl   $0x812e60,0x8(%esp)
  80583d:	00 
  80583e:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  805845:	00 
  805846:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80584d:	e8 c2 b0 ff ff       	call   800914 <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  805852:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805859:	00 
  80585a:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  805861:	00 
  805862:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805869:	e8 cb 23 00 00       	call   807c39 <pbuf_alloc>
  80586e:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  805871:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  805876:	85 c0                	test   %eax,%eax
  805878:	0f 84 2d 01 00 00    	je     8059ab <dhcp_create_request+0x1eb>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80587e:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  805884:	77 1c                	ja     8058a2 <dhcp_create_request+0xe2>
  805886:	c7 44 24 08 8c 2e 81 	movl   $0x812e8c,0x8(%esp)
  80588d:	00 
  80588e:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  805895:	00 
  805896:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80589d:	e8 72 b0 ff ff       	call   800914 <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  8058a2:	8b 15 40 50 81 00    	mov    0x815040,%edx
  8058a8:	89 53 04             	mov    %edx,0x4(%ebx)
  8058ab:	83 c2 01             	add    $0x1,%edx
  8058ae:	89 15 40 50 81 00    	mov    %edx,0x815040
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  8058b4:	8b 40 04             	mov    0x4(%eax),%eax
  8058b7:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  8058ba:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  8058bd:	8b 43 20             	mov    0x20(%ebx),%eax
  8058c0:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  8058c4:	8b 43 20             	mov    0x20(%ebx),%eax
  8058c7:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  8058cb:	8b 43 20             	mov    0x20(%ebx),%eax
  8058ce:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  8058d2:	8b 73 20             	mov    0x20(%ebx),%esi
  8058d5:	8b 43 04             	mov    0x4(%ebx),%eax
  8058d8:	89 04 24             	mov    %eax,(%esp)
  8058db:	e8 b4 4e 00 00       	call   80a794 <htonl>
  8058e0:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  8058e3:	8b 43 20             	mov    0x20(%ebx),%eax
  8058e6:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  8058ec:	8b 43 20             	mov    0x20(%ebx),%eax
  8058ef:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  8058f5:	8b 43 20             	mov    0x20(%ebx),%eax
  8058f8:	8b 57 04             	mov    0x4(%edi),%edx
  8058fb:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  8058fe:	8b 43 20             	mov    0x20(%ebx),%eax
  805901:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  805908:	8b 43 20             	mov    0x20(%ebx),%eax
  80590b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  805912:	8b 43 20             	mov    0x20(%ebx),%eax
  805915:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  80591c:	b8 00 00 00 00       	mov    $0x0,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  805921:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805924:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  805927:	8b 5a 20             	mov    0x20(%edx),%ebx
  80592a:	89 c1                	mov    %eax,%ecx
  80592c:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  805930:	ba 00 00 00 00       	mov    $0x0,%edx
  805935:	66 39 c6             	cmp    %ax,%si
  805938:	76 05                	jbe    80593f <dhcp_create_request+0x17f>
  80593a:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  80593f:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  805943:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  805946:	83 f8 10             	cmp    $0x10,%eax
  805949:	75 d9                	jne    805924 <dhcp_create_request+0x164>
  80594b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80594e:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  805950:	8b 53 20             	mov    0x20(%ebx),%edx
  805953:	c6 44 10 2c 00       	movb   $0x0,0x2c(%eax,%edx,1)
  805958:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80595b:	83 f8 40             	cmp    $0x40,%eax
  80595e:	75 f0                	jne    805950 <dhcp_create_request+0x190>
  805960:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  805962:	8b 53 20             	mov    0x20(%ebx),%edx
  805965:	c6 44 10 6c 00       	movb   $0x0,0x6c(%eax,%edx,1)
  80596a:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80596d:	3d 80 00 00 00       	cmp    $0x80,%eax
  805972:	75 ee                	jne    805962 <dhcp_create_request+0x1a2>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  805974:	8b 73 20             	mov    0x20(%ebx),%esi
  805977:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  80597e:	e8 11 4e 00 00       	call   80a794 <htonl>
  805983:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  805989:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  80598f:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  805994:	8b 53 20             	mov    0x20(%ebx),%edx
  805997:	88 84 10 f0 00 00 00 	mov    %al,0xf0(%eax,%edx,1)
  80599e:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  8059a1:	83 f8 44             	cmp    $0x44,%eax
  8059a4:	75 ee                	jne    805994 <dhcp_create_request+0x1d4>
  8059a6:	ba 00 00 00 00       	mov    $0x0,%edx
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  8059ab:	89 d0                	mov    %edx,%eax
  8059ad:	83 c4 2c             	add    $0x2c,%esp
  8059b0:	5b                   	pop    %ebx
  8059b1:	5e                   	pop    %esi
  8059b2:	5f                   	pop    %edi
  8059b3:	5d                   	pop    %ebp
  8059b4:	c3                   	ret    

008059b5 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  8059b5:	55                   	push   %ebp
  8059b6:	89 e5                	mov    %esp,%ebp
  8059b8:	57                   	push   %edi
  8059b9:	56                   	push   %esi
  8059ba:	53                   	push   %ebx
  8059bb:	83 ec 3c             	sub    $0x3c,%esp
  8059be:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  8059c1:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  8059c4:	ba 0d 00 00 00       	mov    $0xd,%edx
  8059c9:	89 d8                	mov    %ebx,%eax
  8059cb:	e8 80 f8 ff ff       	call   805250 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  8059d0:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  8059d7:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  8059de:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  8059e5:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  8059ec:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  8059f3:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  8059fa:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  805a01:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  805a08:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805a0f:	89 f0                	mov    %esi,%eax
  805a11:	e8 aa fd ff ff       	call   8057c0 <dhcp_create_request>
  805a16:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  805a18:	84 c0                	test   %al,%al
  805a1a:	0f 85 87 00 00 00    	jne    805aa7 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805a20:	b9 01 00 00 00       	mov    $0x1,%ecx
  805a25:	ba 35 00 00 00       	mov    $0x35,%edx
  805a2a:	89 d8                	mov    %ebx,%eax
  805a2c:	e8 6b f9 ff ff       	call   80539c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  805a31:	ba 07 00 00 00       	mov    $0x7,%edx
  805a36:	89 d8                	mov    %ebx,%eax
  805a38:	e8 ce f9 ff ff       	call   80540b <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  805a3d:	89 d8                	mov    %ebx,%eax
  805a3f:	e8 17 fa ff ff       	call   80545b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805a44:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805a48:	66 05 f0 00          	add    $0xf0,%ax
  805a4c:	0f b7 c0             	movzwl %ax,%eax
  805a4f:	89 44 24 04          	mov    %eax,0x4(%esp)
  805a53:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805a56:	89 04 24             	mov    %eax,(%esp)
  805a59:	e8 ab 20 00 00       	call   807b09 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  805a5e:	8d 43 2c             	lea    0x2c(%ebx),%eax
  805a61:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805a64:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805a6b:	00 
  805a6c:	89 44 24 04          	mov    %eax,0x4(%esp)
  805a70:	8b 43 08             	mov    0x8(%ebx),%eax
  805a73:	89 04 24             	mov    %eax,(%esp)
  805a76:	e8 03 62 00 00       	call   80bc7e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  805a7b:	89 74 24 10          	mov    %esi,0x10(%esp)
  805a7f:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805a86:	00 
  805a87:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a8a:	89 44 24 08          	mov    %eax,0x8(%esp)
  805a8e:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805a91:	89 44 24 04          	mov    %eax,0x4(%esp)
  805a95:	8b 43 08             	mov    0x8(%ebx),%eax
  805a98:	89 04 24             	mov    %eax,(%esp)
  805a9b:	e8 60 62 00 00       	call   80bd00 <udp_sendto_if>
    dhcp_delete_request(netif);
  805aa0:	89 f0                	mov    %esi,%eax
  805aa2:	e8 ae fb ff ff       	call   805655 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805aa7:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  805aab:	83 c1 01             	add    $0x1,%ecx
  805aae:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  805ab1:	ba 10 27 00 00       	mov    $0x2710,%edx
  805ab6:	80 f9 09             	cmp    $0x9,%cl
  805ab9:	77 08                	ja     805ac3 <dhcp_release+0x10e>
  805abb:	0f b6 c9             	movzbl %cl,%ecx
  805abe:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805ac3:	0f b7 d2             	movzwl %dx,%edx
  805ac6:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805acc:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  805ad1:	89 d0                	mov    %edx,%eax
  805ad3:	f7 e9                	imul   %ecx
  805ad5:	c1 fa 05             	sar    $0x5,%edx
  805ad8:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  805adc:	89 34 24             	mov    %esi,(%esp)
  805adf:	e8 94 18 00 00       	call   807378 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  805ae4:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  805aeb:	00 
  805aec:	89 34 24             	mov    %esi,(%esp)
  805aef:	e8 e0 18 00 00       	call   8073d4 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  805af4:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  805afb:	00 
  805afc:	89 34 24             	mov    %esi,(%esp)
  805aff:	e8 db 17 00 00       	call   8072df <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  805b04:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  805b0b:	00 
  805b0c:	89 34 24             	mov    %esi,(%esp)
  805b0f:	e8 e4 17 00 00       	call   8072f8 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  805b14:	89 f8                	mov    %edi,%eax
  805b16:	83 c4 3c             	add    $0x3c,%esp
  805b19:	5b                   	pop    %ebx
  805b1a:	5e                   	pop    %esi
  805b1b:	5f                   	pop    %edi
  805b1c:	5d                   	pop    %ebp
  805b1d:	c3                   	ret    

00805b1e <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  805b1e:	55                   	push   %ebp
  805b1f:	89 e5                	mov    %esp,%ebp
  805b21:	83 ec 48             	sub    $0x48,%esp
  805b24:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805b27:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805b2a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  805b2d:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  805b30:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  805b33:	ba 05 00 00 00       	mov    $0x5,%edx
  805b38:	89 d8                	mov    %ebx,%eax
  805b3a:	e8 11 f7 ff ff       	call   805250 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805b3f:	89 f8                	mov    %edi,%eax
  805b41:	e8 7a fc ff ff       	call   8057c0 <dhcp_create_request>
  805b46:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  805b48:	84 c0                	test   %al,%al
  805b4a:	0f 85 a4 00 00 00    	jne    805bf4 <dhcp_renew+0xd6>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805b50:	b9 01 00 00 00       	mov    $0x1,%ecx
  805b55:	ba 35 00 00 00       	mov    $0x35,%edx
  805b5a:	89 d8                	mov    %ebx,%eax
  805b5c:	e8 3b f8 ff ff       	call   80539c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  805b61:	ba 03 00 00 00       	mov    $0x3,%edx
  805b66:	89 d8                	mov    %ebx,%eax
  805b68:	e8 9e f8 ff ff       	call   80540b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805b6d:	b9 02 00 00 00       	mov    $0x2,%ecx
  805b72:	ba 39 00 00 00       	mov    $0x39,%edx
  805b77:	89 d8                	mov    %ebx,%eax
  805b79:	e8 1e f8 ff ff       	call   80539c <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  805b7e:	ba 40 02 00 00       	mov    $0x240,%edx
  805b83:	89 d8                	mov    %ebx,%eax
  805b85:	e8 9b f9 ff ff       	call   805525 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  805b8a:	89 d8                	mov    %ebx,%eax
  805b8c:	e8 ca f8 ff ff       	call   80545b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805b91:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805b95:	66 05 f0 00          	add    $0xf0,%ax
  805b99:	0f b7 c0             	movzwl %ax,%eax
  805b9c:	89 44 24 04          	mov    %eax,0x4(%esp)
  805ba0:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805ba3:	89 04 24             	mov    %eax,(%esp)
  805ba6:	e8 5e 1f 00 00       	call   807b09 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  805bab:	8d 43 2c             	lea    0x2c(%ebx),%eax
  805bae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805bb1:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805bb8:	00 
  805bb9:	89 44 24 04          	mov    %eax,0x4(%esp)
  805bbd:	8b 43 08             	mov    0x8(%ebx),%eax
  805bc0:	89 04 24             	mov    %eax,(%esp)
  805bc3:	e8 b6 60 00 00       	call   80bc7e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  805bc8:	89 7c 24 10          	mov    %edi,0x10(%esp)
  805bcc:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805bd3:	00 
  805bd4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805bd7:	89 44 24 08          	mov    %eax,0x8(%esp)
  805bdb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805bde:	89 44 24 04          	mov    %eax,0x4(%esp)
  805be2:	8b 43 08             	mov    0x8(%ebx),%eax
  805be5:	89 04 24             	mov    %eax,(%esp)
  805be8:	e8 13 61 00 00       	call   80bd00 <udp_sendto_if>
    dhcp_delete_request(netif);
  805bed:	89 f8                	mov    %edi,%eax
  805bef:	e8 61 fa ff ff       	call   805655 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805bf4:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  805bf8:	83 c1 01             	add    $0x1,%ecx
  805bfb:	88 4b 01             	mov    %cl,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  805bfe:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  805c03:	80 f9 09             	cmp    $0x9,%cl
  805c06:	77 08                	ja     805c10 <dhcp_renew+0xf2>
  805c08:	0f b6 c9             	movzbl %cl,%ecx
  805c0b:	66 69 d1 d0 07       	imul   $0x7d0,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805c10:	0f b7 d2             	movzwl %dx,%edx
  805c13:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805c19:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  805c1e:	89 d0                	mov    %edx,%eax
  805c20:	f7 e9                	imul   %ecx
  805c22:	c1 fa 05             	sar    $0x5,%edx
  805c25:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  805c29:	89 f0                	mov    %esi,%eax
  805c2b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805c2e:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805c31:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805c34:	89 ec                	mov    %ebp,%esp
  805c36:	5d                   	pop    %ebp
  805c37:	c3                   	ret    

00805c38 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  805c38:	55                   	push   %ebp
  805c39:	89 e5                	mov    %esp,%ebp
  805c3b:	57                   	push   %edi
  805c3c:	56                   	push   %esi
  805c3d:	53                   	push   %ebx
  805c3e:	83 ec 2c             	sub    $0x2c,%esp
  805c41:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  805c43:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  805c46:	a1 e4 37 81 00       	mov    0x8137e4,%eax
  805c4b:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805c4e:	89 f8                	mov    %edi,%eax
  805c50:	e8 6b fb ff ff       	call   8057c0 <dhcp_create_request>
  805c55:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  805c57:	84 c0                	test   %al,%al
  805c59:	0f 85 f0 00 00 00    	jne    805d4f <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805c5f:	b9 01 00 00 00       	mov    $0x1,%ecx
  805c64:	ba 35 00 00 00       	mov    $0x35,%edx
  805c69:	89 d8                	mov    %ebx,%eax
  805c6b:	e8 2c f7 ff ff       	call   80539c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  805c70:	ba 01 00 00 00       	mov    $0x1,%edx
  805c75:	89 d8                	mov    %ebx,%eax
  805c77:	e8 8f f7 ff ff       	call   80540b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805c7c:	b9 02 00 00 00       	mov    $0x2,%ecx
  805c81:	ba 39 00 00 00       	mov    $0x39,%edx
  805c86:	89 d8                	mov    %ebx,%eax
  805c88:	e8 0f f7 ff ff       	call   80539c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  805c8d:	ba 40 02 00 00       	mov    $0x240,%edx
  805c92:	89 d8                	mov    %ebx,%eax
  805c94:	e8 8c f8 ff ff       	call   805525 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  805c99:	b9 04 00 00 00       	mov    $0x4,%ecx
  805c9e:	ba 37 00 00 00       	mov    $0x37,%edx
  805ca3:	89 d8                	mov    %ebx,%eax
  805ca5:	e8 f2 f6 ff ff       	call   80539c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  805caa:	ba 01 00 00 00       	mov    $0x1,%edx
  805caf:	89 d8                	mov    %ebx,%eax
  805cb1:	e8 55 f7 ff ff       	call   80540b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  805cb6:	ba 03 00 00 00       	mov    $0x3,%edx
  805cbb:	89 d8                	mov    %ebx,%eax
  805cbd:	e8 49 f7 ff ff       	call   80540b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  805cc2:	ba 1c 00 00 00       	mov    $0x1c,%edx
  805cc7:	89 d8                	mov    %ebx,%eax
  805cc9:	e8 3d f7 ff ff       	call   80540b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  805cce:	ba 06 00 00 00       	mov    $0x6,%edx
  805cd3:	89 d8                	mov    %ebx,%eax
  805cd5:	e8 31 f7 ff ff       	call   80540b <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  805cda:	89 d8                	mov    %ebx,%eax
  805cdc:	e8 7a f7 ff ff       	call   80545b <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805ce1:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805ce5:	66 05 f0 00          	add    $0xf0,%ax
  805ce9:	0f b7 c0             	movzwl %ax,%eax
  805cec:	89 44 24 04          	mov    %eax,0x4(%esp)
  805cf0:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805cf3:	89 04 24             	mov    %eax,(%esp)
  805cf6:	e8 0e 1e 00 00       	call   807b09 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  805cfb:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805d02:	00 
  805d03:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  805d0a:	00 
  805d0b:	8b 43 08             	mov    0x8(%ebx),%eax
  805d0e:	89 04 24             	mov    %eax,(%esp)
  805d11:	e8 68 5f 00 00       	call   80bc7e <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  805d16:	89 7c 24 10          	mov    %edi,0x10(%esp)
  805d1a:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805d21:	00 
  805d22:	c7 44 24 08 e8 37 81 	movl   $0x8137e8,0x8(%esp)
  805d29:	00 
  805d2a:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805d2d:	89 44 24 04          	mov    %eax,0x4(%esp)
  805d31:	8b 43 08             	mov    0x8(%ebx),%eax
  805d34:	89 04 24             	mov    %eax,(%esp)
  805d37:	e8 c4 5f 00 00       	call   80bd00 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  805d3c:	89 f8                	mov    %edi,%eax
  805d3e:	e8 12 f9 ff ff       	call   805655 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  805d43:	ba 06 00 00 00       	mov    $0x6,%edx
  805d48:	89 d8                	mov    %ebx,%eax
  805d4a:	e8 01 f5 ff ff       	call   805250 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805d4f:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  805d53:	83 c1 01             	add    $0x1,%ecx
  805d56:	88 4b 01             	mov    %cl,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  805d59:	ba 10 27 00 00       	mov    $0x2710,%edx
  805d5e:	80 f9 03             	cmp    $0x3,%cl
  805d61:	77 0b                	ja     805d6e <dhcp_discover+0x136>
  805d63:	0f b6 d1             	movzbl %cl,%edx
  805d66:	83 c2 01             	add    $0x1,%edx
  805d69:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805d6e:	0f b7 d2             	movzwl %dx,%edx
  805d71:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805d77:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  805d7c:	89 d0                	mov    %edx,%eax
  805d7e:	f7 e9                	imul   %ecx
  805d80:	c1 fa 05             	sar    $0x5,%edx
  805d83:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  805d87:	89 f0                	mov    %esi,%eax
  805d89:	83 c4 2c             	add    $0x2c,%esp
  805d8c:	5b                   	pop    %ebx
  805d8d:	5e                   	pop    %esi
  805d8e:	5f                   	pop    %edi
  805d8f:	5d                   	pop    %ebp
  805d90:	c3                   	ret    

00805d91 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  805d91:	55                   	push   %ebp
  805d92:	89 e5                	mov    %esp,%ebp
  805d94:	83 ec 38             	sub    $0x38,%esp
  805d97:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805d9a:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805d9d:	89 7d fc             	mov    %edi,-0x4(%ebp)
  805da0:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  805da2:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  805da5:	ba 04 00 00 00       	mov    $0x4,%edx
  805daa:	89 d8                	mov    %ebx,%eax
  805dac:	e8 9f f4 ff ff       	call   805250 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805db1:	89 f8                	mov    %edi,%eax
  805db3:	e8 08 fa ff ff       	call   8057c0 <dhcp_create_request>
  805db8:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  805dba:	84 c0                	test   %al,%al
  805dbc:	0f 85 a3 00 00 00    	jne    805e65 <dhcp_rebind+0xd4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805dc2:	b9 01 00 00 00       	mov    $0x1,%ecx
  805dc7:	ba 35 00 00 00       	mov    $0x35,%edx
  805dcc:	89 d8                	mov    %ebx,%eax
  805dce:	e8 c9 f5 ff ff       	call   80539c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  805dd3:	ba 03 00 00 00       	mov    $0x3,%edx
  805dd8:	89 d8                	mov    %ebx,%eax
  805dda:	e8 2c f6 ff ff       	call   80540b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805ddf:	b9 02 00 00 00       	mov    $0x2,%ecx
  805de4:	ba 39 00 00 00       	mov    $0x39,%edx
  805de9:	89 d8                	mov    %ebx,%eax
  805deb:	e8 ac f5 ff ff       	call   80539c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  805df0:	ba 40 02 00 00       	mov    $0x240,%edx
  805df5:	89 d8                	mov    %ebx,%eax
  805df7:	e8 29 f7 ff ff       	call   805525 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  805dfc:	89 d8                	mov    %ebx,%eax
  805dfe:	e8 58 f6 ff ff       	call   80545b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805e03:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805e07:	66 05 f0 00          	add    $0xf0,%ax
  805e0b:	0f b7 c0             	movzwl %ax,%eax
  805e0e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805e12:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805e15:	89 04 24             	mov    %eax,(%esp)
  805e18:	e8 ec 1c 00 00       	call   807b09 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  805e1d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805e24:	00 
  805e25:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  805e2c:	00 
  805e2d:	8b 43 08             	mov    0x8(%ebx),%eax
  805e30:	89 04 24             	mov    %eax,(%esp)
  805e33:	e8 46 5e 00 00       	call   80bc7e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  805e38:	89 7c 24 10          	mov    %edi,0x10(%esp)
  805e3c:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805e43:	00 
  805e44:	c7 44 24 08 e8 37 81 	movl   $0x8137e8,0x8(%esp)
  805e4b:	00 
  805e4c:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805e4f:	89 44 24 04          	mov    %eax,0x4(%esp)
  805e53:	8b 43 08             	mov    0x8(%ebx),%eax
  805e56:	89 04 24             	mov    %eax,(%esp)
  805e59:	e8 a2 5e 00 00       	call   80bd00 <udp_sendto_if>
    dhcp_delete_request(netif);
  805e5e:	89 f8                	mov    %edi,%eax
  805e60:	e8 f0 f7 ff ff       	call   805655 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805e65:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  805e69:	83 c1 01             	add    $0x1,%ecx
  805e6c:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  805e6f:	ba 10 27 00 00       	mov    $0x2710,%edx
  805e74:	80 f9 09             	cmp    $0x9,%cl
  805e77:	77 08                	ja     805e81 <dhcp_rebind+0xf0>
  805e79:	0f b6 c9             	movzbl %cl,%ecx
  805e7c:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805e81:	0f b7 d2             	movzwl %dx,%edx
  805e84:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805e8a:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  805e8f:	89 d0                	mov    %edx,%eax
  805e91:	f7 e9                	imul   %ecx
  805e93:	c1 fa 05             	sar    $0x5,%edx
  805e96:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  805e9a:	89 f0                	mov    %esi,%eax
  805e9c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805e9f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805ea2:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805ea5:	89 ec                	mov    %ebp,%esp
  805ea7:	5d                   	pop    %ebp
  805ea8:	c3                   	ret    

00805ea9 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  805ea9:	55                   	push   %ebp
  805eaa:	89 e5                	mov    %esp,%ebp
  805eac:	53                   	push   %ebx
  805ead:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  805eb0:	8b 1d 04 f0 b3 00    	mov    0xb3f004,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  805eb6:	85 db                	test   %ebx,%ebx
  805eb8:	74 67                	je     805f21 <dhcp_coarse_tmr+0x78>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  805eba:	8b 43 20             	mov    0x20(%ebx),%eax
  805ebd:	85 c0                	test   %eax,%eax
  805ebf:	74 5a                	je     805f1b <dhcp_coarse_tmr+0x72>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  805ec1:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  805ec5:	8d 4a ff             	lea    -0x1(%edx),%ecx
  805ec8:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  805ecc:	66 83 fa 01          	cmp    $0x1,%dx
  805ed0:	75 1b                	jne    805eed <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  805ed2:	8b 43 20             	mov    0x20(%ebx),%eax
  805ed5:	0f b6 00             	movzbl (%eax),%eax
  805ed8:	3c 01                	cmp    $0x1,%al
  805eda:	74 08                	je     805ee4 <dhcp_coarse_tmr+0x3b>
  805edc:	3c 0a                	cmp    $0xa,%al
  805ede:	74 04                	je     805ee4 <dhcp_coarse_tmr+0x3b>
  805ee0:	3c 05                	cmp    $0x5,%al
  805ee2:	75 37                	jne    805f1b <dhcp_coarse_tmr+0x72>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  805ee4:	89 d8                	mov    %ebx,%eax
  805ee6:	e8 a6 fe ff ff       	call   805d91 <dhcp_rebind>
  805eeb:	eb 2e                	jmp    805f1b <dhcp_coarse_tmr+0x72>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  805eed:	8b 53 20             	mov    0x20(%ebx),%edx
  805ef0:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  805ef4:	8d 48 ff             	lea    -0x1(%eax),%ecx
  805ef7:	66 89 4a 28          	mov    %cx,0x28(%edx)
  805efb:	66 83 f8 01          	cmp    $0x1,%ax
  805eff:	75 1a                	jne    805f1b <dhcp_coarse_tmr+0x72>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  805f01:	8b 43 20             	mov    0x20(%ebx),%eax
  805f04:	0f b6 00             	movzbl (%eax),%eax
  805f07:	3c 01                	cmp    $0x1,%al
  805f09:	74 08                	je     805f13 <dhcp_coarse_tmr+0x6a>
  805f0b:	3c 0a                	cmp    $0xa,%al
  805f0d:	74 04                	je     805f13 <dhcp_coarse_tmr+0x6a>
  805f0f:	3c 05                	cmp    $0x5,%al
  805f11:	75 08                	jne    805f1b <dhcp_coarse_tmr+0x72>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  805f13:	89 1c 24             	mov    %ebx,(%esp)
  805f16:	e8 03 fc ff ff       	call   805b1e <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  805f1b:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  805f1d:	85 db                	test   %ebx,%ebx
  805f1f:	75 99                	jne    805eba <dhcp_coarse_tmr+0x11>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  805f21:	83 c4 14             	add    $0x14,%esp
  805f24:	5b                   	pop    %ebx
  805f25:	5d                   	pop    %ebp
  805f26:	c3                   	ret    

00805f27 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  805f27:	55                   	push   %ebp
  805f28:	89 e5                	mov    %esp,%ebp
  805f2a:	83 ec 28             	sub    $0x28,%esp
  805f2d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  805f30:	89 75 fc             	mov    %esi,-0x4(%ebp)
  805f33:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  805f36:	85 f6                	test   %esi,%esi
  805f38:	75 1c                	jne    805f56 <dhcp_arp_reply+0x2f>
  805f3a:	c7 44 24 08 3b 2f 81 	movl   $0x812f3b,0x8(%esp)
  805f41:	00 
  805f42:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  805f49:	00 
  805f4a:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  805f51:	e8 be a9 ff ff       	call   800914 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  805f56:	8b 5e 20             	mov    0x20(%esi),%ebx
  805f59:	85 db                	test   %ebx,%ebx
  805f5b:	0f 84 04 01 00 00    	je     806065 <dhcp_arp_reply+0x13e>
  805f61:	80 3b 08             	cmpb   $0x8,(%ebx)
  805f64:	0f 85 fb 00 00 00    	jne    806065 <dhcp_arp_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  805f6a:	8b 45 0c             	mov    0xc(%ebp),%eax
  805f6d:	8b 00                	mov    (%eax),%eax
  805f6f:	3b 43 30             	cmp    0x30(%ebx),%eax
  805f72:	0f 85 ed 00 00 00    	jne    806065 <dhcp_arp_reply+0x13e>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  805f78:	ba 0c 00 00 00       	mov    $0xc,%edx
  805f7d:	89 d8                	mov    %ebx,%eax
  805f7f:	e8 cc f2 ff ff       	call   805250 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805f84:	89 f0                	mov    %esi,%eax
  805f86:	e8 35 f8 ff ff       	call   8057c0 <dhcp_create_request>
  if (result == ERR_OK) {
  805f8b:	84 c0                	test   %al,%al
  805f8d:	0f 85 c8 00 00 00    	jne    80605b <dhcp_arp_reply+0x134>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805f93:	b9 01 00 00 00       	mov    $0x1,%ecx
  805f98:	ba 35 00 00 00       	mov    $0x35,%edx
  805f9d:	89 d8                	mov    %ebx,%eax
  805f9f:	e8 f8 f3 ff ff       	call   80539c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  805fa4:	ba 04 00 00 00       	mov    $0x4,%edx
  805fa9:	89 d8                	mov    %ebx,%eax
  805fab:	e8 5b f4 ff ff       	call   80540b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805fb0:	b9 02 00 00 00       	mov    $0x2,%ecx
  805fb5:	ba 39 00 00 00       	mov    $0x39,%edx
  805fba:	89 d8                	mov    %ebx,%eax
  805fbc:	e8 db f3 ff ff       	call   80539c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  805fc1:	ba 40 02 00 00       	mov    $0x240,%edx
  805fc6:	89 d8                	mov    %ebx,%eax
  805fc8:	e8 58 f5 ff ff       	call   805525 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  805fcd:	b9 04 00 00 00       	mov    $0x4,%ecx
  805fd2:	ba 32 00 00 00       	mov    $0x32,%edx
  805fd7:	89 d8                	mov    %ebx,%eax
  805fd9:	e8 be f3 ff ff       	call   80539c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  805fde:	8b 43 30             	mov    0x30(%ebx),%eax
  805fe1:	89 04 24             	mov    %eax,(%esp)
  805fe4:	e8 cc 49 00 00       	call   80a9b5 <ntohl>
  805fe9:	89 c2                	mov    %eax,%edx
  805feb:	89 d8                	mov    %ebx,%eax
  805fed:	e8 b2 f5 ff ff       	call   8055a4 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  805ff2:	89 d8                	mov    %ebx,%eax
  805ff4:	e8 62 f4 ff ff       	call   80545b <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805ff9:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805ffd:	66 05 f0 00          	add    $0xf0,%ax
  806001:	0f b7 c0             	movzwl %ax,%eax
  806004:	89 44 24 04          	mov    %eax,0x4(%esp)
  806008:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80600b:	89 04 24             	mov    %eax,(%esp)
  80600e:	e8 f6 1a 00 00       	call   807b09 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806013:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80601a:	00 
  80601b:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  806022:	00 
  806023:	8b 43 08             	mov    0x8(%ebx),%eax
  806026:	89 04 24             	mov    %eax,(%esp)
  806029:	e8 50 5c 00 00       	call   80bc7e <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80602e:	89 74 24 10          	mov    %esi,0x10(%esp)
  806032:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806039:	00 
  80603a:	c7 44 24 08 e8 37 81 	movl   $0x8137e8,0x8(%esp)
  806041:	00 
  806042:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806045:	89 44 24 04          	mov    %eax,0x4(%esp)
  806049:	8b 43 08             	mov    0x8(%ebx),%eax
  80604c:	89 04 24             	mov    %eax,(%esp)
  80604f:	e8 ac 5c 00 00       	call   80bd00 <udp_sendto_if>
    dhcp_delete_request(netif);
  806054:	89 f0                	mov    %esi,%eax
  806056:	e8 fa f5 ff ff       	call   805655 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80605b:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80605f:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  806065:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  806068:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80606b:	89 ec                	mov    %ebp,%esp
  80606d:	5d                   	pop    %ebp
  80606e:	c3                   	ret    

0080606f <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  80606f:	55                   	push   %ebp
  806070:	89 e5                	mov    %esp,%ebp
  806072:	57                   	push   %edi
  806073:	56                   	push   %esi
  806074:	53                   	push   %ebx
  806075:	83 ec 2c             	sub    $0x2c,%esp
  806078:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80607a:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80607d:	e8 3e f7 ff ff       	call   8057c0 <dhcp_create_request>
  806082:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  806084:	84 c0                	test   %al,%al
  806086:	0f 85 3a 01 00 00    	jne    8061c6 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80608c:	b9 01 00 00 00       	mov    $0x1,%ecx
  806091:	ba 35 00 00 00       	mov    $0x35,%edx
  806096:	89 d8                	mov    %ebx,%eax
  806098:	e8 ff f2 ff ff       	call   80539c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80609d:	ba 03 00 00 00       	mov    $0x3,%edx
  8060a2:	89 d8                	mov    %ebx,%eax
  8060a4:	e8 62 f3 ff ff       	call   80540b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8060a9:	b9 02 00 00 00       	mov    $0x2,%ecx
  8060ae:	ba 39 00 00 00       	mov    $0x39,%edx
  8060b3:	89 d8                	mov    %ebx,%eax
  8060b5:	e8 e2 f2 ff ff       	call   80539c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8060ba:	ba 40 02 00 00       	mov    $0x240,%edx
  8060bf:	89 d8                	mov    %ebx,%eax
  8060c1:	e8 5f f4 ff ff       	call   805525 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8060c6:	b9 04 00 00 00       	mov    $0x4,%ecx
  8060cb:	ba 32 00 00 00       	mov    $0x32,%edx
  8060d0:	89 d8                	mov    %ebx,%eax
  8060d2:	e8 c5 f2 ff ff       	call   80539c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8060d7:	8b 43 30             	mov    0x30(%ebx),%eax
  8060da:	89 04 24             	mov    %eax,(%esp)
  8060dd:	e8 d3 48 00 00       	call   80a9b5 <ntohl>
  8060e2:	89 c2                	mov    %eax,%edx
  8060e4:	89 d8                	mov    %ebx,%eax
  8060e6:	e8 b9 f4 ff ff       	call   8055a4 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8060eb:	b9 04 00 00 00       	mov    $0x4,%ecx
  8060f0:	ba 36 00 00 00       	mov    $0x36,%edx
  8060f5:	89 d8                	mov    %ebx,%eax
  8060f7:	e8 a0 f2 ff ff       	call   80539c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8060fc:	8b 43 2c             	mov    0x2c(%ebx),%eax
  8060ff:	89 04 24             	mov    %eax,(%esp)
  806102:	e8 ae 48 00 00       	call   80a9b5 <ntohl>
  806107:	89 c2                	mov    %eax,%edx
  806109:	89 d8                	mov    %ebx,%eax
  80610b:	e8 94 f4 ff ff       	call   8055a4 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  806110:	b9 04 00 00 00       	mov    $0x4,%ecx
  806115:	ba 37 00 00 00       	mov    $0x37,%edx
  80611a:	89 d8                	mov    %ebx,%eax
  80611c:	e8 7b f2 ff ff       	call   80539c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  806121:	ba 01 00 00 00       	mov    $0x1,%edx
  806126:	89 d8                	mov    %ebx,%eax
  806128:	e8 de f2 ff ff       	call   80540b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80612d:	ba 03 00 00 00       	mov    $0x3,%edx
  806132:	89 d8                	mov    %ebx,%eax
  806134:	e8 d2 f2 ff ff       	call   80540b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  806139:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80613e:	89 d8                	mov    %ebx,%eax
  806140:	e8 c6 f2 ff ff       	call   80540b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  806145:	ba 06 00 00 00       	mov    $0x6,%edx
  80614a:	89 d8                	mov    %ebx,%eax
  80614c:	e8 ba f2 ff ff       	call   80540b <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  806151:	89 d8                	mov    %ebx,%eax
  806153:	e8 03 f3 ff ff       	call   80545b <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806158:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80615c:	66 05 f0 00          	add    $0xf0,%ax
  806160:	0f b7 c0             	movzwl %ax,%eax
  806163:	89 44 24 04          	mov    %eax,0x4(%esp)
  806167:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80616a:	89 04 24             	mov    %eax,(%esp)
  80616d:	e8 97 19 00 00       	call   807b09 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806172:	89 7c 24 10          	mov    %edi,0x10(%esp)
  806176:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80617d:	00 
  80617e:	c7 44 24 08 e8 37 81 	movl   $0x8137e8,0x8(%esp)
  806185:	00 
  806186:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806189:	89 44 24 04          	mov    %eax,0x4(%esp)
  80618d:	8b 43 08             	mov    0x8(%ebx),%eax
  806190:	89 04 24             	mov    %eax,(%esp)
  806193:	e8 68 5b 00 00       	call   80bd00 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806198:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80619f:	00 
  8061a0:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  8061a7:	00 
  8061a8:	8b 43 08             	mov    0x8(%ebx),%eax
  8061ab:	89 04 24             	mov    %eax,(%esp)
  8061ae:	e8 cb 5a 00 00       	call   80bc7e <udp_connect>
    dhcp_delete_request(netif);
  8061b3:	89 f8                	mov    %edi,%eax
  8061b5:	e8 9b f4 ff ff       	call   805655 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8061ba:	ba 01 00 00 00       	mov    $0x1,%edx
  8061bf:	89 d8                	mov    %ebx,%eax
  8061c1:	e8 8a f0 ff ff       	call   805250 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8061c6:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  8061ca:	83 c1 01             	add    $0x1,%ecx
  8061cd:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8061d0:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  8061d5:	80 f9 03             	cmp    $0x3,%cl
  8061d8:	77 08                	ja     8061e2 <dhcp_select+0x173>
  8061da:	0f b6 c9             	movzbl %cl,%ecx
  8061dd:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8061e2:	0f b7 d2             	movzwl %dx,%edx
  8061e5:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8061eb:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8061f0:	89 d0                	mov    %edx,%eax
  8061f2:	f7 e9                	imul   %ecx
  8061f4:	c1 fa 05             	sar    $0x5,%edx
  8061f7:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8061fb:	89 f0                	mov    %esi,%eax
  8061fd:	83 c4 2c             	add    $0x2c,%esp
  806200:	5b                   	pop    %ebx
  806201:	5e                   	pop    %esi
  806202:	5f                   	pop    %edi
  806203:	5d                   	pop    %ebp
  806204:	c3                   	ret    

00806205 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  806205:	55                   	push   %ebp
  806206:	89 e5                	mov    %esp,%ebp
  806208:	83 ec 38             	sub    $0x38,%esp
  80620b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80620e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806211:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806214:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  806217:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  80621a:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  806221:	e8 ba 09 00 00       	call   806be0 <mem_malloc>
  806226:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  806228:	85 c0                	test   %eax,%eax
  80622a:	0f 84 40 01 00 00    	je     806370 <dhcp_inform+0x16b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  806230:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  806233:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  80623a:	00 
  80623b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806242:	00 
  806243:	89 04 24             	mov    %eax,(%esp)
  806246:	e8 4b b0 ff ff       	call   801296 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  80624b:	e8 df 58 00 00       	call   80bb2f <udp_new>
  806250:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  806253:	85 c0                	test   %eax,%eax
  806255:	75 0e                	jne    806265 <dhcp_inform+0x60>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  806257:	89 1c 24             	mov    %ebx,(%esp)
  80625a:	e8 16 0d 00 00       	call   806f75 <mem_free>
    return;
  80625f:	90                   	nop
  806260:	e9 0b 01 00 00       	jmp    806370 <dhcp_inform+0x16b>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  806265:	89 f0                	mov    %esi,%eax
  806267:	e8 54 f5 ff ff       	call   8057c0 <dhcp_create_request>
  if (result == ERR_OK) {
  80626c:	84 c0                	test   %al,%al
  80626e:	66 90                	xchg   %ax,%ax
  806270:	0f 85 d9 00 00 00    	jne    80634f <dhcp_inform+0x14a>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  806276:	b9 01 00 00 00       	mov    $0x1,%ecx
  80627b:	ba 35 00 00 00       	mov    $0x35,%edx
  806280:	89 d8                	mov    %ebx,%eax
  806282:	e8 15 f1 ff ff       	call   80539c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  806287:	ba 08 00 00 00       	mov    $0x8,%edx
  80628c:	89 d8                	mov    %ebx,%eax
  80628e:	e8 78 f1 ff ff       	call   80540b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  806293:	b9 02 00 00 00       	mov    $0x2,%ecx
  806298:	ba 39 00 00 00       	mov    $0x39,%edx
  80629d:	89 d8                	mov    %ebx,%eax
  80629f:	e8 f8 f0 ff ff       	call   80539c <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  8062a4:	ba 40 02 00 00       	mov    $0x240,%edx
  8062a9:	89 d8                	mov    %ebx,%eax
  8062ab:	e8 75 f2 ff ff       	call   805525 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  8062b0:	89 d8                	mov    %ebx,%eax
  8062b2:	e8 a4 f1 ff ff       	call   80545b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8062b7:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8062bb:	66 05 f0 00          	add    $0xf0,%ax
  8062bf:	0f b7 c0             	movzwl %ax,%eax
  8062c2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8062c6:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8062c9:	89 04 24             	mov    %eax,(%esp)
  8062cc:	e8 38 18 00 00       	call   807b09 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  8062d1:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  8062d8:	00 
  8062d9:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  8062e0:	00 
  8062e1:	8b 43 08             	mov    0x8(%ebx),%eax
  8062e4:	89 04 24             	mov    %eax,(%esp)
  8062e7:	e8 cc 58 00 00       	call   80bbb8 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  8062ec:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8062f3:	00 
  8062f4:	c7 44 24 04 e8 37 81 	movl   $0x8137e8,0x4(%esp)
  8062fb:	00 
  8062fc:	8b 43 08             	mov    0x8(%ebx),%eax
  8062ff:	89 04 24             	mov    %eax,(%esp)
  806302:	e8 77 59 00 00       	call   80bc7e <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806307:	89 74 24 10          	mov    %esi,0x10(%esp)
  80630b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806312:	00 
  806313:	c7 44 24 08 e8 37 81 	movl   $0x8137e8,0x8(%esp)
  80631a:	00 
  80631b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80631e:	89 44 24 04          	mov    %eax,0x4(%esp)
  806322:	8b 43 08             	mov    0x8(%ebx),%eax
  806325:	89 04 24             	mov    %eax,(%esp)
  806328:	e8 d3 59 00 00       	call   80bd00 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80632d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806334:	00 
  806335:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  80633c:	00 
  80633d:	8b 43 08             	mov    0x8(%ebx),%eax
  806340:	89 04 24             	mov    %eax,(%esp)
  806343:	e8 36 59 00 00       	call   80bc7e <udp_connect>
    dhcp_delete_request(netif);
  806348:	89 f0                	mov    %esi,%eax
  80634a:	e8 06 f3 ff ff       	call   805655 <dhcp_delete_request>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  80634f:	8b 43 08             	mov    0x8(%ebx),%eax
  806352:	85 c0                	test   %eax,%eax
  806354:	74 08                	je     80635e <dhcp_inform+0x159>
      udp_remove(dhcp->pcb);
  806356:	89 04 24             	mov    %eax,(%esp)
  806359:	e8 0e 58 00 00       	call   80bb6c <udp_remove>
    }
    dhcp->pcb = NULL;
  80635e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  806365:	89 1c 24             	mov    %ebx,(%esp)
  806368:	e8 08 0c 00 00       	call   806f75 <mem_free>
    netif->dhcp = old_dhcp;
  80636d:	89 7e 20             	mov    %edi,0x20(%esi)
  }
}
  806370:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  806373:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806376:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806379:	89 ec                	mov    %ebp,%esp
  80637b:	5d                   	pop    %ebp
  80637c:	c3                   	ret    

0080637d <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  80637d:	55                   	push   %ebp
  80637e:	89 e5                	mov    %esp,%ebp
  806380:	56                   	push   %esi
  806381:	53                   	push   %ebx
  806382:	83 ec 10             	sub    $0x10,%esp
  806385:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  806388:	85 f6                	test   %esi,%esi
  80638a:	75 1c                	jne    8063a8 <dhcp_start+0x2b>
  80638c:	c7 44 24 08 3b 2f 81 	movl   $0x812f3b,0x8(%esp)
  806393:	00 
  806394:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  80639b:	00 
  80639c:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8063a3:	e8 6c a5 ff ff       	call   800914 <_panic>
  dhcp = netif->dhcp;
  8063a8:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  8063ab:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  8063af:	85 db                	test   %ebx,%ebx
  8063b1:	75 1e                	jne    8063d1 <dhcp_start+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  8063b3:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  8063ba:	e8 21 08 00 00       	call   806be0 <mem_malloc>
  8063bf:	89 c3                	mov    %eax,%ebx
    if (dhcp == NULL) {
  8063c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8063c6:	85 db                	test   %ebx,%ebx
  8063c8:	0f 84 a5 00 00 00    	je     806473 <dhcp_start+0xf6>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  8063ce:	89 5e 20             	mov    %ebx,0x20(%esi)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  8063d1:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  8063d8:	00 
  8063d9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8063e0:	00 
  8063e1:	89 1c 24             	mov    %ebx,(%esp)
  8063e4:	e8 ad ae ff ff       	call   801296 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  8063e9:	e8 41 57 00 00       	call   80bb2f <udp_new>
  8063ee:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8063f1:	85 c0                	test   %eax,%eax
  8063f3:	75 16                	jne    80640b <dhcp_start+0x8e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  8063f5:	89 1c 24             	mov    %ebx,(%esp)
  8063f8:	e8 78 0b 00 00       	call   806f75 <mem_free>
    netif->dhcp = dhcp = NULL;
  8063fd:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  806404:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  806409:	eb 68                	jmp    806473 <dhcp_start+0xf6>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80640b:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  806412:	00 
  806413:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  80641a:	00 
  80641b:	89 04 24             	mov    %eax,(%esp)
  80641e:	e8 95 57 00 00       	call   80bbb8 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806423:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80642a:	00 
  80642b:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  806432:	00 
  806433:	8b 43 08             	mov    0x8(%ebx),%eax
  806436:	89 04 24             	mov    %eax,(%esp)
  806439:	e8 40 58 00 00       	call   80bc7e <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  80643e:	89 74 24 08          	mov    %esi,0x8(%esp)
  806442:	c7 44 24 04 52 66 80 	movl   $0x806652,0x4(%esp)
  806449:	00 
  80644a:	8b 43 08             	mov    0x8(%ebx),%eax
  80644d:	89 04 24             	mov    %eax,(%esp)
  806450:	e8 c6 56 00 00       	call   80bb1b <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  806455:	89 f0                	mov    %esi,%eax
  806457:	e8 dc f7 ff ff       	call   805c38 <dhcp_discover>
  if (result != ERR_OK) {
  80645c:	84 c0                	test   %al,%al
  80645e:	74 0f                	je     80646f <dhcp_start+0xf2>
    /* free resources allocated above */
    dhcp_stop(netif);
  806460:	89 34 24             	mov    %esi,(%esp)
  806463:	e8 d9 f2 ff ff       	call   805741 <dhcp_stop>
  806468:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80646d:	eb 04                	jmp    806473 <dhcp_start+0xf6>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  80646f:	80 4e 2e 08          	orb    $0x8,0x2e(%esi)
  return result;
}
  806473:	83 c4 10             	add    $0x10,%esp
  806476:	5b                   	pop    %ebx
  806477:	5e                   	pop    %esi
  806478:	5d                   	pop    %ebp
  806479:	c3                   	ret    

0080647a <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  80647a:	55                   	push   %ebp
  80647b:	89 e5                	mov    %esp,%ebp
  80647d:	53                   	push   %ebx
  80647e:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  806481:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  806484:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80648b:	00 
  80648c:	8d 53 30             	lea    0x30(%ebx),%edx
  80648f:	89 54 24 04          	mov    %edx,0x4(%esp)
  806493:	89 04 24             	mov    %eax,(%esp)
  806496:	e8 9c 62 00 00       	call   80c737 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  80649b:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80649f:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  8064a5:	ba 08 00 00 00       	mov    $0x8,%edx
  8064aa:	89 d8                	mov    %ebx,%eax
  8064ac:	e8 9f ed ff ff       	call   805250 <dhcp_set_state>
}
  8064b1:	83 c4 14             	add    $0x14,%esp
  8064b4:	5b                   	pop    %ebx
  8064b5:	5d                   	pop    %ebp
  8064b6:	c3                   	ret    

008064b7 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  8064b7:	55                   	push   %ebp
  8064b8:	89 e5                	mov    %esp,%ebp
  8064ba:	57                   	push   %edi
  8064bb:	56                   	push   %esi
  8064bc:	53                   	push   %ebx
  8064bd:	83 ec 2c             	sub    $0x2c,%esp
  8064c0:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8064c2:	85 c0                	test   %eax,%eax
  8064c4:	75 1c                	jne    8064e2 <dhcp_bind+0x2b>
  8064c6:	c7 44 24 08 30 2f 81 	movl   $0x812f30,0x8(%esp)
  8064cd:	00 
  8064ce:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  8064d5:	00 
  8064d6:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8064dd:	e8 32 a4 ff ff       	call   800914 <_panic>
  dhcp = netif->dhcp;
  8064e2:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  8064e5:	85 db                	test   %ebx,%ebx
  8064e7:	75 1c                	jne    806505 <dhcp_bind+0x4e>
  8064e9:	c7 44 24 08 49 2f 81 	movl   $0x812f49,0x8(%esp)
  8064f0:	00 
  8064f1:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  8064f8:	00 
  8064f9:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  806500:	e8 0f a4 ff ff       	call   800914 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  806505:	8b 53 50             	mov    0x50(%ebx),%edx
  806508:	83 fa ff             	cmp    $0xffffffff,%edx
  80650b:	74 2c                	je     806539 <dhcp_bind+0x82>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80650d:	83 c2 1e             	add    $0x1e,%edx
  806510:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  806515:	89 d0                	mov    %edx,%eax
  806517:	f7 e1                	mul    %ecx
  806519:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80651c:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  806522:	b8 ff ff 00 00       	mov    $0xffff,%eax
  806527:	0f 47 d0             	cmova  %eax,%edx
    if (dhcp->t1_timeout == 0) {
      dhcp->t1_timeout = 1;
  80652a:	66 85 d2             	test   %dx,%dx
  80652d:	b8 01 00 00 00       	mov    $0x1,%eax
  806532:	0f 44 d0             	cmove  %eax,%edx
  806535:	66 89 53 28          	mov    %dx,0x28(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  806539:	8b 53 54             	mov    0x54(%ebx),%edx
  80653c:	83 fa ff             	cmp    $0xffffffff,%edx
  80653f:	74 2c                	je     80656d <dhcp_bind+0xb6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  806541:	83 c2 1e             	add    $0x1e,%edx
  806544:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  806549:	89 d0                	mov    %edx,%eax
  80654b:	f7 e1                	mul    %ecx
  80654d:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  806550:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  806556:	b8 ff ff 00 00       	mov    $0xffff,%eax
  80655b:	0f 47 d0             	cmova  %eax,%edx
    if (dhcp->t2_timeout == 0) {
      dhcp->t2_timeout = 1;
  80655e:	66 85 d2             	test   %dx,%dx
  806561:	b8 01 00 00 00       	mov    $0x1,%eax
  806566:	0f 44 d0             	cmove  %eax,%edx
  806569:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80656d:	83 fb cc             	cmp    $0xffffffcc,%ebx
  806570:	0f 84 c5 00 00 00    	je     80663b <dhcp_bind+0x184>
  806576:	8b 43 34             	mov    0x34(%ebx),%eax
  806579:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  80657c:	85 c0                	test   %eax,%eax
  80657e:	75 49                	jne    8065c9 <dhcp_bind+0x112>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  806580:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  806587:	e8 29 44 00 00       	call   80a9b5 <ntohl>
  80658c:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  80658f:	84 c0                	test   %al,%al
  806591:	78 11                	js     8065a4 <dhcp_bind+0xed>
      sn_mask.addr = htonl(0xff000000);
  806593:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  80659a:	e8 f5 41 00 00       	call   80a794 <htonl>
  80659f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8065a2:	eb 25                	jmp    8065c9 <dhcp_bind+0x112>
    } else if (first_octet >= 192) {
  8065a4:	3c bf                	cmp    $0xbf,%al
  8065a6:	76 12                	jbe    8065ba <dhcp_bind+0x103>
      sn_mask.addr = htonl(0xffffff00);
  8065a8:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  8065af:	90                   	nop
  8065b0:	e8 df 41 00 00       	call   80a794 <htonl>
  8065b5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8065b8:	eb 0f                	jmp    8065c9 <dhcp_bind+0x112>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  8065ba:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  8065c1:	e8 ce 41 00 00       	call   80a794 <htonl>
  8065c6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8065c9:	83 fb c8             	cmp    $0xffffffc8,%ebx
  8065cc:	74 79                	je     806647 <dhcp_bind+0x190>
  8065ce:	8b 43 38             	mov    0x38(%ebx),%eax
  8065d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  8065d4:	85 c0                	test   %eax,%eax
  8065d6:	75 1a                	jne    8065f2 <dhcp_bind+0x13b>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8065d8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8065db:	23 7b 30             	and    0x30(%ebx),%edi
  8065de:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  8065e1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8065e8:	e8 a7 41 00 00       	call   80a794 <htonl>
  8065ed:	09 c7                	or     %eax,%edi
  8065ef:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  8065f2:	8d 43 30             	lea    0x30(%ebx),%eax
  8065f5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8065f9:	89 34 24             	mov    %esi,(%esp)
  8065fc:	e8 d3 0d 00 00       	call   8073d4 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  806601:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  806604:	89 44 24 04          	mov    %eax,0x4(%esp)
  806608:	89 34 24             	mov    %esi,(%esp)
  80660b:	e8 e8 0c 00 00       	call   8072f8 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  806610:	8d 45 e0             	lea    -0x20(%ebp),%eax
  806613:	89 44 24 04          	mov    %eax,0x4(%esp)
  806617:	89 34 24             	mov    %esi,(%esp)
  80661a:	e8 c0 0c 00 00       	call   8072df <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  80661f:	89 34 24             	mov    %esi,(%esp)
  806622:	e8 77 0d 00 00       	call   80739e <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  806627:	ba 0a 00 00 00       	mov    $0xa,%edx
  80662c:	89 d8                	mov    %ebx,%eax
  80662e:	e8 1d ec ff ff       	call   805250 <dhcp_set_state>
}
  806633:	83 c4 2c             	add    $0x2c,%esp
  806636:	5b                   	pop    %ebx
  806637:	5e                   	pop    %esi
  806638:	5f                   	pop    %edi
  806639:	5d                   	pop    %ebp
  80663a:	c3                   	ret    
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80663b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  806642:	e9 39 ff ff ff       	jmp    806580 <dhcp_bind+0xc9>
    } else {
      sn_mask.addr = htonl(0xffff0000);
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  806647:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80664e:	66 90                	xchg   %ax,%ax
  806650:	eb 86                	jmp    8065d8 <dhcp_bind+0x121>

00806652 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  806652:	55                   	push   %ebp
  806653:	89 e5                	mov    %esp,%ebp
  806655:	57                   	push   %edi
  806656:	56                   	push   %esi
  806657:	53                   	push   %ebx
  806658:	83 ec 2c             	sub    $0x2c,%esp
  struct netif *netif = (struct netif *)arg;
  80665b:	8b 45 08             	mov    0x8(%ebp),%eax
  80665e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  struct dhcp *dhcp = netif->dhcp;
  806661:	8b 50 20             	mov    0x20(%eax),%edx
  806664:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  806667:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80666a:	8b 71 04             	mov    0x4(%ecx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  80666d:	89 4a 0c             	mov    %ecx,0xc(%edx)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  806670:	80 3e 02             	cmpb   $0x2,(%esi)
  806673:	0f 85 33 04 00 00    	jne    806aac <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  806679:	0f b6 78 24          	movzbl 0x24(%eax),%edi
  80667d:	89 fb                	mov    %edi,%ebx
  80667f:	84 db                	test   %bl,%bl
  806681:	74 35                	je     8066b8 <dhcp_recv+0x66>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  806683:	0f b6 48 25          	movzbl 0x25(%eax),%ecx
  806687:	89 c2                	mov    %eax,%edx
  806689:	b8 00 00 00 00       	mov    $0x0,%eax
  80668e:	3a 4e 1c             	cmp    0x1c(%esi),%cl
  806691:	74 1c                	je     8066af <dhcp_recv+0x5d>
  806693:	e9 14 04 00 00       	jmp    806aac <dhcp_recv+0x45a>
  806698:	0f b6 5a 26          	movzbl 0x26(%edx),%ebx
  80669c:	0f b6 4c 06 1d       	movzbl 0x1d(%esi,%eax,1),%ecx
  8066a1:	83 c0 01             	add    $0x1,%eax
  8066a4:	83 c2 01             	add    $0x1,%edx
  8066a7:	38 cb                	cmp    %cl,%bl
  8066a9:	0f 85 fd 03 00 00    	jne    806aac <dhcp_recv+0x45a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8066af:	8d 48 01             	lea    0x1(%eax),%ecx
  8066b2:	89 fb                	mov    %edi,%ebx
  8066b4:	38 cb                	cmp    %cl,%bl
  8066b6:	77 e0                	ja     806698 <dhcp_recv+0x46>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8066b8:	8b 46 04             	mov    0x4(%esi),%eax
  8066bb:	89 04 24             	mov    %eax,(%esp)
  8066be:	e8 f2 42 00 00       	call   80a9b5 <ntohl>
  8066c3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8066c6:	3b 42 04             	cmp    0x4(%edx),%eax
  8066c9:	0f 85 dd 03 00 00    	jne    806aac <dhcp_recv+0x45a>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  8066cf:	85 d2                	test   %edx,%edx
  8066d1:	75 1c                	jne    8066ef <dhcp_recv+0x9d>
  8066d3:	c7 44 24 08 54 2f 81 	movl   $0x812f54,0x8(%esp)
  8066da:	00 
  8066db:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  8066e2:	00 
  8066e3:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8066ea:	e8 25 a2 ff ff       	call   800914 <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8066ef:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8066f2:	83 79 0c 00          	cmpl   $0x0,0xc(%ecx)
  8066f6:	75 1c                	jne    806714 <dhcp_recv+0xc2>
  8066f8:	c7 44 24 08 61 2f 81 	movl   $0x812f61,0x8(%esp)
  8066ff:	00 
  806700:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  806707:	00 
  806708:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80670f:	e8 00 a2 ff ff       	call   800914 <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  806714:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806717:	e8 e4 ef ff ff       	call   805700 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80671c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80671f:	8b 43 0c             	mov    0xc(%ebx),%eax
  806722:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  806726:	66 3d f0 00          	cmp    $0xf0,%ax
  80672a:	76 1e                	jbe    80674a <dhcp_recv+0xf8>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80672c:	66 2d f0 00          	sub    $0xf0,%ax
  806730:	66 89 43 18          	mov    %ax,0x18(%ebx)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  806734:	0f b7 c0             	movzwl %ax,%eax
  806737:	89 04 24             	mov    %eax,(%esp)
  80673a:	e8 a1 04 00 00       	call   806be0 <mem_malloc>
  80673f:	89 43 14             	mov    %eax,0x14(%ebx)
    if (dhcp->options_in == NULL) {
  806742:	85 c0                	test   %eax,%eax
  806744:	0f 84 62 03 00 00    	je     806aac <dhcp_recv+0x45a>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80674a:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  806751:	e8 8a 04 00 00       	call   806be0 <mem_malloc>
  806756:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806759:	89 42 10             	mov    %eax,0x10(%edx)
  if (dhcp->msg_in == NULL) {
  80675c:	85 c0                	test   %eax,%eax
  80675e:	75 1a                	jne    80677a <dhcp_recv+0x128>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  806760:	8b 42 14             	mov    0x14(%edx),%eax
  806763:	89 04 24             	mov    %eax,(%esp)
  806766:	e8 0a 08 00 00       	call   806f75 <mem_free>
    dhcp->options_in = NULL;
  80676b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80676e:	c7 41 14 00 00 00 00 	movl   $0x0,0x14(%ecx)
  806775:	e9 32 03 00 00       	jmp    806aac <dhcp_recv+0x45a>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80677a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  806781:	00 
  806782:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  806789:	00 
  80678a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80678e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806791:	8b 43 0c             	mov    0xc(%ebx),%eax
  806794:	89 04 24             	mov    %eax,(%esp)
  806797:	e8 6a 0f 00 00       	call   807706 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80679c:	66 3d f0 00          	cmp    $0xf0,%ax
  8067a0:	74 1c                	je     8067be <dhcp_recv+0x16c>
  8067a2:	c7 44 24 08 d0 2e 81 	movl   $0x812ed0,0x8(%esp)
  8067a9:	00 
  8067aa:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  8067b1:	00 
  8067b2:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8067b9:	e8 56 a1 ff ff       	call   800914 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  8067be:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8067c1:	8b 42 14             	mov    0x14(%edx),%eax
  8067c4:	85 c0                	test   %eax,%eax
  8067c6:	0f 84 fd 02 00 00    	je     806ac9 <dhcp_recv+0x477>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8067cc:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  8067d3:	00 
  8067d4:	89 d1                	mov    %edx,%ecx
  8067d6:	0f b7 52 18          	movzwl 0x18(%edx),%edx
  8067da:	89 54 24 08          	mov    %edx,0x8(%esp)
  8067de:	89 44 24 04          	mov    %eax,0x4(%esp)
  8067e2:	8b 41 0c             	mov    0xc(%ecx),%eax
  8067e5:	89 04 24             	mov    %eax,(%esp)
  8067e8:	e8 19 0f 00 00       	call   807706 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8067ed:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8067f0:	66 3b 43 18          	cmp    0x18(%ebx),%ax
  8067f4:	0f 84 cf 02 00 00    	je     806ac9 <dhcp_recv+0x477>
  8067fa:	c7 44 24 08 71 2f 81 	movl   $0x812f71,0x8(%esp)
  806801:	00 
  806802:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  806809:	00 
  80680a:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  806811:	e8 fe a0 ff ff       	call   800914 <_panic>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  806816:	83 c0 02             	add    $0x2,%eax
  806819:	e8 4d eb ff ff       	call   80536b <dhcp_get_option_byte>
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80681e:	3c 05                	cmp    $0x5,%al
  806820:	0f 85 a5 01 00 00    	jne    8069cb <dhcp_recv+0x379>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  806826:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806829:	0f b6 02             	movzbl (%edx),%eax
  80682c:	3c 01                	cmp    $0x1,%al
  80682e:	0f 85 76 01 00 00    	jne    8069aa <dhcp_recv+0x358>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806834:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806837:	8b 59 20             	mov    0x20(%ecx),%ebx
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  80683a:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  dhcp->offered_gw_addr.addr = 0;
  806841:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_bc_addr.addr = 0;
  806848:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  80684f:	ba 33 00 00 00       	mov    $0x33,%edx
  806854:	89 d8                	mov    %ebx,%eax
  806856:	e8 04 ea ff ff       	call   80525f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80685b:	85 c0                	test   %eax,%eax
  80685d:	74 0b                	je     80686a <dhcp_recv+0x218>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  80685f:	83 c0 02             	add    $0x2,%eax
  806862:	e8 0c eb ff ff       	call   805373 <dhcp_get_option_long>
  806867:	89 43 4c             	mov    %eax,0x4c(%ebx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80686a:	ba 3a 00 00 00       	mov    $0x3a,%edx
  80686f:	89 d8                	mov    %ebx,%eax
  806871:	e8 e9 e9 ff ff       	call   80525f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806876:	85 c0                	test   %eax,%eax
  806878:	74 0d                	je     806887 <dhcp_recv+0x235>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  80687a:	83 c0 02             	add    $0x2,%eax
  80687d:	e8 f1 ea ff ff       	call   805373 <dhcp_get_option_long>
  806882:	89 43 50             	mov    %eax,0x50(%ebx)
  806885:	eb 08                	jmp    80688f <dhcp_recv+0x23d>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  806887:	8b 43 4c             	mov    0x4c(%ebx),%eax
  80688a:	d1 e8                	shr    %eax
  80688c:	89 43 50             	mov    %eax,0x50(%ebx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  80688f:	ba 3b 00 00 00       	mov    $0x3b,%edx
  806894:	89 d8                	mov    %ebx,%eax
  806896:	e8 c4 e9 ff ff       	call   80525f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80689b:	85 c0                	test   %eax,%eax
  80689d:	74 0d                	je     8068ac <dhcp_recv+0x25a>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  80689f:	83 c0 02             	add    $0x2,%eax
  8068a2:	e8 cc ea ff ff       	call   805373 <dhcp_get_option_long>
  8068a7:	89 43 54             	mov    %eax,0x54(%ebx)
  8068aa:	eb 06                	jmp    8068b2 <dhcp_recv+0x260>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  8068ac:	8b 43 4c             	mov    0x4c(%ebx),%eax
  8068af:	89 43 54             	mov    %eax,0x54(%ebx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8068b2:	8b 53 10             	mov    0x10(%ebx),%edx
  8068b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8068ba:	83 fa f0             	cmp    $0xfffffff0,%edx
  8068bd:	74 03                	je     8068c2 <dhcp_recv+0x270>
  8068bf:	8b 42 10             	mov    0x10(%edx),%eax
  8068c2:	89 43 30             	mov    %eax,0x30(%ebx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8068c5:	ba 01 00 00 00       	mov    $0x1,%edx
  8068ca:	89 d8                	mov    %ebx,%eax
  8068cc:	e8 8e e9 ff ff       	call   80525f <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  8068d1:	85 c0                	test   %eax,%eax
  8068d3:	74 13                	je     8068e8 <dhcp_recv+0x296>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8068d5:	83 c0 02             	add    $0x2,%eax
  8068d8:	e8 96 ea ff ff       	call   805373 <dhcp_get_option_long>
  8068dd:	89 04 24             	mov    %eax,(%esp)
  8068e0:	e8 af 3e 00 00       	call   80a794 <htonl>
  8068e5:	89 43 34             	mov    %eax,0x34(%ebx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8068e8:	ba 03 00 00 00       	mov    $0x3,%edx
  8068ed:	89 d8                	mov    %ebx,%eax
  8068ef:	e8 6b e9 ff ff       	call   80525f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8068f4:	85 c0                	test   %eax,%eax
  8068f6:	74 13                	je     80690b <dhcp_recv+0x2b9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8068f8:	83 c0 02             	add    $0x2,%eax
  8068fb:	e8 73 ea ff ff       	call   805373 <dhcp_get_option_long>
  806900:	89 04 24             	mov    %eax,(%esp)
  806903:	e8 8c 3e 00 00       	call   80a794 <htonl>
  806908:	89 43 38             	mov    %eax,0x38(%ebx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  80690b:	ba 1c 00 00 00       	mov    $0x1c,%edx
  806910:	89 d8                	mov    %ebx,%eax
  806912:	e8 48 e9 ff ff       	call   80525f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806917:	85 c0                	test   %eax,%eax
  806919:	74 13                	je     80692e <dhcp_recv+0x2dc>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80691b:	83 c0 02             	add    $0x2,%eax
  80691e:	e8 50 ea ff ff       	call   805373 <dhcp_get_option_long>
  806923:	89 04 24             	mov    %eax,(%esp)
  806926:	e8 69 3e 00 00       	call   80a794 <htonl>
  80692b:	89 43 3c             	mov    %eax,0x3c(%ebx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  80692e:	ba 06 00 00 00       	mov    $0x6,%edx
  806933:	89 d8                	mov    %ebx,%eax
  806935:	e8 25 e9 ff ff       	call   80525f <dhcp_get_option_ptr>
  80693a:	89 c6                	mov    %eax,%esi
  if (option_ptr != NULL) {
  80693c:	85 c0                	test   %eax,%eax
  80693e:	74 54                	je     806994 <dhcp_recv+0x342>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  806940:	8d 40 01             	lea    0x1(%eax),%eax
  806943:	e8 23 ea ff ff       	call   80536b <dhcp_get_option_byte>
  806948:	c0 e8 02             	shr    $0x2,%al
  80694b:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  80694e:	83 f8 03             	cmp    $0x3,%eax
  806951:	ba 02 00 00 00       	mov    $0x2,%edx
  806956:	0f 43 c2             	cmovae %edx,%eax
  806959:	89 43 40             	mov    %eax,0x40(%ebx)
  80695c:	bf 00 00 00 00       	mov    $0x0,%edi
  806961:	89 f8                	mov    %edi,%eax
  806963:	89 f7                	mov    %esi,%edi
  806965:	89 de                	mov    %ebx,%esi
  806967:	89 c3                	mov    %eax,%ebx
  806969:	eb 21                	jmp    80698c <dhcp_recv+0x33a>
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  80696b:	0f b6 c3             	movzbl %bl,%eax
  80696e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806971:	8d 44 87 02          	lea    0x2(%edi,%eax,4),%eax
  806975:	e8 f9 e9 ff ff       	call   805373 <dhcp_get_option_long>
  80697a:	89 04 24             	mov    %eax,(%esp)
  80697d:	e8 12 3e 00 00       	call   80a794 <htonl>
  806982:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806985:	89 44 96 44          	mov    %eax,0x44(%esi,%edx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  806989:	83 c3 01             	add    $0x1,%ebx
  80698c:	0f b6 c3             	movzbl %bl,%eax
  80698f:	3b 46 40             	cmp    0x40(%esi),%eax
  806992:	72 d7                	jb     80696b <dhcp_recv+0x319>
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  806994:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806997:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  80699d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8069a0:	e8 d5 fa ff ff       	call   80647a <dhcp_check>
  8069a5:	e9 02 01 00 00       	jmp    806aac <dhcp_recv+0x45a>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  8069aa:	83 e8 03             	sub    $0x3,%eax
  8069ad:	3c 02                	cmp    $0x2,%al
  8069af:	0f 87 f7 00 00 00    	ja     806aac <dhcp_recv+0x45a>
      dhcp->request_timeout = 0;
  8069b5:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8069b8:	66 c7 43 26 00 00    	movw   $0x0,0x26(%ebx)
      dhcp_bind(netif);
  8069be:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8069c1:	e8 f1 fa ff ff       	call   8064b7 <dhcp_bind>
  8069c6:	e9 e1 00 00 00       	jmp    806aac <dhcp_recv+0x45a>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  8069cb:	3c 06                	cmp    $0x6,%al
  8069cd:	0f 85 80 00 00 00    	jne    806a53 <dhcp_recv+0x401>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8069d3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8069d6:	0f b6 02             	movzbl (%edx),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  8069d9:	3c 03                	cmp    $0x3,%al
  8069db:	74 10                	je     8069ed <dhcp_recv+0x39b>
  8069dd:	3c 01                	cmp    $0x1,%al
  8069df:	74 0c                	je     8069ed <dhcp_recv+0x39b>
  8069e1:	3c 04                	cmp    $0x4,%al
  8069e3:	74 08                	je     8069ed <dhcp_recv+0x39b>
  8069e5:	3c 05                	cmp    $0x5,%al
  8069e7:	0f 85 bf 00 00 00    	jne    806aac <dhcp_recv+0x45a>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  8069ed:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8069f0:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  8069f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8069f9:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  8069fc:	89 04 24             	mov    %eax,(%esp)
  8069ff:	e8 74 09 00 00       	call   807378 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  806a04:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  806a0b:	00 
  806a0c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806a0f:	89 14 24             	mov    %edx,(%esp)
  806a12:	e8 bd 09 00 00       	call   8073d4 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  806a17:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  806a1e:	00 
  806a1f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806a22:	89 0c 24             	mov    %ecx,(%esp)
  806a25:	e8 b5 08 00 00       	call   8072df <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  806a2a:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  806a31:	00 
  806a32:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806a35:	89 04 24             	mov    %eax,(%esp)
  806a38:	e8 bb 08 00 00       	call   8072f8 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  806a3d:	ba 0c 00 00 00       	mov    $0xc,%edx
  806a42:	89 d8                	mov    %ebx,%eax
  806a44:	e8 07 e8 ff ff       	call   805250 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  806a49:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806a4c:	e8 e7 f1 ff ff       	call   805c38 <dhcp_discover>
  806a51:	eb 59                	jmp    806aac <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  806a53:	3c 02                	cmp    $0x2,%al
  806a55:	75 55                	jne    806aac <dhcp_recv+0x45a>
  806a57:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806a5a:	80 3a 06             	cmpb   $0x6,(%edx)
  806a5d:	8d 76 00             	lea    0x0(%esi),%esi
  806a60:	75 4a                	jne    806aac <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  806a62:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806a68:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806a6b:	8b 59 20             	mov    0x20(%ecx),%ebx
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  806a6e:	ba 36 00 00 00       	mov    $0x36,%edx
  806a73:	89 d8                	mov    %ebx,%eax
  806a75:	e8 e5 e7 ff ff       	call   80525f <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  806a7a:	85 c0                	test   %eax,%eax
  806a7c:	74 2e                	je     806aac <dhcp_recv+0x45a>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806a7e:	83 c0 02             	add    $0x2,%eax
  806a81:	e8 ed e8 ff ff       	call   805373 <dhcp_get_option_long>
  806a86:	89 04 24             	mov    %eax,(%esp)
  806a89:	e8 06 3d 00 00       	call   80a794 <htonl>
  806a8e:	89 43 2c             	mov    %eax,0x2c(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  806a91:	8b 53 10             	mov    0x10(%ebx),%edx
  806a94:	b8 00 00 00 00       	mov    $0x0,%eax
  806a99:	83 fa f0             	cmp    $0xfffffff0,%edx
  806a9c:	74 03                	je     806aa1 <dhcp_recv+0x44f>
  806a9e:	8b 42 10             	mov    0x10(%edx),%eax
  806aa1:	89 43 30             	mov    %eax,0x30(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  806aa4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806aa7:	e8 c3 f5 ff ff       	call   80606f <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  806aac:	8b 5d 10             	mov    0x10(%ebp),%ebx
  806aaf:	89 1c 24             	mov    %ebx,(%esp)
  806ab2:	e8 c6 0e 00 00       	call   80797d <pbuf_free>
  dhcp->p = NULL;
  806ab7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806aba:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
  806ac1:	83 c4 2c             	add    $0x2c,%esp
  806ac4:	5b                   	pop    %ebx
  806ac5:	5e                   	pop    %esi
  806ac6:	5f                   	pop    %edi
  806ac7:	5d                   	pop    %ebp
  806ac8:	c3                   	ret    
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  806ac9:	ba 35 00 00 00       	mov    $0x35,%edx
  806ace:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806ad1:	e8 89 e7 ff ff       	call   80525f <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  806ad6:	85 c0                	test   %eax,%eax
  806ad8:	0f 85 38 fd ff ff    	jne    806816 <dhcp_recv+0x1c4>
  806ade:	66 90                	xchg   %ax,%ax
  806ae0:	eb ca                	jmp    806aac <dhcp_recv+0x45a>

00806ae2 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  806ae2:	55                   	push   %ebp
  806ae3:	89 e5                	mov    %esp,%ebp
  806ae5:	53                   	push   %ebx
  806ae6:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  806ae9:	8b 1d 04 f0 b3 00    	mov    0xb3f004,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  806aef:	85 db                	test   %ebx,%ebx
  806af1:	0f 84 dd 00 00 00    	je     806bd4 <dhcp_fine_tmr+0xf2>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  806af7:	8b 43 20             	mov    0x20(%ebx),%eax
  806afa:	85 c0                	test   %eax,%eax
  806afc:	0f 84 c8 00 00 00    	je     806bca <dhcp_fine_tmr+0xe8>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  806b02:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  806b06:	66 83 fa 01          	cmp    $0x1,%dx
  806b0a:	76 0c                	jbe    806b18 <dhcp_fine_tmr+0x36>
        netif->dhcp->request_timeout--;
  806b0c:	83 ea 01             	sub    $0x1,%edx
  806b0f:	66 89 50 26          	mov    %dx,0x26(%eax)
  806b13:	e9 b2 00 00 00       	jmp    806bca <dhcp_fine_tmr+0xe8>
      }
      else if (netif->dhcp->request_timeout == 1) {
  806b18:	66 83 fa 01          	cmp    $0x1,%dx
  806b1c:	0f 85 a8 00 00 00    	jne    806bca <dhcp_fine_tmr+0xe8>
        netif->dhcp->request_timeout--;
  806b22:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806b28:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  806b2b:	0f b6 02             	movzbl (%edx),%eax
  806b2e:	3c 0c                	cmp    $0xc,%al
  806b30:	74 04                	je     806b36 <dhcp_fine_tmr+0x54>
  806b32:	3c 06                	cmp    $0x6,%al
  806b34:	75 0f                	jne    806b45 <dhcp_fine_tmr+0x63>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  806b36:	89 d8                	mov    %ebx,%eax
  806b38:	e8 fb f0 ff ff       	call   805c38 <dhcp_discover>
  806b3d:	8d 76 00             	lea    0x0(%esi),%esi
  806b40:	e9 85 00 00 00       	jmp    806bca <dhcp_fine_tmr+0xe8>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  806b45:	3c 01                	cmp    $0x1,%al
  806b47:	75 23                	jne    806b6c <dhcp_fine_tmr+0x8a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  806b49:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  806b4d:	8d 76 00             	lea    0x0(%esi),%esi
  806b50:	77 09                	ja     806b5b <dhcp_fine_tmr+0x79>
      dhcp_select(netif);
  806b52:	89 d8                	mov    %ebx,%eax
  806b54:	e8 16 f5 ff ff       	call   80606f <dhcp_select>
  806b59:	eb 6f                	jmp    806bca <dhcp_fine_tmr+0xe8>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  806b5b:	89 1c 24             	mov    %ebx,(%esp)
  806b5e:	e8 52 ee ff ff       	call   8059b5 <dhcp_release>
      dhcp_discover(netif);
  806b63:	89 d8                	mov    %ebx,%eax
  806b65:	e8 ce f0 ff ff       	call   805c38 <dhcp_discover>
  806b6a:	eb 5e                	jmp    806bca <dhcp_fine_tmr+0xe8>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  806b6c:	3c 08                	cmp    $0x8,%al
  806b6e:	66 90                	xchg   %ax,%ax
  806b70:	75 20                	jne    806b92 <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  806b72:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  806b76:	66 90                	xchg   %ax,%ax
  806b78:	77 0d                	ja     806b87 <dhcp_fine_tmr+0xa5>
      dhcp_check(netif);
  806b7a:	89 d8                	mov    %ebx,%eax
  806b7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  806b80:	e8 f5 f8 ff ff       	call   80647a <dhcp_check>
  806b85:	eb 43                	jmp    806bca <dhcp_fine_tmr+0xe8>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  806b87:	89 d8                	mov    %ebx,%eax
  806b89:	e8 29 f9 ff ff       	call   8064b7 <dhcp_bind>
  806b8e:	66 90                	xchg   %ax,%ax
  806b90:	eb 38                	jmp    806bca <dhcp_fine_tmr+0xe8>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  806b92:	3c 05                	cmp    $0x5,%al
  806b94:	75 11                	jne    806ba7 <dhcp_fine_tmr+0xc5>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  806b96:	89 1c 24             	mov    %ebx,(%esp)
  806b99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  806ba0:	e8 79 ef ff ff       	call   805b1e <dhcp_renew>
  806ba5:	eb 23                	jmp    806bca <dhcp_fine_tmr+0xe8>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  806ba7:	3c 04                	cmp    $0x4,%al
  806ba9:	75 1f                	jne    806bca <dhcp_fine_tmr+0xe8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  806bab:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  806baf:	90                   	nop
  806bb0:	77 09                	ja     806bbb <dhcp_fine_tmr+0xd9>
      dhcp_rebind(netif);
  806bb2:	89 d8                	mov    %ebx,%eax
  806bb4:	e8 d8 f1 ff ff       	call   805d91 <dhcp_rebind>
  806bb9:	eb 0f                	jmp    806bca <dhcp_fine_tmr+0xe8>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  806bbb:	89 1c 24             	mov    %ebx,(%esp)
  806bbe:	e8 f2 ed ff ff       	call   8059b5 <dhcp_release>
      dhcp_discover(netif);
  806bc3:	89 d8                	mov    %ebx,%eax
  806bc5:	e8 6e f0 ff ff       	call   805c38 <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  806bca:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  806bcc:	85 db                	test   %ebx,%ebx
  806bce:	0f 85 23 ff ff ff    	jne    806af7 <dhcp_fine_tmr+0x15>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  806bd4:	83 c4 14             	add    $0x14,%esp
  806bd7:	5b                   	pop    %ebx
  806bd8:	5d                   	pop    %ebp
  806bd9:	c3                   	ret    
  806bda:	00 00                	add    %al,(%eax)
  806bdc:	00 00                	add    %al,(%eax)
	...

00806be0 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  806be0:	55                   	push   %ebp
  806be1:	89 e5                	mov    %esp,%ebp
  806be3:	83 ec 38             	sub    $0x38,%esp
  806be6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806be9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806bec:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806bef:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  806bf2:	85 c0                	test   %eax,%eax
  806bf4:	0f 84 be 01 00 00    	je     806db8 <mem_malloc+0x1d8>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  806bfa:	83 c0 03             	add    $0x3,%eax
  806bfd:	83 e0 fc             	and    $0xfffffffc,%eax
  806c00:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(size < MIN_SIZE_ALIGNED) {
  806c03:	83 f8 0b             	cmp    $0xb,%eax
  806c06:	77 09                	ja     806c11 <mem_malloc+0x31>
  806c08:	c7 45 e4 0c 00 00 00 	movl   $0xc,-0x1c(%ebp)
  806c0f:	eb 0d                	jmp    806c1e <mem_malloc+0x3e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  806c11:	81 7d e4 00 00 22 00 	cmpl   $0x220000,-0x1c(%ebp)
  806c18:	0f 87 9a 01 00 00    	ja     806db8 <mem_malloc+0x1d8>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  806c1e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806c25:	00 
  806c26:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806c2b:	89 04 24             	mov    %eax,(%esp)
  806c2e:	e8 43 67 00 00       	call   80d376 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  806c33:	a1 64 63 a3 00       	mov    0xa36364,%eax
  806c38:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806c3b:	8b 15 5c 63 a3 00    	mov    0xa3635c,%edx
  806c41:	29 d0                	sub    %edx,%eax
  806c43:	b9 00 00 22 00       	mov    $0x220000,%ecx
  806c48:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
  806c4b:	39 c8                	cmp    %ecx,%eax
  806c4d:	0f 83 51 01 00 00    	jae    806da4 <mem_malloc+0x1c4>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  806c53:	89 55 e0             	mov    %edx,-0x20(%ebp)
  806c56:	8b 75 e0             	mov    -0x20(%ebp),%esi
  806c59:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  806c5c:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  806c60:	0f 85 34 01 00 00    	jne    806d9a <mem_malloc+0x1ba>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  806c66:	8b 3b                	mov    (%ebx),%edi
  806c68:	83 ef 0c             	sub    $0xc,%edi
  806c6b:	29 c7                	sub    %eax,%edi
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  806c6d:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  806c70:	0f 87 24 01 00 00    	ja     806d9a <mem_malloc+0x1ba>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  806c76:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806c79:	83 c2 18             	add    $0x18,%edx
  806c7c:	39 d7                	cmp    %edx,%edi
  806c7e:	72 2a                	jb     806caa <mem_malloc+0xca>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  806c80:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806c83:	8d 4c 02 0c          	lea    0xc(%edx,%eax,1),%ecx
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  806c87:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  806c8a:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  806c8e:	8b 3b                	mov    (%ebx),%edi
  806c90:	89 3a                	mov    %edi,(%edx)
          mem2->prev = ptr;
  806c92:	89 42 04             	mov    %eax,0x4(%edx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  806c95:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  806c97:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  806c9b:	8b 02                	mov    (%edx),%eax
  806c9d:	3d 00 00 22 00       	cmp    $0x220000,%eax
  806ca2:	74 0a                	je     806cae <mem_malloc+0xce>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  806ca4:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  806ca8:	eb 04                	jmp    806cae <mem_malloc+0xce>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  806caa:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  806cae:	39 5d dc             	cmp    %ebx,-0x24(%ebp)
  806cb1:	75 67                	jne    806d1a <mem_malloc+0x13a>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  806cb3:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  806cb6:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  806cba:	84 c0                	test   %al,%al
  806cbc:	74 31                	je     806cef <mem_malloc+0x10f>
  806cbe:	8b 15 60 63 a3 00    	mov    0xa36360,%edx
  806cc4:	39 d1                	cmp    %edx,%ecx
  806cc6:	74 52                	je     806d1a <mem_malloc+0x13a>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  806cc8:	8b 09                	mov    (%ecx),%ecx
  806cca:	8d 0c 0e             	lea    (%esi,%ecx,1),%ecx
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  806ccd:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  806cd1:	84 c0                	test   %al,%al
  806cd3:	75 0b                	jne    806ce0 <mem_malloc+0x100>
  806cd5:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  806cd8:	89 0d 64 63 a3 00    	mov    %ecx,0xa36364
  806cde:	eb 0f                	jmp    806cef <mem_malloc+0x10f>
  806ce0:	39 d1                	cmp    %edx,%ecx
  806ce2:	75 e4                	jne    806cc8 <mem_malloc+0xe8>
  806ce4:	89 4d dc             	mov    %ecx,-0x24(%ebp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
  806ce7:	89 0d 64 63 a3 00    	mov    %ecx,0xa36364
  806ced:	eb 2b                	jmp    806d1a <mem_malloc+0x13a>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  806cef:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806cf2:	3b 15 60 63 a3 00    	cmp    0xa36360,%edx
  806cf8:	74 20                	je     806d1a <mem_malloc+0x13a>
  806cfa:	84 c0                	test   %al,%al
  806cfc:	74 1c                	je     806d1a <mem_malloc+0x13a>
  806cfe:	c7 44 24 08 8d 2f 81 	movl   $0x812f8d,0x8(%esp)
  806d05:	00 
  806d06:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
  806d0d:	00 
  806d0e:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806d15:	e8 fa 9b ff ff       	call   800914 <_panic>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  806d1a:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806d1f:	89 04 24             	mov    %eax,(%esp)
  806d22:	e8 40 69 00 00       	call   80d667 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  806d27:	89 d8                	mov    %ebx,%eax
  806d29:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806d2c:	8d 54 19 0c          	lea    0xc(%ecx,%ebx,1),%edx
  806d30:	3b 15 60 63 a3 00    	cmp    0xa36360,%edx
  806d36:	76 1c                	jbe    806d54 <mem_malloc+0x174>
  806d38:	c7 44 24 08 30 30 81 	movl   $0x813030,0x8(%esp)
  806d3f:	00 
  806d40:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  806d47:	00 
  806d48:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806d4f:	e8 c0 9b ff ff       	call   800914 <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  806d54:	f6 c3 03             	test   $0x3,%bl
  806d57:	74 1c                	je     806d75 <mem_malloc+0x195>
  806d59:	c7 44 24 08 60 30 81 	movl   $0x813060,0x8(%esp)
  806d60:	00 
  806d61:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  806d68:	00 
  806d69:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806d70:	e8 9f 9b ff ff       	call   800914 <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  806d75:	a8 03                	test   $0x3,%al
  806d77:	74 1c                	je     806d95 <mem_malloc+0x1b5>
  806d79:	c7 44 24 08 90 30 81 	movl   $0x813090,0x8(%esp)
  806d80:	00 
  806d81:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  806d88:	00 
  806d89:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806d90:	e8 7f 9b ff ff       	call   800914 <_panic>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  806d95:	8d 43 0c             	lea    0xc(%ebx),%eax
  806d98:	eb 23                	jmp    806dbd <mem_malloc+0x1dd>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  806d9a:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  806d9c:	39 c1                	cmp    %eax,%ecx
  806d9e:	0f 87 b2 fe ff ff    	ja     806c56 <mem_malloc+0x76>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  806da4:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806da9:	89 04 24             	mov    %eax,(%esp)
  806dac:	e8 b6 68 00 00       	call   80d667 <sys_sem_signal>
  806db1:	b8 00 00 00 00       	mov    $0x0,%eax
  return NULL;
  806db6:	eb 05                	jmp    806dbd <mem_malloc+0x1dd>
  806db8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806dbd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  806dc0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806dc3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806dc6:	89 ec                	mov    %ebp,%esp
  806dc8:	5d                   	pop    %ebp
  806dc9:	c3                   	ret    

00806dca <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  806dca:	55                   	push   %ebp
  806dcb:	89 e5                	mov    %esp,%ebp
  806dcd:	83 ec 18             	sub    $0x18,%esp
  806dd0:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  806dd3:	89 75 fc             	mov    %esi,-0x4(%ebp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  806dd6:	8b 75 0c             	mov    0xc(%ebp),%esi
  806dd9:	0f af 75 08          	imul   0x8(%ebp),%esi
  806ddd:	89 34 24             	mov    %esi,(%esp)
  806de0:	e8 fb fd ff ff       	call   806be0 <mem_malloc>
  806de5:	89 c3                	mov    %eax,%ebx
  if (p) {
  806de7:	85 c0                	test   %eax,%eax
  806de9:	74 14                	je     806dff <mem_calloc+0x35>
    /* zero the memory */
    memset(p, 0, count * size);
  806deb:	89 74 24 08          	mov    %esi,0x8(%esp)
  806def:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806df6:	00 
  806df7:	89 04 24             	mov    %eax,(%esp)
  806dfa:	e8 97 a4 ff ff       	call   801296 <memset>
  }
  return p;
}
  806dff:	89 d8                	mov    %ebx,%eax
  806e01:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  806e04:	8b 75 fc             	mov    -0x4(%ebp),%esi
  806e07:	89 ec                	mov    %ebp,%esp
  806e09:	5d                   	pop    %ebp
  806e0a:	c3                   	ret    

00806e0b <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  806e0b:	55                   	push   %ebp
  806e0c:	89 e5                	mov    %esp,%ebp
  806e0e:	83 ec 38             	sub    $0x38,%esp
  806e11:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806e14:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806e17:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806e1a:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  806e1d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  806e20:	83 c3 03             	add    $0x3,%ebx
  806e23:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  806e26:	83 fb 0b             	cmp    $0xb,%ebx
  806e29:	77 07                	ja     806e32 <mem_realloc+0x27>
  806e2b:	bb 0c 00 00 00       	mov    $0xc,%ebx
  806e30:	eb 13                	jmp    806e45 <mem_realloc+0x3a>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  806e32:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  806e38:	76 0b                	jbe    806e45 <mem_realloc+0x3a>
  806e3a:	be 00 00 00 00       	mov    $0x0,%esi
  806e3f:	90                   	nop
  806e40:	e9 21 01 00 00       	jmp    806f66 <mem_realloc+0x15b>
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  806e45:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  806e4a:	39 c6                	cmp    %eax,%esi
  806e4c:	72 08                	jb     806e56 <mem_realloc+0x4b>
  806e4e:	3b 35 60 63 a3 00    	cmp    0xa36360,%esi
  806e54:	72 1c                	jb     806e72 <mem_realloc+0x67>
  806e56:	c7 44 24 08 ba 2f 81 	movl   $0x812fba,0x8(%esp)
  806e5d:	00 
  806e5e:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  806e65:	00 
  806e66:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806e6d:	e8 a2 9a ff ff       	call   800914 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  806e72:	8d 7e f4             	lea    -0xc(%esi),%edi
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  806e75:	89 fa                	mov    %edi,%edx
  806e77:	29 c2                	sub    %eax,%edx
  806e79:	89 55 e0             	mov    %edx,-0x20(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  806e7c:	8b 07                	mov    (%edi),%eax
  806e7e:	83 e8 0c             	sub    $0xc,%eax
  806e81:	29 d0                	sub    %edx,%eax
  806e83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  806e86:	39 d8                	cmp    %ebx,%eax
  806e88:	73 1c                	jae    806ea6 <mem_realloc+0x9b>
  806e8a:	c7 44 24 08 b4 30 81 	movl   $0x8130b4,0x8(%esp)
  806e91:	00 
  806e92:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  806e99:	00 
  806e9a:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806ea1:	e8 6e 9a ff ff       	call   800914 <_panic>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  806ea6:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
  806ea9:	0f 84 b7 00 00 00    	je     806f66 <mem_realloc+0x15b>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  806eaf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806eb6:	00 
  806eb7:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806ebc:	89 04 24             	mov    %eax,(%esp)
  806ebf:	e8 b2 64 00 00       	call   80d376 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  806ec4:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  806ec9:	89 c2                	mov    %eax,%edx
  806ecb:	03 17                	add    (%edi),%edx
  if(mem2->used == 0) {
  806ecd:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  806ed1:	75 41                	jne    806f14 <mem_realloc+0x109>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  806ed3:	8b 0a                	mov    (%edx),%ecx
  806ed5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  806ed8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806edb:	8d 5c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ebx
    if (lfree == mem2) {
  806edf:	39 15 64 63 a3 00    	cmp    %edx,0xa36364
  806ee5:	75 09                	jne    806ef0 <mem_realloc+0xe5>
      lfree = (struct mem *)&ram[ptr2];
  806ee7:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  806eea:	89 15 64 63 a3 00    	mov    %edx,0xa36364
    }
    mem2 = (struct mem *)&ram[ptr2];
  806ef0:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  806ef3:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  806ef7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806efa:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  806efc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806eff:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  806f02:	89 1f                	mov    %ebx,(%edi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  806f04:	8b 12                	mov    (%edx),%edx
  806f06:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  806f0c:	74 4b                	je     806f59 <mem_realloc+0x14e>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  806f0e:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
  806f12:	eb 45                	jmp    806f59 <mem_realloc+0x14e>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  806f14:	8d 53 18             	lea    0x18(%ebx),%edx
  806f17:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  806f1a:	72 3d                	jb     806f59 <mem_realloc+0x14e>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  806f1c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806f1f:	8d 5c 13 0c          	lea    0xc(%ebx,%edx,1),%ebx
    mem2 = (struct mem *)&ram[ptr2];
  806f23:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    if (mem2 < lfree) {
      lfree = mem2;
  806f26:	3b 15 64 63 a3 00    	cmp    0xa36364,%edx
  806f2c:	8b 0d 64 63 a3 00    	mov    0xa36364,%ecx
  806f32:	0f 42 ca             	cmovb  %edx,%ecx
  806f35:	89 0d 64 63 a3 00    	mov    %ecx,0xa36364
    }
    mem2->used = 0;
  806f3b:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  806f3f:	8b 0f                	mov    (%edi),%ecx
  806f41:	89 0a                	mov    %ecx,(%edx)
    mem2->prev = ptr;
  806f43:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806f46:	89 4a 04             	mov    %ecx,0x4(%edx)
    mem->next = ptr2;
  806f49:	89 1f                	mov    %ebx,(%edi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  806f4b:	8b 12                	mov    (%edx),%edx
  806f4d:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  806f53:	74 04                	je     806f59 <mem_realloc+0x14e>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  806f55:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  806f59:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806f5e:	89 04 24             	mov    %eax,(%esp)
  806f61:	e8 01 67 00 00       	call   80d667 <sys_sem_signal>
  return rmem;
}
  806f66:	89 f0                	mov    %esi,%eax
  806f68:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  806f6b:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806f6e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806f71:	89 ec                	mov    %ebp,%esp
  806f73:	5d                   	pop    %ebp
  806f74:	c3                   	ret    

00806f75 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  806f75:	55                   	push   %ebp
  806f76:	89 e5                	mov    %esp,%ebp
  806f78:	83 ec 18             	sub    $0x18,%esp
  806f7b:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  806f7e:	89 75 fc             	mov    %esi,-0x4(%ebp)
  806f81:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  806f84:	85 db                	test   %ebx,%ebx
  806f86:	0f 84 7d 01 00 00    	je     807109 <mem_free+0x194>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  806f8c:	f6 c3 03             	test   $0x3,%bl
  806f8f:	74 1c                	je     806fad <mem_free+0x38>
  806f91:	c7 44 24 08 d8 30 81 	movl   $0x8130d8,0x8(%esp)
  806f98:	00 
  806f99:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  806fa0:	00 
  806fa1:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806fa8:	e8 67 99 ff ff       	call   800914 <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  806fad:	3b 1d 5c 63 a3 00    	cmp    0xa3635c,%ebx
  806fb3:	72 08                	jb     806fbd <mem_free+0x48>
  806fb5:	3b 1d 60 63 a3 00    	cmp    0xa36360,%ebx
  806fbb:	72 1c                	jb     806fd9 <mem_free+0x64>
  806fbd:	c7 44 24 08 d4 2f 81 	movl   $0x812fd4,0x8(%esp)
  806fc4:	00 
  806fc5:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  806fcc:	00 
  806fcd:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806fd4:	e8 3b 99 ff ff       	call   800914 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  806fd9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806fe0:	00 
  806fe1:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806fe6:	89 04 24             	mov    %eax,(%esp)
  806fe9:	e8 88 63 00 00       	call   80d376 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  806fee:	83 eb 0c             	sub    $0xc,%ebx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  806ff1:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  806ff5:	75 1c                	jne    807013 <mem_free+0x9e>
  806ff7:	c7 44 24 08 eb 2f 81 	movl   $0x812feb,0x8(%esp)
  806ffe:	00 
  806fff:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  807006:	00 
  807007:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  80700e:	e8 01 99 ff ff       	call   800914 <_panic>
  /* ... and is now unused. */
  mem->used = 0;
  807013:	c6 43 08 00          	movb   $0x0,0x8(%ebx)

  if (mem < lfree) {
  807017:	3b 1d 64 63 a3 00    	cmp    0xa36364,%ebx
  80701d:	73 06                	jae    807025 <mem_free+0xb0>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80701f:	89 1d 64 63 a3 00    	mov    %ebx,0xa36364
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  807025:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  80702a:	39 c3                	cmp    %eax,%ebx
  80702c:	73 1c                	jae    80704a <mem_free+0xd5>
  80702e:	c7 44 24 08 ff 2f 81 	movl   $0x812fff,0x8(%esp)
  807035:	00 
  807036:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  80703d:	00 
  80703e:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  807045:	e8 ca 98 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80704a:	8b 35 60 63 a3 00    	mov    0xa36360,%esi
  807050:	39 f3                	cmp    %esi,%ebx
  807052:	72 1c                	jb     807070 <mem_free+0xfb>
  807054:	c7 44 24 08 16 30 81 	movl   $0x813016,0x8(%esp)
  80705b:	00 
  80705c:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  807063:	00 
  807064:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  80706b:	e8 a4 98 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  807070:	8b 13                	mov    (%ebx),%edx
  807072:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  807078:	76 1c                	jbe    807096 <mem_free+0x121>
  80707a:	c7 44 24 08 fc 30 81 	movl   $0x8130fc,0x8(%esp)
  807081:	00 
  807082:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  807089:	00 
  80708a:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  807091:	e8 7e 98 ff ff       	call   800914 <_panic>

  nmem = (struct mem *)&ram[mem->next];
  807096:	89 c1                	mov    %eax,%ecx
  807098:	8d 14 10             	lea    (%eax,%edx,1),%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80709b:	39 d3                	cmp    %edx,%ebx
  80709d:	74 2d                	je     8070cc <mem_free+0x157>
  80709f:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8070a3:	75 27                	jne    8070cc <mem_free+0x157>
  8070a5:	39 d6                	cmp    %edx,%esi
  8070a7:	74 23                	je     8070cc <mem_free+0x157>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
      lfree = mem;
  8070a9:	3b 15 64 63 a3 00    	cmp    0xa36364,%edx
  8070af:	8b 35 64 63 a3 00    	mov    0xa36364,%esi
  8070b5:	0f 44 f3             	cmove  %ebx,%esi
  8070b8:	89 35 64 63 a3 00    	mov    %esi,0xa36364
    }
    mem->next = nmem->next;
  8070be:	8b 32                	mov    (%edx),%esi
  8070c0:	89 33                	mov    %esi,(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  8070c2:	8b 12                	mov    (%edx),%edx
  8070c4:	89 de                	mov    %ebx,%esi
  8070c6:	29 c6                	sub    %eax,%esi
  8070c8:	89 74 10 04          	mov    %esi,0x4(%eax,%edx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  8070cc:	89 ca                	mov    %ecx,%edx
  8070ce:	03 53 04             	add    0x4(%ebx),%edx
  if (pmem != mem && pmem->used == 0) {
  8070d1:	39 d3                	cmp    %edx,%ebx
  8070d3:	74 27                	je     8070fc <mem_free+0x187>
  8070d5:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8070d9:	75 21                	jne    8070fc <mem_free+0x187>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
      lfree = pmem;
  8070db:	3b 1d 64 63 a3 00    	cmp    0xa36364,%ebx
  8070e1:	8b 35 64 63 a3 00    	mov    0xa36364,%esi
  8070e7:	0f 44 f2             	cmove  %edx,%esi
  8070ea:	89 35 64 63 a3 00    	mov    %esi,0xa36364
    }
    pmem->next = mem->next;
  8070f0:	8b 33                	mov    (%ebx),%esi
  8070f2:	89 32                	mov    %esi,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8070f4:	8b 1b                	mov    (%ebx),%ebx
  8070f6:	29 c2                	sub    %eax,%edx
  8070f8:	89 54 19 04          	mov    %edx,0x4(%ecx,%ebx,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8070fc:	a1 68 63 a3 00       	mov    0xa36368,%eax
  807101:	89 04 24             	mov    %eax,(%esp)
  807104:	e8 5e 65 00 00       	call   80d667 <sys_sem_signal>
}
  807109:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80710c:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80710f:	89 ec                	mov    %ebp,%esp
  807111:	5d                   	pop    %ebp
  807112:	c3                   	ret    

00807113 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  807113:	55                   	push   %ebp
  807114:	89 e5                	mov    %esp,%ebp
  807116:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  807119:	b8 43 63 81 00       	mov    $0x816343,%eax
  80711e:	83 e0 fc             	and    $0xfffffffc,%eax
  807121:	a3 5c 63 a3 00       	mov    %eax,0xa3635c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  807126:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  80712c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  807133:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  807137:	05 00 00 22 00       	add    $0x220000,%eax
  80713c:	a3 60 63 a3 00       	mov    %eax,0xa36360
  ram_end->used = 1;
  807141:	c6 40 08 01          	movb   $0x1,0x8(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  807145:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  80714b:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%eax)

  mem_sem = sys_sem_new(1);
  807152:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  807159:	e8 67 63 00 00       	call   80d4c5 <sys_sem_new>
  80715e:	a3 68 63 a3 00       	mov    %eax,0xa36368

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  807163:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  807168:	a3 64 63 a3 00       	mov    %eax,0xa36364

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  80716d:	c9                   	leave  
  80716e:	c3                   	ret    
	...

00807170 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  807170:	55                   	push   %ebp
  807171:	89 e5                	mov    %esp,%ebp
  807173:	57                   	push   %edi
  807174:	56                   	push   %esi
  807175:	53                   	push   %ebx
  807176:	83 ec 04             	sub    $0x4,%esp
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  807179:	b8 c3 63 a3 00       	mov    $0xa363c3,%eax
  80717e:	83 e0 fc             	and    $0xfffffffc,%eax
  807181:	89 45 f0             	mov    %eax,-0x10(%ebp)
  807184:	bf 00 00 00 00       	mov    $0x0,%edi
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  807189:	c7 84 3f 80 63 a3 00 	movl   $0x0,0xa36380(%edi,%edi,1)
  807190:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  807194:	0f b7 9f ba 31 81 00 	movzwl 0x8131ba(%edi),%ebx
  80719b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80719e:	66 85 db             	test   %bx,%bx
  8071a1:	74 3c                	je     8071df <memp_init+0x6f>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  8071a3:	0f b7 b7 9e 31 81 00 	movzwl 0x81319e(%edi),%esi
  8071aa:	b9 00 00 00 00       	mov    $0x0,%ecx
  8071af:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  8071b4:	89 08                	mov    %ecx,(%eax)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8071b6:	83 c2 01             	add    $0x1,%edx
  8071b9:	89 c1                	mov    %eax,%ecx
  8071bb:	8d 04 30             	lea    (%eax,%esi,1),%eax
  8071be:	66 39 da             	cmp    %bx,%dx
  8071c1:	72 f1                	jb     8071b4 <memp_init+0x44>
 * Initialize this module.
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
  8071c3:	83 eb 01             	sub    $0x1,%ebx
  8071c6:	0f b7 db             	movzwl %bx,%ebx
  8071c9:	8d 43 01             	lea    0x1(%ebx),%eax
  8071cc:	0f af c6             	imul   %esi,%eax
  8071cf:	03 45 f0             	add    -0x10(%ebp),%eax
  8071d2:	0f af de             	imul   %esi,%ebx
  8071d5:	03 5d f0             	add    -0x10(%ebp),%ebx
  8071d8:	89 9c 3f 80 63 a3 00 	mov    %ebx,0xa36380(%edi,%edi,1)
  8071df:	83 c7 02             	add    $0x2,%edi
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  8071e2:	83 ff 1c             	cmp    $0x1c,%edi
  8071e5:	74 05                	je     8071ec <memp_init+0x7c>
  8071e7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8071ea:	eb 9d                	jmp    807189 <memp_init+0x19>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  8071ec:	83 c4 04             	add    $0x4,%esp
  8071ef:	5b                   	pop    %ebx
  8071f0:	5e                   	pop    %esi
  8071f1:	5f                   	pop    %edi
  8071f2:	5d                   	pop    %ebp
  8071f3:	c3                   	ret    

008071f4 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8071f4:	55                   	push   %ebp
  8071f5:	89 e5                	mov    %esp,%ebp
  8071f7:	53                   	push   %ebx
  8071f8:	83 ec 14             	sub    $0x14,%esp
  8071fb:	8b 55 08             	mov    0x8(%ebp),%edx
  8071fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  807201:	85 c0                	test   %eax,%eax
  807203:	74 2d                	je     807232 <memp_free+0x3e>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  807205:	a8 03                	test   $0x3,%al
  807207:	74 1c                	je     807225 <memp_free+0x31>
  807209:	c7 44 24 08 28 31 81 	movl   $0x813128,0x8(%esp)
  807210:	00 
  807211:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  807218:	00 
  807219:	c7 04 24 6b 31 81 00 	movl   $0x81316b,(%esp)
  807220:	e8 ef 96 ff ff       	call   800914 <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  807225:	b9 80 63 a3 00       	mov    $0xa36380,%ecx
  80722a:	8b 1c 91             	mov    (%ecx,%edx,4),%ebx
  80722d:	89 18                	mov    %ebx,(%eax)
  memp_tab[type] = memp;
  80722f:	89 04 91             	mov    %eax,(%ecx,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  807232:	83 c4 14             	add    $0x14,%esp
  807235:	5b                   	pop    %ebx
  807236:	5d                   	pop    %ebp
  807237:	c3                   	ret    

00807238 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  807238:	55                   	push   %ebp
  807239:	89 e5                	mov    %esp,%ebp
  80723b:	83 ec 18             	sub    $0x18,%esp
  80723e:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  807241:	83 fa 0d             	cmp    $0xd,%edx
  807244:	76 1c                	jbe    807262 <memp_malloc+0x2a>
  807246:	c7 44 24 08 80 31 81 	movl   $0x813180,0x8(%esp)
  80724d:	00 
  80724e:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  807255:	00 
  807256:	c7 04 24 6b 31 81 00 	movl   $0x81316b,(%esp)
  80725d:	e8 b2 96 ff ff       	call   800914 <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  807262:	8b 04 95 80 63 a3 00 	mov    0xa36380(,%edx,4),%eax
  
  if (memp != NULL) {    
  807269:	85 c0                	test   %eax,%eax
  80726b:	74 29                	je     807296 <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  80726d:	8b 08                	mov    (%eax),%ecx
  80726f:	89 0c 95 80 63 a3 00 	mov    %ecx,0xa36380(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  807276:	a8 03                	test   $0x3,%al
  807278:	74 1c                	je     807296 <memp_malloc+0x5e>
  80727a:	c7 44 24 08 48 31 81 	movl   $0x813148,0x8(%esp)
  807281:	00 
  807282:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  807289:	00 
  80728a:	c7 04 24 6b 31 81 00 	movl   $0x81316b,(%esp)
  807291:	e8 7e 96 ff ff       	call   800914 <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  807296:	c9                   	leave  
  807297:	c3                   	ret    
	...

008072a0 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  8072a0:	55                   	push   %ebp
  8072a1:	89 e5                	mov    %esp,%ebp
  8072a3:	53                   	push   %ebx
  8072a4:	8b 55 08             	mov    0x8(%ebp),%edx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  8072a7:	b8 00 00 00 00       	mov    $0x0,%eax
  8072ac:	85 d2                	test   %edx,%edx
  8072ae:	74 2c                	je     8072dc <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';
  8072b0:	0f b6 5a 02          	movzbl 0x2(%edx),%ebx
  8072b4:	83 eb 30             	sub    $0x30,%ebx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8072b7:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
  8072bc:	85 c0                	test   %eax,%eax
  8072be:	74 1c                	je     8072dc <netif_find+0x3c>
    if (num == netif->num &&
  8072c0:	38 58 31             	cmp    %bl,0x31(%eax)
  8072c3:	75 11                	jne    8072d6 <netif_find+0x36>
       name[0] == netif->name[0] &&
  8072c5:	0f b6 0a             	movzbl (%edx),%ecx
  8072c8:	3a 48 2f             	cmp    0x2f(%eax),%cl
  8072cb:	75 09                	jne    8072d6 <netif_find+0x36>
       name[1] == netif->name[1]) {
  8072cd:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
  8072d1:	3a 48 30             	cmp    0x30(%eax),%cl
  8072d4:	74 06                	je     8072dc <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8072d6:	8b 00                	mov    (%eax),%eax
  8072d8:	85 c0                	test   %eax,%eax
  8072da:	75 e4                	jne    8072c0 <netif_find+0x20>
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  8072dc:	5b                   	pop    %ebx
  8072dd:	5d                   	pop    %ebp
  8072de:	c3                   	ret    

008072df <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  8072df:	55                   	push   %ebp
  8072e0:	89 e5                	mov    %esp,%ebp
  8072e2:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  8072e5:	b8 00 00 00 00       	mov    $0x0,%eax
  8072ea:	85 d2                	test   %edx,%edx
  8072ec:	74 02                	je     8072f0 <netif_set_gw+0x11>
  8072ee:	8b 02                	mov    (%edx),%eax
  8072f0:	8b 55 08             	mov    0x8(%ebp),%edx
  8072f3:	89 42 0c             	mov    %eax,0xc(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  8072f6:	5d                   	pop    %ebp
  8072f7:	c3                   	ret    

008072f8 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  8072f8:	55                   	push   %ebp
  8072f9:	89 e5                	mov    %esp,%ebp
  8072fb:	8b 55 0c             	mov    0xc(%ebp),%edx
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  8072fe:	b8 00 00 00 00       	mov    $0x0,%eax
  807303:	85 d2                	test   %edx,%edx
  807305:	74 02                	je     807309 <netif_set_netmask+0x11>
  807307:	8b 02                	mov    (%edx),%eax
  807309:	8b 55 08             	mov    0x8(%ebp),%edx
  80730c:	89 42 08             	mov    %eax,0x8(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  80730f:	5d                   	pop    %ebp
  807310:	c3                   	ret    

00807311 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  807311:	55                   	push   %ebp
  807312:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  807314:	8b 45 08             	mov    0x8(%ebp),%eax
  807317:	a3 08 f0 b3 00       	mov    %eax,0xb3f008
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80731c:	5d                   	pop    %ebp
  80731d:	c3                   	ret    

0080731e <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80731e:	55                   	push   %ebp
  80731f:	89 e5                	mov    %esp,%ebp
  807321:	83 ec 04             	sub    $0x4,%esp
  807324:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  807327:	85 c9                	test   %ecx,%ecx
  807329:	74 4b                	je     807376 <netif_remove+0x58>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80732b:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
  807330:	39 c8                	cmp    %ecx,%eax
  807332:	75 1e                	jne    807352 <netif_remove+0x34>
    netif_list = netif->next;
  807334:	8b 00                	mov    (%eax),%eax
  807336:	a3 04 f0 b3 00       	mov    %eax,0xb3f004
  80733b:	eb 25                	jmp    807362 <netif_remove+0x44>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  80733d:	8b 10                	mov    (%eax),%edx
  80733f:	39 ca                	cmp    %ecx,%edx
  807341:	74 08                	je     80734b <netif_remove+0x2d>
  807343:	89 d0                	mov    %edx,%eax
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  807345:	85 c0                	test   %eax,%eax
  807347:	75 f4                	jne    80733d <netif_remove+0x1f>
  807349:	eb 2b                	jmp    807376 <netif_remove+0x58>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
  80734b:	8b 11                	mov    (%ecx),%edx
  80734d:	89 10                	mov    %edx,(%eax)
  80734f:	90                   	nop
  807350:	eb 10                	jmp    807362 <netif_remove+0x44>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  807352:	85 c0                	test   %eax,%eax
  807354:	74 20                	je     807376 <netif_remove+0x58>
      if (tmpNetif->next == netif) {
  807356:	8b 10                	mov    (%eax),%edx
  807358:	39 ca                	cmp    %ecx,%edx
  80735a:	74 ef                	je     80734b <netif_remove+0x2d>
  80735c:	89 d0                	mov    %edx,%eax
  80735e:	66 90                	xchg   %ax,%ax
  807360:	eb e3                	jmp    807345 <netif_remove+0x27>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  807362:	39 0d 08 f0 b3 00    	cmp    %ecx,0xb3f008
  807368:	75 0c                	jne    807376 <netif_remove+0x58>
    /* reset default netif */
    netif_set_default(NULL);
  80736a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  807371:	e8 9b ff ff ff       	call   807311 <netif_set_default>
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  807376:	c9                   	leave  
  807377:	c3                   	ret    

00807378 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  807378:	55                   	push   %ebp
  807379:	89 e5                	mov    %esp,%ebp
  80737b:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  80737e:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  807382:	f6 c2 01             	test   $0x1,%dl
  807385:	74 06                	je     80738d <netif_set_down+0x15>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  807387:	83 e2 fe             	and    $0xfffffffe,%edx
  80738a:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80738d:	5d                   	pop    %ebp
  80738e:	c3                   	ret    

0080738f <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80738f:	55                   	push   %ebp
  807390:	89 e5                	mov    %esp,%ebp
  807392:	8b 45 08             	mov    0x8(%ebp),%eax
  807395:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  807399:	83 e0 01             	and    $0x1,%eax
  return (netif->flags & NETIF_FLAG_UP)?1:0;
}
  80739c:	5d                   	pop    %ebp
  80739d:	c3                   	ret    

0080739e <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80739e:	55                   	push   %ebp
  80739f:	89 e5                	mov    %esp,%ebp
  8073a1:	83 ec 18             	sub    $0x18,%esp
  8073a4:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8073a7:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  8073ab:	f6 c2 01             	test   $0x1,%dl
  8073ae:	75 22                	jne    8073d2 <netif_set_up+0x34>
    netif->flags |= NETIF_FLAG_UP;
  8073b0:	83 ca 01             	or     $0x1,%edx
  8073b3:	88 50 2e             	mov    %dl,0x2e(%eax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  8073b6:	f6 c2 20             	test   $0x20,%dl
  8073b9:	74 17                	je     8073d2 <netif_set_up+0x34>
      etharp_query(netif, &(netif->ip_addr), NULL);
  8073bb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8073c2:	00 
  8073c3:	8d 50 04             	lea    0x4(%eax),%edx
  8073c6:	89 54 24 04          	mov    %edx,0x4(%esp)
  8073ca:	89 04 24             	mov    %eax,(%esp)
  8073cd:	e8 65 53 00 00       	call   80c737 <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  8073d2:	c9                   	leave  
  8073d3:	c3                   	ret    

008073d4 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  8073d4:	55                   	push   %ebp
  8073d5:	89 e5                	mov    %esp,%ebp
  8073d7:	57                   	push   %edi
  8073d8:	56                   	push   %esi
  8073d9:	53                   	push   %ebx
  8073da:	83 ec 1c             	sub    $0x1c,%esp
  8073dd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8073e0:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  8073e3:	8b 06                	mov    (%esi),%eax
  8073e5:	3b 43 04             	cmp    0x4(%ebx),%eax
  8073e8:	74 54                	je     80743e <netif_set_ipaddr+0x6a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  8073ea:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
    while (pcb != NULL) {
  8073ef:	85 c0                	test   %eax,%eax
  8073f1:	74 1d                	je     807410 <netif_set_ipaddr+0x3c>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8073f3:	8b 10                	mov    (%eax),%edx
  8073f5:	3b 53 04             	cmp    0x4(%ebx),%edx
  8073f8:	75 0f                	jne    807409 <netif_set_ipaddr+0x35>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  8073fa:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  8073fd:	89 04 24             	mov    %eax,(%esp)
  807400:	e8 99 16 00 00       	call   808a9e <tcp_abort>
  807405:	89 f8                	mov    %edi,%eax
  807407:	eb 03                	jmp    80740c <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
  807409:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  80740c:	85 c0                	test   %eax,%eax
  80740e:	75 e3                	jne    8073f3 <netif_set_ipaddr+0x1f>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  807410:	a1 14 f0 b3 00       	mov    0xb3f014,%eax
  807415:	85 c0                	test   %eax,%eax
  807417:	74 25                	je     80743e <netif_set_ipaddr+0x6a>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  807419:	b9 00 00 00 00       	mov    $0x0,%ecx
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80741e:	85 c0                	test   %eax,%eax
  807420:	74 15                	je     807437 <netif_set_ipaddr+0x63>
  807422:	8b 10                	mov    (%eax),%edx
  807424:	85 d2                	test   %edx,%edx
  807426:	74 0f                	je     807437 <netif_set_ipaddr+0x63>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  807428:	3b 53 04             	cmp    0x4(%ebx),%edx
  80742b:	75 0a                	jne    807437 <netif_set_ipaddr+0x63>
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80742d:	89 ca                	mov    %ecx,%edx
  80742f:	85 f6                	test   %esi,%esi
  807431:	74 02                	je     807435 <netif_set_ipaddr+0x61>
  807433:	8b 16                	mov    (%esi),%edx
  807435:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  807437:	8b 40 0c             	mov    0xc(%eax),%eax
  80743a:	85 c0                	test   %eax,%eax
  80743c:	75 e0                	jne    80741e <netif_set_ipaddr+0x4a>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80743e:	b8 00 00 00 00       	mov    $0x0,%eax
  807443:	85 f6                	test   %esi,%esi
  807445:	74 02                	je     807449 <netif_set_ipaddr+0x75>
  807447:	8b 06                	mov    (%esi),%eax
  807449:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80744c:	83 c4 1c             	add    $0x1c,%esp
  80744f:	5b                   	pop    %ebx
  807450:	5e                   	pop    %esi
  807451:	5f                   	pop    %edi
  807452:	5d                   	pop    %ebp
  807453:	c3                   	ret    

00807454 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  807454:	55                   	push   %ebp
  807455:	89 e5                	mov    %esp,%ebp
  807457:	53                   	push   %ebx
  807458:	83 ec 14             	sub    $0x14,%esp
  80745b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif_set_ipaddr(netif, ipaddr);
  80745e:	8b 45 0c             	mov    0xc(%ebp),%eax
  807461:	89 44 24 04          	mov    %eax,0x4(%esp)
  807465:	89 1c 24             	mov    %ebx,(%esp)
  807468:	e8 67 ff ff ff       	call   8073d4 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  80746d:	8b 45 10             	mov    0x10(%ebp),%eax
  807470:	89 44 24 04          	mov    %eax,0x4(%esp)
  807474:	89 1c 24             	mov    %ebx,(%esp)
  807477:	e8 7c fe ff ff       	call   8072f8 <netif_set_netmask>
  netif_set_gw(netif, gw);
  80747c:	8b 45 14             	mov    0x14(%ebp),%eax
  80747f:	89 44 24 04          	mov    %eax,0x4(%esp)
  807483:	89 1c 24             	mov    %ebx,(%esp)
  807486:	e8 54 fe ff ff       	call   8072df <netif_set_gw>
}
  80748b:	83 c4 14             	add    $0x14,%esp
  80748e:	5b                   	pop    %ebx
  80748f:	5d                   	pop    %ebp
  807490:	c3                   	ret    

00807491 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  807491:	55                   	push   %ebp
  807492:	89 e5                	mov    %esp,%ebp
  807494:	53                   	push   %ebx
  807495:	83 ec 14             	sub    $0x14,%esp
  807498:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  80749b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  8074a2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  8074a9:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  8074b0:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  8074b4:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  8074bb:	8b 45 18             	mov    0x18(%ebp),%eax
  8074be:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  8074c1:	0f b6 05 24 54 b3 00 	movzbl 0xb35424,%eax
  8074c8:	88 43 31             	mov    %al,0x31(%ebx)
  8074cb:	83 c0 01             	add    $0x1,%eax
  8074ce:	a2 24 54 b3 00       	mov    %al,0xb35424
  netif->input = input;
  8074d3:	8b 45 20             	mov    0x20(%ebp),%eax
  8074d6:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  8074d9:	8b 45 14             	mov    0x14(%ebp),%eax
  8074dc:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8074e0:	8b 45 10             	mov    0x10(%ebp),%eax
  8074e3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8074e7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8074ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  8074ee:	89 1c 24             	mov    %ebx,(%esp)
  8074f1:	e8 5e ff ff ff       	call   807454 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  8074f6:	89 1c 24             	mov    %ebx,(%esp)
  8074f9:	ff 55 1c             	call   *0x1c(%ebp)
  8074fc:	84 c0                	test   %al,%al
  8074fe:	74 07                	je     807507 <netif_add+0x76>
  807500:	bb 00 00 00 00       	mov    $0x0,%ebx
  807505:	eb 0d                	jmp    807514 <netif_add+0x83>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  807507:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
  80750c:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  80750e:	89 1d 04 f0 b3 00    	mov    %ebx,0xb3f004
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  807514:	89 d8                	mov    %ebx,%eax
  807516:	83 c4 14             	add    $0x14,%esp
  807519:	5b                   	pop    %ebx
  80751a:	5d                   	pop    %ebp
  80751b:	c3                   	ret    
  80751c:	00 00                	add    %al,(%eax)
	...

00807520 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  807520:	55                   	push   %ebp
  807521:	89 e5                	mov    %esp,%ebp
  807523:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  while (p != NULL) {
  807526:	b8 00 00 00 00       	mov    $0x0,%eax
  80752b:	85 d2                	test   %edx,%edx
  80752d:	74 09                	je     807538 <pbuf_clen+0x18>
    ++len;
  80752f:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  807532:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  807534:	85 d2                	test   %edx,%edx
  807536:	75 f7                	jne    80752f <pbuf_clen+0xf>
    ++len;
    p = p->next;
  }
  return len;
}
  807538:	5d                   	pop    %ebp
  807539:	c3                   	ret    

0080753a <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  80753a:	55                   	push   %ebp
  80753b:	89 e5                	mov    %esp,%ebp
  80753d:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  807540:	85 c0                	test   %eax,%eax
  807542:	74 05                	je     807549 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  807544:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  807549:	5d                   	pop    %ebp
  80754a:	c3                   	ret    

0080754b <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  80754b:	55                   	push   %ebp
  80754c:	89 e5                	mov    %esp,%ebp
  80754e:	53                   	push   %ebx
  80754f:	83 ec 14             	sub    $0x14,%esp
  807552:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807555:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807558:	85 db                	test   %ebx,%ebx
  80755a:	74 0e                	je     80756a <pbuf_cat+0x1f>
  80755c:	85 c9                	test   %ecx,%ecx
  80755e:	74 0a                	je     80756a <pbuf_cat+0x1f>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807560:	8b 13                	mov    (%ebx),%edx
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807562:	89 d8                	mov    %ebx,%eax
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807564:	85 d2                	test   %edx,%edx
  807566:	75 1e                	jne    807586 <pbuf_cat+0x3b>
  807568:	eb 2c                	jmp    807596 <pbuf_cat+0x4b>
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80756a:	c7 44 24 08 d8 31 81 	movl   $0x8131d8,0x8(%esp)
  807571:	00 
  807572:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  807579:	00 
  80757a:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807581:	e8 8e 93 ff ff       	call   800914 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  807586:	0f b7 51 08          	movzwl 0x8(%ecx),%edx
  80758a:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80758e:	8b 00                	mov    (%eax),%eax
  807590:	8b 10                	mov    (%eax),%edx
  807592:	85 d2                	test   %edx,%edx
  807594:	75 f0                	jne    807586 <pbuf_cat+0x3b>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  807596:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  80759a:	66 3b 58 0a          	cmp    0xa(%eax),%bx
  80759e:	74 1c                	je     8075bc <pbuf_cat+0x71>
  8075a0:	c7 44 24 08 10 32 81 	movl   $0x813210,0x8(%esp)
  8075a7:	00 
  8075a8:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  8075af:	00 
  8075b0:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8075b7:	e8 58 93 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  8075bc:	85 d2                	test   %edx,%edx
  8075be:	74 1c                	je     8075dc <pbuf_cat+0x91>
  8075c0:	c7 44 24 08 82 33 81 	movl   $0x813382,0x8(%esp)
  8075c7:	00 
  8075c8:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  8075cf:	00 
  8075d0:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8075d7:	e8 38 93 ff ff       	call   800914 <_panic>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  8075dc:	66 03 59 08          	add    0x8(%ecx),%bx
  8075e0:	66 89 58 08          	mov    %bx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  8075e4:	89 08                	mov    %ecx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  8075e6:	83 c4 14             	add    $0x14,%esp
  8075e9:	5b                   	pop    %ebx
  8075ea:	5d                   	pop    %ebp
  8075eb:	c3                   	ret    

008075ec <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  8075ec:	55                   	push   %ebp
  8075ed:	89 e5                	mov    %esp,%ebp
  8075ef:	53                   	push   %ebx
  8075f0:	83 ec 14             	sub    $0x14,%esp
  8075f3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  8075f6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8075fa:	8b 45 08             	mov    0x8(%ebp),%eax
  8075fd:	89 04 24             	mov    %eax,(%esp)
  807600:	e8 46 ff ff ff       	call   80754b <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  807605:	89 1c 24             	mov    %ebx,(%esp)
  807608:	e8 2d ff ff ff       	call   80753a <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80760d:	83 c4 14             	add    $0x14,%esp
  807610:	5b                   	pop    %ebx
  807611:	5d                   	pop    %ebp
  807612:	c3                   	ret    

00807613 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  807613:	55                   	push   %ebp
  807614:	89 e5                	mov    %esp,%ebp
  807616:	83 ec 18             	sub    $0x18,%esp
  807619:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80761c:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80761f:	8b 55 08             	mov    0x8(%ebp),%edx
  807622:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  807626:	85 d2                	test   %edx,%edx
  807628:	75 1c                	jne    807646 <pbuf_header+0x33>
  80762a:	c7 44 24 08 4b 34 81 	movl   $0x81344b,0x8(%esp)
  807631:	00 
  807632:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  807639:	00 
  80763a:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807641:	e8 ce 92 ff ff       	call   800914 <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  807646:	b8 00 00 00 00       	mov    $0x0,%eax
  80764b:	66 85 c9             	test   %cx,%cx
  80764e:	0f 84 a8 00 00 00    	je     8076fc <pbuf_header+0xe9>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  807654:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  807656:	66 85 c9             	test   %cx,%cx
  807659:	79 24                	jns    80767f <pbuf_header+0x6c>
    increment_magnitude = -header_size_increment;
  80765b:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80765d:	66 3b 72 0a          	cmp    0xa(%edx),%si
  807661:	76 1c                	jbe    80767f <pbuf_header+0x6c>
  807663:	c7 44 24 08 92 33 81 	movl   $0x813392,0x8(%esp)
  80766a:	00 
  80766b:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  807672:	00 
  807673:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  80767a:	e8 95 92 ff ff       	call   800914 <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  80767f:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  807683:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  807686:	66 85 c0             	test   %ax,%ax
  807689:	74 06                	je     807691 <pbuf_header+0x7e>
  80768b:	66 83 f8 03          	cmp    $0x3,%ax
  80768f:	75 1d                	jne    8076ae <pbuf_header+0x9b>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  807691:	0f bf c1             	movswl %cx,%eax
  807694:	89 de                	mov    %ebx,%esi
  807696:	29 c6                	sub    %eax,%esi
  807698:	89 f0                	mov    %esi,%eax
  80769a:	89 72 04             	mov    %esi,0x4(%edx)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  80769d:	8d 72 10             	lea    0x10(%edx),%esi
  8076a0:	39 f0                	cmp    %esi,%eax
  8076a2:	73 44                	jae    8076e8 <pbuf_header+0xd5>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  8076a4:	89 5a 04             	mov    %ebx,0x4(%edx)
  8076a7:	b8 01 00 00 00       	mov    $0x1,%eax
      /* bail out unsuccesfully */
      return 1;
  8076ac:	eb 4e                	jmp    8076fc <pbuf_header+0xe9>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  8076ae:	83 e8 01             	sub    $0x1,%eax
  8076b1:	66 83 f8 01          	cmp    $0x1,%ax
  8076b5:	77 15                	ja     8076cc <pbuf_header+0xb9>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8076b7:	66 85 c9             	test   %cx,%cx
  8076ba:	79 3b                	jns    8076f7 <pbuf_header+0xe4>
  8076bc:	66 3b 72 0a          	cmp    0xa(%edx),%si
  8076c0:	77 35                	ja     8076f7 <pbuf_header+0xe4>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  8076c2:	0f bf c1             	movswl %cx,%eax
  8076c5:	29 c3                	sub    %eax,%ebx
  8076c7:	89 5a 04             	mov    %ebx,0x4(%edx)
  8076ca:	eb 1c                	jmp    8076e8 <pbuf_header+0xd5>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  8076cc:	c7 44 24 08 b0 33 81 	movl   $0x8133b0,0x8(%esp)
  8076d3:	00 
  8076d4:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  8076db:	00 
  8076dc:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8076e3:	e8 2c 92 ff ff       	call   800914 <_panic>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8076e8:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  8076ec:	66 01 4a 08          	add    %cx,0x8(%edx)
  8076f0:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  8076f5:	eb 05                	jmp    8076fc <pbuf_header+0xe9>
  8076f7:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8076fc:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8076ff:	8b 75 fc             	mov    -0x4(%ebp),%esi
  807702:	89 ec                	mov    %ebp,%esp
  807704:	5d                   	pop    %ebp
  807705:	c3                   	ret    

00807706 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  807706:	55                   	push   %ebp
  807707:	89 e5                	mov    %esp,%ebp
  807709:	57                   	push   %edi
  80770a:	56                   	push   %esi
  80770b:	53                   	push   %ebx
  80770c:	83 ec 2c             	sub    $0x2c,%esp
  80770f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807712:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  807716:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80771a:	85 db                	test   %ebx,%ebx
  80771c:	75 1c                	jne    80773a <pbuf_copy_partial+0x34>
  80771e:	c7 44 24 08 40 32 81 	movl   $0x813240,0x8(%esp)
  807725:	00 
  807726:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  80772d:	00 
  80772e:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807735:	e8 da 91 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80773a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80773e:	75 1c                	jne    80775c <pbuf_copy_partial+0x56>
  807740:	c7 44 24 08 64 32 81 	movl   $0x813264,0x8(%esp)
  807747:	00 
  807748:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  80774f:	00 
  807750:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807757:	e8 b8 91 ff ff       	call   800914 <_panic>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80775c:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  807762:	66 85 f6             	test   %si,%si
  807765:	74 61                	je     8077c8 <pbuf_copy_partial+0xc2>
  807767:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    if ((offset != 0) && (offset >= p->len)) {
  80776d:	66 85 c0             	test   %ax,%ax
  807770:	74 0e                	je     807780 <pbuf_copy_partial+0x7a>
  807772:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807776:	66 39 c2             	cmp    %ax,%dx
  807779:	77 05                	ja     807780 <pbuf_copy_partial+0x7a>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80777b:	66 29 d0             	sub    %dx,%ax
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  80777e:	eb 3d                	jmp    8077bd <pbuf_copy_partial+0xb7>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  807780:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  807784:	66 29 c7             	sub    %ax,%di
  807787:	66 39 f7             	cmp    %si,%di
  80778a:	0f 47 fe             	cmova  %esi,%edi
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80778d:	0f b7 d7             	movzwl %di,%edx
  807790:	89 54 24 08          	mov    %edx,0x8(%esp)
  807794:	0f b7 c0             	movzwl %ax,%eax
  807797:	03 43 04             	add    0x4(%ebx),%eax
  80779a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80779e:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8077a2:	03 45 0c             	add    0xc(%ebp),%eax
  8077a5:	89 04 24             	mov    %eax,(%esp)
  8077a8:	e8 c4 9b ff ff       	call   801371 <memcpy>
      copied_total += buf_copy_len;
  8077ad:	66 01 7d e4          	add    %di,-0x1c(%ebp)
      left += buf_copy_len;
  8077b1:	66 01 7d e6          	add    %di,-0x1a(%ebp)
      len -= buf_copy_len;
  8077b5:	66 29 fe             	sub    %di,%si
  8077b8:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  8077bd:	8b 1b                	mov    (%ebx),%ebx
  8077bf:	66 85 f6             	test   %si,%si
  8077c2:	74 04                	je     8077c8 <pbuf_copy_partial+0xc2>
  8077c4:	85 db                	test   %ebx,%ebx
  8077c6:	75 a5                	jne    80776d <pbuf_copy_partial+0x67>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  8077c8:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8077cc:	83 c4 2c             	add    $0x2c,%esp
  8077cf:	5b                   	pop    %ebx
  8077d0:	5e                   	pop    %esi
  8077d1:	5f                   	pop    %edi
  8077d2:	5d                   	pop    %ebp
  8077d3:	c3                   	ret    

008077d4 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  8077d4:	55                   	push   %ebp
  8077d5:	89 e5                	mov    %esp,%ebp
  8077d7:	57                   	push   %edi
  8077d8:	56                   	push   %esi
  8077d9:	53                   	push   %ebx
  8077da:	83 ec 4c             	sub    $0x4c,%esp
  8077dd:	8b 75 08             	mov    0x8(%ebp),%esi
  8077e0:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  8077e3:	85 f6                	test   %esi,%esi
  8077e5:	0f 94 c0             	sete   %al
  8077e8:	74 0e                	je     8077f8 <pbuf_copy+0x24>
  8077ea:	85 db                	test   %ebx,%ebx
  8077ec:	74 0a                	je     8077f8 <pbuf_copy+0x24>
  8077ee:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  8077f2:	66 3b 53 08          	cmp    0x8(%ebx),%dx
  8077f6:	73 1c                	jae    807814 <pbuf_copy+0x40>
  8077f8:	c7 44 24 08 8c 32 81 	movl   $0x81328c,0x8(%esp)
  8077ff:	00 
  807800:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  807807:	00 
  807808:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  80780f:	e8 00 91 ff ff       	call   800914 <_panic>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  807814:	84 c0                	test   %al,%al
  807816:	74 26                	je     80783e <pbuf_copy+0x6a>
  807818:	eb 08                	jmp    807822 <pbuf_copy+0x4e>
  80781a:	85 f6                	test   %esi,%esi
  80781c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  807820:	75 27                	jne    807849 <pbuf_copy+0x75>
  807822:	c7 44 24 08 be 33 81 	movl   $0x8133be,0x8(%esp)
  807829:	00 
  80782a:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  807831:	00 
  807832:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807839:	e8 d6 90 ff ff       	call   800914 <_panic>
  80783e:	bf 00 00 00 00       	mov    $0x0,%edi
  807843:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  807849:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  80784d:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807851:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807855:	29 c2                	sub    %eax,%edx
  807857:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80785a:	0f b7 d1             	movzwl %cx,%edx
  80785d:	0f b7 c7             	movzwl %di,%eax
  807860:	29 c2                	sub    %eax,%edx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  807862:	66 29 f9             	sub    %di,%cx
  807865:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807869:	66 2b 45 e6          	sub    -0x1a(%ebp),%ax
  80786d:	39 55 c4             	cmp    %edx,-0x3c(%ebp)
  807870:	89 ca                	mov    %ecx,%edx
  807872:	0f 4c d0             	cmovl  %eax,%edx
  807875:	66 89 55 c8          	mov    %dx,-0x38(%ebp)
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  807879:	0f b7 c2             	movzwl %dx,%eax
  80787c:	89 44 24 08          	mov    %eax,0x8(%esp)
  807880:	0f b7 c7             	movzwl %di,%eax
  807883:	03 43 04             	add    0x4(%ebx),%eax
  807886:	89 44 24 04          	mov    %eax,0x4(%esp)
  80788a:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80788e:	03 46 04             	add    0x4(%esi),%eax
  807891:	89 04 24             	mov    %eax,(%esp)
  807894:	e8 d8 9a ff ff       	call   801371 <memcpy>
    offset_to += len;
  807899:	0f b7 45 c8          	movzwl -0x38(%ebp),%eax
  80789d:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  8078a1:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8078a5:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  8078a9:	76 1c                	jbe    8078c7 <pbuf_copy+0xf3>
  8078ab:	c7 44 24 08 cb 33 81 	movl   $0x8133cb,0x8(%esp)
  8078b2:	00 
  8078b3:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  8078ba:	00 
  8078bb:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8078c2:	e8 4d 90 ff ff       	call   800914 <_panic>
    if (offset_to == p_to->len) {
  8078c7:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  8078cb:	75 08                	jne    8078d5 <pbuf_copy+0x101>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  8078cd:	8b 36                	mov    (%esi),%esi
  8078cf:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
  8078d5:	66 03 7d c8          	add    -0x38(%ebp),%di
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  8078d9:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8078dd:	66 39 c7             	cmp    %ax,%di
  8078e0:	76 1c                	jbe    8078fe <pbuf_copy+0x12a>
  8078e2:	c7 44 24 08 e2 33 81 	movl   $0x8133e2,0x8(%esp)
  8078e9:	00 
  8078ea:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  8078f1:	00 
  8078f2:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8078f9:	e8 16 90 ff ff       	call   800914 <_panic>
    if (offset_from >= p_from->len) {
  8078fe:	66 39 c7             	cmp    %ax,%di
  807901:	72 07                	jb     80790a <pbuf_copy+0x136>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  807903:	8b 1b                	mov    (%ebx),%ebx
  807905:	bf 00 00 00 00       	mov    $0x0,%edi
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80790a:	85 db                	test   %ebx,%ebx
  80790c:	74 2b                	je     807939 <pbuf_copy+0x165>
  80790e:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807912:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  807916:	75 21                	jne    807939 <pbuf_copy+0x165>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807918:	83 3b 00             	cmpl   $0x0,(%ebx)
  80791b:	74 1c                	je     807939 <pbuf_copy+0x165>
  80791d:	c7 44 24 08 bc 32 81 	movl   $0x8132bc,0x8(%esp)
  807924:	00 
  807925:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  80792c:	00 
  80792d:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807934:	e8 db 8f ff ff       	call   800914 <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  807939:	85 f6                	test   %esi,%esi
  80793b:	74 2b                	je     807968 <pbuf_copy+0x194>
  80793d:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807941:	66 3b 46 08          	cmp    0x8(%esi),%ax
  807945:	75 21                	jne    807968 <pbuf_copy+0x194>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807947:	83 3e 00             	cmpl   $0x0,(%esi)
  80794a:	74 1c                	je     807968 <pbuf_copy+0x194>
  80794c:	c7 44 24 08 bc 32 81 	movl   $0x8132bc,0x8(%esp)
  807953:	00 
  807954:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  80795b:	00 
  80795c:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807963:	e8 ac 8f ff ff       	call   800914 <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  807968:	85 db                	test   %ebx,%ebx
  80796a:	0f 85 aa fe ff ff    	jne    80781a <pbuf_copy+0x46>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  807970:	b8 00 00 00 00       	mov    $0x0,%eax
  807975:	83 c4 4c             	add    $0x4c,%esp
  807978:	5b                   	pop    %ebx
  807979:	5e                   	pop    %esi
  80797a:	5f                   	pop    %edi
  80797b:	5d                   	pop    %ebp
  80797c:	c3                   	ret    

0080797d <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80797d:	55                   	push   %ebp
  80797e:	89 e5                	mov    %esp,%ebp
  807980:	56                   	push   %esi
  807981:	53                   	push   %ebx
  807982:	83 ec 10             	sub    $0x10,%esp
  807985:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  807988:	85 c0                	test   %eax,%eax
  80798a:	75 1c                	jne    8079a8 <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  80798c:	c7 44 24 08 4b 34 81 	movl   $0x81344b,0x8(%esp)
  807993:	00 
  807994:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  80799b:	00 
  80799c:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8079a3:	e8 6c 8f ff ff       	call   800914 <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  8079a8:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  8079ac:	77 0a                	ja     8079b8 <pbuf_free+0x3b>
  8079ae:	be 00 00 00 00       	mov    $0x0,%esi
  8079b3:	e9 82 00 00 00       	jmp    807a3a <pbuf_free+0xbd>
  8079b8:	c7 44 24 08 fd 33 81 	movl   $0x8133fd,0x8(%esp)
  8079bf:	00 
  8079c0:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  8079c7:	00 
  8079c8:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8079cf:	e8 40 8f ff ff       	call   800914 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  8079d4:	c7 44 24 08 12 34 81 	movl   $0x813412,0x8(%esp)
  8079db:	00 
  8079dc:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  8079e3:	00 
  8079e4:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8079eb:	e8 24 8f ff ff       	call   800914 <_panic>
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  8079f0:	8b 18                	mov    (%eax),%ebx
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  8079f2:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  8079f6:	66 83 fa 03          	cmp    $0x3,%dx
  8079fa:	75 12                	jne    807a0e <pbuf_free+0x91>
        memp_free(MEMP_PBUF_POOL, p);
  8079fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  807a00:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807a07:	e8 e8 f7 ff ff       	call   8071f4 <memp_free>
  807a0c:	eb 23                	jmp    807a31 <pbuf_free+0xb4>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  807a0e:	83 ea 01             	sub    $0x1,%edx
  807a11:	66 83 fa 01          	cmp    $0x1,%dx
  807a15:	77 12                	ja     807a29 <pbuf_free+0xac>
        memp_free(MEMP_PBUF, p);
  807a17:	89 44 24 04          	mov    %eax,0x4(%esp)
  807a1b:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  807a22:	e8 cd f7 ff ff       	call   8071f4 <memp_free>
  807a27:	eb 08                	jmp    807a31 <pbuf_free+0xb4>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  807a29:	89 04 24             	mov    %eax,(%esp)
  807a2c:	e8 44 f5 ff ff       	call   806f75 <mem_free>
      }
      count++;
  807a31:	83 c6 01             	add    $0x1,%esi
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  807a34:	85 db                	test   %ebx,%ebx
  807a36:	74 17                	je     807a4f <pbuf_free+0xd2>
  807a38:	89 d8                	mov    %ebx,%eax
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  807a3a:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  807a3e:	66 85 d2             	test   %dx,%dx
  807a41:	74 91                	je     8079d4 <pbuf_free+0x57>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  807a43:	83 ea 01             	sub    $0x1,%edx
  807a46:	66 89 50 0e          	mov    %dx,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  807a4a:	66 85 d2             	test   %dx,%dx
  807a4d:	74 a1                	je     8079f0 <pbuf_free+0x73>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  807a4f:	89 f0                	mov    %esi,%eax
  807a51:	83 c4 10             	add    $0x10,%esp
  807a54:	5b                   	pop    %ebx
  807a55:	5e                   	pop    %esi
  807a56:	5d                   	pop    %ebp
  807a57:	c3                   	ret    

00807a58 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  807a58:	55                   	push   %ebp
  807a59:	89 e5                	mov    %esp,%ebp
  807a5b:	83 ec 38             	sub    $0x38,%esp
  807a5e:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  807a61:	89 75 f8             	mov    %esi,-0x8(%ebp)
  807a64:	89 7d fc             	mov    %edi,-0x4(%ebp)
  807a67:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  807a6a:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  807a6c:	b8 01 00 00 00       	mov    $0x1,%eax
  807a71:	85 f6                	test   %esi,%esi
  807a73:	74 55                	je     807aca <pbuf_dechain+0x72>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  807a75:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  807a79:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807a7d:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  807a81:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  807a84:	0f b7 fa             	movzwl %dx,%edi
  807a87:	0f b7 c8             	movzwl %ax,%ecx
  807a8a:	29 cf                	sub    %ecx,%edi
  807a8c:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  807a8f:	74 1c                	je     807aad <pbuf_dechain+0x55>
  807a91:	c7 44 24 08 e8 32 81 	movl   $0x8132e8,0x8(%esp)
  807a98:	00 
  807a99:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  807aa0:	00 
  807aa1:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807aa8:	e8 67 8e ff ff       	call   800914 <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  807aad:	66 29 c2             	sub    %ax,%dx
  807ab0:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  807ab4:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  807aba:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807abe:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  807ac2:	89 34 24             	mov    %esi,(%esp)
  807ac5:	e8 b3 fe ff ff       	call   80797d <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  807aca:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  807ace:	66 3b 53 0a          	cmp    0xa(%ebx),%dx
  807ad2:	74 1c                	je     807af0 <pbuf_dechain+0x98>
  807ad4:	c7 44 24 08 28 34 81 	movl   $0x813428,0x8(%esp)
  807adb:	00 
  807adc:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  807ae3:	00 
  807ae4:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807aeb:	e8 24 8e ff ff       	call   800914 <_panic>
  return ((tail_gone > 0) ? NULL : q);
  807af0:	84 c0                	test   %al,%al
  807af2:	b8 00 00 00 00       	mov    $0x0,%eax
  807af7:	0f 45 f0             	cmovne %eax,%esi
}
  807afa:	89 f0                	mov    %esi,%eax
  807afc:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  807aff:	8b 75 f8             	mov    -0x8(%ebp),%esi
  807b02:	8b 7d fc             	mov    -0x4(%ebp),%edi
  807b05:	89 ec                	mov    %ebp,%esp
  807b07:	5d                   	pop    %ebp
  807b08:	c3                   	ret    

00807b09 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  807b09:	55                   	push   %ebp
  807b0a:	89 e5                	mov    %esp,%ebp
  807b0c:	56                   	push   %esi
  807b0d:	53                   	push   %ebx
  807b0e:	83 ec 10             	sub    $0x10,%esp
  807b11:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807b14:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  807b18:	85 db                	test   %ebx,%ebx
  807b1a:	75 1c                	jne    807b38 <pbuf_realloc+0x2f>
  807b1c:	c7 44 24 08 3d 34 81 	movl   $0x81343d,0x8(%esp)
  807b23:	00 
  807b24:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  807b2b:	00 
  807b2c:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807b33:	e8 dc 8d ff ff       	call   800914 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  807b38:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  807b3c:	3c 03                	cmp    $0x3,%al
  807b3e:	74 28                	je     807b68 <pbuf_realloc+0x5f>
  807b40:	3c 01                	cmp    $0x1,%al
  807b42:	74 24                	je     807b68 <pbuf_realloc+0x5f>
  807b44:	84 c0                	test   %al,%al
  807b46:	74 20                	je     807b68 <pbuf_realloc+0x5f>
  807b48:	3c 02                	cmp    $0x2,%al
  807b4a:	74 1c                	je     807b68 <pbuf_realloc+0x5f>
  807b4c:	c7 44 24 08 55 34 81 	movl   $0x813455,0x8(%esp)
  807b53:	00 
  807b54:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  807b5b:	00 
  807b5c:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807b63:	e8 ac 8d ff ff       	call   800914 <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  807b68:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  807b6c:	66 39 f0             	cmp    %si,%ax
  807b6f:	0f 86 bd 00 00 00    	jbe    807c32 <pbuf_realloc+0x129>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  807b75:	0f b7 d6             	movzwl %si,%edx
  807b78:	0f b7 c0             	movzwl %ax,%eax
  807b7b:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  807b7d:	eb 4d                	jmp    807bcc <pbuf_realloc+0xc3>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  807b7f:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  807b85:	7e 1c                	jle    807ba3 <pbuf_realloc+0x9a>
  807b87:	c7 44 24 08 70 34 81 	movl   $0x813470,0x8(%esp)
  807b8e:	00 
  807b8f:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  807b96:	00 
  807b97:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807b9e:	e8 71 8d ff ff       	call   800914 <_panic>
    q->tot_len += (u16_t)grow;
  807ba3:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  807ba7:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  807ba9:	85 db                	test   %ebx,%ebx
  807bab:	75 1c                	jne    807bc9 <pbuf_realloc+0xc0>
  807bad:	c7 44 24 08 81 34 81 	movl   $0x813481,0x8(%esp)
  807bb4:	00 
  807bb5:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  807bbc:	00 
  807bbd:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807bc4:	e8 4b 8d ff ff       	call   800914 <_panic>
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  807bc9:	66 29 c6             	sub    %ax,%si

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  807bcc:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807bd0:	66 39 c6             	cmp    %ax,%si
  807bd3:	77 aa                	ja     807b7f <pbuf_realloc+0x76>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  807bd5:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  807bd9:	75 3b                	jne    807c16 <pbuf_realloc+0x10d>
  807bdb:	66 39 f0             	cmp    %si,%ax
  807bde:	74 36                	je     807c16 <pbuf_realloc+0x10d>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  807be0:	0f b7 c6             	movzwl %si,%eax
  807be3:	03 43 04             	add    0x4(%ebx),%eax
  807be6:	29 d8                	sub    %ebx,%eax
  807be8:	89 44 24 04          	mov    %eax,0x4(%esp)
  807bec:	89 1c 24             	mov    %ebx,(%esp)
  807bef:	e8 17 f2 ff ff       	call   806e0b <mem_realloc>
  807bf4:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  807bf6:	85 c0                	test   %eax,%eax
  807bf8:	75 1c                	jne    807c16 <pbuf_realloc+0x10d>
  807bfa:	c7 44 24 08 99 34 81 	movl   $0x813499,0x8(%esp)
  807c01:	00 
  807c02:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  807c09:	00 
  807c0a:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807c11:	e8 fe 8c ff ff       	call   800914 <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  807c16:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  807c1a:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  807c1e:	8b 03                	mov    (%ebx),%eax
  807c20:	85 c0                	test   %eax,%eax
  807c22:	74 08                	je     807c2c <pbuf_realloc+0x123>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  807c24:	89 04 24             	mov    %eax,(%esp)
  807c27:	e8 51 fd ff ff       	call   80797d <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  807c2c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  807c32:	83 c4 10             	add    $0x10,%esp
  807c35:	5b                   	pop    %ebx
  807c36:	5e                   	pop    %esi
  807c37:	5d                   	pop    %ebp
  807c38:	c3                   	ret    

00807c39 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  807c39:	55                   	push   %ebp
  807c3a:	89 e5                	mov    %esp,%ebp
  807c3c:	57                   	push   %edi
  807c3d:	56                   	push   %esi
  807c3e:	53                   	push   %ebx
  807c3f:	83 ec 2c             	sub    $0x2c,%esp
  807c42:	8b 45 08             	mov    0x8(%ebp),%eax
  807c45:	8b 7d 10             	mov    0x10(%ebp),%edi
  807c48:	0f b7 5d 0c          	movzwl 0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  807c4c:	83 f8 01             	cmp    $0x1,%eax
  807c4f:	74 21                	je     807c72 <pbuf_alloc+0x39>
  807c51:	ba 14 00 00 00       	mov    $0x14,%edx
  807c56:	83 f8 01             	cmp    $0x1,%eax
  807c59:	72 1c                	jb     807c77 <pbuf_alloc+0x3e>
  807c5b:	83 f8 02             	cmp    $0x2,%eax
  807c5e:	74 0a                	je     807c6a <pbuf_alloc+0x31>
  807c60:	83 f8 03             	cmp    $0x3,%eax
  807c63:	75 1e                	jne    807c83 <pbuf_alloc+0x4a>
  807c65:	8d 76 00             	lea    0x0(%esi),%esi
  807c68:	eb 35                	jmp    807c9f <pbuf_alloc+0x66>
  807c6a:	ba 00 00 00 00       	mov    $0x0,%edx
  807c6f:	90                   	nop
  807c70:	eb 08                	jmp    807c7a <pbuf_alloc+0x41>
  807c72:	ba 00 00 00 00       	mov    $0x0,%edx
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  807c77:	83 c2 14             	add    $0x14,%edx
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  807c7a:	83 c2 0e             	add    $0xe,%edx
  807c7d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    break;
  807c81:	eb 22                	jmp    807ca5 <pbuf_alloc+0x6c>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  807c83:	c7 44 24 08 b4 34 81 	movl   $0x8134b4,0x8(%esp)
  807c8a:	00 
  807c8b:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  807c92:	00 
  807c93:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807c9a:	e8 75 8c ff ff       	call   800914 <_panic>
  807c9f:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
    return NULL;
  }

  switch (type) {
  807ca5:	83 ff 02             	cmp    $0x2,%edi
  807ca8:	77 0e                	ja     807cb8 <pbuf_alloc+0x7f>
  807caa:	83 ff 01             	cmp    $0x1,%edi
  807cad:	0f 83 bf 01 00 00    	jae    807e72 <pbuf_alloc+0x239>
  807cb3:	e9 78 01 00 00       	jmp    807e30 <pbuf_alloc+0x1f7>
  807cb8:	83 ff 03             	cmp    $0x3,%edi
  807cbb:	90                   	nop
  807cbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  807cc0:	0f 85 da 01 00 00    	jne    807ea0 <pbuf_alloc+0x267>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  807cc6:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807ccd:	8d 76 00             	lea    0x0(%esi),%esi
  807cd0:	e8 63 f5 ff ff       	call   807238 <memp_malloc>
  807cd5:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  807cd7:	85 c0                	test   %eax,%eax
  807cd9:	0f 84 e7 01 00 00    	je     807ec6 <pbuf_alloc+0x28d>
      return NULL;
    }
    p->type = type;
  807cdf:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  807ce3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  807ce9:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807ced:	8d 54 06 13          	lea    0x13(%esi,%eax,1),%edx
  807cf1:	83 e2 fc             	and    $0xfffffffc,%edx
  807cf4:	89 56 04             	mov    %edx,0x4(%esi)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  807cf7:	66 89 5e 08          	mov    %bx,0x8(%esi)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  807cfb:	0f b7 db             	movzwl %bx,%ebx
  807cfe:	83 c0 03             	add    $0x3,%eax
  807d01:	89 c1                	mov    %eax,%ecx
  807d03:	83 e1 fc             	and    $0xfffffffc,%ecx
  807d06:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  807d0b:	29 c8                	sub    %ecx,%eax
  807d0d:	39 d8                	cmp    %ebx,%eax
  807d0f:	0f 4f c3             	cmovg  %ebx,%eax
  807d12:	89 c1                	mov    %eax,%ecx
  807d14:	66 89 46 0a          	mov    %ax,0xa(%esi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  807d18:	8d 86 e0 07 00 00    	lea    0x7e0(%esi),%eax
  807d1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807d21:	0f b7 c1             	movzwl %cx,%eax
  807d24:	01 c2                	add    %eax,%edx
  807d26:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
  807d29:	76 1c                	jbe    807d47 <pbuf_alloc+0x10e>
  807d2b:	c7 44 24 08 0c 33 81 	movl   $0x81330c,0x8(%esp)
  807d32:	00 
  807d33:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  807d3a:	00 
  807d3b:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807d42:	e8 cd 8b ff ff       	call   800914 <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  807d47:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  807d4d:	0f b7 c9             	movzwl %cx,%ecx
  807d50:	29 cb                	sub    %ecx,%ebx
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  807d52:	85 db                	test   %ebx,%ebx
  807d54:	0f 8e 62 01 00 00    	jle    807ebc <pbuf_alloc+0x283>
  807d5a:	89 f7                	mov    %esi,%edi
      q = memp_malloc(MEMP_PBUF_POOL);
  807d5c:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807d63:	e8 d0 f4 ff ff       	call   807238 <memp_malloc>
      if (q == NULL) {
  807d68:	85 c0                	test   %eax,%eax
  807d6a:	75 12                	jne    807d7e <pbuf_alloc+0x145>
        /* free chain so far allocated */
        pbuf_free(p);
  807d6c:	89 34 24             	mov    %esi,(%esp)
  807d6f:	e8 09 fc ff ff       	call   80797d <pbuf_free>
  807d74:	be 00 00 00 00       	mov    $0x0,%esi
        /* bail out unsuccesfully */
        return NULL;
  807d79:	e9 48 01 00 00       	jmp    807ec6 <pbuf_alloc+0x28d>
      }
      q->type = type;
  807d7e:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  807d82:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  807d86:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  807d8c:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  807d8e:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  807d94:	7e 1c                	jle    807db2 <pbuf_alloc+0x179>
  807d96:	c7 44 24 08 cf 34 81 	movl   $0x8134cf,0x8(%esp)
  807d9d:	00 
  807d9e:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  807da5:	00 
  807da6:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807dad:	e8 62 8b ff ff       	call   800914 <_panic>
      q->tot_len = (u16_t)rem_len;
  807db2:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  807db6:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  807dbb:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
  807dc0:	0f 46 cb             	cmovbe %ebx,%ecx
  807dc3:	66 89 48 0a          	mov    %cx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  807dc7:	8d 50 10             	lea    0x10(%eax),%edx
  807dca:	89 50 04             	mov    %edx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  807dcd:	f6 c2 03             	test   $0x3,%dl
  807dd0:	74 1c                	je     807dee <pbuf_alloc+0x1b5>
  807dd2:	c7 44 24 08 40 33 81 	movl   $0x813340,0x8(%esp)
  807dd9:	00 
  807dda:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  807de1:	00 
  807de2:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807de9:	e8 26 8b ff ff       	call   800914 <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  807dee:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807df2:	03 56 04             	add    0x4(%esi),%edx
  807df5:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  807df8:	73 1c                	jae    807e16 <pbuf_alloc+0x1dd>
  807dfa:	c7 44 24 08 0c 33 81 	movl   $0x81330c,0x8(%esp)
  807e01:	00 
  807e02:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  807e09:	00 
  807e0a:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807e11:	e8 fe 8a ff ff       	call   800914 <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  807e16:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  807e1c:	0f b7 c9             	movzwl %cx,%ecx
  807e1f:	29 cb                	sub    %ecx,%ebx
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  807e21:	85 db                	test   %ebx,%ebx
  807e23:	0f 8e 93 00 00 00    	jle    807ebc <pbuf_alloc+0x283>
  807e29:	89 c7                	mov    %eax,%edi
  807e2b:	e9 2c ff ff ff       	jmp    807d5c <pbuf_alloc+0x123>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  807e30:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  807e34:	8d 57 13             	lea    0x13(%edi),%edx
  807e37:	83 e2 fc             	and    $0xfffffffc,%edx
  807e3a:	0f b7 c3             	movzwl %bx,%eax
  807e3d:	83 c0 03             	add    $0x3,%eax
  807e40:	83 e0 fc             	and    $0xfffffffc,%eax
  807e43:	8d 04 02             	lea    (%edx,%eax,1),%eax
  807e46:	89 04 24             	mov    %eax,(%esp)
  807e49:	e8 92 ed ff ff       	call   806be0 <mem_malloc>
  807e4e:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  807e50:	85 c0                	test   %eax,%eax
  807e52:	74 72                	je     807ec6 <pbuf_alloc+0x28d>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  807e54:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  807e58:	83 e0 fc             	and    $0xfffffffc,%eax
  807e5b:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  807e5e:	66 89 5e 08          	mov    %bx,0x8(%esi)
  807e62:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  807e66:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  807e6c:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  807e70:	eb 4a                	jmp    807ebc <pbuf_alloc+0x283>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  807e72:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  807e79:	e8 ba f3 ff ff       	call   807238 <memp_malloc>
  807e7e:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  807e80:	85 c0                	test   %eax,%eax
  807e82:	74 42                	je     807ec6 <pbuf_alloc+0x28d>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  807e84:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  807e8b:	66 89 58 08          	mov    %bx,0x8(%eax)
  807e8f:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  807e93:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  807e99:	89 f8                	mov    %edi,%eax
  807e9b:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  807e9e:	eb 1c                	jmp    807ebc <pbuf_alloc+0x283>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  807ea0:	c7 44 24 08 e3 34 81 	movl   $0x8134e3,0x8(%esp)
  807ea7:	00 
  807ea8:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  807eaf:	00 
  807eb0:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807eb7:	e8 58 8a ff ff       	call   800914 <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  807ebc:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  807ec2:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  807ec6:	89 f0                	mov    %esi,%eax
  807ec8:	83 c4 2c             	add    $0x2c,%esp
  807ecb:	5b                   	pop    %ebx
  807ecc:	5e                   	pop    %esi
  807ecd:	5f                   	pop    %edi
  807ece:	5d                   	pop    %ebp
  807ecf:	c3                   	ret    

00807ed0 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  807ed0:	55                   	push   %ebp
  807ed1:	89 e5                	mov    %esp,%ebp
  807ed3:	83 ec 18             	sub    $0x18,%esp
  807ed6:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  807ed9:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  807ede:	8b 40 04             	mov    0x4(%eax),%eax
  807ee1:	8b 00                	mov    (%eax),%eax
  807ee3:	89 04 24             	mov    %eax,(%esp)
  807ee6:	e8 7c 57 00 00       	call   80d667 <sys_sem_signal>
}
  807eeb:	c9                   	leave  
  807eec:	c3                   	ret    

00807eed <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  807eed:	55                   	push   %ebp
  807eee:	89 e5                	mov    %esp,%ebp
  807ef0:	57                   	push   %edi
  807ef1:	56                   	push   %esi
  807ef2:	53                   	push   %ebx
  807ef3:	83 ec 1c             	sub    $0x1c,%esp
  807ef6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807ef9:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  807efc:	e8 3a 52 00 00       	call   80d13b <sys_arch_timeouts>

  if (timeouts == NULL) {
  807f01:	85 c0                	test   %eax,%eax
  807f03:	75 1c                	jne    807f21 <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  807f05:	c7 44 24 08 00 35 81 	movl   $0x813500,0x8(%esp)
  807f0c:	00 
  807f0d:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  807f14:	00 
  807f15:	c7 04 24 20 35 81 00 	movl   $0x813520,(%esp)
  807f1c:	e8 f3 89 ff ff       	call   800914 <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  807f21:	8b 10                	mov    (%eax),%edx
  807f23:	85 d2                	test   %edx,%edx
  807f25:	74 4b                	je     807f72 <sys_untimeout+0x85>
  807f27:	bf 00 00 00 00       	mov    $0x0,%edi
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == h) && (t->arg == arg)) {
  807f2c:	39 5a 08             	cmp    %ebx,0x8(%edx)
  807f2f:	75 33                	jne    807f64 <sys_untimeout+0x77>
  807f31:	39 72 0c             	cmp    %esi,0xc(%edx)
  807f34:	75 2e                	jne    807f64 <sys_untimeout+0x77>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  807f36:	85 ff                	test   %edi,%edi
  807f38:	75 08                	jne    807f42 <sys_untimeout+0x55>
        timeouts->next = t->next;
  807f3a:	8b 0a                	mov    (%edx),%ecx
  807f3c:	89 08                	mov    %ecx,(%eax)
  807f3e:	66 90                	xchg   %ax,%ax
  807f40:	eb 04                	jmp    807f46 <sys_untimeout+0x59>
      else
        prev_t->next = t->next;
  807f42:	8b 02                	mov    (%edx),%eax
  807f44:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  807f46:	8b 02                	mov    (%edx),%eax
  807f48:	85 c0                	test   %eax,%eax
  807f4a:	74 06                	je     807f52 <sys_untimeout+0x65>
        t->next->time += t->time;
  807f4c:	8b 4a 04             	mov    0x4(%edx),%ecx
  807f4f:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  807f52:	89 54 24 04          	mov    %edx,0x4(%esp)
  807f56:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  807f5d:	e8 92 f2 ff ff       	call   8071f4 <memp_free>
      return;
  807f62:	eb 0e                	jmp    807f72 <sys_untimeout+0x85>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  807f64:	8b 0a                	mov    (%edx),%ecx
  807f66:	85 c9                	test   %ecx,%ecx
  807f68:	74 08                	je     807f72 <sys_untimeout+0x85>
  807f6a:	89 d7                	mov    %edx,%edi
  807f6c:	89 ca                	mov    %ecx,%edx
  807f6e:	66 90                	xchg   %ax,%ax
  807f70:	eb ba                	jmp    807f2c <sys_untimeout+0x3f>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  807f72:	83 c4 1c             	add    $0x1c,%esp
  807f75:	5b                   	pop    %ebx
  807f76:	5e                   	pop    %esi
  807f77:	5f                   	pop    %edi
  807f78:	5d                   	pop    %ebp
  807f79:	c3                   	ret    

00807f7a <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  807f7a:	55                   	push   %ebp
  807f7b:	89 e5                	mov    %esp,%ebp
  807f7d:	56                   	push   %esi
  807f7e:	53                   	push   %ebx
  807f7f:	83 ec 10             	sub    $0x10,%esp
  807f82:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  807f85:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  807f8c:	e8 a7 f2 ff ff       	call   807238 <memp_malloc>
  807f91:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  807f93:	85 c0                	test   %eax,%eax
  807f95:	75 1c                	jne    807fb3 <sys_timeout+0x39>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  807f97:	c7 44 24 08 34 35 81 	movl   $0x813534,0x8(%esp)
  807f9e:	00 
  807f9f:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  807fa6:	00 
  807fa7:	c7 04 24 20 35 81 00 	movl   $0x813520,(%esp)
  807fae:	e8 61 89 ff ff       	call   800914 <_panic>
    return;
  }
  timeout->next = NULL;
  807fb3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  807fb9:	8b 45 0c             	mov    0xc(%ebp),%eax
  807fbc:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  807fbf:	8b 45 10             	mov    0x10(%ebp),%eax
  807fc2:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  807fc5:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  807fc8:	e8 6e 51 00 00       	call   80d13b <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  807fcd:	85 c0                	test   %eax,%eax
  807fcf:	75 1c                	jne    807fed <sys_timeout+0x73>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  807fd1:	c7 44 24 08 51 35 81 	movl   $0x813551,0x8(%esp)
  807fd8:	00 
  807fd9:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  807fe0:	00 
  807fe1:	c7 04 24 20 35 81 00 	movl   $0x813520,(%esp)
  807fe8:	e8 27 89 ff ff       	call   800914 <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  807fed:	8b 10                	mov    (%eax),%edx
  807fef:	85 d2                	test   %edx,%edx
  807ff1:	75 04                	jne    807ff7 <sys_timeout+0x7d>
    timeouts->next = timeout;
  807ff3:	89 18                	mov    %ebx,(%eax)
    return;
  807ff5:	eb 4c                	jmp    808043 <sys_timeout+0xc9>
  }

  if (timeouts->next->time > msecs) {
  807ff7:	8b 4a 04             	mov    0x4(%edx),%ecx
  807ffa:	39 ce                	cmp    %ecx,%esi
  807ffc:	73 2d                	jae    80802b <sys_timeout+0xb1>
    timeouts->next->time -= msecs;
  807ffe:	29 f1                	sub    %esi,%ecx
  808000:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  808003:	8b 10                	mov    (%eax),%edx
  808005:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  808007:	89 18                	mov    %ebx,(%eax)
  808009:	eb 38                	jmp    808043 <sys_timeout+0xc9>
  80800b:	89 c2                	mov    %eax,%edx
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  80800d:	8b 73 04             	mov    0x4(%ebx),%esi
  808010:	2b 70 04             	sub    0x4(%eax),%esi
  808013:	89 73 04             	mov    %esi,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  808016:	8b 00                	mov    (%eax),%eax
  808018:	85 c0                	test   %eax,%eax
  80801a:	74 07                	je     808023 <sys_timeout+0xa9>
  80801c:	3b 70 04             	cmp    0x4(%eax),%esi
  80801f:	73 ea                	jae    80800b <sys_timeout+0x91>
  808021:	eb 1b                	jmp    80803e <sys_timeout+0xc4>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
  808023:	8b 02                	mov    (%edx),%eax
  808025:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  808027:	89 1a                	mov    %ebx,(%edx)
  808029:	eb 18                	jmp    808043 <sys_timeout+0xc9>
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  80802b:	8b 73 04             	mov    0x4(%ebx),%esi
  80802e:	29 ce                	sub    %ecx,%esi
  808030:	89 73 04             	mov    %esi,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  808033:	8b 02                	mov    (%edx),%eax
  808035:	85 c0                	test   %eax,%eax
  808037:	74 ea                	je     808023 <sys_timeout+0xa9>
  808039:	3b 70 04             	cmp    0x4(%eax),%esi
  80803c:	73 cd                	jae    80800b <sys_timeout+0x91>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  80803e:	29 70 04             	sub    %esi,0x4(%eax)
  808041:	eb e0                	jmp    808023 <sys_timeout+0xa9>
        t->next = timeout;
        break;
      }
    }
  }
}
  808043:	83 c4 10             	add    $0x10,%esp
  808046:	5b                   	pop    %ebx
  808047:	5e                   	pop    %esi
  808048:	5d                   	pop    %ebp
  808049:	c3                   	ret    

0080804a <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80804a:	55                   	push   %ebp
  80804b:	89 e5                	mov    %esp,%ebp
  80804d:	57                   	push   %edi
  80804e:	56                   	push   %esi
  80804f:	53                   	push   %ebx
  808050:	83 ec 1c             	sub    $0x1c,%esp
  808053:	8b 7d 08             	mov    0x8(%ebp),%edi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  808056:	e8 e0 50 00 00       	call   80d13b <sys_arch_timeouts>
  80805b:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80805d:	85 c0                	test   %eax,%eax
  80805f:	74 06                	je     808067 <sys_sem_wait+0x1d>
  808061:	8b 00                	mov    (%eax),%eax
  808063:	85 c0                	test   %eax,%eax
  808065:	75 12                	jne    808079 <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  808067:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80806e:	00 
  80806f:	89 3c 24             	mov    %edi,(%esp)
  808072:	e8 ff 52 00 00       	call   80d376 <sys_arch_sem_wait>

 again:

  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  808077:	eb 58                	jmp    8080d1 <sys_sem_wait+0x87>
    sys_arch_sem_wait(sem, 0);
  } else {
    if (timeouts->next->time > 0) {
  808079:	8b 40 04             	mov    0x4(%eax),%eax
  80807c:	85 c0                	test   %eax,%eax
  80807e:	74 11                	je     808091 <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  808080:	89 44 24 04          	mov    %eax,0x4(%esp)
  808084:	89 3c 24             	mov    %edi,(%esp)
  808087:	e8 ea 52 00 00       	call   80d376 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80808c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80808f:	75 29                	jne    8080ba <sys_sem_wait+0x70>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  808091:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  808093:	8b 10                	mov    (%eax),%edx
  808095:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  808097:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80809a:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80809d:	89 44 24 04          	mov    %eax,0x4(%esp)
  8080a1:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8080a8:	e8 47 f1 ff ff       	call   8071f4 <memp_free>
      if (h != NULL) {
  8080ad:	85 db                	test   %ebx,%ebx
  8080af:	74 a5                	je     808056 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  8080b1:	89 34 24             	mov    %esi,(%esp)
  8080b4:	ff d3                	call   *%ebx
  8080b6:	66 90                	xchg   %ax,%ax
  8080b8:	eb 9c                	jmp    808056 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8080ba:	8b 13                	mov    (%ebx),%edx
  8080bc:	8b 4a 04             	mov    0x4(%edx),%ecx
  8080bf:	39 c8                	cmp    %ecx,%eax
  8080c1:	73 07                	jae    8080ca <sys_sem_wait+0x80>
        timeouts->next->time -= time_needed;
  8080c3:	29 c1                	sub    %eax,%ecx
  8080c5:	89 4a 04             	mov    %ecx,0x4(%edx)
  8080c8:	eb 07                	jmp    8080d1 <sys_sem_wait+0x87>
      } else {
        timeouts->next->time = 0;
  8080ca:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  8080d1:	83 c4 1c             	add    $0x1c,%esp
  8080d4:	5b                   	pop    %ebx
  8080d5:	5e                   	pop    %esi
  8080d6:	5f                   	pop    %edi
  8080d7:	5d                   	pop    %ebp
  8080d8:	c3                   	ret    

008080d9 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8080d9:	55                   	push   %ebp
  8080da:	89 e5                	mov    %esp,%ebp
  8080dc:	83 ec 28             	sub    $0x28,%esp
  8080df:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8080e2:	8d 55 08             	lea    0x8(%ebp),%edx
  8080e5:	89 55 f4             	mov    %edx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8080e8:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8080ee:	85 c0                	test   %eax,%eax
  8080f0:	74 17                	je     808109 <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  8080f2:	8d 55 f0             	lea    -0x10(%ebp),%edx
  8080f5:	89 54 24 08          	mov    %edx,0x8(%esp)
  8080f9:	c7 44 24 04 d0 7e 80 	movl   $0x807ed0,0x4(%esp)
  808100:	00 
  808101:	89 04 24             	mov    %eax,(%esp)
  808104:	e8 71 fe ff ff       	call   807f7a <sys_timeout>
  }
  sys_sem_wait(sem);
  808109:	8b 45 08             	mov    0x8(%ebp),%eax
  80810c:	89 04 24             	mov    %eax,(%esp)
  80810f:	e8 36 ff ff ff       	call   80804a <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  808114:	b8 00 00 00 00       	mov    $0x0,%eax
  808119:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80811e:	75 18                	jne    808138 <sys_sem_wait_timeout+0x5f>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  808120:	8d 45 f0             	lea    -0x10(%ebp),%eax
  808123:	89 44 24 04          	mov    %eax,0x4(%esp)
  808127:	c7 04 24 d0 7e 80 00 	movl   $0x807ed0,(%esp)
  80812e:	e8 ba fd ff ff       	call   807eed <sys_untimeout>
  808133:	b8 01 00 00 00       	mov    $0x1,%eax
    return 1;
  }
}
  808138:	c9                   	leave  
  808139:	c3                   	ret    

0080813a <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80813a:	55                   	push   %ebp
  80813b:	89 e5                	mov    %esp,%ebp
  80813d:	53                   	push   %ebx
  80813e:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  808141:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808148:	e8 78 53 00 00       	call   80d4c5 <sys_sem_new>
  80814d:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  80814f:	8b 45 08             	mov    0x8(%ebp),%eax
  808152:	89 44 24 04          	mov    %eax,0x4(%esp)
  808156:	89 1c 24             	mov    %ebx,(%esp)
  808159:	e8 7b ff ff ff       	call   8080d9 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  80815e:	89 1c 24             	mov    %ebx,(%esp)
  808161:	e8 9d 4e 00 00       	call   80d003 <sys_sem_free>
}
  808166:	83 c4 14             	add    $0x14,%esp
  808169:	5b                   	pop    %ebx
  80816a:	5d                   	pop    %ebp
  80816b:	c3                   	ret    

0080816c <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80816c:	55                   	push   %ebp
  80816d:	89 e5                	mov    %esp,%ebp
  80816f:	57                   	push   %edi
  808170:	56                   	push   %esi
  808171:	53                   	push   %ebx
  808172:	83 ec 1c             	sub    $0x1c,%esp
  808175:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  808178:	e8 be 4f 00 00       	call   80d13b <sys_arch_timeouts>
  80817d:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80817f:	85 c0                	test   %eax,%eax
  808181:	74 06                	je     808189 <sys_mbox_fetch+0x1d>
  808183:	8b 00                	mov    (%eax),%eax
  808185:	85 c0                	test   %eax,%eax
  808187:	75 19                	jne    8081a2 <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  808189:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808190:	00 
  808191:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808195:	8b 45 08             	mov    0x8(%ebp),%eax
  808198:	89 04 24             	mov    %eax,(%esp)
  80819b:	e8 53 55 00 00       	call   80d6f3 <sys_arch_mbox_fetch>
  void *arg;

 again:
  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  8081a0:	eb 5f                	jmp    808201 <sys_mbox_fetch+0x95>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  8081a2:	8b 40 04             	mov    0x4(%eax),%eax
  8081a5:	85 c0                	test   %eax,%eax
  8081a7:	74 18                	je     8081c1 <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8081a9:	89 44 24 08          	mov    %eax,0x8(%esp)
  8081ad:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8081b1:	8b 45 08             	mov    0x8(%ebp),%eax
  8081b4:	89 04 24             	mov    %eax,(%esp)
  8081b7:	e8 37 55 00 00       	call   80d6f3 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8081bc:	83 f8 ff             	cmp    $0xffffffff,%eax
  8081bf:	75 29                	jne    8081ea <sys_mbox_fetch+0x7e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8081c1:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8081c3:	8b 10                	mov    (%eax),%edx
  8081c5:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8081c7:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8081ca:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8081cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8081d1:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8081d8:	e8 17 f0 ff ff       	call   8071f4 <memp_free>
      if (h != NULL) {
  8081dd:	85 db                	test   %ebx,%ebx
  8081df:	74 97                	je     808178 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  8081e1:	89 34 24             	mov    %esi,(%esp)
  8081e4:	ff d3                	call   *%ebx
  8081e6:	66 90                	xchg   %ax,%ax
  8081e8:	eb 8e                	jmp    808178 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8081ea:	8b 13                	mov    (%ebx),%edx
  8081ec:	8b 4a 04             	mov    0x4(%edx),%ecx
  8081ef:	39 c8                	cmp    %ecx,%eax
  8081f1:	73 07                	jae    8081fa <sys_mbox_fetch+0x8e>
        timeouts->next->time -= time_needed;
  8081f3:	29 c1                	sub    %eax,%ecx
  8081f5:	89 4a 04             	mov    %ecx,0x4(%edx)
  8081f8:	eb 07                	jmp    808201 <sys_mbox_fetch+0x95>
      } else {
        timeouts->next->time = 0;
  8081fa:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  808201:	83 c4 1c             	add    $0x1c,%esp
  808204:	5b                   	pop    %ebx
  808205:	5e                   	pop    %esi
  808206:	5f                   	pop    %edi
  808207:	5d                   	pop    %ebp
  808208:	c3                   	ret    
  808209:	00 00                	add    %al,(%eax)
  80820b:	00 00                	add    %al,(%eax)
  80820d:	00 00                	add    %al,(%eax)
	...

00808210 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  808210:	55                   	push   %ebp
  808211:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  808213:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  808218:	5d                   	pop    %ebp
  808219:	c3                   	ret    

0080821a <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80821a:	55                   	push   %ebp
  80821b:	89 e5                	mov    %esp,%ebp
  80821d:	57                   	push   %edi
  80821e:	56                   	push   %esi
  80821f:	53                   	push   %ebx
  808220:	83 ec 08             	sub    $0x8,%esp
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808223:	8b 0d 0c f0 b3 00    	mov    0xb3f00c,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808229:	8b 1d 20 f0 b3 00    	mov    0xb3f020,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80822f:	a1 14 f0 b3 00       	mov    0xb3f014,%eax
  808234:	89 45 f0             	mov    %eax,-0x10(%ebp)
  808237:	0f b7 15 48 50 81 00 	movzwl 0x815048,%edx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80823e:	be 00 10 00 00       	mov    $0x1000,%esi
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  808243:	89 cf                	mov    %ecx,%edi
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  808245:	66 83 c2 01          	add    $0x1,%dx
  808249:	0f 48 d6             	cmovs  %esi,%edx
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80824c:	85 c9                	test   %ecx,%ecx
  80824e:	74 19                	je     808269 <tcp_new_port+0x4f>
    if (pcb->local_port == port) {
  808250:	89 f8                	mov    %edi,%eax
  808252:	66 3b 51 1c          	cmp    0x1c(%ecx),%dx
  808256:	75 0a                	jne    808262 <tcp_new_port+0x48>
  808258:	eb eb                	jmp    808245 <tcp_new_port+0x2b>
  80825a:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  80825e:	66 90                	xchg   %ax,%ax
  808260:	74 e3                	je     808245 <tcp_new_port+0x2b>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808262:	8b 40 0c             	mov    0xc(%eax),%eax
  808265:	85 c0                	test   %eax,%eax
  808267:	75 f1                	jne    80825a <tcp_new_port+0x40>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808269:	85 db                	test   %ebx,%ebx
  80826b:	74 1c                	je     808289 <tcp_new_port+0x6f>
    if (pcb->local_port == port) {
  80826d:	89 d8                	mov    %ebx,%eax
  80826f:	66 3b 53 1c          	cmp    0x1c(%ebx),%dx
  808273:	75 0d                	jne    808282 <tcp_new_port+0x68>
  808275:	eb ce                	jmp    808245 <tcp_new_port+0x2b>
  808277:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  80827b:	90                   	nop
  80827c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  808280:	74 c3                	je     808245 <tcp_new_port+0x2b>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808282:	8b 40 0c             	mov    0xc(%eax),%eax
  808285:	85 c0                	test   %eax,%eax
  808287:	75 ee                	jne    808277 <tcp_new_port+0x5d>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  808289:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  80828d:	8d 76 00             	lea    0x0(%esi),%esi
  808290:	75 09                	jne    80829b <tcp_new_port+0x81>
  808292:	66 89 15 48 50 81 00 	mov    %dx,0x815048
  808299:	eb 30                	jmp    8082cb <tcp_new_port+0xb1>
    if (pcb->local_port == port) {
  80829b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80829e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  8082a1:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  8082a5:	75 13                	jne    8082ba <tcp_new_port+0xa0>
  8082a7:	eb 9c                	jmp    808245 <tcp_new_port+0x2b>
  8082a9:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  8082ad:	8d 76 00             	lea    0x0(%esi),%esi
  8082b0:	75 0b                	jne    8082bd <tcp_new_port+0xa3>
  8082b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  8082b8:	eb 8b                	jmp    808245 <tcp_new_port+0x2b>
  8082ba:	8b 45 ec             	mov    -0x14(%ebp),%eax
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8082bd:	8b 40 0c             	mov    0xc(%eax),%eax
  8082c0:	85 c0                	test   %eax,%eax
  8082c2:	75 e5                	jne    8082a9 <tcp_new_port+0x8f>
  8082c4:	66 89 15 48 50 81 00 	mov    %dx,0x815048
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  8082cb:	0f b7 05 48 50 81 00 	movzwl 0x815048,%eax
  8082d2:	83 c4 08             	add    $0x8,%esp
  8082d5:	5b                   	pop    %ebx
  8082d6:	5e                   	pop    %esi
  8082d7:	5f                   	pop    %edi
  8082d8:	5d                   	pop    %ebp
  8082d9:	c3                   	ret    

008082da <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8082da:	55                   	push   %ebp
  8082db:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8082dd:	8b 55 0c             	mov    0xc(%ebp),%edx
  8082e0:	8b 45 08             	mov    0x8(%ebp),%eax
  8082e3:	88 50 14             	mov    %dl,0x14(%eax)
}
  8082e6:	5d                   	pop    %ebp
  8082e7:	c3                   	ret    

008082e8 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8082e8:	55                   	push   %ebp
  8082e9:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  8082eb:	8b 55 0c             	mov    0xc(%ebp),%edx
  8082ee:	8b 45 08             	mov    0x8(%ebp),%eax
  8082f1:	89 50 18             	mov    %edx,0x18(%eax)
}
  8082f4:	5d                   	pop    %ebp
  8082f5:	c3                   	ret    

008082f6 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  8082f6:	55                   	push   %ebp
  8082f7:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  8082f9:	8b 55 0c             	mov    0xc(%ebp),%edx
  8082fc:	8b 45 08             	mov    0x8(%ebp),%eax
  8082ff:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  808305:	5d                   	pop    %ebp
  808306:	c3                   	ret    

00808307 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  808307:	55                   	push   %ebp
  808308:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  80830a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80830d:	8b 45 08             	mov    0x8(%ebp),%eax
  808310:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  808316:	5d                   	pop    %ebp
  808317:	c3                   	ret    

00808318 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  808318:	55                   	push   %ebp
  808319:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  80831b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80831e:	8b 45 08             	mov    0x8(%ebp),%eax
  808321:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  808327:	5d                   	pop    %ebp
  808328:	c3                   	ret    

00808329 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  808329:	55                   	push   %ebp
  80832a:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  80832c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80832f:	8b 45 08             	mov    0x8(%ebp),%eax
  808332:	89 50 20             	mov    %edx,0x20(%eax)
}
  808335:	5d                   	pop    %ebp
  808336:	c3                   	ret    

00808337 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  808337:	55                   	push   %ebp
  808338:	89 e5                	mov    %esp,%ebp
  80833a:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  80833d:	8b 55 0c             	mov    0xc(%ebp),%edx
  808340:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  808346:	8b 55 10             	mov    0x10(%ebp),%edx
  808349:	88 50 31             	mov    %dl,0x31(%eax)
}
  80834c:	5d                   	pop    %ebp
  80834d:	c3                   	ret    

0080834e <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  80834e:	55                   	push   %ebp
  80834f:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  808351:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  808356:	03 05 44 50 81 00    	add    0x815044,%eax
  80835c:	a3 44 50 81 00       	mov    %eax,0x815044
  return iss;
}
  808361:	5d                   	pop    %ebp
  808362:	c3                   	ret    

00808363 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  808363:	55                   	push   %ebp
  808364:	89 e5                	mov    %esp,%ebp
  808366:	53                   	push   %ebx
  808367:	83 ec 14             	sub    $0x14,%esp
  80836a:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80836e:	8b 45 0c             	mov    0xc(%ebp),%eax
  808371:	89 04 24             	mov    %eax,(%esp)
  808374:	e8 e8 11 00 00       	call   809561 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  808379:	85 c0                	test   %eax,%eax
  80837b:	74 12                	je     80838f <tcp_eff_send_mss+0x2c>
  80837d:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  808381:	66 85 c0             	test   %ax,%ax
  808384:	74 09                	je     80838f <tcp_eff_send_mss+0x2c>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  808386:	83 e8 28             	sub    $0x28,%eax
  808389:	66 39 c3             	cmp    %ax,%bx
  80838c:	0f 47 d8             	cmova  %eax,%ebx
  }
  return sendmss;
}
  80838f:	89 d8                	mov    %ebx,%eax
  808391:	83 c4 14             	add    $0x14,%esp
  808394:	5b                   	pop    %ebx
  808395:	5d                   	pop    %ebp
  808396:	c3                   	ret    

00808397 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  808397:	55                   	push   %ebp
  808398:	89 e5                	mov    %esp,%ebp
  80839a:	83 ec 18             	sub    $0x18,%esp
  80839d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8083a0:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8083a3:	8b 45 08             	mov    0x8(%ebp),%eax
  8083a6:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  8083aa:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  8083ae:	0f b7 f1             	movzwl %cx,%esi
  8083b1:	0f b7 da             	movzwl %dx,%ebx
  8083b4:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  8083b7:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  8083bd:	76 0e                	jbe    8083cd <tcp_recved+0x36>
    pcb->rcv_wnd = TCP_WND;
  8083bf:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  8083c5:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  8083cb:	eb 11                	jmp    8083de <tcp_recved+0x47>
  } else {
    pcb->rcv_wnd += len;
  8083cd:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  8083d0:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  8083d4:	66 3b 50 34          	cmp    0x34(%eax),%dx
  8083d8:	72 04                	jb     8083de <tcp_recved+0x47>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8083da:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  8083de:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  8083e2:	f6 c2 03             	test   $0x3,%dl
  8083e5:	75 20                	jne    808407 <tcp_recved+0x70>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  8083e7:	f6 c2 01             	test   $0x1,%dl
  8083ea:	74 13                	je     8083ff <tcp_recved+0x68>
  8083ec:	83 e2 fe             	and    $0xfffffffe,%edx
  8083ef:	83 ca 02             	or     $0x2,%edx
  8083f2:	88 50 20             	mov    %dl,0x20(%eax)
  8083f5:	89 04 24             	mov    %eax,(%esp)
  8083f8:	e8 fe 29 00 00       	call   80adfb <tcp_output>
  8083fd:	eb 23                	jmp    808422 <tcp_recved+0x8b>
  8083ff:	83 ca 01             	or     $0x1,%edx
  808402:	88 50 20             	mov    %dl,0x20(%eax)
  808405:	eb 1b                	jmp    808422 <tcp_recved+0x8b>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  808407:	f6 c2 01             	test   $0x1,%dl
  80840a:	74 16                	je     808422 <tcp_recved+0x8b>
  80840c:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  808412:	76 0e                	jbe    808422 <tcp_recved+0x8b>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  808414:	83 ca 02             	or     $0x2,%edx
  808417:	88 50 20             	mov    %dl,0x20(%eax)
  80841a:	89 04 24             	mov    %eax,(%esp)
  80841d:	e8 d9 29 00 00       	call   80adfb <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  808422:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808425:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808428:	89 ec                	mov    %ebp,%esp
  80842a:	5d                   	pop    %ebp
  80842b:	c3                   	ret    

0080842c <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  80842c:	55                   	push   %ebp
  80842d:	89 e5                	mov    %esp,%ebp
  80842f:	53                   	push   %ebx
  808430:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808433:	8b 1d 0c f0 b3 00    	mov    0xb3f00c,%ebx
  808439:	85 db                	test   %ebx,%ebx
  80843b:	74 6b                	je     8084a8 <tcp_fasttmr+0x7c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80843d:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  808443:	85 c0                	test   %eax,%eax
  808445:	74 40                	je     808487 <tcp_fasttmr+0x5b>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  808447:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80844d:	85 d2                	test   %edx,%edx
  80844f:	74 1e                	je     80846f <tcp_fasttmr+0x43>
  808451:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  808458:	00 
  808459:	89 44 24 08          	mov    %eax,0x8(%esp)
  80845d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808461:	8b 43 18             	mov    0x18(%ebx),%eax
  808464:	89 04 24             	mov    %eax,(%esp)
  808467:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  808469:	84 c0                	test   %al,%al
  80846b:	75 1a                	jne    808487 <tcp_fasttmr+0x5b>
  80846d:	eb 0e                	jmp    80847d <tcp_fasttmr+0x51>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80846f:	89 04 24             	mov    %eax,(%esp)
  808472:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  808478:	e8 00 f5 ff ff       	call   80797d <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80847d:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  808484:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  808487:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80848b:	a8 01                	test   $0x1,%al
  80848d:	74 12                	je     8084a1 <tcp_fasttmr+0x75>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  80848f:	83 c8 02             	or     $0x2,%eax
  808492:	88 43 20             	mov    %al,0x20(%ebx)
  808495:	89 1c 24             	mov    %ebx,(%esp)
  808498:	e8 5e 29 00 00       	call   80adfb <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80849d:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8084a1:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8084a4:	85 db                	test   %ebx,%ebx
  8084a6:	75 95                	jne    80843d <tcp_fasttmr+0x11>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  8084a8:	83 c4 14             	add    $0x14,%esp
  8084ab:	5b                   	pop    %ebx
  8084ac:	5d                   	pop    %ebp
  8084ad:	c3                   	ret    

008084ae <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8084ae:	55                   	push   %ebp
  8084af:	89 e5                	mov    %esp,%ebp
  8084b1:	53                   	push   %ebx
  8084b2:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8084b5:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  8084bc:	e8 77 ed ff ff       	call   807238 <memp_malloc>
  8084c1:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  8084c3:	85 c0                	test   %eax,%eax
  8084c5:	74 22                	je     8084e9 <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  8084c7:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8084ce:	00 
  8084cf:	8b 45 08             	mov    0x8(%ebp),%eax
  8084d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8084d6:	89 1c 24             	mov    %ebx,(%esp)
  8084d9:	e8 93 8e ff ff       	call   801371 <memcpy>
  pbuf_ref(cseg->p);
  8084de:	8b 43 04             	mov    0x4(%ebx),%eax
  8084e1:	89 04 24             	mov    %eax,(%esp)
  8084e4:	e8 51 f0 ff ff       	call   80753a <pbuf_ref>
  return cseg;
}
  8084e9:	89 d8                	mov    %ebx,%eax
  8084eb:	83 c4 14             	add    $0x14,%esp
  8084ee:	5b                   	pop    %ebx
  8084ef:	5d                   	pop    %ebp
  8084f0:	c3                   	ret    

008084f1 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  8084f1:	55                   	push   %ebp
  8084f2:	89 e5                	mov    %esp,%ebp
  8084f4:	83 ec 18             	sub    $0x18,%esp
  8084f7:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8084fa:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8084fd:	8b 75 08             	mov    0x8(%ebp),%esi
  u8_t count = 0;
  
  if (seg != NULL) {
  808500:	bb 00 00 00 00       	mov    $0x0,%ebx
  808505:	85 f6                	test   %esi,%esi
  808507:	74 21                	je     80852a <tcp_seg_free+0x39>
    if (seg->p != NULL) {
  808509:	8b 46 04             	mov    0x4(%esi),%eax
  80850c:	85 c0                	test   %eax,%eax
  80850e:	74 0a                	je     80851a <tcp_seg_free+0x29>
      count = pbuf_free(seg->p);
  808510:	89 04 24             	mov    %eax,(%esp)
  808513:	e8 65 f4 ff ff       	call   80797d <pbuf_free>
  808518:	89 c3                	mov    %eax,%ebx
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  80851a:	89 74 24 04          	mov    %esi,0x4(%esp)
  80851e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808525:	e8 ca ec ff ff       	call   8071f4 <memp_free>
  }
  return count;
}
  80852a:	89 d8                	mov    %ebx,%eax
  80852c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80852f:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808532:	89 ec                	mov    %ebp,%esp
  808534:	5d                   	pop    %ebp
  808535:	c3                   	ret    

00808536 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  808536:	55                   	push   %ebp
  808537:	89 e5                	mov    %esp,%ebp
  808539:	56                   	push   %esi
  80853a:	53                   	push   %ebx
  80853b:	83 ec 10             	sub    $0x10,%esp
  80853e:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808541:	be 00 00 00 00       	mov    $0x0,%esi
  808546:	85 c0                	test   %eax,%eax
  808548:	74 14                	je     80855e <tcp_segs_free+0x28>
    next = seg->next;
  80854a:	8b 18                	mov    (%eax),%ebx
    count += tcp_seg_free(seg);
  80854c:	89 04 24             	mov    %eax,(%esp)
  80854f:	e8 9d ff ff ff       	call   8084f1 <tcp_seg_free>
  808554:	01 c6                	add    %eax,%esi
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808556:	85 db                	test   %ebx,%ebx
  808558:	74 04                	je     80855e <tcp_segs_free+0x28>
  80855a:	89 d8                	mov    %ebx,%eax
  80855c:	eb ec                	jmp    80854a <tcp_segs_free+0x14>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  80855e:	89 f0                	mov    %esi,%eax
  808560:	83 c4 10             	add    $0x10,%esp
  808563:	5b                   	pop    %ebx
  808564:	5e                   	pop    %esi
  808565:	5d                   	pop    %ebp
  808566:	c3                   	ret    

00808567 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  808567:	55                   	push   %ebp
  808568:	89 e5                	mov    %esp,%ebp
  80856a:	53                   	push   %ebx
  80856b:	83 ec 14             	sub    $0x14,%esp
  80856e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  808571:	8b 43 10             	mov    0x10(%ebx),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  808574:	85 c0                	test   %eax,%eax
  808576:	74 62                	je     8085da <tcp_pcb_purge+0x73>
  808578:	83 f8 0a             	cmp    $0xa,%eax
  80857b:	74 5d                	je     8085da <tcp_pcb_purge+0x73>
  80857d:	83 f8 01             	cmp    $0x1,%eax
  808580:	74 58                	je     8085da <tcp_pcb_purge+0x73>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  808582:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  808588:	85 c0                	test   %eax,%eax
  80858a:	74 12                	je     80859e <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  80858c:	89 04 24             	mov    %eax,(%esp)
  80858f:	e8 e9 f3 ff ff       	call   80797d <pbuf_free>
      pcb->refused_data = NULL;
  808594:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80859b:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  80859e:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  8085a4:	8b 43 7c             	mov    0x7c(%ebx),%eax
  8085a7:	89 04 24             	mov    %eax,(%esp)
  8085aa:	e8 87 ff ff ff       	call   808536 <tcp_segs_free>
    pcb->ooseq = NULL;
  8085af:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  8085b6:	8b 43 74             	mov    0x74(%ebx),%eax
  8085b9:	89 04 24             	mov    %eax,(%esp)
  8085bc:	e8 75 ff ff ff       	call   808536 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  8085c1:	8b 43 78             	mov    0x78(%ebx),%eax
  8085c4:	89 04 24             	mov    %eax,(%esp)
  8085c7:	e8 6a ff ff ff       	call   808536 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  8085cc:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  8085d3:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  8085da:	83 c4 14             	add    $0x14,%esp
  8085dd:	5b                   	pop    %ebx
  8085de:	5d                   	pop    %ebp
  8085df:	c3                   	ret    

008085e0 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  8085e0:	55                   	push   %ebp
  8085e1:	89 e5                	mov    %esp,%ebp
  8085e3:	53                   	push   %ebx
  8085e4:	83 ec 14             	sub    $0x14,%esp
  8085e7:	8b 45 08             	mov    0x8(%ebp),%eax
  8085ea:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  8085ed:	8b 10                	mov    (%eax),%edx
  8085ef:	39 da                	cmp    %ebx,%edx
  8085f1:	75 07                	jne    8085fa <tcp_pcb_remove+0x1a>
  8085f3:	8b 52 0c             	mov    0xc(%edx),%edx
  8085f6:	89 10                	mov    %edx,(%eax)
  8085f8:	eb 2a                	jmp    808624 <tcp_pcb_remove+0x44>
  8085fa:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  808600:	85 d2                	test   %edx,%edx
  808602:	74 20                	je     808624 <tcp_pcb_remove+0x44>
  808604:	8b 42 0c             	mov    0xc(%edx),%eax
  808607:	85 c0                	test   %eax,%eax
  808609:	0f 84 c0 00 00 00    	je     8086cf <tcp_pcb_remove+0xef>
  80860f:	39 c3                	cmp    %eax,%ebx
  808611:	75 08                	jne    80861b <tcp_pcb_remove+0x3b>
  808613:	8b 43 0c             	mov    0xc(%ebx),%eax
  808616:	89 42 0c             	mov    %eax,0xc(%edx)
  808619:	eb 09                	jmp    808624 <tcp_pcb_remove+0x44>
  80861b:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808620:	89 c2                	mov    %eax,%edx
  808622:	eb e0                	jmp    808604 <tcp_pcb_remove+0x24>
  808624:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  80862b:	89 1c 24             	mov    %ebx,(%esp)
  80862e:	e8 34 ff ff ff       	call   808567 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  808633:	8b 43 10             	mov    0x10(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  808636:	83 f8 0a             	cmp    $0xa,%eax
  808639:	74 1b                	je     808656 <tcp_pcb_remove+0x76>
  80863b:	83 f8 01             	cmp    $0x1,%eax
  80863e:	74 16                	je     808656 <tcp_pcb_remove+0x76>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  808640:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  808644:	a8 01                	test   $0x1,%al
  808646:	74 0e                	je     808656 <tcp_pcb_remove+0x76>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  808648:	83 c8 02             	or     $0x2,%eax
  80864b:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  80864e:	89 1c 24             	mov    %ebx,(%esp)
  808651:	e8 a5 27 00 00       	call   80adfb <tcp_output>
  }

  if (pcb->state != LISTEN) {
  808656:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  80865a:	74 66                	je     8086c2 <tcp_pcb_remove+0xe2>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  80865c:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  808660:	74 1c                	je     80867e <tcp_pcb_remove+0x9e>
  808662:	c7 44 24 08 6f 35 81 	movl   $0x81356f,0x8(%esp)
  808669:	00 
  80866a:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  808671:	00 
  808672:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808679:	e8 96 82 ff ff       	call   800914 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  80867e:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  808682:	74 1c                	je     8086a0 <tcp_pcb_remove+0xc0>
  808684:	c7 44 24 08 9b 35 81 	movl   $0x81359b,0x8(%esp)
  80868b:	00 
  80868c:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  808693:	00 
  808694:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  80869b:	e8 74 82 ff ff       	call   800914 <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  8086a0:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  8086a4:	74 1c                	je     8086c2 <tcp_pcb_remove+0xe2>
  8086a6:	c7 44 24 08 b4 35 81 	movl   $0x8135b4,0x8(%esp)
  8086ad:	00 
  8086ae:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  8086b5:	00 
  8086b6:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  8086bd:	e8 52 82 ff ff       	call   800914 <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  8086c2:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  8086c9:	83 c4 14             	add    $0x14,%esp
  8086cc:	5b                   	pop    %ebx
  8086cd:	5d                   	pop    %ebp
  8086ce:	c3                   	ret    
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
  8086cf:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  8086d4:	e9 4b ff ff ff       	jmp    808624 <tcp_pcb_remove+0x44>

008086d9 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  8086d9:	55                   	push   %ebp
  8086da:	89 e5                	mov    %esp,%ebp
  8086dc:	83 ec 18             	sub    $0x18,%esp
  8086df:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8086e2:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8086e5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  8086e8:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8086ec:	74 1c                	je     80870a <tcp_listen_with_backlog+0x31>
  8086ee:	c7 44 24 08 cc 35 81 	movl   $0x8135cc,0x8(%esp)
  8086f5:	00 
  8086f6:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  8086fd:	00 
  8086fe:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808705:	e8 0a 82 ff ff       	call   800914 <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80870a:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  808711:	e8 22 eb ff ff       	call   807238 <memp_malloc>
  808716:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  808718:	b8 00 00 00 00       	mov    $0x0,%eax
  80871d:	85 f6                	test   %esi,%esi
  80871f:	0f 84 a8 00 00 00    	je     8087cd <tcp_listen_with_backlog+0xf4>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  808725:	8b 43 18             	mov    0x18(%ebx),%eax
  808728:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  80872b:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  80872f:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  808733:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  80873a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80873e:	83 c8 02             	or     $0x2,%eax
  808741:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  808745:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  808749:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  80874c:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  808750:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  808753:	b8 00 00 00 00       	mov    $0x0,%eax
  808758:	85 db                	test   %ebx,%ebx
  80875a:	74 02                	je     80875e <tcp_listen_with_backlog+0x85>
  80875c:	8b 03                	mov    (%ebx),%eax
  80875e:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808760:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  808766:	39 da                	cmp    %ebx,%edx
  808768:	75 0a                	jne    808774 <tcp_listen_with_backlog+0x9b>
  80876a:	8b 42 0c             	mov    0xc(%edx),%eax
  80876d:	a3 1c f0 b3 00       	mov    %eax,0xb3f01c
  808772:	eb 26                	jmp    80879a <tcp_listen_with_backlog+0xc1>
  808774:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  80877a:	85 d2                	test   %edx,%edx
  80877c:	74 1c                	je     80879a <tcp_listen_with_backlog+0xc1>
  80877e:	8b 42 0c             	mov    0xc(%edx),%eax
  808781:	85 c0                	test   %eax,%eax
  808783:	74 52                	je     8087d7 <tcp_listen_with_backlog+0xfe>
  808785:	39 c3                	cmp    %eax,%ebx
  808787:	75 08                	jne    808791 <tcp_listen_with_backlog+0xb8>
  808789:	8b 43 0c             	mov    0xc(%ebx),%eax
  80878c:	89 42 0c             	mov    %eax,0xc(%edx)
  80878f:	eb 09                	jmp    80879a <tcp_listen_with_backlog+0xc1>
  808791:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808796:	89 c2                	mov    %eax,%edx
  808798:	eb e4                	jmp    80877e <tcp_listen_with_backlog+0xa5>
  80879a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  8087a1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8087a5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8087ac:	e8 43 ea ff ff       	call   8071f4 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  8087b1:	c7 46 20 10 82 80 00 	movl   $0x808210,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  8087b8:	a1 14 f0 b3 00       	mov    0xb3f014,%eax
  8087bd:	89 46 0c             	mov    %eax,0xc(%esi)
  8087c0:	89 35 14 f0 b3 00    	mov    %esi,0xb3f014
  8087c6:	e8 52 c2 ff ff       	call   804a1d <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  8087cb:	89 f0                	mov    %esi,%eax
}
  8087cd:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8087d0:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8087d3:	89 ec                	mov    %ebp,%esp
  8087d5:	5d                   	pop    %ebp
  8087d6:	c3                   	ret    
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8087d7:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  8087dc:	eb bc                	jmp    80879a <tcp_listen_with_backlog+0xc1>

008087de <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8087de:	55                   	push   %ebp
  8087df:	89 e5                	mov    %esp,%ebp
  8087e1:	57                   	push   %edi
  8087e2:	56                   	push   %esi
  8087e3:	53                   	push   %ebx
  8087e4:	83 ec 1c             	sub    $0x1c,%esp
  8087e7:	8b 75 08             	mov    0x8(%ebp),%esi
  8087ea:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8087ed:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  8087f1:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  8087f5:	74 1c                	je     808813 <tcp_bind+0x35>
  8087f7:	c7 44 24 08 f0 35 81 	movl   $0x8135f0,0x8(%esp)
  8087fe:	00 
  8087ff:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  808806:	00 
  808807:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  80880e:	e8 01 81 ff ff       	call   800914 <_panic>

  if (port == 0) {
  808813:	66 85 c0             	test   %ax,%ax
  808816:	75 05                	jne    80881d <tcp_bind+0x3f>
    port = tcp_new_port();
  808818:	e8 fd f9 ff ff       	call   80821a <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80881d:	8b 15 14 f0 b3 00    	mov    0xb3f014,%edx
  808823:	85 d2                	test   %edx,%edx
  808825:	74 39                	je     808860 <tcp_bind+0x82>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  808827:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80882b:	75 2c                	jne    808859 <tcp_bind+0x7b>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80882d:	85 d2                	test   %edx,%edx
  80882f:	0f 84 e1 00 00 00    	je     808916 <tcp_bind+0x138>
  808835:	8b 0a                	mov    (%edx),%ecx
  808837:	85 c9                	test   %ecx,%ecx
  808839:	0f 84 d7 00 00 00    	je     808916 <tcp_bind+0x138>
  80883f:	85 db                	test   %ebx,%ebx
  808841:	0f 84 cf 00 00 00    	je     808916 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  808847:	8b 3b                	mov    (%ebx),%edi
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808849:	85 ff                	test   %edi,%edi
  80884b:	0f 84 c5 00 00 00    	je     808916 <tcp_bind+0x138>
  808851:	39 f9                	cmp    %edi,%ecx
  808853:	0f 84 bd 00 00 00    	je     808916 <tcp_bind+0x138>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  808859:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80885c:	85 d2                	test   %edx,%edx
  80885e:	75 c7                	jne    808827 <tcp_bind+0x49>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  808860:	8b 15 0c f0 b3 00    	mov    0xb3f00c,%edx
  808866:	85 d2                	test   %edx,%edx
  808868:	74 35                	je     80889f <tcp_bind+0xc1>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80886a:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80886e:	75 28                	jne    808898 <tcp_bind+0xba>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808870:	85 d2                	test   %edx,%edx
  808872:	0f 84 9e 00 00 00    	je     808916 <tcp_bind+0x138>
  808878:	8b 0a                	mov    (%edx),%ecx
  80887a:	85 c9                	test   %ecx,%ecx
  80887c:	0f 84 94 00 00 00    	je     808916 <tcp_bind+0x138>
  808882:	85 db                	test   %ebx,%ebx
  808884:	0f 84 8c 00 00 00    	je     808916 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  80888a:	8b 3b                	mov    (%ebx),%edi
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80888c:	85 ff                	test   %edi,%edi
  80888e:	0f 84 82 00 00 00    	je     808916 <tcp_bind+0x138>
  808894:	39 f9                	cmp    %edi,%ecx
  808896:	74 7e                	je     808916 <tcp_bind+0x138>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  808898:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  80889b:	85 d2                	test   %edx,%edx
  80889d:	75 cb                	jne    80886a <tcp_bind+0x8c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80889f:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  8088a5:	85 d2                	test   %edx,%edx
  8088a7:	74 25                	je     8088ce <tcp_bind+0xf0>
    if (cpcb->local_port == port) {
  8088a9:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8088ad:	75 18                	jne    8088c7 <tcp_bind+0xe9>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8088af:	85 d2                	test   %edx,%edx
  8088b1:	74 63                	je     808916 <tcp_bind+0x138>
  8088b3:	8b 0a                	mov    (%edx),%ecx
  8088b5:	85 c9                	test   %ecx,%ecx
  8088b7:	74 5d                	je     808916 <tcp_bind+0x138>
  8088b9:	85 db                	test   %ebx,%ebx
  8088bb:	74 59                	je     808916 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  8088bd:	8b 3b                	mov    (%ebx),%edi
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8088bf:	85 ff                	test   %edi,%edi
  8088c1:	74 53                	je     808916 <tcp_bind+0x138>
  8088c3:	39 f9                	cmp    %edi,%ecx
  8088c5:	74 4f                	je     808916 <tcp_bind+0x138>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8088c7:	8b 52 0c             	mov    0xc(%edx),%edx
  8088ca:	85 d2                	test   %edx,%edx
  8088cc:	75 db                	jne    8088a9 <tcp_bind+0xcb>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8088ce:	8b 15 20 f0 b3 00    	mov    0xb3f020,%edx
  8088d4:	85 d2                	test   %edx,%edx
  8088d6:	74 13                	je     8088eb <tcp_bind+0x10d>
    if (cpcb->local_port == port) {
  8088d8:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8088dc:	75 06                	jne    8088e4 <tcp_bind+0x106>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  8088de:	8b 0a                	mov    (%edx),%ecx
  8088e0:	3b 0b                	cmp    (%ebx),%ecx
  8088e2:	74 32                	je     808916 <tcp_bind+0x138>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8088e4:	8b 52 0c             	mov    0xc(%edx),%edx
  8088e7:	85 d2                	test   %edx,%edx
  8088e9:	75 ed                	jne    8088d8 <tcp_bind+0xfa>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  8088eb:	85 db                	test   %ebx,%ebx
  8088ed:	74 09                	je     8088f8 <tcp_bind+0x11a>
  8088ef:	83 3b 00             	cmpl   $0x0,(%ebx)
  8088f2:	74 04                	je     8088f8 <tcp_bind+0x11a>
    pcb->local_ip = *ipaddr;
  8088f4:	8b 13                	mov    (%ebx),%edx
  8088f6:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  8088f8:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  8088fc:	a1 1c f0 b3 00       	mov    0xb3f01c,%eax
  808901:	89 46 0c             	mov    %eax,0xc(%esi)
  808904:	89 35 1c f0 b3 00    	mov    %esi,0xb3f01c
  80890a:	e8 0e c1 ff ff       	call   804a1d <tcp_timer_needed>
  80890f:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  808914:	eb 05                	jmp    80891b <tcp_bind+0x13d>
  808916:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  80891b:	83 c4 1c             	add    $0x1c,%esp
  80891e:	5b                   	pop    %ebx
  80891f:	5e                   	pop    %esi
  808920:	5f                   	pop    %edi
  808921:	5d                   	pop    %ebp
  808922:	c3                   	ret    

00808923 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  808923:	55                   	push   %ebp
  808924:	89 e5                	mov    %esp,%ebp
  808926:	57                   	push   %edi
  808927:	56                   	push   %esi
  808928:	53                   	push   %ebx
  808929:	83 ec 3c             	sub    $0x3c,%esp
  80892c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80892f:	8b 7d 0c             	mov    0xc(%ebp),%edi
  808932:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808936:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80893a:	74 1c                	je     808958 <tcp_connect+0x35>
  80893c:	c7 44 24 08 1c 36 81 	movl   $0x81361c,0x8(%esp)
  808943:	00 
  808944:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  80894b:	00 
  80894c:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808953:	e8 bc 7f ff ff       	call   800914 <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  808958:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  80895d:	85 ff                	test   %edi,%edi
  80895f:	0f 84 28 01 00 00    	je     808a8d <tcp_connect+0x16a>
    pcb->remote_ip = *ipaddr;
  808965:	8b 17                	mov    (%edi),%edx
  808967:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80896a:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  80896e:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  808973:	75 09                	jne    80897e <tcp_connect+0x5b>
    pcb->local_port = tcp_new_port();
  808975:	e8 a0 f8 ff ff       	call   80821a <tcp_new_port>
  80897a:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  80897e:	e8 cb f9 ff ff       	call   80834e <tcp_next_iss>
  pcb->rcv_nxt = 0;
  808983:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  80898a:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  80898d:	83 e8 01             	sub    $0x1,%eax
  808990:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  808993:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  808996:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  80899c:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  8089a2:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8089a8:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8089ae:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8089b2:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  8089b9:	e8 a5 f9 ff ff       	call   808363 <tcp_eff_send_mss>
  8089be:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  8089c2:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  8089c8:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8089cb:	01 c0                	add    %eax,%eax
  8089cd:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8089d1:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  8089d8:	8b 45 14             	mov    0x14(%ebp),%eax
  8089db:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8089e1:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  8089e7:	39 da                	cmp    %ebx,%edx
  8089e9:	75 0a                	jne    8089f5 <tcp_connect+0xd2>
  8089eb:	8b 42 0c             	mov    0xc(%edx),%eax
  8089ee:	a3 1c f0 b3 00       	mov    %eax,0xb3f01c
  8089f3:	eb 2a                	jmp    808a1f <tcp_connect+0xfc>
  8089f5:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  8089fb:	85 d2                	test   %edx,%edx
  8089fd:	74 20                	je     808a1f <tcp_connect+0xfc>
  8089ff:	8b 42 0c             	mov    0xc(%edx),%eax
  808a02:	85 c0                	test   %eax,%eax
  808a04:	0f 84 8d 00 00 00    	je     808a97 <tcp_connect+0x174>
  808a0a:	39 c3                	cmp    %eax,%ebx
  808a0c:	75 08                	jne    808a16 <tcp_connect+0xf3>
  808a0e:	8b 43 0c             	mov    0xc(%ebx),%eax
  808a11:	89 42 0c             	mov    %eax,0xc(%edx)
  808a14:	eb 09                	jmp    808a1f <tcp_connect+0xfc>
  808a16:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808a1b:	89 c2                	mov    %eax,%edx
  808a1d:	eb e0                	jmp    8089ff <tcp_connect+0xdc>
  808a1f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  TCP_REG(&tcp_active_pcbs, pcb);
  808a26:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  808a2b:	89 43 0c             	mov    %eax,0xc(%ebx)
  808a2e:	89 1d 0c f0 b3 00    	mov    %ebx,0xb3f00c
  808a34:	e8 e4 bf ff ff       	call   804a1d <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  808a39:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  808a40:	e8 4f 1d 00 00       	call   80a794 <htonl>
  808a45:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  808a48:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  808a4f:	00 
  808a50:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  808a53:	89 44 24 14          	mov    %eax,0x14(%esp)
  808a57:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808a5e:	00 
  808a5f:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  808a66:	00 
  808a67:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808a6e:	00 
  808a6f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808a76:	00 
  808a77:	89 1c 24             	mov    %ebx,(%esp)
  808a7a:	e8 c9 28 00 00       	call   80b348 <tcp_enqueue>
  808a7f:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  808a81:	84 c0                	test   %al,%al
  808a83:	75 08                	jne    808a8d <tcp_connect+0x16a>
    tcp_output(pcb);
  808a85:	89 1c 24             	mov    %ebx,(%esp)
  808a88:	e8 6e 23 00 00       	call   80adfb <tcp_output>
  }
  return ret;
} 
  808a8d:	89 f0                	mov    %esi,%eax
  808a8f:	83 c4 3c             	add    $0x3c,%esp
  808a92:	5b                   	pop    %ebx
  808a93:	5e                   	pop    %esi
  808a94:	5f                   	pop    %edi
  808a95:	5d                   	pop    %ebp
  808a96:	c3                   	ret    
  pcb->ssthresh = pcb->mss * 10;
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808a97:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808a9c:	eb 81                	jmp    808a1f <tcp_connect+0xfc>

00808a9e <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  808a9e:	55                   	push   %ebp
  808a9f:	89 e5                	mov    %esp,%ebp
  808aa1:	57                   	push   %edi
  808aa2:	56                   	push   %esi
  808aa3:	53                   	push   %ebx
  808aa4:	83 ec 4c             	sub    $0x4c,%esp
  808aa7:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  808aaa:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  808aae:	75 25                	jne    808ad5 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  808ab0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808ab4:	c7 04 24 20 f0 b3 00 	movl   $0xb3f020,(%esp)
  808abb:	e8 20 fb ff ff       	call   8085e0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  808ac0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808ac4:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808acb:	e8 24 e7 ff ff       	call   8071f4 <memp_free>
  808ad0:	e9 d1 00 00 00       	jmp    808ba6 <tcp_abort+0x108>
  } else {
    seqno = pcb->snd_nxt;
  808ad5:	8b 43 54             	mov    0x54(%ebx),%eax
  808ad8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    ackno = pcb->rcv_nxt;
  808adb:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  808ade:	b8 00 00 00 00       	mov    $0x0,%eax
  808ae3:	85 db                	test   %ebx,%ebx
  808ae5:	74 02                	je     808ae9 <tcp_abort+0x4b>
  808ae7:	8b 03                	mov    (%ebx),%eax
  808ae9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  808aec:	b8 00 00 00 00       	mov    $0x0,%eax
  808af1:	83 fb fc             	cmp    $0xfffffffc,%ebx
  808af4:	74 03                	je     808af9 <tcp_abort+0x5b>
  808af6:	8b 43 04             	mov    0x4(%ebx),%eax
  808af9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  808afc:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  808b00:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    remote_port = pcb->remote_port;
  808b04:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  808b08:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  808b0c:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  808b12:	8b 43 18             	mov    0x18(%ebx),%eax
  808b15:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  808b18:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808b1c:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  808b23:	e8 b8 fa ff ff       	call   8085e0 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  808b28:	8b 43 78             	mov    0x78(%ebx),%eax
  808b2b:	85 c0                	test   %eax,%eax
  808b2d:	74 08                	je     808b37 <tcp_abort+0x99>
      tcp_segs_free(pcb->unacked);
  808b2f:	89 04 24             	mov    %eax,(%esp)
  808b32:	e8 ff f9 ff ff       	call   808536 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  808b37:	8b 43 74             	mov    0x74(%ebx),%eax
  808b3a:	85 c0                	test   %eax,%eax
  808b3c:	74 08                	je     808b46 <tcp_abort+0xa8>
      tcp_segs_free(pcb->unsent);
  808b3e:	89 04 24             	mov    %eax,(%esp)
  808b41:	e8 f0 f9 ff ff       	call   808536 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  808b46:	8b 43 7c             	mov    0x7c(%ebx),%eax
  808b49:	85 c0                	test   %eax,%eax
  808b4b:	74 08                	je     808b55 <tcp_abort+0xb7>
      tcp_segs_free(pcb->ooseq);
  808b4d:	89 04 24             	mov    %eax,(%esp)
  808b50:	e8 e1 f9 ff ff       	call   808536 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  808b55:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808b59:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808b60:	e8 8f e6 ff ff       	call   8071f4 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  808b65:	85 f6                	test   %esi,%esi
  808b67:	74 10                	je     808b79 <tcp_abort+0xdb>
  808b69:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  808b70:	ff 
  808b71:	8b 45 cc             	mov    -0x34(%ebp),%eax
  808b74:	89 04 24             	mov    %eax,(%esp)
  808b77:	ff d6                	call   *%esi
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  808b79:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  808b7d:	89 44 24 14          	mov    %eax,0x14(%esp)
  808b81:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  808b85:	89 44 24 10          	mov    %eax,0x10(%esp)
  808b89:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  808b8c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808b90:	8d 45 e0             	lea    -0x20(%ebp),%eax
  808b93:	89 44 24 08          	mov    %eax,0x8(%esp)
  808b97:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808b9b:	8b 45 d0             	mov    -0x30(%ebp),%eax
  808b9e:	89 04 24             	mov    %eax,(%esp)
  808ba1:	e8 f6 20 00 00       	call   80ac9c <tcp_rst>
  }
}
  808ba6:	83 c4 4c             	add    $0x4c,%esp
  808ba9:	5b                   	pop    %ebx
  808baa:	5e                   	pop    %esi
  808bab:	5f                   	pop    %edi
  808bac:	5d                   	pop    %ebp
  808bad:	c3                   	ret    

00808bae <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  808bae:	55                   	push   %ebp
  808baf:	89 e5                	mov    %esp,%ebp
  808bb1:	83 ec 38             	sub    $0x38,%esp
  808bb4:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  808bb7:	89 75 f8             	mov    %esi,-0x8(%ebp)
  808bba:	89 7d fc             	mov    %edi,-0x4(%ebp)
  808bbd:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  808bc1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808bc8:	e8 6b e6 ff ff       	call   807238 <memp_malloc>
  808bcd:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  808bcf:	85 c0                	test   %eax,%eax
  808bd1:	0f 85 c9 00 00 00    	jne    808ca0 <tcp_alloc+0xf2>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808bd7:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  808bdc:	85 c0                	test   %eax,%eax
  808bde:	74 36                	je     808c16 <tcp_alloc+0x68>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  808be0:	8b 1d 10 f0 b3 00    	mov    0xb3f010,%ebx
  808be6:	bf 00 00 00 00       	mov    $0x0,%edi
  808beb:	b9 00 00 00 00       	mov    $0x0,%ecx
  808bf0:	89 da                	mov    %ebx,%edx
  808bf2:	2b 50 2c             	sub    0x2c(%eax),%edx
  808bf5:	39 ca                	cmp    %ecx,%edx
  808bf7:	72 04                	jb     808bfd <tcp_alloc+0x4f>
  808bf9:	89 c7                	mov    %eax,%edi
  808bfb:	eb 02                	jmp    808bff <tcp_alloc+0x51>
  808bfd:	89 ca                	mov    %ecx,%edx
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808bff:	8b 40 0c             	mov    0xc(%eax),%eax
  808c02:	85 c0                	test   %eax,%eax
  808c04:	74 04                	je     808c0a <tcp_alloc+0x5c>
  808c06:	89 d1                	mov    %edx,%ecx
  808c08:	eb e6                	jmp    808bf0 <tcp_alloc+0x42>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  808c0a:	85 ff                	test   %edi,%edi
  808c0c:	74 08                	je     808c16 <tcp_alloc+0x68>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  808c0e:	89 3c 24             	mov    %edi,(%esp)
  808c11:	e8 88 fe ff ff       	call   808a9e <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  808c16:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808c1d:	e8 16 e6 ff ff       	call   807238 <memp_malloc>
  808c22:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  808c24:	85 c0                	test   %eax,%eax
  808c26:	75 78                	jne    808ca0 <tcp_alloc+0xf2>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808c28:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  808c2d:	85 c0                	test   %eax,%eax
  808c2f:	74 59                	je     808c8a <tcp_alloc+0xdc>
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  808c31:	8b 15 10 f0 b3 00    	mov    0xb3f010,%edx
  808c37:	89 55 e0             	mov    %edx,-0x20(%ebp)
  808c3a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  808c41:	bf 00 00 00 00       	mov    $0x0,%edi
  808c46:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  808c4b:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  808c4f:	89 f3                	mov    %esi,%ebx
  808c51:	38 d3                	cmp    %dl,%bl
  808c53:	72 13                	jb     808c68 <tcp_alloc+0xba>
  808c55:	38 ca                	cmp    %cl,%dl
  808c57:	77 0f                	ja     808c68 <tcp_alloc+0xba>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  808c59:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  808c5c:	2b 58 2c             	sub    0x2c(%eax),%ebx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  808c5f:	39 df                	cmp    %ebx,%edi
  808c61:	77 05                	ja     808c68 <tcp_alloc+0xba>
  808c63:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808c66:	eb 04                	jmp    808c6c <tcp_alloc+0xbe>
  808c68:	89 ca                	mov    %ecx,%edx
  808c6a:	89 fb                	mov    %edi,%ebx
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808c6c:	8b 40 0c             	mov    0xc(%eax),%eax
  808c6f:	85 c0                	test   %eax,%eax
  808c71:	74 06                	je     808c79 <tcp_alloc+0xcb>
  808c73:	89 df                	mov    %ebx,%edi
  808c75:	89 d1                	mov    %edx,%ecx
  808c77:	eb d2                	jmp    808c4b <tcp_alloc+0x9d>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  808c79:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  808c7d:	74 0b                	je     808c8a <tcp_alloc+0xdc>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  808c7f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808c82:	89 04 24             	mov    %eax,(%esp)
  808c85:	e8 14 fe ff ff       	call   808a9e <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  808c8a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808c91:	e8 a2 e5 ff ff       	call   807238 <memp_malloc>
  808c96:	89 c3                	mov    %eax,%ebx
    }
  }
  if (pcb != NULL) {
  808c98:	85 c0                	test   %eax,%eax
  808c9a:	0f 84 9b 00 00 00    	je     808d3b <tcp_alloc+0x18d>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  808ca0:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  808ca7:	00 
  808ca8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808caf:	00 
  808cb0:	89 1c 24             	mov    %ebx,(%esp)
  808cb3:	e8 de 85 ff ff       	call   801296 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  808cb8:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  808cbc:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  808cc2:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  808cc8:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  808cce:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  808cd4:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  808cd8:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  808cdc:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  808ce2:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  808ce8:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  808cee:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  808cf4:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  808cfa:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  808d00:	e8 49 f6 ff ff       	call   80834e <tcp_next_iss>
    pcb->snd_wl2 = iss;
  808d05:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  808d08:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  808d0b:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  808d0e:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  808d11:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  808d14:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  808d19:	89 43 2c             	mov    %eax,0x2c(%ebx)

    pcb->polltmr = 0;
  808d1c:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  808d20:	c7 83 88 00 00 00 2f 	movl   $0x80932f,0x88(%ebx)
  808d27:	93 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  808d2a:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  808d31:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  808d34:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  }
  return pcb;
}
  808d3b:	89 d8                	mov    %ebx,%eax
  808d3d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  808d40:	8b 75 f8             	mov    -0x8(%ebp),%esi
  808d43:	8b 7d fc             	mov    -0x4(%ebp),%edi
  808d46:	89 ec                	mov    %ebp,%esp
  808d48:	5d                   	pop    %ebp
  808d49:	c3                   	ret    

00808d4a <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  808d4a:	55                   	push   %ebp
  808d4b:	89 e5                	mov    %esp,%ebp
  808d4d:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  808d50:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  808d57:	e8 52 fe ff ff       	call   808bae <tcp_alloc>
}
  808d5c:	c9                   	leave  
  808d5d:	c3                   	ret    

00808d5e <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  808d5e:	55                   	push   %ebp
  808d5f:	89 e5                	mov    %esp,%ebp
  808d61:	57                   	push   %edi
  808d62:	56                   	push   %esi
  808d63:	53                   	push   %ebx
  808d64:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  808d67:	83 05 10 f0 b3 00 01 	addl   $0x1,0xb3f010

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  808d6e:	8b 1d 0c f0 b3 00    	mov    0xb3f00c,%ebx
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  808d74:	85 db                	test   %ebx,%ebx
  808d76:	0f 84 5d 03 00 00    	je     8090d9 <tcp_slowtmr+0x37b>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  808d7c:	8b 43 10             	mov    0x10(%ebx),%eax
  808d7f:	85 c0                	test   %eax,%eax
  808d81:	74 1c                	je     808d9f <tcp_slowtmr+0x41>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  808d83:	83 f8 01             	cmp    $0x1,%eax
  808d86:	74 38                	je     808dc0 <tcp_slowtmr+0x62>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  808d88:	83 f8 0a             	cmp    $0xa,%eax
  808d8b:	74 54                	je     808de1 <tcp_slowtmr+0x83>
  808d8d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  808d91:	bf 00 00 00 00       	mov    $0x0,%edi
  808d96:	eb 67                	jmp    808dff <tcp_slowtmr+0xa1>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  808d98:	8b 46 10             	mov    0x10(%esi),%eax
  808d9b:	85 c0                	test   %eax,%eax
  808d9d:	75 1c                	jne    808dbb <tcp_slowtmr+0x5d>
  808d9f:	c7 44 24 08 50 36 81 	movl   $0x813650,0x8(%esp)
  808da6:	00 
  808da7:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  808dae:	00 
  808daf:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808db6:	e8 59 7b ff ff       	call   800914 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  808dbb:	83 f8 01             	cmp    $0x1,%eax
  808dbe:	75 1c                	jne    808ddc <tcp_slowtmr+0x7e>
  808dc0:	c7 44 24 08 7c 36 81 	movl   $0x81367c,0x8(%esp)
  808dc7:	00 
  808dc8:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  808dcf:	00 
  808dd0:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808dd7:	e8 38 7b ff ff       	call   800914 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  808ddc:	83 f8 0a             	cmp    $0xa,%eax
  808ddf:	75 1c                	jne    808dfd <tcp_slowtmr+0x9f>
  808de1:	c7 44 24 08 a8 36 81 	movl   $0x8136a8,0x8(%esp)
  808de8:	00 
  808de9:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  808df0:	00 
  808df1:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808df8:	e8 17 7b ff ff       	call   800914 <_panic>
  808dfd:	89 f3                	mov    %esi,%ebx

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  808dff:	83 f8 02             	cmp    $0x2,%eax
  808e02:	75 0a                	jne    808e0e <tcp_slowtmr+0xb0>
  808e04:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  808e08:	0f 84 ef 00 00 00    	je     808efd <tcp_slowtmr+0x19f>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  808e0e:	80 7b 46 0c          	cmpb   $0xc,0x46(%ebx)
  808e12:	0f 84 e5 00 00 00    	je     808efd <tcp_slowtmr+0x19f>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  808e18:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  808e1f:	90                   	nop
  808e20:	74 55                	je     808e77 <tcp_slowtmr+0x119>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  808e22:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  808e28:	83 c0 01             	add    $0x1,%eax
  808e2b:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  808e31:	0f b6 93 a4 00 00 00 	movzbl 0xa4(%ebx),%edx
  808e38:	0f b6 92 dc 37 81 00 	movzbl 0x8137dc(%edx),%edx
  808e3f:	39 d0                	cmp    %edx,%eax
  808e41:	0f 82 bd 00 00 00    	jb     808f04 <tcp_slowtmr+0x1a6>
          pcb->persist_cnt = 0;
  808e47:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  808e4e:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  808e51:	0f b6 83 a4 00 00 00 	movzbl 0xa4(%ebx),%eax
  808e58:	3c 06                	cmp    $0x6,%al
  808e5a:	77 09                	ja     808e65 <tcp_slowtmr+0x107>
            pcb->persist_backoff++;
  808e5c:	83 c0 01             	add    $0x1,%eax
  808e5f:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  808e65:	89 1c 24             	mov    %ebx,(%esp)
  808e68:	e8 63 1b 00 00       	call   80a9d0 <tcp_zero_window_probe>
  808e6d:	be 00 00 00 00       	mov    $0x0,%esi
  808e72:	e9 92 00 00 00       	jmp    808f09 <tcp_slowtmr+0x1ab>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  808e77:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  808e7b:	66 85 c0             	test   %ax,%ax
  808e7e:	78 07                	js     808e87 <tcp_slowtmr+0x129>
          ++pcb->rtime;
  808e80:	83 c0 01             	add    $0x1,%eax
  808e83:	66 89 43 32          	mov    %ax,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  808e87:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  808e8b:	74 77                	je     808f04 <tcp_slowtmr+0x1a6>
  808e8d:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  808e91:	66 3b 43 44          	cmp    0x44(%ebx),%ax
  808e95:	7c 6d                	jl     808f04 <tcp_slowtmr+0x1a6>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  808e97:	83 7b 10 02          	cmpl   $0x2,0x10(%ebx)
  808e9b:	74 20                	je     808ebd <tcp_slowtmr+0x15f>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  808e9d:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  808ea1:	66 c1 f8 03          	sar    $0x3,%ax
  808ea5:	98                   	cwtl   
  808ea6:	0f bf 53 42          	movswl 0x42(%ebx),%edx
  808eaa:	01 d0                	add    %edx,%eax
  808eac:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  808eb0:	0f b6 8a d0 37 81 00 	movzbl 0x8137d0(%edx),%ecx
  808eb7:	d3 e0                	shl    %cl,%eax
  808eb9:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  808ebd:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  808ec3:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  808ec7:	66 39 43 4e          	cmp    %ax,0x4e(%ebx)
  808ecb:	66 0f 46 43 4e       	cmovbe 0x4e(%ebx),%ax
  808ed0:	66 d1 e8             	shr    %ax
  808ed3:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  808ed7:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  808edb:	66 39 d0             	cmp    %dx,%ax
  808ede:	73 06                	jae    808ee6 <tcp_slowtmr+0x188>
            pcb->ssthresh = pcb->mss * 2;
  808ee0:	01 d2                	add    %edx,%edx
  808ee2:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  808ee6:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  808eea:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  808eee:	89 1c 24             	mov    %ebx,(%esp)
  808ef1:	e8 fd 23 00 00       	call   80b2f3 <tcp_rexmit_rto>
  808ef6:	be 00 00 00 00       	mov    $0x0,%esi
  808efb:	eb 0c                	jmp    808f09 <tcp_slowtmr+0x1ab>
  808efd:	be 01 00 00 00       	mov    $0x1,%esi
  808f02:	eb 05                	jmp    808f09 <tcp_slowtmr+0x1ab>
  808f04:	be 00 00 00 00       	mov    $0x0,%esi
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  808f09:	8b 43 10             	mov    0x10(%ebx),%eax
  808f0c:	83 f8 06             	cmp    $0x6,%eax
  808f0f:	75 13                	jne    808f24 <tcp_slowtmr+0x1c6>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  808f11:	8b 15 10 f0 b3 00    	mov    0xb3f010,%edx
  808f17:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  808f1a:	83 fa 29             	cmp    $0x29,%edx
  808f1d:	89 f2                	mov    %esi,%edx
  808f1f:	80 da ff             	sbb    $0xff,%dl
  808f22:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  808f24:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  808f28:	74 6a                	je     808f94 <tcp_slowtmr+0x236>
  808f2a:	83 f8 04             	cmp    $0x4,%eax
  808f2d:	74 05                	je     808f34 <tcp_slowtmr+0x1d6>
  808f2f:	83 f8 07             	cmp    $0x7,%eax
  808f32:	75 60                	jne    808f94 <tcp_slowtmr+0x236>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  808f34:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  808f39:	2b 43 2c             	sub    0x2c(%ebx),%eax
  808f3c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  808f3f:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  808f45:	8d 81 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%eax
  808f4b:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  808f50:	f7 e2                	mul    %edx
  808f52:	c1 ea 05             	shr    $0x5,%edx
  808f55:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  808f58:	76 0a                	jbe    808f64 <tcp_slowtmr+0x206>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  808f5a:	89 1c 24             	mov    %ebx,(%esp)
  808f5d:	e8 3c fb ff ff       	call   808a9e <tcp_abort>
  808f62:	eb 30                	jmp    808f94 <tcp_slowtmr+0x236>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  808f64:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  808f6b:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  808f71:	8d 0c 0a             	lea    (%edx,%ecx,1),%ecx
  808f74:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  808f79:	89 c8                	mov    %ecx,%eax
  808f7b:	f7 e2                	mul    %edx
  808f7d:	c1 ea 05             	shr    $0x5,%edx
  808f80:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  808f83:	76 0f                	jbe    808f94 <tcp_slowtmr+0x236>
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  808f85:	89 1c 24             	mov    %ebx,(%esp)
  808f88:	e8 ba 1b 00 00       	call   80ab47 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  808f8d:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  808f94:	8b 53 7c             	mov    0x7c(%ebx),%edx
  808f97:	85 d2                	test   %edx,%edx
  808f99:	74 25                	je     808fc0 <tcp_slowtmr+0x262>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  808f9b:	8b 0d 10 f0 b3 00    	mov    0xb3f010,%ecx
  808fa1:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  808fa4:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  808fa8:	8d 04 40             	lea    (%eax,%eax,2),%eax
  808fab:	01 c0                	add    %eax,%eax
  808fad:	39 c1                	cmp    %eax,%ecx
  808faf:	72 0f                	jb     808fc0 <tcp_slowtmr+0x262>
      tcp_segs_free(pcb->ooseq);
  808fb1:	89 14 24             	mov    %edx,(%esp)
  808fb4:	e8 7d f5 ff ff       	call   808536 <tcp_segs_free>
      pcb->ooseq = NULL;
  808fb9:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  808fc0:	8b 43 10             	mov    0x10(%ebx),%eax
  808fc3:	83 f8 03             	cmp    $0x3,%eax
  808fc6:	75 13                	jne    808fdb <tcp_slowtmr+0x27d>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  808fc8:	8b 15 10 f0 b3 00    	mov    0xb3f010,%edx
  808fce:	2b 53 2c             	sub    0x2c(%ebx),%edx
  808fd1:	83 fa 28             	cmp    $0x28,%edx
  808fd4:	76 05                	jbe    808fdb <tcp_slowtmr+0x27d>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  808fd6:	83 c6 01             	add    $0x1,%esi
  808fd9:	eb 19                	jmp    808ff4 <tcp_slowtmr+0x296>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  808fdb:	83 f8 09             	cmp    $0x9,%eax
  808fde:	75 14                	jne    808ff4 <tcp_slowtmr+0x296>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  808fe0:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  808fe5:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  808fe8:	3d f1 00 00 00       	cmp    $0xf1,%eax
  808fed:	89 f2                	mov    %esi,%edx
  808fef:	80 da ff             	sbb    $0xff,%dl
  808ff2:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  808ff4:	89 f0                	mov    %esi,%eax
  808ff6:	84 c0                	test   %al,%al
  808ff8:	0f 84 94 00 00 00    	je     809092 <tcp_slowtmr+0x334>
      tcp_pcb_purge(pcb);      
  808ffe:	89 1c 24             	mov    %ebx,(%esp)
  809001:	e8 61 f5 ff ff       	call   808567 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  809006:	85 ff                	test   %edi,%edi
  809008:	74 2c                	je     809036 <tcp_slowtmr+0x2d8>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80900a:	3b 1d 0c f0 b3 00    	cmp    0xb3f00c,%ebx
  809010:	75 1c                	jne    80902e <tcp_slowtmr+0x2d0>
  809012:	c7 44 24 08 d8 36 81 	movl   $0x8136d8,0x8(%esp)
  809019:	00 
  80901a:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  809021:	00 
  809022:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  809029:	e8 e6 78 ff ff       	call   800914 <_panic>
        prev->next = pcb->next;
  80902e:	8b 43 0c             	mov    0xc(%ebx),%eax
  809031:	89 47 0c             	mov    %eax,0xc(%edi)
  809034:	eb 2d                	jmp    809063 <tcp_slowtmr+0x305>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  809036:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  80903b:	39 d8                	cmp    %ebx,%eax
  80903d:	74 1c                	je     80905b <tcp_slowtmr+0x2fd>
  80903f:	c7 44 24 08 04 37 81 	movl   $0x813704,0x8(%esp)
  809046:	00 
  809047:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  80904e:	00 
  80904f:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  809056:	e8 b9 78 ff ff       	call   800914 <_panic>
        tcp_active_pcbs = pcb->next;
  80905b:	8b 40 0c             	mov    0xc(%eax),%eax
  80905e:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  809063:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  809069:	85 c0                	test   %eax,%eax
  80906b:	74 10                	je     80907d <tcp_slowtmr+0x31f>
  80906d:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  809074:	ff 
  809075:	8b 53 18             	mov    0x18(%ebx),%edx
  809078:	89 14 24             	mov    %edx,(%esp)
  80907b:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  80907d:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  809080:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809084:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80908b:	e8 64 e1 ff ff       	call   8071f4 <memp_free>
  809090:	eb 3f                	jmp    8090d1 <tcp_slowtmr+0x373>
      pcb = pcb2;
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  809092:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  809096:	83 c0 01             	add    $0x1,%eax
  809099:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  80909c:	3a 43 31             	cmp    0x31(%ebx),%al
  80909f:	72 2b                	jb     8090cc <tcp_slowtmr+0x36e>
        pcb->polltmr = 0;
  8090a1:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  8090a5:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  8090ab:	85 c0                	test   %eax,%eax
  8090ad:	74 0f                	je     8090be <tcp_slowtmr+0x360>
  8090af:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8090b3:	8b 53 18             	mov    0x18(%ebx),%edx
  8090b6:	89 14 24             	mov    %edx,(%esp)
  8090b9:	ff d0                	call   *%eax
  8090bb:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  8090be:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8090c2:	75 08                	jne    8090cc <tcp_slowtmr+0x36e>
          tcp_output(pcb);
  8090c4:	89 1c 24             	mov    %ebx,(%esp)
  8090c7:	e8 2f 1d 00 00       	call   80adfb <tcp_output>
        }
      }
      
      prev = pcb;
      pcb = pcb->next;
  8090cc:	8b 73 0c             	mov    0xc(%ebx),%esi
  8090cf:	89 df                	mov    %ebx,%edi
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  8090d1:	85 f6                	test   %esi,%esi
  8090d3:	0f 85 bf fc ff ff    	jne    808d98 <tcp_slowtmr+0x3a>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  8090d9:	8b 1d 20 f0 b3 00    	mov    0xb3f020,%ebx
  while (pcb != NULL) {
  8090df:	85 db                	test   %ebx,%ebx
  8090e1:	0f 84 c7 00 00 00    	je     8091ae <tcp_slowtmr+0x450>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8090e7:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  8090eb:	75 0d                	jne    8090fa <tcp_slowtmr+0x39c>
  8090ed:	be 00 00 00 00       	mov    $0x0,%esi
  8090f2:	eb 24                	jmp    809118 <tcp_slowtmr+0x3ba>
  8090f4:	83 7f 10 0a          	cmpl   $0xa,0x10(%edi)
  8090f8:	74 1c                	je     809116 <tcp_slowtmr+0x3b8>
  8090fa:	c7 44 24 08 30 37 81 	movl   $0x813730,0x8(%esp)
  809101:	00 
  809102:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  809109:	00 
  80910a:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  809111:	e8 fe 77 ff ff       	call   800914 <_panic>
  809116:	89 fb                	mov    %edi,%ebx
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  809118:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  80911d:	2b 43 2c             	sub    0x2c(%ebx),%eax
  809120:	3d f0 00 00 00       	cmp    $0xf0,%eax
  809125:	76 7a                	jbe    8091a1 <tcp_slowtmr+0x443>
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      tcp_pcb_purge(pcb);      
  809127:	89 1c 24             	mov    %ebx,(%esp)
  80912a:	e8 38 f4 ff ff       	call   808567 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  80912f:	85 f6                	test   %esi,%esi
  809131:	74 2c                	je     80915f <tcp_slowtmr+0x401>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  809133:	3b 1d 20 f0 b3 00    	cmp    0xb3f020,%ebx
  809139:	75 1c                	jne    809157 <tcp_slowtmr+0x3f9>
  80913b:	c7 44 24 08 60 37 81 	movl   $0x813760,0x8(%esp)
  809142:	00 
  809143:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  80914a:	00 
  80914b:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  809152:	e8 bd 77 ff ff       	call   800914 <_panic>
        prev->next = pcb->next;
  809157:	8b 43 0c             	mov    0xc(%ebx),%eax
  80915a:	89 46 0c             	mov    %eax,0xc(%esi)
  80915d:	eb 2d                	jmp    80918c <tcp_slowtmr+0x42e>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80915f:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  809164:	39 d8                	cmp    %ebx,%eax
  809166:	74 1c                	je     809184 <tcp_slowtmr+0x426>
  809168:	c7 44 24 08 88 37 81 	movl   $0x813788,0x8(%esp)
  80916f:	00 
  809170:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  809177:	00 
  809178:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  80917f:	e8 90 77 ff ff       	call   800914 <_panic>
        tcp_tw_pcbs = pcb->next;
  809184:	8b 40 0c             	mov    0xc(%eax),%eax
  809187:	a3 20 f0 b3 00       	mov    %eax,0xb3f020
      }
      pcb2 = pcb->next;
  80918c:	8b 7b 0c             	mov    0xc(%ebx),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  80918f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809193:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80919a:	e8 55 e0 ff ff       	call   8071f4 <memp_free>
  80919f:	eb 05                	jmp    8091a6 <tcp_slowtmr+0x448>
      pcb = pcb2;
    } else {
      prev = pcb;
      pcb = pcb->next;
  8091a1:	8b 7b 0c             	mov    0xc(%ebx),%edi
  8091a4:	89 de                	mov    %ebx,%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  8091a6:	85 ff                	test   %edi,%edi
  8091a8:	0f 85 46 ff ff ff    	jne    8090f4 <tcp_slowtmr+0x396>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  8091ae:	83 c4 2c             	add    $0x2c,%esp
  8091b1:	5b                   	pop    %ebx
  8091b2:	5e                   	pop    %esi
  8091b3:	5f                   	pop    %edi
  8091b4:	5d                   	pop    %ebp
  8091b5:	c3                   	ret    

008091b6 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  8091b6:	55                   	push   %ebp
  8091b7:	89 e5                	mov    %esp,%ebp
  8091b9:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  8091bc:	e8 6b f2 ff ff       	call   80842c <tcp_fasttmr>

  if (++tcp_timer & 1) {
  8091c1:	0f b6 05 28 54 b3 00 	movzbl 0xb35428,%eax
  8091c8:	83 c0 01             	add    $0x1,%eax
  8091cb:	a2 28 54 b3 00       	mov    %al,0xb35428
  8091d0:	a8 01                	test   $0x1,%al
  8091d2:	74 05                	je     8091d9 <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  8091d4:	e8 85 fb ff ff       	call   808d5e <tcp_slowtmr>
  }
}
  8091d9:	c9                   	leave  
  8091da:	c3                   	ret    

008091db <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  8091db:	55                   	push   %ebp
  8091dc:	89 e5                	mov    %esp,%ebp
  8091de:	53                   	push   %ebx
  8091df:	83 ec 14             	sub    $0x14,%esp
  8091e2:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  8091e5:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8091e9:	77 0a                	ja     8091f5 <tcp_close+0x1a>
  8091eb:	8b 43 10             	mov    0x10(%ebx),%eax
  8091ee:	ff 24 85 b0 37 81 00 	jmp    *0x8137b0(,%eax,4)
  8091f5:	bb 00 00 00 00       	mov    $0x0,%ebx
  8091fa:	e9 05 01 00 00       	jmp    809304 <tcp_close+0x129>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  8091ff:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  809205:	39 da                	cmp    %ebx,%edx
  809207:	75 0a                	jne    809213 <tcp_close+0x38>
  809209:	8b 42 0c             	mov    0xc(%edx),%eax
  80920c:	a3 1c f0 b3 00       	mov    %eax,0xb3f01c
  809211:	eb 2a                	jmp    80923d <tcp_close+0x62>
  809213:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  809219:	85 d2                	test   %edx,%edx
  80921b:	74 20                	je     80923d <tcp_close+0x62>
  80921d:	8b 42 0c             	mov    0xc(%edx),%eax
  809220:	85 c0                	test   %eax,%eax
  809222:	0f 84 fd 00 00 00    	je     809325 <tcp_close+0x14a>
  809228:	39 c3                	cmp    %eax,%ebx
  80922a:	75 08                	jne    809234 <tcp_close+0x59>
  80922c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80922f:	89 42 0c             	mov    %eax,0xc(%edx)
  809232:	eb 09                	jmp    80923d <tcp_close+0x62>
  809234:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  809239:	89 c2                	mov    %eax,%edx
  80923b:	eb e0                	jmp    80921d <tcp_close+0x42>
  80923d:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  809244:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809248:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80924f:	e8 a0 df ff ff       	call   8071f4 <memp_free>
  809254:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  809259:	e9 c1 00 00 00       	jmp    80931f <tcp_close+0x144>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  80925e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809262:	c7 04 24 14 f0 b3 00 	movl   $0xb3f014,(%esp)
  809269:	e8 72 f3 ff ff       	call   8085e0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  80926e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809272:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  809279:	e8 76 df ff ff       	call   8071f4 <memp_free>
  80927e:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  809283:	e9 97 00 00 00       	jmp    80931f <tcp_close+0x144>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  809288:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80928c:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  809293:	e8 48 f3 ff ff       	call   8085e0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  809298:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80929c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8092a3:	e8 4c df ff ff       	call   8071f4 <memp_free>
  8092a8:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  8092ad:	eb 70                	jmp    80931f <tcp_close+0x144>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8092af:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8092b6:	00 
  8092b7:	89 1c 24             	mov    %ebx,(%esp)
  8092ba:	e8 f9 27 00 00       	call   80bab8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8092bf:	84 c0                	test   %al,%al
  8092c1:	75 5c                	jne    80931f <tcp_close+0x144>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  8092c3:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8092ca:	eb 38                	jmp    809304 <tcp_close+0x129>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8092cc:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8092d3:	00 
  8092d4:	89 1c 24             	mov    %ebx,(%esp)
  8092d7:	e8 dc 27 00 00       	call   80bab8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8092dc:	84 c0                	test   %al,%al
  8092de:	75 3f                	jne    80931f <tcp_close+0x144>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  8092e0:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8092e7:	eb 1b                	jmp    809304 <tcp_close+0x129>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8092e9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8092f0:	00 
  8092f1:	89 1c 24             	mov    %ebx,(%esp)
  8092f4:	e8 bf 27 00 00       	call   80bab8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8092f9:	84 c0                	test   %al,%al
  8092fb:	75 22                	jne    80931f <tcp_close+0x144>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  8092fd:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  809304:	85 db                	test   %ebx,%ebx
  809306:	75 0a                	jne    809312 <tcp_close+0x137>
  809308:	b8 00 00 00 00       	mov    $0x0,%eax
  80930d:	8d 76 00             	lea    0x0(%esi),%esi
  809310:	eb 0d                	jmp    80931f <tcp_close+0x144>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  809312:	89 1c 24             	mov    %ebx,(%esp)
  809315:	e8 e1 1a 00 00       	call   80adfb <tcp_output>
  80931a:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  80931f:	83 c4 14             	add    $0x14,%esp
  809322:	5b                   	pop    %ebx
  809323:	5d                   	pop    %ebp
  809324:	c3                   	ret    
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  809325:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  80932a:	e9 0e ff ff ff       	jmp    80923d <tcp_close+0x62>

0080932f <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80932f:	55                   	push   %ebp
  809330:	89 e5                	mov    %esp,%ebp
  809332:	83 ec 18             	sub    $0x18,%esp
  809335:	8b 45 10             	mov    0x10(%ebp),%eax
  809338:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  80933c:	85 c0                	test   %eax,%eax
  80933e:	74 0f                	je     80934f <tcp_recv_null+0x20>
    pbuf_free(p);
  809340:	89 04 24             	mov    %eax,(%esp)
  809343:	e8 35 e6 ff ff       	call   80797d <pbuf_free>
  809348:	b8 00 00 00 00       	mov    $0x0,%eax
  80934d:	eb 14                	jmp    809363 <tcp_recv_null+0x34>
  } else if (err == ERR_OK) {
  80934f:	b8 00 00 00 00       	mov    $0x0,%eax
  809354:	84 d2                	test   %dl,%dl
  809356:	75 0b                	jne    809363 <tcp_recv_null+0x34>
    return tcp_close(pcb);
  809358:	8b 45 0c             	mov    0xc(%ebp),%eax
  80935b:	89 04 24             	mov    %eax,(%esp)
  80935e:	e8 78 fe ff ff       	call   8091db <tcp_close>
  }
  return ERR_OK;
}
  809363:	c9                   	leave  
  809364:	c3                   	ret    
  809365:	00 00                	add    %al,(%eax)
	...

00809368 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  809368:	55                   	push   %ebp
  809369:	89 e5                	mov    %esp,%ebp
  80936b:	53                   	push   %ebx
  80936c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  80936f:	8b 45 08             	mov    0x8(%ebp),%eax
  809372:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  809374:	8d 5a ff             	lea    -0x1(%edx),%ebx
  809377:	b8 01 00 00 00       	mov    $0x1,%eax
  80937c:	83 fb fd             	cmp    $0xfffffffd,%ebx
  80937f:	77 26                	ja     8093a7 <ip_addr_isbroadcast+0x3f>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  809381:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  809385:	74 1b                	je     8093a2 <ip_addr_isbroadcast+0x3a>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  809387:	8b 41 04             	mov    0x4(%ecx),%eax
  80938a:	39 d0                	cmp    %edx,%eax
  80938c:	74 14                	je     8093a2 <ip_addr_isbroadcast+0x3a>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  80938e:	8b 49 08             	mov    0x8(%ecx),%ecx
  809391:	31 d0                	xor    %edx,%eax
  809393:	85 c8                	test   %ecx,%eax
  809395:	75 0b                	jne    8093a2 <ip_addr_isbroadcast+0x3a>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  809397:	f7 d1                	not    %ecx
  809399:	21 ca                	and    %ecx,%edx
  80939b:	39 d1                	cmp    %edx,%ecx
  80939d:	0f 94 c0             	sete   %al
  8093a0:	eb 05                	jmp    8093a7 <ip_addr_isbroadcast+0x3f>
  8093a2:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  8093a7:	5b                   	pop    %ebx
  8093a8:	5d                   	pop    %ebp
  8093a9:	c3                   	ret    
  8093aa:	00 00                	add    %al,(%eax)
  8093ac:	00 00                	add    %al,(%eax)
	...

008093b0 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  8093b0:	55                   	push   %ebp
  8093b1:	89 e5                	mov    %esp,%ebp
  8093b3:	83 ec 48             	sub    $0x48,%esp
  8093b6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8093b9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8093bc:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8093bf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8093c2:	8b 7d 10             	mov    0x10(%ebp),%edi
  8093c5:	8b 75 20             	mov    0x20(%ebp),%esi
  8093c8:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  8093cc:	88 45 d8             	mov    %al,-0x28(%ebp)
  8093cf:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
  8093d3:	88 55 d7             	mov    %dl,-0x29(%ebp)
  8093d6:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  8093da:	88 45 d6             	mov    %al,-0x2a(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  8093dd:	85 ff                	test   %edi,%edi
  8093df:	0f 84 3a 01 00 00    	je     80951f <ip_output_if+0x16f>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  8093e5:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8093ec:	00 
  8093ed:	89 1c 24             	mov    %ebx,(%esp)
  8093f0:	e8 1e e2 ff ff       	call   807613 <pbuf_header>
  8093f5:	89 c2                	mov    %eax,%edx
  8093f7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8093fc:	84 d2                	test   %dl,%dl
  8093fe:	0f 85 50 01 00 00    	jne    809554 <ip_output_if+0x1a4>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  809404:	8b 43 04             	mov    0x4(%ebx),%eax
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  809407:	66 83 7b 0a 13       	cmpw   $0x13,0xa(%ebx)
  80940c:	77 1c                	ja     80942a <ip_output_if+0x7a>
  80940e:	c7 44 24 08 ec 37 81 	movl   $0x8137ec,0x8(%esp)
  809415:	00 
  809416:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  80941d:	00 
  80941e:	c7 04 24 19 38 81 00 	movl   $0x813819,(%esp)
  809425:	e8 ea 74 ff ff       	call   800914 <_panic>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  80942a:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  80942d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  809431:	89 04 24             	mov    %eax,(%esp)
  809434:	e8 47 13 00 00       	call   80a780 <ntohs>
  809439:	0f b6 d0             	movzbl %al,%edx
  80943c:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
  809440:	c1 e0 08             	shl    $0x8,%eax
  809443:	09 d0                	or     %edx,%eax
  809445:	0f b7 c0             	movzwl %ax,%eax
  809448:	89 04 24             	mov    %eax,(%esp)
  80944b:	e8 23 13 00 00       	call   80a773 <htons>
  809450:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809453:	66 89 42 08          	mov    %ax,0x8(%edx)
    IPH_PROTO_SET(iphdr, proto);
  809457:	0f b7 c0             	movzwl %ax,%eax
  80945a:	89 04 24             	mov    %eax,(%esp)
  80945d:	e8 1e 13 00 00       	call   80a780 <ntohs>
  809462:	89 c2                	mov    %eax,%edx
  809464:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  80946a:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
  80946e:	09 d0                	or     %edx,%eax
  809470:	0f b7 c0             	movzwl %ax,%eax
  809473:	89 04 24             	mov    %eax,(%esp)
  809476:	e8 f8 12 00 00       	call   80a773 <htons>
  80947b:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80947e:	66 89 42 08          	mov    %ax,0x8(%edx)

    ip_addr_set(&(iphdr->dest), dest);
  809482:	8b 07                	mov    (%edi),%eax
  809484:	89 42 10             	mov    %eax,0x10(%edx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  809487:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
  80948b:	80 cc 45             	or     $0x45,%ah
  80948e:	89 04 24             	mov    %eax,(%esp)
  809491:	e8 dd 12 00 00       	call   80a773 <htons>
  809496:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809499:	66 89 02             	mov    %ax,(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  80949c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8094a0:	89 04 24             	mov    %eax,(%esp)
  8094a3:	e8 cb 12 00 00       	call   80a773 <htons>
  8094a8:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8094ab:	66 89 42 02          	mov    %ax,0x2(%edx)
    IPH_OFFSET_SET(iphdr, 0);
  8094af:	66 c7 42 06 00 00    	movw   $0x0,0x6(%edx)
    IPH_ID_SET(iphdr, htons(ip_id));
  8094b5:	0f b7 05 2c 54 b3 00 	movzwl 0xb3542c,%eax
  8094bc:	89 04 24             	mov    %eax,(%esp)
  8094bf:	e8 af 12 00 00       	call   80a773 <htons>
  8094c4:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8094c7:	66 89 42 04          	mov    %ax,0x4(%edx)
    ++ip_id;
  8094cb:	66 83 05 2c 54 b3 00 	addw   $0x1,0xb3542c
  8094d2:	01 

    if (ip_addr_isany(src)) {
  8094d3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8094d7:	74 09                	je     8094e2 <ip_output_if+0x132>
  8094d9:	8b 55 0c             	mov    0xc(%ebp),%edx
  8094dc:	8b 02                	mov    (%edx),%eax
  8094de:	85 c0                	test   %eax,%eax
  8094e0:	75 15                	jne    8094f7 <ip_output_if+0x147>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  8094e2:	b8 00 00 00 00       	mov    $0x0,%eax
  8094e7:	83 fe fc             	cmp    $0xfffffffc,%esi
  8094ea:	74 03                	je     8094ef <ip_output_if+0x13f>
  8094ec:	8b 46 04             	mov    0x4(%esi),%eax
  8094ef:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8094f2:	89 42 0c             	mov    %eax,0xc(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    ++ip_id;

    if (ip_addr_isany(src)) {
  8094f5:	eb 06                	jmp    8094fd <ip_output_if+0x14d>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
    } else {
      ip_addr_set(&(iphdr->src), src);
  8094f7:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8094fa:	89 42 0c             	mov    %eax,0xc(%edx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  8094fd:	8b 45 d0             	mov    -0x30(%ebp),%eax
  809500:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  809506:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80950d:	00 
  80950e:	89 04 24             	mov    %eax,(%esp)
  809511:	e8 44 0f 00 00       	call   80a45a <inet_chksum>
  809516:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809519:	66 89 42 0a          	mov    %ax,0xa(%edx)
  80951d:	eb 06                	jmp    809525 <ip_output_if+0x175>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  80951f:	8b 7b 04             	mov    0x4(%ebx),%edi
  809522:	83 c7 10             	add    $0x10,%edi
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  809525:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
  809529:	66 85 c0             	test   %ax,%ax
  80952c:	74 18                	je     809546 <ip_output_if+0x196>
  80952e:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  809532:	73 12                	jae    809546 <ip_output_if+0x196>
    return ip_frag(p,netif,dest);
  809534:	89 7c 24 08          	mov    %edi,0x8(%esp)
  809538:	89 74 24 04          	mov    %esi,0x4(%esp)
  80953c:	89 1c 24             	mov    %ebx,(%esp)
  80953f:	e8 ac 03 00 00       	call   8098f0 <ip_frag>
  809544:	eb 0e                	jmp    809554 <ip_output_if+0x1a4>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  809546:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80954a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80954e:	89 34 24             	mov    %esi,(%esp)
  809551:	ff 56 14             	call   *0x14(%esi)
  }
}
  809554:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809557:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80955a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80955d:	89 ec                	mov    %ebp,%esp
  80955f:	5d                   	pop    %ebp
  809560:	c3                   	ret    

00809561 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  809561:	55                   	push   %ebp
  809562:	89 e5                	mov    %esp,%ebp
  809564:	56                   	push   %esi
  809565:	53                   	push   %ebx
  809566:	83 ec 10             	sub    $0x10,%esp
  809569:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80956c:	8b 1d 04 f0 b3 00    	mov    0xb3f004,%ebx
  809572:	85 db                	test   %ebx,%ebx
  809574:	74 1c                	je     809592 <ip_route+0x31>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  809576:	89 1c 24             	mov    %ebx,(%esp)
  809579:	e8 11 de ff ff       	call   80738f <netif_is_up>
  80957e:	84 c0                	test   %al,%al
  809580:	74 0a                	je     80958c <ip_route+0x2b>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  809582:	8b 43 04             	mov    0x4(%ebx),%eax
  809585:	33 06                	xor    (%esi),%eax
  809587:	85 43 08             	test   %eax,0x8(%ebx)
  80958a:	74 28                	je     8095b4 <ip_route+0x53>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80958c:	8b 1b                	mov    (%ebx),%ebx
  80958e:	85 db                	test   %ebx,%ebx
  809590:	75 e4                	jne    809576 <ip_route+0x15>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  809592:	a1 08 f0 b3 00       	mov    0xb3f008,%eax
  809597:	85 c0                	test   %eax,%eax
  809599:	74 14                	je     8095af <ip_route+0x4e>
  80959b:	89 04 24             	mov    %eax,(%esp)
  80959e:	e8 ec dd ff ff       	call   80738f <netif_is_up>
  8095a3:	84 c0                	test   %al,%al
  8095a5:	74 08                	je     8095af <ip_route+0x4e>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  8095a7:	8b 1d 08 f0 b3 00    	mov    0xb3f008,%ebx
  8095ad:	eb 05                	jmp    8095b4 <ip_route+0x53>
  8095af:	bb 00 00 00 00       	mov    $0x0,%ebx
}
  8095b4:	89 d8                	mov    %ebx,%eax
  8095b6:	83 c4 10             	add    $0x10,%esp
  8095b9:	5b                   	pop    %ebx
  8095ba:	5e                   	pop    %esi
  8095bb:	5d                   	pop    %ebp
  8095bc:	c3                   	ret    

008095bd <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  8095bd:	55                   	push   %ebp
  8095be:	89 e5                	mov    %esp,%ebp
  8095c0:	83 ec 48             	sub    $0x48,%esp
  8095c3:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8095c6:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8095c9:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8095cc:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8095cf:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  8095d3:	88 45 e7             	mov    %al,-0x19(%ebp)
  8095d6:	0f b6 7d 18          	movzbl 0x18(%ebp),%edi
  8095da:	0f b6 75 1c          	movzbl 0x1c(%ebp),%esi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  8095de:	89 1c 24             	mov    %ebx,(%esp)
  8095e1:	e8 7b ff ff ff       	call   809561 <ip_route>
  8095e6:	89 c2                	mov    %eax,%edx
  8095e8:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8095ed:	85 d2                	test   %edx,%edx
  8095ef:	74 36                	je     809627 <ip_output+0x6a>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  8095f1:	89 54 24 18          	mov    %edx,0x18(%esp)
  8095f5:	81 e6 ff 00 00 00    	and    $0xff,%esi
  8095fb:	89 74 24 14          	mov    %esi,0x14(%esp)
  8095ff:	81 e7 ff 00 00 00    	and    $0xff,%edi
  809605:	89 7c 24 10          	mov    %edi,0x10(%esp)
  809609:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80960d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809611:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  809615:	8b 45 0c             	mov    0xc(%ebp),%eax
  809618:	89 44 24 04          	mov    %eax,0x4(%esp)
  80961c:	8b 45 08             	mov    0x8(%ebp),%eax
  80961f:	89 04 24             	mov    %eax,(%esp)
  809622:	e8 89 fd ff ff       	call   8093b0 <ip_output_if>
}
  809627:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80962a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80962d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809630:	89 ec                	mov    %ebp,%esp
  809632:	5d                   	pop    %ebp
  809633:	c3                   	ret    

00809634 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  809634:	55                   	push   %ebp
  809635:	89 e5                	mov    %esp,%ebp
  809637:	83 ec 48             	sub    $0x48,%esp
  80963a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80963d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  809640:	89 7d fc             	mov    %edi,-0x4(%ebp)
  809643:	8b 75 08             	mov    0x8(%ebp),%esi

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  809646:	8b 5e 04             	mov    0x4(%esi),%ebx
  if (IPH_V(iphdr) != 4) {
  809649:	0f b7 03             	movzwl (%ebx),%eax
  80964c:	89 04 24             	mov    %eax,(%esp)
  80964f:	e8 2c 11 00 00       	call   80a780 <ntohs>
  809654:	66 c1 e8 0c          	shr    $0xc,%ax
  809658:	66 83 f8 04          	cmp    $0x4,%ax
  80965c:	74 0d                	je     80966b <ip_input+0x37>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  80965e:	89 34 24             	mov    %esi,(%esp)
  809661:	e8 17 e3 ff ff       	call   80797d <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  809666:	e9 72 02 00 00       	jmp    8098dd <ip_input+0x2a9>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  80966b:	0f b7 03             	movzwl (%ebx),%eax
  80966e:	89 04 24             	mov    %eax,(%esp)
  809671:	e8 0a 11 00 00       	call   80a780 <ntohs>
  809676:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  80967a:	83 e0 3c             	and    $0x3c,%eax
  80967d:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  809681:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809685:	89 04 24             	mov    %eax,(%esp)
  809688:	e8 f3 10 00 00       	call   80a780 <ntohs>
  80968d:	89 c7                	mov    %eax,%edi

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  80968f:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809693:	66 3b 46 0a          	cmp    0xa(%esi),%ax
  809697:	77 06                	ja     80969f <ip_input+0x6b>
  809699:	66 3b 7e 08          	cmp    0x8(%esi),%di
  80969d:	76 0d                	jbe    8096ac <ip_input+0x78>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  80969f:	89 34 24             	mov    %esi,(%esp)
  8096a2:	e8 d6 e2 ff ff       	call   80797d <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  8096a7:	e9 31 02 00 00       	jmp    8098dd <ip_input+0x2a9>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  8096ac:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8096b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8096b4:	89 1c 24             	mov    %ebx,(%esp)
  8096b7:	e8 9e 0d 00 00       	call   80a45a <inet_chksum>
  8096bc:	66 85 c0             	test   %ax,%ax
  8096bf:	74 0d                	je     8096ce <ip_input+0x9a>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  8096c1:	89 34 24             	mov    %esi,(%esp)
  8096c4:	e8 b4 e2 ff ff       	call   80797d <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8096c9:	e9 0f 02 00 00       	jmp    8098dd <ip_input+0x2a9>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  8096ce:	0f b7 ff             	movzwl %di,%edi
  8096d1:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8096d5:	89 34 24             	mov    %esi,(%esp)
  8096d8:	e8 2c e4 ff ff       	call   807b09 <pbuf_realloc>
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8096dd:	8d 43 10             	lea    0x10(%ebx),%eax
  8096e0:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8096e3:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8096e6:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
        netif = netif->next;
      }
      if (netif == inp) {
        netif = netif->next;
      }
    } while(netif != NULL);
  8096ed:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  8096f0:	89 de                	mov    %ebx,%esi
  8096f2:	bb 01 00 00 00       	mov    $0x1,%ebx
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  8096f7:	89 3c 24             	mov    %edi,(%esp)
  8096fa:	e8 90 dc ff ff       	call   80738f <netif_is_up>
  8096ff:	84 c0                	test   %al,%al
  809701:	74 27                	je     80972a <ip_input+0xf6>
  809703:	83 ff fc             	cmp    $0xfffffffc,%edi
  809706:	74 22                	je     80972a <ip_input+0xf6>
  809708:	8b 47 04             	mov    0x4(%edi),%eax
  80970b:	85 c0                	test   %eax,%eax
  80970d:	8d 76 00             	lea    0x0(%esi),%esi
  809710:	74 18                	je     80972a <ip_input+0xf6>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809712:	3b 46 10             	cmp    0x10(%esi),%eax
  809715:	74 36                	je     80974d <ip_input+0x119>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  809717:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80971b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80971e:	89 04 24             	mov    %eax,(%esp)
  809721:	e8 42 fc ff ff       	call   809368 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809726:	84 c0                	test   %al,%al
  809728:	75 23                	jne    80974d <ip_input+0x119>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  80972a:	85 db                	test   %ebx,%ebx
  80972c:	74 08                	je     809736 <ip_input+0x102>
        first = 0;
        netif = netif_list;
  80972e:	8b 3d 04 f0 b3 00    	mov    0xb3f004,%edi
  809734:	eb 02                	jmp    809738 <ip_input+0x104>
      } else {
        netif = netif->next;
  809736:	8b 3f                	mov    (%edi),%edi
      }
      if (netif == inp) {
  809738:	3b 7d 0c             	cmp    0xc(%ebp),%edi
  80973b:	75 05                	jne    809742 <ip_input+0x10e>
        netif = netif->next;
  80973d:	8b 45 0c             	mov    0xc(%ebp),%eax
  809740:	8b 38                	mov    (%eax),%edi
      }
    } while(netif != NULL);
  809742:	85 ff                	test   %edi,%edi
  809744:	74 12                	je     809758 <ip_input+0x124>
  809746:	bb 00 00 00 00       	mov    $0x0,%ebx
  80974b:	eb aa                	jmp    8096f7 <ip_input+0xc3>
  80974d:	89 f3                	mov    %esi,%ebx
  80974f:	8b 75 d4             	mov    -0x2c(%ebp),%esi
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  809752:	85 ff                	test   %edi,%edi
  809754:	75 2e                	jne    809784 <ip_input+0x150>
  809756:	eb 05                	jmp    80975d <ip_input+0x129>
  809758:	89 f3                	mov    %esi,%ebx
  80975a:	8b 75 d4             	mov    -0x2c(%ebp),%esi
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  80975d:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809761:	89 04 24             	mov    %eax,(%esp)
  809764:	e8 17 10 00 00       	call   80a780 <ntohs>
  809769:	3c 11                	cmp    $0x11,%al
  80976b:	75 17                	jne    809784 <ip_input+0x150>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  80976d:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809771:	0f b7 44 03 02       	movzwl 0x2(%ebx,%eax,1),%eax
  809776:	89 04 24             	mov    %eax,(%esp)
  809779:	e8 02 10 00 00       	call   80a780 <ntohs>
  80977e:	66 83 f8 44          	cmp    $0x44,%ax
  809782:	74 4e                	je     8097d2 <ip_input+0x19e>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  809784:	8b 45 0c             	mov    0xc(%ebp),%eax
  809787:	89 44 24 04          	mov    %eax,0x4(%esp)
  80978b:	8d 43 0c             	lea    0xc(%ebx),%eax
  80978e:	89 04 24             	mov    %eax,(%esp)
  809791:	e8 d2 fb ff ff       	call   809368 <ip_addr_isbroadcast>
  809796:	84 c0                	test   %al,%al
  809798:	75 2b                	jne    8097c5 <ip_input+0x191>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  80979a:	8b 43 0c             	mov    0xc(%ebx),%eax
  80979d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8097a0:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  8097a7:	e8 09 12 00 00       	call   80a9b5 <ntohl>
  8097ac:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8097af:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8097b6:	e8 fa 11 00 00       	call   80a9b5 <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8097bb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8097be:	23 55 dc             	and    -0x24(%ebp),%edx
  8097c1:	39 c2                	cmp    %eax,%edx
  8097c3:	75 10                	jne    8097d5 <ip_input+0x1a1>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  8097c5:	89 34 24             	mov    %esi,(%esp)
  8097c8:	e8 b0 e1 ff ff       	call   80797d <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  8097cd:	e9 0b 01 00 00       	jmp    8098dd <ip_input+0x2a9>
  8097d2:	8b 7d 0c             	mov    0xc(%ebp),%edi
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  8097d5:	85 ff                	test   %edi,%edi
  8097d7:	75 11                	jne    8097ea <ip_input+0x1b6>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  8097d9:	89 34 24             	mov    %esi,(%esp)
  8097dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8097e0:	e8 98 e1 ff ff       	call   80797d <pbuf_free>
    return ERR_OK;
  8097e5:	e9 f3 00 00 00       	jmp    8098dd <ip_input+0x2a9>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  8097ea:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
  8097ee:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  8097f5:	e8 79 0f 00 00       	call   80a773 <htons>
  8097fa:	66 85 f8             	test   %di,%ax
  8097fd:	74 15                	je     809814 <ip_input+0x1e0>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  8097ff:	89 34 24             	mov    %esi,(%esp)
  809802:	e8 4a 05 00 00       	call   809d51 <ip_reass>
  809807:	89 c6                	mov    %eax,%esi
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  809809:	85 c0                	test   %eax,%eax
  80980b:	0f 84 cc 00 00 00    	je     8098dd <ip_input+0x2a9>
      return ERR_OK;
    }
    iphdr = p->payload;
  809811:	8b 58 04             	mov    0x4(%eax),%ebx
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  809814:	8b 45 0c             	mov    0xc(%ebp),%eax
  809817:	89 44 24 04          	mov    %eax,0x4(%esp)
  80981b:	89 34 24             	mov    %esi,(%esp)
  80981e:	e8 50 7e 00 00       	call   811673 <raw_input>
  809823:	84 c0                	test   %al,%al
  809825:	0f 85 b2 00 00 00    	jne    8098dd <ip_input+0x2a9>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  80982b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80982f:	89 04 24             	mov    %eax,(%esp)
  809832:	e8 49 0f 00 00       	call   80a780 <ntohs>
  809837:	0f b6 c0             	movzbl %al,%eax
  80983a:	83 f8 06             	cmp    $0x6,%eax
  80983d:	74 24                	je     809863 <ip_input+0x22f>
  80983f:	83 f8 11             	cmp    $0x11,%eax
  809842:	74 0e                	je     809852 <ip_input+0x21e>
  809844:	83 f8 01             	cmp    $0x1,%eax
  809847:	75 3c                	jne    809885 <ip_input+0x251>
  809849:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  809850:	eb 22                	jmp    809874 <ip_input+0x240>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  809852:	8b 45 0c             	mov    0xc(%ebp),%eax
  809855:	89 44 24 04          	mov    %eax,0x4(%esp)
  809859:	89 34 24             	mov    %esi,(%esp)
  80985c:	e8 c7 26 00 00       	call   80bf28 <udp_input>
      break;
  809861:	eb 7a                	jmp    8098dd <ip_input+0x2a9>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  809863:	8b 45 0c             	mov    0xc(%ebp),%eax
  809866:	89 44 24 04          	mov    %eax,0x4(%esp)
  80986a:	89 34 24             	mov    %esi,(%esp)
  80986d:	e8 c5 6d 00 00       	call   810637 <tcp_input>
      break;
  809872:	eb 69                	jmp    8098dd <ip_input+0x2a9>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  809874:	8b 45 0c             	mov    0xc(%ebp),%eax
  809877:	89 44 24 04          	mov    %eax,0x4(%esp)
  80987b:	89 34 24             	mov    %esi,(%esp)
  80987e:	e8 c1 80 00 00       	call   811944 <icmp_input>
      break;
  809883:	eb 58                	jmp    8098dd <ip_input+0x2a9>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  809885:	8b 45 0c             	mov    0xc(%ebp),%eax
  809888:	89 44 24 04          	mov    %eax,0x4(%esp)
  80988c:	8d 43 10             	lea    0x10(%ebx),%eax
  80988f:	89 04 24             	mov    %eax,(%esp)
  809892:	e8 d1 fa ff ff       	call   809368 <ip_addr_isbroadcast>
  809897:	84 c0                	test   %al,%al
  809899:	75 3a                	jne    8098d5 <ip_input+0x2a1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  80989b:	8b 43 10             	mov    0x10(%ebx),%eax
  80989e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8098a1:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  8098a8:	e8 08 11 00 00       	call   80a9b5 <ntohl>
  8098ad:	89 c7                	mov    %eax,%edi
  8098af:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8098b6:	e8 fa 10 00 00       	call   80a9b5 <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8098bb:	23 7d e4             	and    -0x1c(%ebp),%edi
  8098be:	39 c7                	cmp    %eax,%edi
  8098c0:	74 13                	je     8098d5 <ip_input+0x2a1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  8098c2:	89 5e 04             	mov    %ebx,0x4(%esi)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  8098c5:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  8098cc:	00 
  8098cd:	89 34 24             	mov    %esi,(%esp)
  8098d0:	e8 5d 7f 00 00       	call   811832 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  8098d5:	89 34 24             	mov    %esi,(%esp)
  8098d8:	e8 a0 e0 ff ff       	call   80797d <pbuf_free>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  8098dd:	b8 00 00 00 00       	mov    $0x0,%eax
  8098e2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8098e5:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8098e8:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8098eb:	89 ec                	mov    %ebp,%esp
  8098ed:	5d                   	pop    %ebp
  8098ee:	c3                   	ret    
	...

008098f0 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  8098f0:	55                   	push   %ebp
  8098f1:	89 e5                	mov    %esp,%ebp
  8098f3:	57                   	push   %edi
  8098f4:	56                   	push   %esi
  8098f5:	53                   	push   %ebx
  8098f6:	83 ec 5c             	sub    $0x5c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  8098f9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8098fc:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  809900:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  809907:	00 
  809908:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80990f:	00 
  809910:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809917:	e8 1d e3 ff ff       	call   807c39 <pbuf_alloc>
  80991c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if (rambuf == NULL) {
  80991f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809924:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  809928:	0f 84 c6 01 00 00    	je     809af4 <ip_frag+0x204>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  80992e:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809931:	66 89 72 0a          	mov    %si,0xa(%edx)
  809935:	66 89 72 08          	mov    %si,0x8(%edx)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  809939:	bb 63 54 b3 00       	mov    $0xb35463,%ebx
  80993e:	83 e3 fc             	and    $0xfffffffc,%ebx
  809941:	89 5a 04             	mov    %ebx,0x4(%edx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  809944:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80994b:	00 
  80994c:	8b 55 08             	mov    0x8(%ebp),%edx
  80994f:	8b 42 04             	mov    0x4(%edx),%eax
  809952:	89 44 24 04          	mov    %eax,0x4(%esp)
  809956:	89 1c 24             	mov    %ebx,(%esp)
  809959:	e8 13 7a ff ff       	call   801371 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  80995e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809962:	89 04 24             	mov    %eax,(%esp)
  809965:	e8 16 0e 00 00       	call   80a780 <ntohs>
  80996a:	89 c2                	mov    %eax,%edx
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
  80996c:	66 25 00 20          	and    $0x2000,%ax
  809970:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)

  left = p->tot_len - IP_HLEN;
  809974:	8b 45 08             	mov    0x8(%ebp),%eax
  809977:	0f b7 48 08          	movzwl 0x8(%eax),%ecx

  nfb = (mtu - IP_HLEN) / 8;
  80997b:	0f b7 f6             	movzwl %si,%esi
  80997e:	8d 46 f3             	lea    -0xd(%esi),%eax
  809981:	83 ee 14             	sub    $0x14,%esi
  809984:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809987:	0f 49 c6             	cmovns %esi,%eax
  80998a:	c1 e8 03             	shr    $0x3,%eax
  80998d:	66 89 45 b8          	mov    %ax,-0x48(%ebp)

  while (left) {
  809991:	66 83 e9 14          	sub    $0x14,%cx
  809995:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
  809999:	0f 84 45 01 00 00    	je     809ae4 <ip_frag+0x1f4>
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  80999f:	66 81 e2 ff 1f       	and    $0x1fff,%dx
  8099a4:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8099a8:	66 c7 45 e2 14 00    	movw   $0x14,-0x1e(%ebp)
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;
  8099ae:	c1 e0 03             	shl    $0x3,%eax
  8099b1:	66 89 45 b2          	mov    %ax,-0x4e(%ebp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8099b5:	8d 53 14             	lea    0x14(%ebx),%edx
  8099b8:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    last = (left <= mtu - IP_HLEN);
  8099bb:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8099bf:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  8099c2:	0f 9d c0             	setge  %al
  8099c5:	0f b6 f0             	movzbl %al,%esi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  8099c8:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8099cc:	66 25 ff 1f          	and    $0x1fff,%ax
  8099d0:	66 0b 45 d2          	or     -0x2e(%ebp),%ax
  8099d4:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    if (!last)
  8099d8:	0f b7 7d e6          	movzwl -0x1a(%ebp),%edi
  8099dc:	66 85 f6             	test   %si,%si
  8099df:	75 0a                	jne    8099eb <ip_frag+0xfb>
      tmp = tmp | IP_MF;
  8099e1:	66 81 4d e4 00 20    	orw    $0x2000,-0x1c(%ebp)
  8099e7:	0f b7 7d b2          	movzwl -0x4e(%ebp),%edi

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8099eb:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8099ef:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8099f3:	0f b7 c7             	movzwl %di,%eax
  8099f6:	89 44 24 08          	mov    %eax,0x8(%esp)
  8099fa:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  8099fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  809a01:	8b 55 08             	mov    0x8(%ebp),%edx
  809a04:	89 14 24             	mov    %edx,(%esp)
  809a07:	e8 fa dc ff ff       	call   807706 <pbuf_copy_partial>
  809a0c:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  809a10:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  809a14:	89 04 24             	mov    %eax,(%esp)
  809a17:	e8 57 0d 00 00       	call   80a773 <htons>
  809a1c:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  809a20:	8d 47 14             	lea    0x14(%edi),%eax
  809a23:	0f b7 c0             	movzwl %ax,%eax
  809a26:	89 04 24             	mov    %eax,(%esp)
  809a29:	e8 45 0d 00 00       	call   80a773 <htons>
  809a2e:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  809a32:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  809a38:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  809a3f:	00 
  809a40:	89 1c 24             	mov    %ebx,(%esp)
  809a43:	e8 12 0a 00 00       	call   80a45a <inet_chksum>
  809a48:	66 89 43 0a          	mov    %ax,0xa(%ebx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  809a4c:	66 85 f6             	test   %si,%si
  809a4f:	74 19                	je     809a6a <ip_frag+0x17a>
      pbuf_realloc(rambuf, left + IP_HLEN);
  809a51:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  809a55:	83 c0 14             	add    $0x14,%eax
  809a58:	0f b7 c0             	movzwl %ax,%eax
  809a5b:	89 44 24 04          	mov    %eax,0x4(%esp)
  809a5f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  809a62:	89 04 24             	mov    %eax,(%esp)
  809a65:	e8 9f e0 ff ff       	call   807b09 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  809a6a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809a71:	00 
  809a72:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809a79:	00 
  809a7a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809a81:	e8 b3 e1 ff ff       	call   807c39 <pbuf_alloc>
  809a86:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  809a88:	85 c0                	test   %eax,%eax
  809a8a:	74 46                	je     809ad2 <ip_frag+0x1e2>
      pbuf_chain(header, rambuf);
  809a8c:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809a8f:	89 54 24 04          	mov    %edx,0x4(%esp)
  809a93:	89 04 24             	mov    %eax,(%esp)
  809a96:	e8 51 db ff ff       	call   8075ec <pbuf_chain>
      netif->output(netif, header, dest);
  809a9b:	8b 45 10             	mov    0x10(%ebp),%eax
  809a9e:	89 44 24 08          	mov    %eax,0x8(%esp)
  809aa2:	89 74 24 04          	mov    %esi,0x4(%esp)
  809aa6:	8b 55 0c             	mov    0xc(%ebp),%edx
  809aa9:	89 14 24             	mov    %edx,(%esp)
  809aac:	ff 52 14             	call   *0x14(%edx)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  809aaf:	89 34 24             	mov    %esi,(%esp)
  809ab2:	e8 c6 de ff ff       	call   80797d <pbuf_free>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  809ab7:	66 29 7d e6          	sub    %di,-0x1a(%ebp)
  809abb:	74 27                	je     809ae4 <ip_frag+0x1f4>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809abd:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  809ac1:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  809ac5:	0f b7 55 b8          	movzwl -0x48(%ebp),%edx
  809ac9:	66 01 55 e0          	add    %dx,-0x20(%ebp)
  809acd:	e9 e9 fe ff ff       	jmp    8099bb <ip_frag+0xcb>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  809ad2:	8b 45 d8             	mov    -0x28(%ebp),%eax
  809ad5:	89 04 24             	mov    %eax,(%esp)
  809ad8:	e8 a0 de ff ff       	call   80797d <pbuf_free>
  809add:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
  809ae2:	eb 10                	jmp    809af4 <ip_frag+0x204>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  809ae4:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809ae7:	89 14 24             	mov    %edx,(%esp)
  809aea:	e8 8e de ff ff       	call   80797d <pbuf_free>
  809aef:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  809af4:	83 c4 5c             	add    $0x5c,%esp
  809af7:	5b                   	pop    %ebx
  809af8:	5e                   	pop    %esi
  809af9:	5f                   	pop    %edi
  809afa:	5d                   	pop    %ebp
  809afb:	c3                   	ret    

00809afc <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  809afc:	55                   	push   %ebp
  809afd:	89 e5                	mov    %esp,%ebp
  809aff:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  809b02:	8b 0d 40 54 b3 00    	mov    0xb35440,%ecx
  809b08:	39 c1                	cmp    %eax,%ecx
  809b0a:	75 0a                	jne    809b16 <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  809b0c:	8b 11                	mov    (%ecx),%edx
  809b0e:	89 15 40 54 b3 00    	mov    %edx,0xb35440
  809b14:	eb 24                	jmp    809b3a <ip_reass_dequeue_datagram+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  809b16:	85 d2                	test   %edx,%edx
  809b18:	75 1c                	jne    809b36 <ip_reass_dequeue_datagram+0x3a>
  809b1a:	c7 44 24 08 31 38 81 	movl   $0x813831,0x8(%esp)
  809b21:	00 
  809b22:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  809b29:	00 
  809b2a:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  809b31:	e8 de 6d ff ff       	call   800914 <_panic>
    prev->next = ipr->next;
  809b36:	8b 08                	mov    (%eax),%ecx
  809b38:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  809b3a:	89 44 24 04          	mov    %eax,0x4(%esp)
  809b3e:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  809b45:	e8 aa d6 ff ff       	call   8071f4 <memp_free>
}
  809b4a:	c9                   	leave  
  809b4b:	c3                   	ret    

00809b4c <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  809b4c:	55                   	push   %ebp
  809b4d:	89 e5                	mov    %esp,%ebp
  809b4f:	57                   	push   %edi
  809b50:	56                   	push   %esi
  809b51:	53                   	push   %ebx
  809b52:	83 ec 2c             	sub    $0x2c,%esp
  809b55:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809b58:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  809b5b:	39 c2                	cmp    %eax,%edx
  809b5d:	75 1c                	jne    809b7b <ip_reass_free_complete_datagram+0x2f>
  809b5f:	c7 44 24 08 67 38 81 	movl   $0x813867,0x8(%esp)
  809b66:	00 
  809b67:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  809b6e:	00 
  809b6f:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  809b76:	e8 99 6d ff ff       	call   800914 <_panic>
  if (prev != NULL) {
  809b7b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  809b7f:	74 26                	je     809ba7 <ip_reass_free_complete_datagram+0x5b>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  809b81:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809b84:	8b 45 e0             	mov    -0x20(%ebp),%eax
  809b87:	39 10                	cmp    %edx,(%eax)
  809b89:	74 1c                	je     809ba7 <ip_reass_free_complete_datagram+0x5b>
  809b8b:	c7 44 24 08 73 38 81 	movl   $0x813873,0x8(%esp)
  809b92:	00 
  809b93:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  809b9a:	00 
  809b9b:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  809ba2:	e8 6d 6d ff ff       	call   800914 <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  809ba7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809baa:	8b 58 04             	mov    0x4(%eax),%ebx
  809bad:	8b 43 04             	mov    0x4(%ebx),%eax
  if (iprh->start == 0) {
  809bb0:	bf 00 00 00 00       	mov    $0x0,%edi
  809bb5:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  809bba:	75 47                	jne    809c03 <ip_reass_free_complete_datagram+0xb7>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  809bbc:	8b 00                	mov    (%eax),%eax
  809bbe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809bc1:	89 42 04             	mov    %eax,0x4(%edx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  809bc4:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809bcb:	00 
  809bcc:	89 d0                	mov    %edx,%eax
  809bce:	83 c0 08             	add    $0x8,%eax
  809bd1:	89 44 24 04          	mov    %eax,0x4(%esp)
  809bd5:	8b 43 04             	mov    0x4(%ebx),%eax
  809bd8:	89 04 24             	mov    %eax,(%esp)
  809bdb:	e8 91 77 ff ff       	call   801371 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  809be0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  809be7:	00 
  809be8:	89 1c 24             	mov    %ebx,(%esp)
  809beb:	e8 30 7b 00 00       	call   811720 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  809bf0:	89 1c 24             	mov    %ebx,(%esp)
  809bf3:	e8 28 d9 ff ff       	call   807520 <pbuf_clen>
  809bf8:	0f b6 f8             	movzbl %al,%edi
    pbuf_free(p);
  809bfb:	89 1c 24             	mov    %ebx,(%esp)
  809bfe:	e8 7a dd ff ff       	call   80797d <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  809c03:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809c06:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  809c09:	85 db                	test   %ebx,%ebx
  809c0b:	74 22                	je     809c2f <ip_reass_free_complete_datagram+0xe3>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  809c0d:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  809c10:	8b 30                	mov    (%eax),%esi
    pbufs_freed += pbuf_clen(pcur);
  809c12:	89 1c 24             	mov    %ebx,(%esp)
  809c15:	e8 06 d9 ff ff       	call   807520 <pbuf_clen>
  809c1a:	0f b6 c0             	movzbl %al,%eax
  809c1d:	01 c7                	add    %eax,%edi
    pbuf_free(pcur);    
  809c1f:	89 1c 24             	mov    %ebx,(%esp)
  809c22:	e8 56 dd ff ff       	call   80797d <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  809c27:	85 f6                	test   %esi,%esi
  809c29:	74 04                	je     809c2f <ip_reass_free_complete_datagram+0xe3>
  809c2b:	89 f3                	mov    %esi,%ebx
  809c2d:	eb de                	jmp    809c0d <ip_reass_free_complete_datagram+0xc1>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  809c2f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  809c32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809c35:	e8 c2 fe ff ff       	call   809afc <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  809c3a:	0f b7 05 44 54 b3 00 	movzwl 0xb35444,%eax
  809c41:	0f b7 d0             	movzwl %ax,%edx
  809c44:	39 fa                	cmp    %edi,%edx
  809c46:	7d 1c                	jge    809c64 <ip_reass_free_complete_datagram+0x118>
  809c48:	c7 44 24 08 85 38 81 	movl   $0x813885,0x8(%esp)
  809c4f:	00 
  809c50:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  809c57:	00 
  809c58:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  809c5f:	e8 b0 6c ff ff       	call   800914 <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  809c64:	66 29 f8             	sub    %di,%ax
  809c67:	66 a3 44 54 b3 00    	mov    %ax,0xb35444

  return pbufs_freed;
}
  809c6d:	89 f8                	mov    %edi,%eax
  809c6f:	83 c4 2c             	add    $0x2c,%esp
  809c72:	5b                   	pop    %ebx
  809c73:	5e                   	pop    %esi
  809c74:	5f                   	pop    %edi
  809c75:	5d                   	pop    %ebp
  809c76:	c3                   	ret    

00809c77 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  809c77:	55                   	push   %ebp
  809c78:	89 e5                	mov    %esp,%ebp
  809c7a:	57                   	push   %edi
  809c7b:	56                   	push   %esi
  809c7c:	53                   	push   %ebx
  809c7d:	83 ec 2c             	sub    $0x2c,%esp
  809c80:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809c83:	89 55 dc             	mov    %edx,-0x24(%ebp)
  809c86:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  809c8d:	8b 0d 40 54 b3 00    	mov    0xb35440,%ecx
    while (r != NULL) {
  809c93:	85 c9                	test   %ecx,%ecx
  809c95:	74 6f                	je     809d06 <ip_reass_remove_oldest_datagram+0x8f>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  809c97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809c9a:	8b 78 0c             	mov    0xc(%eax),%edi
  809c9d:	bb 00 00 00 00       	mov    $0x0,%ebx
  809ca2:	ba 00 00 00 00       	mov    $0x0,%edx
  809ca7:	b8 00 00 00 00       	mov    $0x0,%eax
  809cac:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  809caf:	39 79 14             	cmp    %edi,0x14(%ecx)
  809cb2:	75 15                	jne    809cc9 <ip_reass_remove_oldest_datagram+0x52>
  809cb4:	8b 51 18             	mov    0x18(%ecx),%edx
  809cb7:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  809cba:	3b 56 10             	cmp    0x10(%esi),%edx
  809cbd:	75 0a                	jne    809cc9 <ip_reass_remove_oldest_datagram+0x52>
  809cbf:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  809cc3:	66 3b 56 04          	cmp    0x4(%esi),%dx
  809cc7:	74 14                	je     809cdd <ip_reass_remove_oldest_datagram+0x66>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  809cc9:	83 c3 01             	add    $0x1,%ebx
        if (oldest == NULL) {
  809ccc:	85 c0                	test   %eax,%eax
  809cce:	74 0b                	je     809cdb <ip_reass_remove_oldest_datagram+0x64>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
  809cd0:	0f b6 71 1f          	movzbl 0x1f(%ecx),%esi
  809cd4:	89 f2                	mov    %esi,%edx
  809cd6:	3a 50 1f             	cmp    0x1f(%eax),%dl
  809cd9:	77 02                	ja     809cdd <ip_reass_remove_oldest_datagram+0x66>
  809cdb:	89 c8                	mov    %ecx,%eax
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  809cdd:	8b 31                	mov    (%ecx),%esi
  809cdf:	85 f6                	test   %esi,%esi
  809ce1:	74 07                	je     809cea <ip_reass_remove_oldest_datagram+0x73>
  809ce3:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  809ce6:	89 f1                	mov    %esi,%ecx
  809ce8:	eb c5                	jmp    809caf <ip_reass_remove_oldest_datagram+0x38>
  809cea:	8b 55 d4             	mov    -0x2c(%ebp),%edx
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  809ced:	85 c0                	test   %eax,%eax
  809cef:	74 08                	je     809cf9 <ip_reass_remove_oldest_datagram+0x82>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  809cf1:	e8 56 fe ff ff       	call   809b4c <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  809cf6:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  809cf9:	8b 75 dc             	mov    -0x24(%ebp),%esi
  809cfc:	39 75 e0             	cmp    %esi,-0x20(%ebp)
  809cff:	7d 05                	jge    809d06 <ip_reass_remove_oldest_datagram+0x8f>
  809d01:	83 fb 01             	cmp    $0x1,%ebx
  809d04:	7f 87                	jg     809c8d <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
}
  809d06:	8b 45 e0             	mov    -0x20(%ebp),%eax
  809d09:	83 c4 2c             	add    $0x2c,%esp
  809d0c:	5b                   	pop    %ebx
  809d0d:	5e                   	pop    %esi
  809d0e:	5f                   	pop    %edi
  809d0f:	5d                   	pop    %ebp
  809d10:	c3                   	ret    

00809d11 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  809d11:	55                   	push   %ebp
  809d12:	89 e5                	mov    %esp,%ebp
  809d14:	56                   	push   %esi
  809d15:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  809d16:	a1 40 54 b3 00       	mov    0xb35440,%eax
  while (r != NULL) {
  809d1b:	85 c0                	test   %eax,%eax
  809d1d:	74 2a                	je     809d49 <ip_reass_tmr+0x38>
  809d1f:	be 00 00 00 00       	mov    $0x0,%esi
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  809d24:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  809d28:	84 d2                	test   %dl,%dl
  809d2a:	74 0c                	je     809d38 <ip_reass_tmr+0x27>
      r->timer--;
  809d2c:	83 ea 01             	sub    $0x1,%edx
  809d2f:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
  809d32:	8b 18                	mov    (%eax),%ebx
  809d34:	89 c6                	mov    %eax,%esi
  809d36:	eb 09                	jmp    809d41 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  809d38:	8b 18                	mov    (%eax),%ebx
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  809d3a:	89 f2                	mov    %esi,%edx
  809d3c:	e8 0b fe ff ff       	call   809b4c <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  809d41:	85 db                	test   %ebx,%ebx
  809d43:	74 04                	je     809d49 <ip_reass_tmr+0x38>
  809d45:	89 d8                	mov    %ebx,%eax
  809d47:	eb db                	jmp    809d24 <ip_reass_tmr+0x13>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  809d49:	5b                   	pop    %ebx
  809d4a:	5e                   	pop    %esi
  809d4b:	5d                   	pop    %ebp
  809d4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  809d50:	c3                   	ret    

00809d51 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  809d51:	55                   	push   %ebp
  809d52:	89 e5                	mov    %esp,%ebp
  809d54:	57                   	push   %edi
  809d55:	56                   	push   %esi
  809d56:	53                   	push   %ebx
  809d57:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  809d5a:	8b 45 08             	mov    0x8(%ebp),%eax
  809d5d:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  809d60:	0f b7 03             	movzwl (%ebx),%eax
  809d63:	89 04 24             	mov    %eax,(%esp)
  809d66:	e8 15 0a 00 00       	call   80a780 <ntohs>
  809d6b:	c1 e8 06             	shr    $0x6,%eax
  809d6e:	83 e0 3c             	and    $0x3c,%eax
  809d71:	83 f8 14             	cmp    $0x14,%eax
  809d74:	0f 85 f3 04 00 00    	jne    80a26d <ip_reass+0x51c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  809d7a:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809d7e:	89 04 24             	mov    %eax,(%esp)
  809d81:	e8 fa 09 00 00       	call   80a780 <ntohs>
  809d86:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  809d8a:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809d8e:	89 04 24             	mov    %eax,(%esp)
  809d91:	e8 ea 09 00 00       	call   80a780 <ntohs>
  809d96:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  809d9a:	0f b7 03             	movzwl (%ebx),%eax
  809d9d:	89 04 24             	mov    %eax,(%esp)
  809da0:	e8 db 09 00 00       	call   80a780 <ntohs>
  809da5:	66 89 45 dc          	mov    %ax,-0x24(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  809da9:	8b 55 08             	mov    0x8(%ebp),%edx
  809dac:	89 14 24             	mov    %edx,(%esp)
  809daf:	e8 6c d7 ff ff       	call   807520 <pbuf_clen>
  809db4:	89 c7                	mov    %eax,%edi
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  809db6:	0f b6 c8             	movzbl %al,%ecx
  809db9:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  809dbc:	0f b7 05 44 54 b3 00 	movzwl 0xb35444,%eax
  809dc3:	01 c8                	add    %ecx,%eax
  809dc5:	83 f8 0a             	cmp    $0xa,%eax
  809dc8:	7e 24                	jle    809dee <ip_reass+0x9d>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  809dca:	89 ca                	mov    %ecx,%edx
  809dcc:	89 d8                	mov    %ebx,%eax
  809dce:	e8 a4 fe ff ff       	call   809c77 <ip_reass_remove_oldest_datagram>
  809dd3:	85 c0                	test   %eax,%eax
  809dd5:	0f 84 92 04 00 00    	je     80a26d <ip_reass+0x51c>
  809ddb:	0f b7 05 44 54 b3 00 	movzwl 0xb35444,%eax
  809de2:	03 45 e0             	add    -0x20(%ebp),%eax
  809de5:	83 f8 0a             	cmp    $0xa,%eax
  809de8:	0f 8f 7f 04 00 00    	jg     80a26d <ip_reass+0x51c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  809dee:	8b 35 40 54 b3 00    	mov    0xb35440,%esi
  809df4:	85 f6                	test   %esi,%esi
  809df6:	0f 84 97 04 00 00    	je     80a293 <ip_reass+0x542>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  809dfc:	8b 53 0c             	mov    0xc(%ebx),%edx
  809dff:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  809e06:	b9 00 00 00 00       	mov    $0x0,%ecx
  809e0b:	39 56 14             	cmp    %edx,0x14(%esi)
  809e0e:	75 12                	jne    809e22 <ip_reass+0xd1>
  809e10:	8b 46 18             	mov    0x18(%esi),%eax
  809e13:	3b 43 10             	cmp    0x10(%ebx),%eax
  809e16:	75 0a                	jne    809e22 <ip_reass+0xd1>
  809e18:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  809e1c:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  809e20:	74 11                	je     809e33 <ip_reass+0xe2>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  809e22:	8b 06                	mov    (%esi),%eax
  809e24:	85 c0                	test   %eax,%eax
  809e26:	75 05                	jne    809e2d <ip_reass+0xdc>
  809e28:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809e2b:	eb 10                	jmp    809e3d <ip_reass+0xec>
  809e2d:	89 f1                	mov    %esi,%ecx
  809e2f:	89 c6                	mov    %eax,%esi
  809e31:	eb d8                	jmp    809e0b <ip_reass+0xba>
  809e33:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  809e36:	89 75 cc             	mov    %esi,-0x34(%ebp)
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  809e39:	85 f6                	test   %esi,%esi
  809e3b:	75 7d                	jne    809eba <ip_reass+0x169>
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  809e3d:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  809e44:	e8 ef d3 ff ff       	call   807238 <memp_malloc>
  809e49:	89 c6                	mov    %eax,%esi
  if (ipr == NULL) {
  809e4b:	85 c0                	test   %eax,%eax
  809e4d:	75 29                	jne    809e78 <ip_reass+0x127>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  809e4f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  809e52:	89 d8                	mov    %ebx,%eax
  809e54:	e8 1e fe ff ff       	call   809c77 <ip_reass_remove_oldest_datagram>
  809e59:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  809e5c:	0f 8f 0b 04 00 00    	jg     80a26d <ip_reass+0x51c>
      ipr = memp_malloc(MEMP_REASSDATA);
  809e62:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  809e69:	e8 ca d3 ff ff       	call   807238 <memp_malloc>
  809e6e:	89 c6                	mov    %eax,%esi
    }
    if (ipr == NULL)
  809e70:	85 c0                	test   %eax,%eax
  809e72:	0f 84 f5 03 00 00    	je     80a26d <ip_reass+0x51c>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  809e78:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  809e7f:	00 
  809e80:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809e87:	00 
  809e88:	89 34 24             	mov    %esi,(%esp)
  809e8b:	e8 06 74 ff ff       	call   801296 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  809e90:	c6 46 1f 03          	movb   $0x3,0x1f(%esi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  809e94:	a1 40 54 b3 00       	mov    0xb35440,%eax
  809e99:	89 06                	mov    %eax,(%esi)
  reassdatagrams = ipr;
  809e9b:	89 35 40 54 b3 00    	mov    %esi,0xb35440
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  809ea1:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809ea8:	00 
  809ea9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809ead:	8d 46 08             	lea    0x8(%esi),%eax
  809eb0:	89 04 24             	mov    %eax,(%esp)
  809eb3:	e8 b9 74 ff ff       	call   801371 <memcpy>
  809eb8:	eb 41                	jmp    809efb <ip_reass+0x1aa>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  809eba:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809ebe:	89 04 24             	mov    %eax,(%esp)
  809ec1:	e8 ba 08 00 00       	call   80a780 <ntohs>
  809ec6:	66 a9 ff 1f          	test   $0x1fff,%ax
  809eca:	75 2f                	jne    809efb <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  809ecc:	8b 55 cc             	mov    -0x34(%ebp),%edx
  809ecf:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  809ed3:	89 04 24             	mov    %eax,(%esp)
  809ed6:	e8 a5 08 00 00       	call   80a780 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  809edb:	66 a9 ff 1f          	test   $0x1fff,%ax
  809edf:	74 1a                	je     809efb <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  809ee1:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809ee8:	00 
  809ee9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809eed:	8b 45 cc             	mov    -0x34(%ebp),%eax
  809ef0:	83 c0 08             	add    $0x8,%eax
  809ef3:	89 04 24             	mov    %eax,(%esp)
  809ef6:	e8 76 74 ff ff       	call   801371 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  809efb:	66 81 e7 ff 00       	and    $0xff,%di
  809f00:	66 01 3d 44 54 b3 00 	add    %di,0xb35444

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  809f07:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809f0b:	89 04 24             	mov    %eax,(%esp)
  809f0e:	e8 6d 08 00 00       	call   80a780 <ntohs>
  809f13:	f6 c4 20             	test   $0x20,%ah
  809f16:	75 23                	jne    809f3b <ip_reass+0x1ea>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  809f18:	80 4e 1e 01          	orb    $0x1,0x1e(%esi)
    ipr->datagram_len = offset + len;
  809f1c:	0f b7 4d d0          	movzwl -0x30(%ebp),%ecx
  809f20:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
  809f24:	8d 14 cb             	lea    (%ebx,%ecx,8),%edx
  809f27:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  809f2b:	66 c1 e8 08          	shr    $0x8,%ax
  809f2f:	83 e0 0f             	and    $0xf,%eax
  809f32:	f7 d8                	neg    %eax
  809f34:	8d 04 82             	lea    (%edx,%eax,4),%eax
  809f37:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  809f3b:	8b 7d 08             	mov    0x8(%ebp),%edi
  809f3e:	8b 5f 04             	mov    0x4(%edi),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  809f41:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809f45:	89 04 24             	mov    %eax,(%esp)
  809f48:	e8 33 08 00 00       	call   80a780 <ntohs>
  809f4d:	89 c7                	mov    %eax,%edi
  809f4f:	0f b7 03             	movzwl (%ebx),%eax
  809f52:	89 04 24             	mov    %eax,(%esp)
  809f55:	e8 26 08 00 00       	call   80a780 <ntohs>
  809f5a:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  809f5e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809f62:	89 04 24             	mov    %eax,(%esp)
  809f65:	e8 16 08 00 00       	call   80a780 <ntohs>
  809f6a:	c1 e0 03             	shl    $0x3,%eax
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  809f6d:	8b 55 08             	mov    0x8(%ebp),%edx
  809f70:	8b 52 04             	mov    0x4(%edx),%edx
  809f73:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  809f76:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  809f7c:	66 89 42 04          	mov    %ax,0x4(%edx)
  iprh->end = offset + len;
  809f80:	8d 0c 38             	lea    (%eax,%edi,1),%ecx
  809f83:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  809f87:	66 c1 ea 08          	shr    $0x8,%dx
  809f8b:	83 e2 0f             	and    $0xf,%edx
  809f8e:	f7 da                	neg    %edx
  809f90:	8d 14 91             	lea    (%ecx,%edx,4),%edx
  809f93:	66 89 55 da          	mov    %dx,-0x26(%ebp)
  809f97:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809f9a:	66 89 51 06          	mov    %dx,0x6(%ecx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  809f9e:	8b 7e 04             	mov    0x4(%esi),%edi
  809fa1:	85 ff                	test   %edi,%edi
  809fa3:	0f 84 0c 03 00 00    	je     80a2b5 <ip_reass+0x564>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  809fa9:	8b 57 04             	mov    0x4(%edi),%edx
    if (iprh->start < iprh_tmp->start) {
  809fac:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  809fb0:	66 39 c8             	cmp    %cx,%ax
  809fb3:	0f 82 e6 02 00 00    	jb     80a29f <ip_reass+0x54e>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  809fb9:	66 39 c8             	cmp    %cx,%ax
  809fbc:	0f 84 1f 02 00 00    	je     80a1e1 <ip_reass+0x490>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  809fc2:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  809fc9:	66 39 42 06          	cmp    %ax,0x6(%edx)
  809fcd:	0f 86 87 00 00 00    	jbe    80a05a <ip_reass+0x309>
  809fd3:	e9 09 02 00 00       	jmp    80a1e1 <ip_reass+0x490>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  809fd8:	8b 4f 04             	mov    0x4(%edi),%ecx
    if (iprh->start < iprh_tmp->start) {
  809fdb:	0f b7 59 04          	movzwl 0x4(%ecx),%ebx
  809fdf:	66 39 d8             	cmp    %bx,%ax
  809fe2:	73 49                	jae    80a02d <ip_reass+0x2dc>
  809fe4:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  809fe7:	89 75 dc             	mov    %esi,-0x24(%ebp)
  809fea:	8b 75 d0             	mov    -0x30(%ebp),%esi
  809fed:	89 d3                	mov    %edx,%ebx
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  809fef:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809ff2:	89 39                	mov    %edi,(%ecx)
      if (iprh_prev != NULL) {
  809ff4:	85 d2                	test   %edx,%edx
  809ff6:	74 25                	je     80a01d <ip_reass+0x2cc>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  809ff8:	66 3b 42 06          	cmp    0x6(%edx),%ax
  809ffc:	0f 82 df 01 00 00    	jb     80a1e1 <ip_reass+0x490>
  80a002:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80a006:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80a009:	66 3b 47 04          	cmp    0x4(%edi),%ax
  80a00d:	0f 87 ce 01 00 00    	ja     80a1e1 <ip_reass+0x490>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  80a013:	8b 55 08             	mov    0x8(%ebp),%edx
  80a016:	89 13                	mov    %edx,(%ebx)
  80a018:	e9 c6 00 00 00       	jmp    80a0e3 <ip_reass+0x392>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  80a01d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a020:	89 4e 04             	mov    %ecx,0x4(%esi)
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  80a023:	85 ff                	test   %edi,%edi
  80a025:	0f 85 b8 00 00 00    	jne    80a0e3 <ip_reass+0x392>
  80a02b:	eb 43                	jmp    80a070 <ip_reass+0x31f>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80a02d:	66 39 d8             	cmp    %bx,%ax
  80a030:	0f 84 ab 01 00 00    	je     80a1e1 <ip_reass+0x490>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80a036:	66 3b 41 06          	cmp    0x6(%ecx),%ax
  80a03a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80a040:	0f 82 9b 01 00 00    	jb     80a1e1 <ip_reass+0x490>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  80a046:	85 d2                	test   %edx,%edx
  80a048:	74 0c                	je     80a056 <ip_reass+0x305>
        if (iprh_prev->end != iprh_tmp->start) {
  80a04a:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  80a04e:	bb 00 00 00 00       	mov    $0x0,%ebx
  80a053:	0f 45 f3             	cmovne %ebx,%esi
  80a056:	89 ca                	mov    %ecx,%edx
  80a058:	eb 06                	jmp    80a060 <ip_reass+0x30f>
  80a05a:	89 75 d0             	mov    %esi,-0x30(%ebp)
  80a05d:	8b 75 dc             	mov    -0x24(%ebp),%esi
           * and the previous fragment */
          valid = 0;
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  80a060:	8b 3a                	mov    (%edx),%edi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80a062:	85 ff                	test   %edi,%edi
  80a064:	0f 85 6e ff ff ff    	jne    809fd8 <ip_reass+0x287>
  80a06a:	89 75 dc             	mov    %esi,-0x24(%ebp)
  80a06d:	8b 75 d0             	mov    -0x30(%ebp),%esi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  80a070:	85 d2                	test   %edx,%edx
  80a072:	74 47                	je     80a0bb <ip_reass+0x36a>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  80a074:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a078:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80a07b:	66 3b 47 04          	cmp    0x4(%edi),%ax
  80a07f:	76 1c                	jbe    80a09d <ip_reass+0x34c>
  80a081:	c7 44 24 08 a0 38 81 	movl   $0x8138a0,0x8(%esp)
  80a088:	00 
  80a089:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  80a090:	00 
  80a091:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a098:	e8 77 68 ff ff       	call   800914 <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  80a09d:	8b 45 08             	mov    0x8(%ebp),%eax
  80a0a0:	89 02                	mov    %eax,(%edx)
      if (iprh_prev->end != iprh->start) {
  80a0a2:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a0a6:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a0a9:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80a0ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80a0b2:	0f 44 45 dc          	cmove  -0x24(%ebp),%eax
  80a0b6:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80a0b9:	eb 28                	jmp    80a0e3 <ip_reass+0x392>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  80a0bb:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  80a0bf:	74 1c                	je     80a0dd <ip_reass+0x38c>
  80a0c1:	c7 44 24 08 cc 38 81 	movl   $0x8138cc,0x8(%esp)
  80a0c8:	00 
  80a0c9:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  80a0d0:	00 
  80a0d1:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a0d8:	e8 37 68 ff ff       	call   800914 <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  80a0dd:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a0e0:	89 4e 04             	mov    %ecx,0x4(%esi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80a0e3:	f6 46 1e 01          	testb  $0x1,0x1e(%esi)
  80a0e7:	0f 84 94 01 00 00    	je     80a281 <ip_reass+0x530>
    /* and had no wholes so far */
    if (valid) {
  80a0ed:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80a0f1:	0f 84 8a 01 00 00    	je     80a281 <ip_reass+0x530>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  80a0f7:	8b 56 04             	mov    0x4(%esi),%edx
  80a0fa:	8b 42 04             	mov    0x4(%edx),%eax
  80a0fd:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  80a102:	0f 85 79 01 00 00    	jne    80a281 <ip_reass+0x530>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  80a108:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a10b:	8b 0b                	mov    (%ebx),%ecx
        while (q != NULL) {
  80a10d:	85 c9                	test   %ecx,%ecx
  80a10f:	0f 84 b1 01 00 00    	je     80a2c6 <ip_reass+0x575>
          iprh = (struct ip_reass_helper*)q->payload;
  80a115:	8b 49 04             	mov    0x4(%ecx),%ecx
          if (iprh_prev->end != iprh->start) {
  80a118:	0f b7 5b 06          	movzwl 0x6(%ebx),%ebx
  80a11c:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80a11f:	66 3b 59 04          	cmp    0x4(%ecx),%bx
  80a123:	74 1d                	je     80a142 <ip_reass+0x3f1>
  80a125:	e9 57 01 00 00       	jmp    80a281 <ip_reass+0x530>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80a12a:	8b 49 04             	mov    0x4(%ecx),%ecx
          if (iprh_prev->end != iprh->start) {
  80a12d:	0f b7 5b 06          	movzwl 0x6(%ebx),%ebx
  80a131:	66 3b 59 04          	cmp    0x4(%ecx),%bx
  80a135:	0f 85 46 01 00 00    	jne    80a281 <ip_reass+0x530>
  80a13b:	89 cb                	mov    %ecx,%ebx
  80a13d:	8d 76 00             	lea    0x0(%esi),%esi
  80a140:	eb 03                	jmp    80a145 <ip_reass+0x3f4>
  80a142:	8b 5d e0             	mov    -0x20(%ebp),%ebx
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  80a145:	8b 0b                	mov    (%ebx),%ecx
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  80a147:	85 c9                	test   %ecx,%ecx
  80a149:	75 df                	jne    80a12a <ip_reass+0x3d9>
  80a14b:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  80a14e:	e9 73 01 00 00       	jmp    80a2c6 <ip_reass+0x575>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a153:	c7 44 24 08 be 38 81 	movl   $0x8138be,0x8(%esp)
  80a15a:	00 
  80a15b:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  80a162:	00 
  80a163:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a16a:	e8 a5 67 ff ff       	call   800914 <_panic>
          LWIP_ASSERT("sanity check",
  80a16f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80a172:	75 1c                	jne    80a190 <ip_reass+0x43f>
  80a174:	c7 44 24 08 be 38 81 	movl   $0x8138be,0x8(%esp)
  80a17b:	00 
  80a17c:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  80a183:	00 
  80a184:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a18b:	e8 84 67 ff ff       	call   800914 <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80a190:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a193:	83 38 00             	cmpl   $0x0,(%eax)
  80a196:	74 1c                	je     80a1b4 <ip_reass+0x463>
  80a198:	c7 44 24 08 04 39 81 	movl   $0x813904,0x8(%esp)
  80a19f:	00 
  80a1a0:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  80a1a7:	00 
  80a1a8:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a1af:	e8 60 67 ff ff       	call   800914 <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80a1b4:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a1b7:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a1bb:	66 3b 46 1c          	cmp    0x1c(%esi),%ax
  80a1bf:	0f 84 10 01 00 00    	je     80a2d5 <ip_reass+0x584>
  80a1c5:	c7 44 24 08 28 39 81 	movl   $0x813928,0x8(%esp)
  80a1cc:	00 
  80a1cd:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80a1d4:	00 
  80a1d5:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a1dc:	e8 33 67 ff ff       	call   800914 <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80a1e1:	0f b7 1d 44 54 b3 00 	movzwl 0xb35444,%ebx
  80a1e8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a1eb:	89 0c 24             	mov    %ecx,(%esp)
  80a1ee:	e8 2d d3 ff ff       	call   807520 <pbuf_clen>
  80a1f3:	0f b6 c0             	movzbl %al,%eax
  80a1f6:	66 29 c3             	sub    %ax,%bx
  80a1f9:	66 89 1d 44 54 b3 00 	mov    %bx,0xb35444
  pbuf_free(new_p);
  80a200:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a203:	89 1c 24             	mov    %ebx,(%esp)
  80a206:	e8 72 d7 ff ff       	call   80797d <pbuf_free>
  80a20b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80a212:	eb 74                	jmp    80a288 <ip_reass+0x537>
  80a214:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80a217:	8b 75 e4             	mov    -0x1c(%ebp),%esi

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  80a21a:	8b 5f 04             	mov    0x4(%edi),%ebx

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  80a21d:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80a224:	ff 
  80a225:	89 3c 24             	mov    %edi,(%esp)
  80a228:	e8 e6 d3 ff ff       	call   807613 <pbuf_header>
      pbuf_cat(p, r);
  80a22d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a231:	89 34 24             	mov    %esi,(%esp)
  80a234:	e8 12 d3 ff ff       	call   80754b <pbuf_cat>
      r = iprh->next_pbuf;
  80a239:	8b 3b                	mov    (%ebx),%edi
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a23b:	85 ff                	test   %edi,%edi
  80a23d:	75 db                	jne    80a21a <ip_reass+0x4c9>
  80a23f:	8b 75 e0             	mov    -0x20(%ebp),%esi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80a242:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80a245:	89 f0                	mov    %esi,%eax
  80a247:	e8 b0 f8 ff ff       	call   809afc <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  80a24c:	0f b7 1d 44 54 b3 00 	movzwl 0xb35444,%ebx
  80a253:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80a256:	89 3c 24             	mov    %edi,(%esp)
  80a259:	e8 c2 d2 ff ff       	call   807520 <pbuf_clen>
  80a25e:	0f b6 c0             	movzbl %al,%eax
  80a261:	66 29 c3             	sub    %ax,%bx
  80a264:	66 89 1d 44 54 b3 00 	mov    %bx,0xb35444

    /* Return the pbuf chain */
    return p;
  80a26b:	eb 1b                	jmp    80a288 <ip_reass+0x537>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  80a26d:	8b 45 08             	mov    0x8(%ebp),%eax
  80a270:	89 04 24             	mov    %eax,(%esp)
  80a273:	e8 05 d7 ff ff       	call   80797d <pbuf_free>
  80a278:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  return NULL;
  80a27f:	eb 07                	jmp    80a288 <ip_reass+0x537>
  80a281:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  80a288:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a28b:	83 c4 3c             	add    $0x3c,%esp
  80a28e:	5b                   	pop    %ebx
  80a28f:	5e                   	pop    %esi
  80a290:	5f                   	pop    %edi
  80a291:	5d                   	pop    %ebp
  80a292:	c3                   	ret    

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
  80a293:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  80a29a:	e9 9e fb ff ff       	jmp    809e3d <ip_reass+0xec>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80a29f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a2a2:	89 3a                	mov    %edi,(%edx)
  80a2a4:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a2ab:	ba 00 00 00 00       	mov    $0x0,%edx
  80a2b0:	e9 68 fd ff ff       	jmp    80a01d <ip_reass+0x2cc>
  80a2b5:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a2bc:	ba 00 00 00 00       	mov    $0x0,%edx
  80a2c1:	e9 aa fd ff ff       	jmp    80a070 <ip_reass+0x31f>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a2c6:	85 d2                	test   %edx,%edx
  80a2c8:	0f 85 a1 fe ff ff    	jne    80a16f <ip_reass+0x41e>
  80a2ce:	66 90                	xchg   %ax,%ax
  80a2d0:	e9 7e fe ff ff       	jmp    80a153 <ip_reass+0x402>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  80a2d5:	83 c0 14             	add    $0x14,%eax
  80a2d8:	66 89 46 1c          	mov    %ax,0x1c(%esi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80a2dc:	8b 46 04             	mov    0x4(%esi),%eax
  80a2df:	8b 58 04             	mov    0x4(%eax),%ebx
  80a2e2:	8b 3b                	mov    (%ebx),%edi

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  80a2e4:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a2eb:	00 
  80a2ec:	8d 46 08             	lea    0x8(%esi),%eax
  80a2ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a2f3:	89 1c 24             	mov    %ebx,(%esp)
  80a2f6:	e8 76 70 ff ff       	call   801371 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  80a2fb:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80a2ff:	89 04 24             	mov    %eax,(%esp)
  80a302:	e8 6c 04 00 00       	call   80a773 <htons>
  80a307:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(fraghdr, 0);
  80a30b:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_CHKSUM_SET(fraghdr, 0);
  80a311:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  80a317:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80a31e:	00 
  80a31f:	89 1c 24             	mov    %ebx,(%esp)
  80a322:	e8 33 01 00 00       	call   80a45a <inet_chksum>
  80a327:	66 89 43 0a          	mov    %ax,0xa(%ebx)

    p = ipr->p;
  80a32b:	8b 4e 04             	mov    0x4(%esi),%ecx
  80a32e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a331:	85 ff                	test   %edi,%edi
  80a333:	0f 85 db fe ff ff    	jne    80a214 <ip_reass+0x4c3>
  80a339:	e9 04 ff ff ff       	jmp    80a242 <ip_reass+0x4f1>
	...

0080a340 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80a340:	55                   	push   %ebp
  80a341:	89 e5                	mov    %esp,%ebp
  80a343:	57                   	push   %edi
  80a344:	56                   	push   %esi
  80a345:	53                   	push   %ebx
  80a346:	83 ec 2c             	sub    $0x2c,%esp
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  80a349:	89 c7                	mov    %eax,%edi
  while (len > 1) {
  80a34b:	b9 00 00 00 00       	mov    $0x0,%ecx
  80a350:	66 83 fa 01          	cmp    $0x1,%dx
  80a354:	76 3a                	jbe    80a390 <lwip_standard_chksum+0x50>
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80a356:	83 ea 02             	sub    $0x2,%edx
  80a359:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
  80a35d:	66 d1 ea             	shr    %dx
  80a360:	0f b7 d2             	movzwl %dx,%edx
  80a363:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80a366:	8d 74 50 02          	lea    0x2(%eax,%edx,2),%esi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80a36a:	0f b6 18             	movzbl (%eax),%ebx
  80a36d:	c1 e3 08             	shl    $0x8,%ebx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  80a370:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  80a374:	09 da                	or     %ebx,%edx
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80a376:	83 c0 02             	add    $0x2,%eax
    src = (*octetptr) << 8;
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
  80a379:	0f b7 d2             	movzwl %dx,%edx
  80a37c:	01 d1                	add    %edx,%ecx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80a37e:	39 c6                	cmp    %eax,%esi
  80a380:	75 e8                	jne    80a36a <lwip_standard_chksum+0x2a>
  80a382:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a385:	8d 7c 47 02          	lea    0x2(%edi,%eax,2),%edi
  80a389:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  80a38d:	83 e2 01             	and    $0x1,%edx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  80a390:	66 85 d2             	test   %dx,%dx
  80a393:	74 0b                	je     80a3a0 <lwip_standard_chksum+0x60>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  80a395:	0f b6 07             	movzbl (%edi),%eax
  80a398:	c1 e0 08             	shl    $0x8,%eax
  80a39b:	0f b7 c0             	movzwl %ax,%eax
  80a39e:	01 c1                	add    %eax,%ecx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a3a0:	89 c8                	mov    %ecx,%eax
  80a3a2:	c1 e8 10             	shr    $0x10,%eax
  80a3a5:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  80a3ab:	01 c1                	add    %eax,%ecx
  if ((acc & 0xffff0000) != 0) {
  80a3ad:	f7 c1 00 00 ff ff    	test   $0xffff0000,%ecx
  80a3b3:	74 0d                	je     80a3c2 <lwip_standard_chksum+0x82>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a3b5:	89 c8                	mov    %ecx,%eax
  80a3b7:	c1 e8 10             	shr    $0x10,%eax
  80a3ba:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  80a3c0:	01 c1                	add    %eax,%ecx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  80a3c2:	0f b7 c9             	movzwl %cx,%ecx
  80a3c5:	89 0c 24             	mov    %ecx,(%esp)
  80a3c8:	e8 a6 03 00 00       	call   80a773 <htons>
}
  80a3cd:	83 c4 2c             	add    $0x2c,%esp
  80a3d0:	5b                   	pop    %ebx
  80a3d1:	5e                   	pop    %esi
  80a3d2:	5f                   	pop    %edi
  80a3d3:	5d                   	pop    %ebp
  80a3d4:	c3                   	ret    

0080a3d5 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  80a3d5:	55                   	push   %ebp
  80a3d6:	89 e5                	mov    %esp,%ebp
  80a3d8:	57                   	push   %edi
  80a3d9:	56                   	push   %esi
  80a3da:	53                   	push   %ebx
  80a3db:	83 ec 0c             	sub    $0xc,%esp
  80a3de:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80a3e1:	be 00 00 00 00       	mov    $0x0,%esi
  80a3e6:	85 db                	test   %ebx,%ebx
  80a3e8:	74 64                	je     80a44e <inet_chksum_pbuf+0x79>
  80a3ea:	bf 00 00 00 00       	mov    $0x0,%edi
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a3ef:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80a3f3:	8b 43 04             	mov    0x4(%ebx),%eax
  80a3f6:	e8 45 ff ff ff       	call   80a340 <lwip_standard_chksum>
  80a3fb:	0f b7 c0             	movzwl %ax,%eax
  80a3fe:	8d 34 30             	lea    (%eax,%esi,1),%esi
    acc = FOLD_U32T(acc);
  80a401:	89 f0                	mov    %esi,%eax
  80a403:	c1 e8 10             	shr    $0x10,%eax
  80a406:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80a40c:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80a40e:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a412:	74 1c                	je     80a430 <inet_chksum_pbuf+0x5b>
      swapped = 1 - swapped;
  80a414:	b8 01 00 00 00       	mov    $0x1,%eax
  80a419:	89 fa                	mov    %edi,%edx
  80a41b:	28 d0                	sub    %dl,%al
  80a41d:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80a41f:	89 f0                	mov    %esi,%eax
  80a421:	c1 e0 08             	shl    $0x8,%eax
  80a424:	25 ff ff 00 00       	and    $0xffff,%eax
  80a429:	89 f2                	mov    %esi,%edx
  80a42b:	0f b6 f6             	movzbl %dh,%esi
  80a42e:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80a430:	8b 1b                	mov    (%ebx),%ebx
  80a432:	85 db                	test   %ebx,%ebx
  80a434:	75 b9                	jne    80a3ef <inet_chksum_pbuf+0x1a>
  80a436:	89 f0                	mov    %esi,%eax
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  80a438:	89 fa                	mov    %edi,%edx
  80a43a:	84 d2                	test   %dl,%dl
  80a43c:	74 10                	je     80a44e <inet_chksum_pbuf+0x79>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a43e:	89 f2                	mov    %esi,%edx
  80a440:	c1 e2 08             	shl    $0x8,%edx
  80a443:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a449:	0f b6 f4             	movzbl %ah,%esi
  80a44c:	09 d6                	or     %edx,%esi
  80a44e:	89 f0                	mov    %esi,%eax
  80a450:	f7 d0                	not    %eax
  }
  return (u16_t)~(acc & 0xffffUL);
}
  80a452:	83 c4 0c             	add    $0xc,%esp
  80a455:	5b                   	pop    %ebx
  80a456:	5e                   	pop    %esi
  80a457:	5f                   	pop    %edi
  80a458:	5d                   	pop    %ebp
  80a459:	c3                   	ret    

0080a45a <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  80a45a:	55                   	push   %ebp
  80a45b:	89 e5                	mov    %esp,%ebp
  80a45d:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80a460:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  80a464:	8b 45 08             	mov    0x8(%ebp),%eax
  80a467:	e8 d4 fe ff ff       	call   80a340 <lwip_standard_chksum>
  80a46c:	f7 d0                	not    %eax
}
  80a46e:	c9                   	leave  
  80a46f:	c3                   	ret    

0080a470 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  80a470:	55                   	push   %ebp
  80a471:	89 e5                	mov    %esp,%ebp
  80a473:	57                   	push   %edi
  80a474:	56                   	push   %esi
  80a475:	53                   	push   %ebx
  80a476:	83 ec 2c             	sub    $0x2c,%esp
  80a479:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a47c:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80a480:	88 45 e7             	mov    %al,-0x19(%ebp)
  80a483:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80a487:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80a48b:	be 00 00 00 00       	mov    $0x0,%esi
  80a490:	85 db                	test   %ebx,%ebx
  80a492:	74 64                	je     80a4f8 <inet_chksum_pseudo+0x88>
  80a494:	bf 00 00 00 00       	mov    $0x0,%edi
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a499:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80a49d:	8b 43 04             	mov    0x4(%ebx),%eax
  80a4a0:	e8 9b fe ff ff       	call   80a340 <lwip_standard_chksum>
  80a4a5:	0f b7 c0             	movzwl %ax,%eax
  80a4a8:	8d 34 30             	lea    (%eax,%esi,1),%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  80a4ab:	89 f0                	mov    %esi,%eax
  80a4ad:	c1 e8 10             	shr    $0x10,%eax
  80a4b0:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80a4b6:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80a4b8:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a4bc:	74 1c                	je     80a4da <inet_chksum_pseudo+0x6a>
      swapped = 1 - swapped;
  80a4be:	b8 01 00 00 00       	mov    $0x1,%eax
  80a4c3:	89 fa                	mov    %edi,%edx
  80a4c5:	28 d0                	sub    %dl,%al
  80a4c7:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80a4c9:	89 f0                	mov    %esi,%eax
  80a4cb:	c1 e0 08             	shl    $0x8,%eax
  80a4ce:	25 ff ff 00 00       	and    $0xffff,%eax
  80a4d3:	89 f2                	mov    %esi,%edx
  80a4d5:	0f b6 f6             	movzbl %dh,%esi
  80a4d8:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80a4da:	8b 1b                	mov    (%ebx),%ebx
  80a4dc:	85 db                	test   %ebx,%ebx
  80a4de:	75 b9                	jne    80a499 <inet_chksum_pseudo+0x29>
  80a4e0:	89 f0                	mov    %esi,%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80a4e2:	89 fa                	mov    %edi,%edx
  80a4e4:	84 d2                	test   %dl,%dl
  80a4e6:	74 10                	je     80a4f8 <inet_chksum_pseudo+0x88>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a4e8:	89 f2                	mov    %esi,%edx
  80a4ea:	c1 e2 08             	shl    $0x8,%edx
  80a4ed:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a4f3:	0f b6 f4             	movzbl %ah,%esi
  80a4f6:	09 d6                	or     %edx,%esi
  }
  acc += (src->addr & 0xffffUL);
  80a4f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a4fb:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80a4fd:	8b 45 10             	mov    0x10(%ebp),%eax
  80a500:	8b 00                	mov    (%eax),%eax
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80a502:	89 d1                	mov    %edx,%ecx
  80a504:	c1 e9 10             	shr    $0x10,%ecx
  80a507:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a50d:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  80a510:	0f b7 c8             	movzwl %ax,%ecx
  80a513:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  80a515:	c1 e8 10             	shr    $0x10,%eax
  80a518:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80a51b:	8d 34 30             	lea    (%eax,%esi,1),%esi
  acc += (u32_t)htons((u16_t)proto);
  80a51e:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80a522:	89 04 24             	mov    %eax,(%esp)
  80a525:	e8 49 02 00 00       	call   80a773 <htons>
  80a52a:	0f b7 c0             	movzwl %ax,%eax
  80a52d:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  80a52f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80a533:	89 04 24             	mov    %eax,(%esp)
  80a536:	e8 38 02 00 00       	call   80a773 <htons>
  80a53b:	0f b7 c0             	movzwl %ax,%eax
  80a53e:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80a540:	89 f0                	mov    %esi,%eax
  80a542:	c1 e8 10             	shr    $0x10,%eax
  80a545:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80a54b:	01 c6                	add    %eax,%esi
  acc = FOLD_U32T(acc);
  80a54d:	89 f0                	mov    %esi,%eax
  80a54f:	c1 e8 10             	shr    $0x10,%eax
  80a552:	8d 04 06             	lea    (%esi,%eax,1),%eax
  80a555:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80a557:	83 c4 2c             	add    $0x2c,%esp
  80a55a:	5b                   	pop    %ebx
  80a55b:	5e                   	pop    %esi
  80a55c:	5f                   	pop    %edi
  80a55d:	5d                   	pop    %ebp
  80a55e:	c3                   	ret    

0080a55f <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80a55f:	55                   	push   %ebp
  80a560:	89 e5                	mov    %esp,%ebp
  80a562:	57                   	push   %edi
  80a563:	56                   	push   %esi
  80a564:	53                   	push   %ebx
  80a565:	83 ec 3c             	sub    $0x3c,%esp
  80a568:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a56b:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80a56f:	88 45 d6             	mov    %al,-0x2a(%ebp)
  80a572:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80a576:	66 89 55 d4          	mov    %dx,-0x2c(%ebp)
  80a57a:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80a57e:	85 db                	test   %ebx,%ebx
  80a580:	74 05                	je     80a587 <inet_chksum_pseudo_partial+0x28>
  80a582:	66 85 f6             	test   %si,%si
  80a585:	75 0a                	jne    80a591 <inet_chksum_pseudo_partial+0x32>
  80a587:	bf 00 00 00 00       	mov    $0x0,%edi
  80a58c:	e9 a7 00 00 00       	jmp    80a638 <inet_chksum_pseudo_partial+0xd9>
  80a591:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
  80a595:	bf 00 00 00 00       	mov    $0x0,%edi
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  80a59a:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a59e:	66 39 c6             	cmp    %ax,%si
  80a5a1:	89 c2                	mov    %eax,%edx
  80a5a3:	0f 46 d6             	cmovbe %esi,%edx
  80a5a6:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80a5aa:	0f b7 d2             	movzwl %dx,%edx
  80a5ad:	8b 43 04             	mov    0x4(%ebx),%eax
  80a5b0:	e8 8b fd ff ff       	call   80a340 <lwip_standard_chksum>
    chksum_len -= chklen;
  80a5b5:	66 2b 75 d8          	sub    -0x28(%ebp),%si
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  80a5b9:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  80a5be:	76 1c                	jbe    80a5dc <inet_chksum_pseudo_partial+0x7d>
  80a5c0:	c7 44 24 08 55 39 81 	movl   $0x813955,0x8(%esp)
  80a5c7:	00 
  80a5c8:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  80a5cf:	00 
  80a5d0:	c7 04 24 60 39 81 00 	movl   $0x813960,(%esp)
  80a5d7:	e8 38 63 ff ff       	call   800914 <_panic>
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80a5dc:	0f b7 c0             	movzwl %ax,%eax
  80a5df:	8d 3c 38             	lea    (%eax,%edi,1),%edi
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80a5e2:	89 fa                	mov    %edi,%edx
  80a5e4:	c1 ea 10             	shr    $0x10,%edx
  80a5e7:	81 e7 ff ff 00 00    	and    $0xffff,%edi
  80a5ed:	01 d7                	add    %edx,%edi
    if (q->len % 2 != 0) {
  80a5ef:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a5f3:	74 1c                	je     80a611 <inet_chksum_pseudo_partial+0xb2>
      swapped = 1 - swapped;
  80a5f5:	b8 01 00 00 00       	mov    $0x1,%eax
  80a5fa:	2a 45 d7             	sub    -0x29(%ebp),%al
  80a5fd:	88 45 d7             	mov    %al,-0x29(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80a600:	89 f8                	mov    %edi,%eax
  80a602:	c1 e0 08             	shl    $0x8,%eax
  80a605:	25 ff ff 00 00       	and    $0xffff,%eax
  80a60a:	89 fa                	mov    %edi,%edx
  80a60c:	0f b6 fe             	movzbl %dh,%edi
  80a60f:	09 c7                	or     %eax,%edi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80a611:	8b 1b                	mov    (%ebx),%ebx
  80a613:	85 db                	test   %ebx,%ebx
  80a615:	74 09                	je     80a620 <inet_chksum_pseudo_partial+0xc1>
  80a617:	66 85 f6             	test   %si,%si
  80a61a:	0f 85 7a ff ff ff    	jne    80a59a <inet_chksum_pseudo_partial+0x3b>
  80a620:	89 f8                	mov    %edi,%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80a622:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80a626:	74 10                	je     80a638 <inet_chksum_pseudo_partial+0xd9>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a628:	89 fa                	mov    %edi,%edx
  80a62a:	c1 e2 08             	shl    $0x8,%edx
  80a62d:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a633:	0f b6 fc             	movzbl %ah,%edi
  80a636:	09 d7                	or     %edx,%edi
  }
  acc += (src->addr & 0xffffUL);
  80a638:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a63b:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80a63d:	8b 45 10             	mov    0x10(%ebp),%eax
  80a640:	8b 00                	mov    (%eax),%eax
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80a642:	89 d1                	mov    %edx,%ecx
  80a644:	c1 e9 10             	shr    $0x10,%ecx
  80a647:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a64d:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  80a650:	0f b7 c8             	movzwl %ax,%ecx
  80a653:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  80a655:	c1 e8 10             	shr    $0x10,%eax
  80a658:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80a65b:	8d 3c 38             	lea    (%eax,%edi,1),%edi
  acc += (u32_t)htons((u16_t)proto);
  80a65e:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
  80a662:	89 04 24             	mov    %eax,(%esp)
  80a665:	e8 09 01 00 00       	call   80a773 <htons>
  80a66a:	0f b7 c0             	movzwl %ax,%eax
  80a66d:	01 c7                	add    %eax,%edi
  acc += (u32_t)htons(proto_len);
  80a66f:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80a673:	89 04 24             	mov    %eax,(%esp)
  80a676:	e8 f8 00 00 00       	call   80a773 <htons>
  80a67b:	0f b7 c0             	movzwl %ax,%eax
  80a67e:	01 c7                	add    %eax,%edi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80a680:	89 f8                	mov    %edi,%eax
  80a682:	c1 e8 10             	shr    $0x10,%eax
  80a685:	81 e7 ff ff 00 00    	and    $0xffff,%edi
  80a68b:	8d 04 07             	lea    (%edi,%eax,1),%eax
  acc = FOLD_U32T(acc);
  80a68e:	89 c2                	mov    %eax,%edx
  80a690:	c1 ea 10             	shr    $0x10,%edx
  80a693:	01 d0                	add    %edx,%eax
  80a695:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80a697:	83 c4 3c             	add    $0x3c,%esp
  80a69a:	5b                   	pop    %ebx
  80a69b:	5e                   	pop    %esi
  80a69c:	5f                   	pop    %edi
  80a69d:	5d                   	pop    %ebp
  80a69e:	c3                   	ret    
	...

0080a6a0 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80a6a0:	55                   	push   %ebp
  80a6a1:	89 e5                	mov    %esp,%ebp
  80a6a3:	57                   	push   %edi
  80a6a4:	56                   	push   %esi
  80a6a5:	53                   	push   %ebx
  80a6a6:	83 ec 20             	sub    $0x20,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  80a6a9:	8b 45 08             	mov    0x8(%ebp),%eax
  80a6ac:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  80a6af:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80a6b2:	89 45 e0             	mov    %eax,-0x20(%ebp)
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80a6b5:	8d 55 f3             	lea    -0xd(%ebp),%edx
  80a6b8:	89 55 d8             	mov    %edx,-0x28(%ebp)
  80a6bb:	bb 3c 5a b3 00       	mov    $0xb35a3c,%ebx
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80a6c0:	b9 cd ff ff ff       	mov    $0xffffffcd,%ecx
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80a6c5:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80a6c8:	0f b6 37             	movzbl (%edi),%esi
  80a6cb:	ba 00 00 00 00       	mov    $0x0,%edx
  80a6d0:	89 d0                	mov    %edx,%eax
  80a6d2:	89 f2                	mov    %esi,%edx
  80a6d4:	89 de                	mov    %ebx,%esi
  80a6d6:	89 c3                	mov    %eax,%ebx
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80a6d8:	89 d0                	mov    %edx,%eax
  80a6da:	f6 e1                	mul    %cl
  80a6dc:	66 c1 e8 08          	shr    $0x8,%ax
  80a6e0:	c0 e8 03             	shr    $0x3,%al
  80a6e3:	89 c7                	mov    %eax,%edi
  80a6e5:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a6e8:	01 c0                	add    %eax,%eax
  80a6ea:	28 c2                	sub    %al,%dl
  80a6ec:	89 d0                	mov    %edx,%eax
      *ap /= (u8_t)10;
  80a6ee:	89 fa                	mov    %edi,%edx
      inv[i++] = '0' + rem;
  80a6f0:	0f b6 fb             	movzbl %bl,%edi
  80a6f3:	83 c0 30             	add    $0x30,%eax
  80a6f6:	88 44 3d ed          	mov    %al,-0x13(%ebp,%edi,1)
  80a6fa:	8d 43 01             	lea    0x1(%ebx),%eax
    } while(*ap);
  80a6fd:	84 d2                	test   %dl,%dl
  80a6ff:	74 04                	je     80a705 <inet_ntoa+0x65>
  80a701:	89 c3                	mov    %eax,%ebx
  80a703:	eb d3                	jmp    80a6d8 <inet_ntoa+0x38>
  80a705:	88 45 d7             	mov    %al,-0x29(%ebp)
  80a708:	89 df                	mov    %ebx,%edi
  80a70a:	89 f3                	mov    %esi,%ebx
  80a70c:	89 d6                	mov    %edx,%esi
  80a70e:	89 fa                	mov    %edi,%edx
  80a710:	88 55 dc             	mov    %dl,-0x24(%ebp)
  80a713:	89 f0                	mov    %esi,%eax
  80a715:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80a718:	88 07                	mov    %al,(%edi)
    while(i--)
  80a71a:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80a71e:	74 2a                	je     80a74a <inet_ntoa+0xaa>
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80a720:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  80a724:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80a727:	8d 7c 03 01          	lea    0x1(%ebx,%eax,1),%edi
  80a72b:	89 d8                	mov    %ebx,%eax
  80a72d:	89 de                	mov    %ebx,%esi
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  80a72f:	0f b6 da             	movzbl %dl,%ebx
  80a732:	0f b6 5c 1d ed       	movzbl -0x13(%ebp,%ebx,1),%ebx
  80a737:	88 18                	mov    %bl,(%eax)
  80a739:	83 c0 01             	add    $0x1,%eax
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  80a73c:	83 ea 01             	sub    $0x1,%edx
  80a73f:	39 f8                	cmp    %edi,%eax
  80a741:	75 ec                	jne    80a72f <inet_ntoa+0x8f>
  80a743:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80a746:	8d 5c 16 01          	lea    0x1(%esi,%edx,1),%ebx
      *rp++ = inv[i];
    *rp++ = '.';
  80a74a:	c6 03 2e             	movb   $0x2e,(%ebx)
  80a74d:	8d 43 01             	lea    0x1(%ebx),%eax
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  80a750:	8b 7d d8             	mov    -0x28(%ebp),%edi
  80a753:	39 7d e0             	cmp    %edi,-0x20(%ebp)
  80a756:	74 0b                	je     80a763 <inet_ntoa+0xc3>
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  80a758:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  80a75c:	89 c3                	mov    %eax,%ebx
  80a75e:	e9 62 ff ff ff       	jmp    80a6c5 <inet_ntoa+0x25>
  }
  *--rp = 0;
  80a763:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  80a766:	b8 3c 5a b3 00       	mov    $0xb35a3c,%eax
  80a76b:	83 c4 20             	add    $0x20,%esp
  80a76e:	5b                   	pop    %ebx
  80a76f:	5e                   	pop    %esi
  80a770:	5f                   	pop    %edi
  80a771:	5d                   	pop    %ebp
  80a772:	c3                   	ret    

0080a773 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  80a773:	55                   	push   %ebp
  80a774:	89 e5                	mov    %esp,%ebp
  80a776:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80a77a:	66 c1 c0 08          	rol    $0x8,%ax
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
}
  80a77e:	5d                   	pop    %ebp
  80a77f:	c3                   	ret    

0080a780 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  80a780:	55                   	push   %ebp
  80a781:	89 e5                	mov    %esp,%ebp
  80a783:	83 ec 04             	sub    $0x4,%esp
  return htons(n);
  80a786:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80a78a:	89 04 24             	mov    %eax,(%esp)
  80a78d:	e8 e1 ff ff ff       	call   80a773 <htons>
}
  80a792:	c9                   	leave  
  80a793:	c3                   	ret    

0080a794 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  80a794:	55                   	push   %ebp
  80a795:	89 e5                	mov    %esp,%ebp
  80a797:	8b 55 08             	mov    0x8(%ebp),%edx
  80a79a:	89 d1                	mov    %edx,%ecx
  80a79c:	c1 e9 18             	shr    $0x18,%ecx
  80a79f:	89 d0                	mov    %edx,%eax
  80a7a1:	c1 e0 18             	shl    $0x18,%eax
  80a7a4:	09 c8                	or     %ecx,%eax
  80a7a6:	89 d1                	mov    %edx,%ecx
  80a7a8:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80a7ae:	c1 e1 08             	shl    $0x8,%ecx
  80a7b1:	09 c8                	or     %ecx,%eax
  80a7b3:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  80a7b9:	c1 ea 08             	shr    $0x8,%edx
  80a7bc:	09 d0                	or     %edx,%eax
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  80a7be:	5d                   	pop    %ebp
  80a7bf:	c3                   	ret    

0080a7c0 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  80a7c0:	55                   	push   %ebp
  80a7c1:	89 e5                	mov    %esp,%ebp
  80a7c3:	57                   	push   %edi
  80a7c4:	56                   	push   %esi
  80a7c5:	53                   	push   %ebx
  80a7c6:	83 ec 28             	sub    $0x28,%esp
  80a7c9:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  80a7cc:	0f be 10             	movsbl (%eax),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80a7cf:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80a7d2:	80 f9 09             	cmp    $0x9,%cl
  80a7d5:	0f 87 a8 01 00 00    	ja     80a983 <inet_aton+0x1c3>
  80a7db:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  80a7de:	89 4d d8             	mov    %ecx,-0x28(%ebp)
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80a7e1:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  80a7e4:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
  80a7e7:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
  80a7ee:	83 fa 30             	cmp    $0x30,%edx
  80a7f1:	75 24                	jne    80a817 <inet_aton+0x57>
      c = *++cp;
  80a7f3:	83 c0 01             	add    $0x1,%eax
  80a7f6:	0f be 10             	movsbl (%eax),%edx
      if (c == 'x' || c == 'X') {
  80a7f9:	83 fa 78             	cmp    $0x78,%edx
  80a7fc:	74 0c                	je     80a80a <inet_aton+0x4a>
  80a7fe:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
  80a805:	83 fa 58             	cmp    $0x58,%edx
  80a808:	75 0d                	jne    80a817 <inet_aton+0x57>
        base = 16;
        c = *++cp;
  80a80a:	83 c0 01             	add    $0x1,%eax
  80a80d:	0f be 10             	movsbl (%eax),%edx
  80a810:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
  80a817:	83 c0 01             	add    $0x1,%eax
  80a81a:	be 00 00 00 00       	mov    $0x0,%esi
  80a81f:	eb 03                	jmp    80a824 <inet_aton+0x64>
  80a821:	83 c0 01             	add    $0x1,%eax
  80a824:	8d 78 ff             	lea    -0x1(%eax),%edi
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  80a827:	89 d1                	mov    %edx,%ecx
  80a829:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  80a82c:	80 fb 09             	cmp    $0x9,%bl
  80a82f:	77 0d                	ja     80a83e <inet_aton+0x7e>
        val = (val * base) + (int)(c - '0');
  80a831:	0f af 75 e0          	imul   -0x20(%ebp),%esi
  80a835:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  80a839:	0f be 10             	movsbl (%eax),%edx
  80a83c:	eb e3                	jmp    80a821 <inet_aton+0x61>
      } else if (base == 16 && isxdigit(c)) {
  80a83e:	83 7d e0 10          	cmpl   $0x10,-0x20(%ebp)
  80a842:	75 2b                	jne    80a86f <inet_aton+0xaf>
  80a844:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  80a847:	88 5d d3             	mov    %bl,-0x2d(%ebp)
  80a84a:	80 fb 05             	cmp    $0x5,%bl
  80a84d:	76 08                	jbe    80a857 <inet_aton+0x97>
  80a84f:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  80a852:	80 fb 05             	cmp    $0x5,%bl
  80a855:	77 18                	ja     80a86f <inet_aton+0xaf>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80a857:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  80a85b:	19 c9                	sbb    %ecx,%ecx
  80a85d:	83 e1 20             	and    $0x20,%ecx
  80a860:	c1 e6 04             	shl    $0x4,%esi
  80a863:	29 ca                	sub    %ecx,%edx
  80a865:	8d 52 c9             	lea    -0x37(%edx),%edx
  80a868:	09 d6                	or     %edx,%esi
        c = *++cp;
  80a86a:	0f be 10             	movsbl (%eax),%edx
  80a86d:	eb b2                	jmp    80a821 <inet_aton+0x61>
      } else
        break;
    }
    if (c == '.') {
  80a86f:	83 fa 2e             	cmp    $0x2e,%edx
  80a872:	75 29                	jne    80a89d <inet_aton+0xdd>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80a874:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80a877:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
  80a87a:	0f 86 03 01 00 00    	jbe    80a983 <inet_aton+0x1c3>
        return (0);
      *pp++ = val;
  80a880:	89 32                	mov    %esi,(%edx)
      c = *++cp;
  80a882:	8d 47 01             	lea    0x1(%edi),%eax
  80a885:	0f be 10             	movsbl (%eax),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80a888:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80a88b:	80 f9 09             	cmp    $0x9,%cl
  80a88e:	0f 87 ef 00 00 00    	ja     80a983 <inet_aton+0x1c3>
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
  80a894:	83 45 d8 04          	addl   $0x4,-0x28(%ebp)
  80a898:	e9 4a ff ff ff       	jmp    80a7e7 <inet_aton+0x27>
  80a89d:	89 f3                	mov    %esi,%ebx
  80a89f:	89 f0                	mov    %esi,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80a8a1:	85 d2                	test   %edx,%edx
  80a8a3:	74 36                	je     80a8db <inet_aton+0x11b>
  80a8a5:	80 f9 1f             	cmp    $0x1f,%cl
  80a8a8:	0f 86 d5 00 00 00    	jbe    80a983 <inet_aton+0x1c3>
  80a8ae:	84 d2                	test   %dl,%dl
  80a8b0:	0f 88 cd 00 00 00    	js     80a983 <inet_aton+0x1c3>
  80a8b6:	83 fa 20             	cmp    $0x20,%edx
  80a8b9:	74 20                	je     80a8db <inet_aton+0x11b>
  80a8bb:	83 fa 0c             	cmp    $0xc,%edx
  80a8be:	66 90                	xchg   %ax,%ax
  80a8c0:	74 19                	je     80a8db <inet_aton+0x11b>
  80a8c2:	83 fa 0a             	cmp    $0xa,%edx
  80a8c5:	74 14                	je     80a8db <inet_aton+0x11b>
  80a8c7:	83 fa 0d             	cmp    $0xd,%edx
  80a8ca:	74 0f                	je     80a8db <inet_aton+0x11b>
  80a8cc:	83 fa 09             	cmp    $0x9,%edx
  80a8cf:	90                   	nop
  80a8d0:	74 09                	je     80a8db <inet_aton+0x11b>
  80a8d2:	83 fa 0b             	cmp    $0xb,%edx
  80a8d5:	0f 85 a8 00 00 00    	jne    80a983 <inet_aton+0x1c3>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  80a8db:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80a8de:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80a8e1:	29 d1                	sub    %edx,%ecx
  80a8e3:	89 ca                	mov    %ecx,%edx
  80a8e5:	c1 fa 02             	sar    $0x2,%edx
  80a8e8:	83 c2 01             	add    $0x1,%edx
  80a8eb:	83 fa 02             	cmp    $0x2,%edx
  80a8ee:	74 2a                	je     80a91a <inet_aton+0x15a>
  80a8f0:	83 fa 02             	cmp    $0x2,%edx
  80a8f3:	7f 0d                	jg     80a902 <inet_aton+0x142>
  80a8f5:	85 d2                	test   %edx,%edx
  80a8f7:	0f 84 86 00 00 00    	je     80a983 <inet_aton+0x1c3>
  80a8fd:	8d 76 00             	lea    0x0(%esi),%esi
  80a900:	eb 62                	jmp    80a964 <inet_aton+0x1a4>
  80a902:	83 fa 03             	cmp    $0x3,%edx
  80a905:	8d 76 00             	lea    0x0(%esi),%esi
  80a908:	74 22                	je     80a92c <inet_aton+0x16c>
  80a90a:	83 fa 04             	cmp    $0x4,%edx
  80a90d:	8d 76 00             	lea    0x0(%esi),%esi
  80a910:	75 52                	jne    80a964 <inet_aton+0x1a4>
  80a912:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80a918:	eb 2b                	jmp    80a945 <inet_aton+0x185>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  80a91a:	3d ff ff ff 00       	cmp    $0xffffff,%eax
  80a91f:	90                   	nop
  80a920:	77 61                	ja     80a983 <inet_aton+0x1c3>
      return (0);
    val |= parts[0] << 24;
  80a922:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80a925:	c1 e3 18             	shl    $0x18,%ebx
  80a928:	09 c3                	or     %eax,%ebx
    break;
  80a92a:	eb 38                	jmp    80a964 <inet_aton+0x1a4>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  80a92c:	3d ff ff 00 00       	cmp    $0xffff,%eax
  80a931:	77 50                	ja     80a983 <inet_aton+0x1c3>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  80a933:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80a936:	c1 e3 10             	shl    $0x10,%ebx
  80a939:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a93c:	c1 e2 18             	shl    $0x18,%edx
  80a93f:	09 d3                	or     %edx,%ebx
  80a941:	09 c3                	or     %eax,%ebx
    break;
  80a943:	eb 1f                	jmp    80a964 <inet_aton+0x1a4>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  80a945:	3d ff 00 00 00       	cmp    $0xff,%eax
  80a94a:	77 37                	ja     80a983 <inet_aton+0x1c3>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  80a94c:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80a94f:	c1 e3 10             	shl    $0x10,%ebx
  80a952:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a955:	c1 e2 18             	shl    $0x18,%edx
  80a958:	09 d3                	or     %edx,%ebx
  80a95a:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80a95d:	c1 e2 08             	shl    $0x8,%edx
  80a960:	09 d3                	or     %edx,%ebx
  80a962:	09 c3                	or     %eax,%ebx
    break;
  }
  if (addr)
  80a964:	b8 01 00 00 00       	mov    $0x1,%eax
  80a969:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80a96d:	74 19                	je     80a988 <inet_aton+0x1c8>
    addr->s_addr = htonl(val);
  80a96f:	89 1c 24             	mov    %ebx,(%esp)
  80a972:	e8 1d fe ff ff       	call   80a794 <htonl>
  80a977:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80a97a:	89 03                	mov    %eax,(%ebx)
  80a97c:	b8 01 00 00 00       	mov    $0x1,%eax
  80a981:	eb 05                	jmp    80a988 <inet_aton+0x1c8>
  80a983:	b8 00 00 00 00       	mov    $0x0,%eax
  return (1);
}
  80a988:	83 c4 28             	add    $0x28,%esp
  80a98b:	5b                   	pop    %ebx
  80a98c:	5e                   	pop    %esi
  80a98d:	5f                   	pop    %edi
  80a98e:	5d                   	pop    %ebp
  80a98f:	c3                   	ret    

0080a990 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  80a990:	55                   	push   %ebp
  80a991:	89 e5                	mov    %esp,%ebp
  80a993:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  80a996:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80a999:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a99d:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9a0:	89 04 24             	mov    %eax,(%esp)
  80a9a3:	e8 18 fe ff ff       	call   80a7c0 <inet_aton>
  80a9a8:	85 c0                	test   %eax,%eax
  80a9aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a9af:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
    return (val.s_addr);
  }
  return (INADDR_NONE);
}
  80a9b3:	c9                   	leave  
  80a9b4:	c3                   	ret    

0080a9b5 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  80a9b5:	55                   	push   %ebp
  80a9b6:	89 e5                	mov    %esp,%ebp
  80a9b8:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  80a9bb:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9be:	89 04 24             	mov    %eax,(%esp)
  80a9c1:	e8 ce fd ff ff       	call   80a794 <htonl>
}
  80a9c6:	c9                   	leave  
  80a9c7:	c3                   	ret    
	...

0080a9d0 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80a9d0:	55                   	push   %ebp
  80a9d1:	89 e5                	mov    %esp,%ebp
  80a9d3:	57                   	push   %edi
  80a9d4:	56                   	push   %esi
  80a9d5:	53                   	push   %ebx
  80a9d6:	83 ec 3c             	sub    $0x3c,%esp
  80a9d9:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  80a9dc:	8b 46 78             	mov    0x78(%esi),%eax
  80a9df:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  80a9e2:	85 c0                	test   %eax,%eax
  80a9e4:	75 0e                	jne    80a9f4 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  80a9e6:	8b 56 74             	mov    0x74(%esi),%edx
  80a9e9:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  if(seg == NULL)
  80a9ec:	85 d2                	test   %edx,%edx
  80a9ee:	0f 84 4b 01 00 00    	je     80ab3f <tcp_zero_window_probe+0x16f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  80a9f4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80a9fb:	00 
  80a9fc:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  80aa03:	00 
  80aa04:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80aa0b:	e8 29 d2 ff ff       	call   807c39 <pbuf_alloc>
  80aa10:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80aa12:	85 c0                	test   %eax,%eax
  80aa14:	0f 84 25 01 00 00    	je     80ab3f <tcp_zero_window_probe+0x16f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80aa1a:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80aa1f:	77 1c                	ja     80aa3d <tcp_zero_window_probe+0x6d>
  80aa21:	c7 44 24 08 84 39 81 	movl   $0x813984,0x8(%esp)
  80aa28:	00 
  80aa29:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  80aa30:	00 
  80aa31:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80aa38:	e8 d7 5e ff ff       	call   800914 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80aa3d:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80aa40:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80aa44:	89 04 24             	mov    %eax,(%esp)
  80aa47:	e8 27 fd ff ff       	call   80a773 <htons>
  80aa4c:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80aa4f:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80aa53:	89 04 24             	mov    %eax,(%esp)
  80aa56:	e8 18 fd ff ff       	call   80a773 <htons>
  80aa5b:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  80aa5f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80aa62:	8b 41 10             	mov    0x10(%ecx),%eax
  80aa65:	8b 40 04             	mov    0x4(%eax),%eax
  80aa68:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80aa6b:	8b 46 24             	mov    0x24(%esi),%eax
  80aa6e:	89 04 24             	mov    %eax,(%esp)
  80aa71:	e8 1e fd ff ff       	call   80a794 <htonl>
  80aa76:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80aa79:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80aa7d:	89 04 24             	mov    %eax,(%esp)
  80aa80:	e8 fb fc ff ff       	call   80a780 <ntohs>
  80aa85:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80aa8a:	89 04 24             	mov    %eax,(%esp)
  80aa8d:	e8 e1 fc ff ff       	call   80a773 <htons>
  80aa92:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80aa96:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80aa9a:	89 04 24             	mov    %eax,(%esp)
  80aa9d:	e8 d1 fc ff ff       	call   80a773 <htons>
  80aaa2:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80aaa6:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80aaac:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80aab0:	89 04 24             	mov    %eax,(%esp)
  80aab3:	e8 c8 fc ff ff       	call   80a780 <ntohs>
  80aab8:	83 e0 3f             	and    $0x3f,%eax
  80aabb:	80 cc 50             	or     $0x50,%ah
  80aabe:	89 04 24             	mov    %eax,(%esp)
  80aac1:	e8 ad fc ff ff       	call   80a773 <htons>
  80aac6:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80aaca:	8b 47 04             	mov    0x4(%edi),%eax
  80aacd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80aad0:	8b 51 08             	mov    0x8(%ecx),%edx
  80aad3:	0f b6 12             	movzbl (%edx),%edx
  80aad6:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  80aad9:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80aadf:	8d 46 04             	lea    0x4(%esi),%eax
  80aae2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80aae5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80aae9:	89 44 24 10          	mov    %eax,0x10(%esp)
  80aaed:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80aaf4:	00 
  80aaf5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80aaf8:	89 54 24 08          	mov    %edx,0x8(%esp)
  80aafc:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ab00:	89 3c 24             	mov    %edi,(%esp)
  80ab03:	e8 68 f9 ff ff       	call   80a470 <inet_chksum_pseudo>
  80ab08:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80ab0c:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80ab13:	00 
  80ab14:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ab1b:	00 
  80ab1c:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80ab20:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ab24:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80ab27:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80ab2b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ab2f:	89 3c 24             	mov    %edi,(%esp)
  80ab32:	e8 86 ea ff ff       	call   8095bd <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80ab37:	89 3c 24             	mov    %edi,(%esp)
  80ab3a:	e8 3e ce ff ff       	call   80797d <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80ab3f:	83 c4 3c             	add    $0x3c,%esp
  80ab42:	5b                   	pop    %ebx
  80ab43:	5e                   	pop    %esi
  80ab44:	5f                   	pop    %edi
  80ab45:	5d                   	pop    %ebp
  80ab46:	c3                   	ret    

0080ab47 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80ab47:	55                   	push   %ebp
  80ab48:	89 e5                	mov    %esp,%ebp
  80ab4a:	57                   	push   %edi
  80ab4b:	56                   	push   %esi
  80ab4c:	53                   	push   %ebx
  80ab4d:	83 ec 3c             	sub    $0x3c,%esp
  80ab50:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80ab53:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ab5a:	00 
  80ab5b:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80ab62:	00 
  80ab63:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ab6a:	e8 ca d0 ff ff       	call   807c39 <pbuf_alloc>
  80ab6f:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80ab71:	85 c0                	test   %eax,%eax
  80ab73:	0f 84 1b 01 00 00    	je     80ac94 <tcp_keepalive+0x14d>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80ab79:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80ab7e:	77 1c                	ja     80ab9c <tcp_keepalive+0x55>
  80ab80:	c7 44 24 08 84 39 81 	movl   $0x813984,0x8(%esp)
  80ab87:	00 
  80ab88:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  80ab8f:	00 
  80ab90:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80ab97:	e8 78 5d ff ff       	call   800914 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80ab9c:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80ab9f:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80aba3:	89 04 24             	mov    %eax,(%esp)
  80aba6:	e8 c8 fb ff ff       	call   80a773 <htons>
  80abab:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80abae:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80abb2:	89 04 24             	mov    %eax,(%esp)
  80abb5:	e8 b9 fb ff ff       	call   80a773 <htons>
  80abba:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  80abbe:	8b 46 54             	mov    0x54(%esi),%eax
  80abc1:	83 e8 01             	sub    $0x1,%eax
  80abc4:	89 04 24             	mov    %eax,(%esp)
  80abc7:	e8 c8 fb ff ff       	call   80a794 <htonl>
  80abcc:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80abcf:	8b 46 24             	mov    0x24(%esi),%eax
  80abd2:	89 04 24             	mov    %eax,(%esp)
  80abd5:	e8 ba fb ff ff       	call   80a794 <htonl>
  80abda:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80abdd:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80abe1:	89 04 24             	mov    %eax,(%esp)
  80abe4:	e8 97 fb ff ff       	call   80a780 <ntohs>
  80abe9:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80abee:	89 04 24             	mov    %eax,(%esp)
  80abf1:	e8 7d fb ff ff       	call   80a773 <htons>
  80abf6:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80abfa:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80abfe:	89 04 24             	mov    %eax,(%esp)
  80ac01:	e8 6d fb ff ff       	call   80a773 <htons>
  80ac06:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80ac0a:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80ac10:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ac14:	89 04 24             	mov    %eax,(%esp)
  80ac17:	e8 64 fb ff ff       	call   80a780 <ntohs>
  80ac1c:	83 e0 3f             	and    $0x3f,%eax
  80ac1f:	80 cc 50             	or     $0x50,%ah
  80ac22:	89 04 24             	mov    %eax,(%esp)
  80ac25:	e8 49 fb ff ff       	call   80a773 <htons>
  80ac2a:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80ac2e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80ac34:	8d 46 04             	lea    0x4(%esi),%eax
  80ac37:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ac3a:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80ac3e:	89 44 24 10          	mov    %eax,0x10(%esp)
  80ac42:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80ac49:	00 
  80ac4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ac4d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ac51:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ac55:	89 3c 24             	mov    %edi,(%esp)
  80ac58:	e8 13 f8 ff ff       	call   80a470 <inet_chksum_pseudo>
  80ac5d:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80ac61:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80ac68:	00 
  80ac69:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ac70:	00 
  80ac71:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80ac75:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ac79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ac7c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ac80:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ac84:	89 3c 24             	mov    %edi,(%esp)
  80ac87:	e8 31 e9 ff ff       	call   8095bd <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80ac8c:	89 3c 24             	mov    %edi,(%esp)
  80ac8f:	e8 e9 cc ff ff       	call   80797d <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80ac94:	83 c4 3c             	add    $0x3c,%esp
  80ac97:	5b                   	pop    %ebx
  80ac98:	5e                   	pop    %esi
  80ac99:	5f                   	pop    %edi
  80ac9a:	5d                   	pop    %ebp
  80ac9b:	c3                   	ret    

0080ac9c <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80ac9c:	55                   	push   %ebp
  80ac9d:	89 e5                	mov    %esp,%ebp
  80ac9f:	57                   	push   %edi
  80aca0:	56                   	push   %esi
  80aca1:	53                   	push   %ebx
  80aca2:	83 ec 3c             	sub    $0x3c,%esp
  80aca5:	8b 7d 14             	mov    0x14(%ebp),%edi
  80aca8:	0f b7 45 18          	movzwl 0x18(%ebp),%eax
  80acac:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  80acb0:	0f b7 45 1c          	movzwl 0x1c(%ebp),%eax
  80acb4:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80acb8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80acbf:	00 
  80acc0:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80acc7:	00 
  80acc8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80accf:	e8 65 cf ff ff       	call   807c39 <pbuf_alloc>
  80acd4:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  80acd6:	85 c0                	test   %eax,%eax
  80acd8:	0f 84 15 01 00 00    	je     80adf3 <tcp_rst+0x157>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80acde:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80ace3:	77 1c                	ja     80ad01 <tcp_rst+0x65>
  80ace5:	c7 44 24 08 84 39 81 	movl   $0x813984,0x8(%esp)
  80acec:	00 
  80aced:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  80acf4:	00 
  80acf5:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80acfc:	e8 13 5c ff ff       	call   800914 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80ad01:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  80ad04:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80ad08:	89 04 24             	mov    %eax,(%esp)
  80ad0b:	e8 63 fa ff ff       	call   80a773 <htons>
  80ad10:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  80ad13:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80ad17:	89 04 24             	mov    %eax,(%esp)
  80ad1a:	e8 54 fa ff ff       	call   80a773 <htons>
  80ad1f:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  80ad23:	8b 45 08             	mov    0x8(%ebp),%eax
  80ad26:	89 04 24             	mov    %eax,(%esp)
  80ad29:	e8 66 fa ff ff       	call   80a794 <htonl>
  80ad2e:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  80ad31:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ad34:	89 04 24             	mov    %eax,(%esp)
  80ad37:	e8 58 fa ff ff       	call   80a794 <htonl>
  80ad3c:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  80ad3f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ad43:	89 04 24             	mov    %eax,(%esp)
  80ad46:	e8 35 fa ff ff       	call   80a780 <ntohs>
  80ad4b:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80ad50:	83 c8 14             	or     $0x14,%eax
  80ad53:	89 04 24             	mov    %eax,(%esp)
  80ad56:	e8 18 fa ff ff       	call   80a773 <htons>
  80ad5b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  80ad5f:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80ad66:	e8 08 fa ff ff       	call   80a773 <htons>
  80ad6b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80ad6f:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80ad75:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ad79:	89 04 24             	mov    %eax,(%esp)
  80ad7c:	e8 ff f9 ff ff       	call   80a780 <ntohs>
  80ad81:	83 e0 3f             	and    $0x3f,%eax
  80ad84:	80 cc 50             	or     $0x50,%ah
  80ad87:	89 04 24             	mov    %eax,(%esp)
  80ad8a:	e8 e4 f9 ff ff       	call   80a773 <htons>
  80ad8f:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80ad93:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  80ad99:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80ad9d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80ada1:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80ada8:	00 
  80ada9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80adad:	8b 45 10             	mov    0x10(%ebp),%eax
  80adb0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80adb4:	89 34 24             	mov    %esi,(%esp)
  80adb7:	e8 b4 f6 ff ff       	call   80a470 <inet_chksum_pseudo>
  80adbc:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80adc0:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80adc7:	00 
  80adc8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80adcf:	00 
  80add0:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80add7:	00 
  80add8:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80addc:	8b 45 10             	mov    0x10(%ebp),%eax
  80addf:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ade3:	89 34 24             	mov    %esi,(%esp)
  80ade6:	e8 d2 e7 ff ff       	call   8095bd <ip_output>
  pbuf_free(p);
  80adeb:	89 34 24             	mov    %esi,(%esp)
  80adee:	e8 8a cb ff ff       	call   80797d <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80adf3:	83 c4 3c             	add    $0x3c,%esp
  80adf6:	5b                   	pop    %ebx
  80adf7:	5e                   	pop    %esi
  80adf8:	5f                   	pop    %edi
  80adf9:	5d                   	pop    %ebp
  80adfa:	c3                   	ret    

0080adfb <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80adfb:	55                   	push   %ebp
  80adfc:	89 e5                	mov    %esp,%ebp
  80adfe:	57                   	push   %edi
  80adff:	56                   	push   %esi
  80ae00:	53                   	push   %ebx
  80ae01:	83 ec 4c             	sub    $0x4c,%esp
  80ae04:	8b 75 08             	mov    0x8(%ebp),%esi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80ae07:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae0c:	39 35 28 f0 b3 00    	cmp    %esi,0xb3f028
  80ae12:	0f 84 7e 04 00 00    	je     80b296 <tcp_output+0x49b>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  80ae18:	0f b7 46 4e          	movzwl 0x4e(%esi),%eax
  80ae1c:	66 39 46 5c          	cmp    %ax,0x5c(%esi)
  80ae20:	66 0f 46 46 5c       	cmovbe 0x5c(%esi),%ax
  80ae25:	0f b7 c0             	movzwl %ax,%eax
  80ae28:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  seg = pcb->unsent;
  80ae2b:	8b 5e 74             	mov    0x74(%esi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80ae2e:	8b 7e 78             	mov    0x78(%esi),%edi
  if (useg != NULL) {
  80ae31:	85 ff                	test   %edi,%edi
  80ae33:	74 0a                	je     80ae3f <tcp_output+0x44>
    for (; useg->next != NULL; useg = useg->next);
  80ae35:	8b 07                	mov    (%edi),%eax
  80ae37:	85 c0                	test   %eax,%eax
  80ae39:	74 04                	je     80ae3f <tcp_output+0x44>
  80ae3b:	89 c7                	mov    %eax,%edi
  80ae3d:	eb f6                	jmp    80ae35 <tcp_output+0x3a>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80ae3f:	f6 46 20 02          	testb  $0x2,0x20(%esi)
  80ae43:	75 10                	jne    80ae55 <tcp_output+0x5a>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80ae45:	85 db                	test   %ebx,%ebx
  80ae47:	75 2e                	jne    80ae77 <tcp_output+0x7c>
  80ae49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80ae50:	e9 38 04 00 00       	jmp    80b28d <tcp_output+0x492>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80ae55:	85 db                	test   %ebx,%ebx
  80ae57:	90                   	nop
  80ae58:	74 2e                	je     80ae88 <tcp_output+0x8d>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80ae5a:	8b 43 10             	mov    0x10(%ebx),%eax
  80ae5d:	8b 40 04             	mov    0x4(%eax),%eax
  80ae60:	89 04 24             	mov    %eax,(%esp)
  80ae63:	e8 4d fb ff ff       	call   80a9b5 <ntohl>
  80ae68:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80ae6c:	2b 56 48             	sub    0x48(%esi),%edx
  80ae6f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80ae72:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80ae75:	72 11                	jb     80ae88 <tcp_output+0x8d>
  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80ae77:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    netif = ip_route(&(pcb->remote_ip));
  80ae7a:	8d 46 04             	lea    0x4(%esi),%eax
  80ae7d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ae80:	89 7d d8             	mov    %edi,-0x28(%ebp)
  80ae83:	e9 a7 03 00 00       	jmp    80b22f <tcp_output+0x434>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80ae88:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ae8f:	00 
  80ae90:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80ae97:	00 
  80ae98:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ae9f:	e8 95 cd ff ff       	call   807c39 <pbuf_alloc>
  80aea4:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  80aea6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80aeab:	85 ff                	test   %edi,%edi
  80aead:	0f 84 e3 03 00 00    	je     80b296 <tcp_output+0x49b>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80aeb3:	80 66 20 fc          	andb   $0xfc,0x20(%esi)

    tcphdr = p->payload;
  80aeb7:	8b 5f 04             	mov    0x4(%edi),%ebx
    tcphdr->src = htons(pcb->local_port);
  80aeba:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80aebe:	89 04 24             	mov    %eax,(%esp)
  80aec1:	e8 ad f8 ff ff       	call   80a773 <htons>
  80aec6:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  80aec9:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80aecd:	89 04 24             	mov    %eax,(%esp)
  80aed0:	e8 9e f8 ff ff       	call   80a773 <htons>
  80aed5:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  80aed9:	8b 46 54             	mov    0x54(%esi),%eax
  80aedc:	89 04 24             	mov    %eax,(%esp)
  80aedf:	e8 b0 f8 ff ff       	call   80a794 <htonl>
  80aee4:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  80aee7:	8b 46 24             	mov    0x24(%esi),%eax
  80aeea:	89 04 24             	mov    %eax,(%esp)
  80aeed:	e8 a2 f8 ff ff       	call   80a794 <htonl>
  80aef2:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  80aef5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80aef9:	89 04 24             	mov    %eax,(%esp)
  80aefc:	e8 7f f8 ff ff       	call   80a780 <ntohs>
  80af01:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80af06:	83 c8 10             	or     $0x10,%eax
  80af09:	89 04 24             	mov    %eax,(%esp)
  80af0c:	e8 62 f8 ff ff       	call   80a773 <htons>
  80af11:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80af15:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80af19:	89 04 24             	mov    %eax,(%esp)
  80af1c:	e8 52 f8 ff ff       	call   80a773 <htons>
  80af21:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  80af25:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80af2b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80af2f:	89 04 24             	mov    %eax,(%esp)
  80af32:	e8 49 f8 ff ff       	call   80a780 <ntohs>
  80af37:	83 e0 3f             	and    $0x3f,%eax
  80af3a:	80 cc 50             	or     $0x50,%ah
  80af3d:	89 04 24             	mov    %eax,(%esp)
  80af40:	e8 2e f8 ff ff       	call   80a773 <htons>
  80af45:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80af49:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80af4f:	8d 56 04             	lea    0x4(%esi),%edx
  80af52:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80af55:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80af59:	89 44 24 10          	mov    %eax,0x10(%esp)
  80af5d:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80af64:	00 
  80af65:	89 54 24 08          	mov    %edx,0x8(%esp)
  80af69:	89 74 24 04          	mov    %esi,0x4(%esp)
  80af6d:	89 3c 24             	mov    %edi,(%esp)
  80af70:	e8 fb f4 ff ff       	call   80a470 <inet_chksum_pseudo>
  80af75:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80af79:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80af80:	00 
  80af81:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80af85:	89 44 24 10          	mov    %eax,0x10(%esp)
  80af89:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80af8d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80af91:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80af94:	89 44 24 08          	mov    %eax,0x8(%esp)
  80af98:	89 74 24 04          	mov    %esi,0x4(%esp)
  80af9c:	89 3c 24             	mov    %edi,(%esp)
  80af9f:	e8 19 e6 ff ff       	call   8095bd <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80afa4:	89 3c 24             	mov    %edi,(%esp)
  80afa7:	e8 d1 c9 ff ff       	call   80797d <pbuf_free>
  80afac:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
  80afb1:	e9 e0 02 00 00       	jmp    80b296 <tcp_output+0x49b>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80afb6:	8b 43 10             	mov    0x10(%ebx),%eax
  80afb9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80afbd:	89 04 24             	mov    %eax,(%esp)
  80afc0:	e8 bb f7 ff ff       	call   80a780 <ntohs>
  80afc5:	a8 04                	test   $0x4,%al
  80afc7:	74 1c                	je     80afe5 <tcp_output+0x1ea>
  80afc9:	c7 44 24 08 40 3b 81 	movl   $0x813b40,0x8(%esp)
  80afd0:	00 
  80afd1:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  80afd8:	00 
  80afd9:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80afe0:	e8 2f 59 ff ff       	call   800914 <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80afe5:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80afe9:	74 1c                	je     80b007 <tcp_output+0x20c>
  80afeb:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  80afef:	a8 40                	test   $0x40,%al
  80aff1:	75 14                	jne    80b007 <tcp_output+0x20c>
  80aff3:	8b 56 74             	mov    0x74(%esi),%edx
  80aff6:	85 d2                	test   %edx,%edx
  80aff8:	0f 84 a0 02 00 00    	je     80b29e <tcp_output+0x4a3>
  80affe:	83 3a 00             	cmpl   $0x0,(%edx)
  80b001:	0f 84 97 02 00 00    	je     80b29e <tcp_output+0x4a3>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  80b007:	8b 03                	mov    (%ebx),%eax
  80b009:	89 46 74             	mov    %eax,0x74(%esi)

    if (pcb->state != SYN_SENT) {
  80b00c:	83 7e 10 02          	cmpl   $0x2,0x10(%esi)
  80b010:	74 25                	je     80b037 <tcp_output+0x23c>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  80b012:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b015:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80b019:	89 04 24             	mov    %eax,(%esp)
  80b01c:	e8 5f f7 ff ff       	call   80a780 <ntohs>
  80b021:	83 c8 10             	or     $0x10,%eax
  80b024:	0f b7 c0             	movzwl %ax,%eax
  80b027:	89 04 24             	mov    %eax,(%esp)
  80b02a:	e8 44 f7 ff ff       	call   80a773 <htons>
  80b02f:	66 89 47 0c          	mov    %ax,0xc(%edi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80b033:	80 66 20 fc          	andb   $0xfc,0x20(%esi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b037:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b03a:	8b 46 24             	mov    0x24(%esi),%eax
  80b03d:	89 04 24             	mov    %eax,(%esp)
  80b040:	e8 4f f7 ff ff       	call   80a794 <htonl>
  80b045:	89 47 08             	mov    %eax,0x8(%edi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b048:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b04b:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b04f:	89 04 24             	mov    %eax,(%esp)
  80b052:	e8 1c f7 ff ff       	call   80a773 <htons>
  80b057:	66 89 47 0e          	mov    %ax,0xe(%edi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80b05b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80b05f:	74 05                	je     80b066 <tcp_output+0x26b>
  80b061:	83 3e 00             	cmpl   $0x0,(%esi)
  80b064:	75 22                	jne    80b088 <tcp_output+0x28d>
    netif = ip_route(&(pcb->remote_ip));
  80b066:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b069:	89 14 24             	mov    %edx,(%esp)
  80b06c:	e8 f0 e4 ff ff       	call   809561 <ip_route>
    if (netif == NULL) {
  80b071:	85 c0                	test   %eax,%eax
  80b073:	0f 84 c3 00 00 00    	je     80b13c <tcp_output+0x341>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  80b079:	ba 00 00 00 00       	mov    $0x0,%edx
  80b07e:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80b081:	74 03                	je     80b086 <tcp_output+0x28b>
  80b083:	8b 50 04             	mov    0x4(%eax),%edx
  80b086:	89 16                	mov    %edx,(%esi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  80b088:	66 83 7e 32 ff       	cmpw   $0xffffffff,0x32(%esi)
  80b08d:	75 06                	jne    80b095 <tcp_output+0x29a>
    pcb->rtime = 0;
  80b08f:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)

  if (pcb->rttest == 0) {
  80b095:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
  80b099:	75 19                	jne    80b0b4 <tcp_output+0x2b9>
    pcb->rttest = tcp_ticks;
  80b09b:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  80b0a0:	89 46 38             	mov    %eax,0x38(%esi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  80b0a3:	8b 43 10             	mov    0x10(%ebx),%eax
  80b0a6:	8b 40 04             	mov    0x4(%eax),%eax
  80b0a9:	89 04 24             	mov    %eax,(%esp)
  80b0ac:	e8 04 f9 ff ff       	call   80a9b5 <ntohl>
  80b0b1:	89 46 3c             	mov    %eax,0x3c(%esi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  80b0b4:	8b 43 04             	mov    0x4(%ebx),%eax
  80b0b7:	8b 53 10             	mov    0x10(%ebx),%edx
  80b0ba:	66 2b 50 04          	sub    0x4(%eax),%dx

  seg->p->len -= len;
  80b0be:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  80b0c2:	8b 43 04             	mov    0x4(%ebx),%eax
  80b0c5:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  80b0c9:	8b 43 04             	mov    0x4(%ebx),%eax
  80b0cc:	8b 53 10             	mov    0x10(%ebx),%edx
  80b0cf:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  80b0d2:	8b 43 10             	mov    0x10(%ebx),%eax
  80b0d5:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b0db:	8b 7b 10             	mov    0x10(%ebx),%edi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80b0de:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b0e1:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80b0e5:	89 54 24 10          	mov    %edx,0x10(%esp)
  80b0e9:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b0f0:	00 
  80b0f1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b0f4:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b0f8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b0fb:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b0ff:	89 04 24             	mov    %eax,(%esp)
  80b102:	e8 69 f3 ff ff       	call   80a470 <inet_chksum_pseudo>
  80b107:	66 89 47 10          	mov    %ax,0x10(%edi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80b10b:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b112:	00 
  80b113:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80b117:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b11b:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b11f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b123:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b126:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b12a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b12d:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b131:	8b 43 04             	mov    0x4(%ebx),%eax
  80b134:	89 04 24             	mov    %eax,(%esp)
  80b137:	e8 81 e4 ff ff       	call   8095bd <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80b13c:	8b 43 10             	mov    0x10(%ebx),%eax
  80b13f:	8b 40 04             	mov    0x4(%eax),%eax
  80b142:	89 04 24             	mov    %eax,(%esp)
  80b145:	e8 6b f8 ff ff       	call   80a9b5 <ntohl>
  80b14a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80b14d:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80b151:	8b 43 10             	mov    0x10(%ebx),%eax
  80b154:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b158:	89 04 24             	mov    %eax,(%esp)
  80b15b:	e8 20 f6 ff ff       	call   80a780 <ntohs>
  80b160:	a8 01                	test   $0x1,%al
  80b162:	75 1b                	jne    80b17f <tcp_output+0x384>
  80b164:	8b 43 10             	mov    0x10(%ebx),%eax
  80b167:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b16b:	89 04 24             	mov    %eax,(%esp)
  80b16e:	e8 0d f6 ff ff       	call   80a780 <ntohs>
  80b173:	89 c2                	mov    %eax,%edx
  80b175:	b8 00 00 00 00       	mov    $0x0,%eax
  80b17a:	f6 c2 02             	test   $0x2,%dl
  80b17d:	74 05                	je     80b184 <tcp_output+0x389>
  80b17f:	b8 01 00 00 00       	mov    $0x1,%eax
  80b184:	0f b7 ff             	movzwl %di,%edi
  80b187:	8d 3c 38             	lea    (%eax,%edi,1),%edi
  80b18a:	03 7d dc             	add    -0x24(%ebp),%edi
  80b18d:	89 7e 54             	mov    %edi,0x54(%esi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80b190:	39 7e 58             	cmp    %edi,0x58(%esi)
  80b193:	79 03                	jns    80b198 <tcp_output+0x39d>
      pcb->snd_max = pcb->snd_nxt;
  80b195:	89 7e 58             	mov    %edi,0x58(%esi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  80b198:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80b19c:	8b 43 10             	mov    0x10(%ebx),%eax
  80b19f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b1a3:	89 04 24             	mov    %eax,(%esp)
  80b1a6:	e8 d5 f5 ff ff       	call   80a780 <ntohs>
  80b1ab:	a8 01                	test   $0x1,%al
  80b1ad:	75 18                	jne    80b1c7 <tcp_output+0x3cc>
  80b1af:	8b 43 10             	mov    0x10(%ebx),%eax
  80b1b2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b1b6:	89 04 24             	mov    %eax,(%esp)
  80b1b9:	e8 c2 f5 ff ff       	call   80a780 <ntohs>
  80b1be:	ba 00 00 00 00       	mov    $0x0,%edx
  80b1c3:	a8 02                	test   $0x2,%al
  80b1c5:	74 05                	je     80b1cc <tcp_output+0x3d1>
  80b1c7:	ba 01 00 00 00       	mov    $0x1,%edx
  80b1cc:	0f b7 ff             	movzwl %di,%edi
  80b1cf:	01 fa                	add    %edi,%edx
  80b1d1:	74 4d                	je     80b220 <tcp_output+0x425>
      seg->next = NULL;
  80b1d3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  80b1d9:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80b1dd:	75 08                	jne    80b1e7 <tcp_output+0x3ec>
        pcb->unacked = seg;
  80b1df:	89 5e 78             	mov    %ebx,0x78(%esi)
  80b1e2:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80b1e5:	eb 41                	jmp    80b228 <tcp_output+0x42d>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  80b1e7:	8b 43 10             	mov    0x10(%ebx),%eax
  80b1ea:	8b 40 04             	mov    0x4(%eax),%eax
  80b1ed:	89 04 24             	mov    %eax,(%esp)
  80b1f0:	e8 c0 f7 ff ff       	call   80a9b5 <ntohl>
  80b1f5:	89 c7                	mov    %eax,%edi
  80b1f7:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b1fa:	8b 42 10             	mov    0x10(%edx),%eax
  80b1fd:	8b 40 04             	mov    0x4(%eax),%eax
  80b200:	89 04 24             	mov    %eax,(%esp)
  80b203:	e8 ad f7 ff ff       	call   80a9b5 <ntohl>
  80b208:	39 c7                	cmp    %eax,%edi
  80b20a:	79 0a                	jns    80b216 <tcp_output+0x41b>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  80b20c:	8b 46 78             	mov    0x78(%esi),%eax
  80b20f:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80b211:	89 5e 78             	mov    %ebx,0x78(%esi)
  80b214:	eb 12                	jmp    80b228 <tcp_output+0x42d>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  80b216:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80b219:	89 18                	mov    %ebx,(%eax)
  80b21b:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80b21e:	eb 08                	jmp    80b228 <tcp_output+0x42d>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  80b220:	89 1c 24             	mov    %ebx,(%esp)
  80b223:	e8 c9 d2 ff ff       	call   8084f1 <tcp_seg_free>
    }
    seg = pcb->unsent;
  80b228:	8b 5e 74             	mov    0x74(%esi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80b22b:	85 db                	test   %ebx,%ebx
  80b22d:	74 5e                	je     80b28d <tcp_output+0x492>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  80b22f:	8b 43 10             	mov    0x10(%ebx),%eax
  80b232:	8b 40 04             	mov    0x4(%eax),%eax
  80b235:	89 04 24             	mov    %eax,(%esp)
  80b238:	e8 78 f7 ff ff       	call   80a9b5 <ntohl>
  80b23d:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b241:	2b 56 48             	sub    0x48(%esi),%edx
  80b244:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80b247:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80b24a:	0f 83 66 fd ff ff    	jae    80afb6 <tcp_output+0x1bb>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80b250:	85 db                	test   %ebx,%ebx
  80b252:	74 39                	je     80b28d <tcp_output+0x492>
  80b254:	80 be a4 00 00 00 00 	cmpb   $0x0,0xa4(%esi)
  80b25b:	75 30                	jne    80b28d <tcp_output+0x492>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  80b25d:	8b 43 10             	mov    0x10(%ebx),%eax
  80b260:	8b 40 04             	mov    0x4(%eax),%eax
  80b263:	89 04 24             	mov    %eax,(%esp)
  80b266:	e8 4a f7 ff ff       	call   80a9b5 <ntohl>
  80b26b:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b26f:	2b 56 48             	sub    0x48(%esi),%edx
  80b272:	01 c2                	add    %eax,%edx
  80b274:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
  80b278:	39 c2                	cmp    %eax,%edx
  80b27a:	76 11                	jbe    80b28d <tcp_output+0x492>
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  80b27c:	c7 86 a0 00 00 00 00 	movl   $0x0,0xa0(%esi)
  80b283:	00 00 00 
    pcb->persist_backoff = 1;
  80b286:	c6 86 a4 00 00 00 01 	movb   $0x1,0xa4(%esi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  80b28d:	80 66 20 7f          	andb   $0x7f,0x20(%esi)
  80b291:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80b296:	83 c4 4c             	add    $0x4c,%esp
  80b299:	5b                   	pop    %ebx
  80b29a:	5e                   	pop    %esi
  80b29b:	5f                   	pop    %edi
  80b29c:	5d                   	pop    %ebp
  80b29d:	c3                   	ret    
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80b29e:	a8 a0                	test   $0xa0,%al
  80b2a0:	0f 85 61 fd ff ff    	jne    80b007 <tcp_output+0x20c>
  80b2a6:	eb a8                	jmp    80b250 <tcp_output+0x455>

0080b2a8 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  80b2a8:	55                   	push   %ebp
  80b2a9:	89 e5                	mov    %esp,%ebp
  80b2ab:	53                   	push   %ebx
  80b2ac:	83 ec 14             	sub    $0x14,%esp
  80b2af:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b2b2:	8b 43 78             	mov    0x78(%ebx),%eax
  80b2b5:	85 c0                	test   %eax,%eax
  80b2b7:	74 34                	je     80b2ed <tcp_rexmit+0x45>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  80b2b9:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  80b2bb:	8b 4b 74             	mov    0x74(%ebx),%ecx
  80b2be:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  80b2c0:	8b 43 78             	mov    0x78(%ebx),%eax
  80b2c3:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80b2c6:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b2c9:	8b 40 10             	mov    0x10(%eax),%eax
  80b2cc:	8b 40 04             	mov    0x4(%eax),%eax
  80b2cf:	89 04 24             	mov    %eax,(%esp)
  80b2d2:	e8 de f6 ff ff       	call   80a9b5 <ntohl>
  80b2d7:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  80b2da:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80b2de:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80b2e5:	89 1c 24             	mov    %ebx,(%esp)
  80b2e8:	e8 0e fb ff ff       	call   80adfb <tcp_output>
}
  80b2ed:	83 c4 14             	add    $0x14,%esp
  80b2f0:	5b                   	pop    %ebx
  80b2f1:	5d                   	pop    %ebp
  80b2f2:	c3                   	ret    

0080b2f3 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  80b2f3:	55                   	push   %ebp
  80b2f4:	89 e5                	mov    %esp,%ebp
  80b2f6:	53                   	push   %ebx
  80b2f7:	83 ec 14             	sub    $0x14,%esp
  80b2fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b2fd:	8b 43 78             	mov    0x78(%ebx),%eax
  80b300:	85 c0                	test   %eax,%eax
  80b302:	74 3e                	je     80b342 <tcp_rexmit_rto+0x4f>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  80b304:	89 c2                	mov    %eax,%edx
  80b306:	8b 00                	mov    (%eax),%eax
  80b308:	85 c0                	test   %eax,%eax
  80b30a:	75 f8                	jne    80b304 <tcp_rexmit_rto+0x11>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  80b30c:	8b 43 74             	mov    0x74(%ebx),%eax
  80b30f:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  80b311:	8b 43 78             	mov    0x78(%ebx),%eax
  80b314:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  80b317:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b31e:	8b 40 10             	mov    0x10(%eax),%eax
  80b321:	8b 40 04             	mov    0x4(%eax),%eax
  80b324:	89 04 24             	mov    %eax,(%esp)
  80b327:	e8 89 f6 ff ff       	call   80a9b5 <ntohl>
  80b32c:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  80b32f:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80b333:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  80b33a:	89 1c 24             	mov    %ebx,(%esp)
  80b33d:	e8 b9 fa ff ff       	call   80adfb <tcp_output>
}
  80b342:	83 c4 14             	add    $0x14,%esp
  80b345:	5b                   	pop    %ebx
  80b346:	5d                   	pop    %ebp
  80b347:	c3                   	ret    

0080b348 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  80b348:	55                   	push   %ebp
  80b349:	89 e5                	mov    %esp,%ebp
  80b34b:	57                   	push   %edi
  80b34c:	56                   	push   %esi
  80b34d:	53                   	push   %ebx
  80b34e:	83 ec 6c             	sub    $0x6c,%esp
  80b351:	8b 7d 08             	mov    0x8(%ebp),%edi
  80b354:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b357:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  80b35b:	66 89 45 b6          	mov    %ax,-0x4a(%ebp)
  80b35f:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  80b363:	88 4d af             	mov    %cl,-0x51(%ebp)
  80b366:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  80b36a:	88 45 98             	mov    %al,-0x68(%ebp)
  80b36d:	0f b6 45 20          	movzbl 0x20(%ebp),%eax
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  80b371:	66 83 7d b6 00       	cmpw   $0x0,-0x4a(%ebp)
  80b376:	74 20                	je     80b398 <tcp_enqueue+0x50>
  80b378:	84 c0                	test   %al,%al
  80b37a:	74 1c                	je     80b398 <tcp_enqueue+0x50>
  80b37c:	c7 44 24 08 b4 39 81 	movl   $0x8139b4,0x8(%esp)
  80b383:	00 
  80b384:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  80b38b:	00 
  80b38c:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b393:	e8 7c 55 ff ff       	call   800914 <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  80b398:	85 d2                	test   %edx,%edx
  80b39a:	0f 95 45 b5          	setne  -0x4b(%ebp)
  80b39e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80b3a2:	0f 95 45 bf          	setne  -0x41(%ebp)
  80b3a6:	80 7d b5 00          	cmpb   $0x0,-0x4b(%ebp)
  80b3aa:	74 22                	je     80b3ce <tcp_enqueue+0x86>
  80b3ac:	80 7d bf 00          	cmpb   $0x0,-0x41(%ebp)
  80b3b0:	74 1c                	je     80b3ce <tcp_enqueue+0x86>
  80b3b2:	c7 44 24 08 f4 39 81 	movl   $0x8139f4,0x8(%esp)
  80b3b9:	00 
  80b3ba:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  80b3c1:	00 
  80b3c2:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b3c9:	e8 46 55 ff ff       	call   800914 <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80b3ce:	0f b7 4d b6          	movzwl -0x4a(%ebp),%ecx
  80b3d2:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  80b3d6:	76 0e                	jbe    80b3e6 <tcp_enqueue+0x9e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  80b3d8:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  80b3dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80b3e1:	e9 34 06 00 00       	jmp    80ba1a <tcp_enqueue+0x6d2>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  80b3e6:	8b 4f 68             	mov    0x68(%edi),%ecx
  80b3e9:	89 4d cc             	mov    %ecx,-0x34(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80b3ec:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  80b3f0:	66 89 4d d6          	mov    %cx,-0x2a(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80b3f4:	66 83 f9 1f          	cmp    $0x1f,%cx
  80b3f8:	76 0e                	jbe    80b408 <tcp_enqueue+0xc0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  80b3fa:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  80b3fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80b403:	e9 12 06 00 00       	jmp    80ba1a <tcp_enqueue+0x6d2>
  }
  if (queuelen != 0) {
  80b408:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  80b40d:	74 76                	je     80b485 <tcp_enqueue+0x13d>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80b40f:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b413:	74 4e                	je     80b463 <tcp_enqueue+0x11b>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80b415:	89 c1                	mov    %eax,%ecx
  80b417:	c0 e9 02             	shr    $0x2,%cl
  80b41a:	c1 e1 0c             	shl    $0xc,%ecx
  80b41d:	66 81 c1 00 50       	add    $0x5000,%cx
  80b422:	66 89 4d ba          	mov    %cx,-0x46(%ebp)
  80b426:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80b429:	0f b7 55 b6          	movzwl -0x4a(%ebp),%edx
  80b42d:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
  80b431:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  80b438:	bb 00 00 00 00       	mov    $0x0,%ebx
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80b43d:	0f b6 4d 98          	movzbl -0x68(%ebp),%ecx
  80b441:	83 e1 01             	and    $0x1,%ecx
  80b444:	89 4d b0             	mov    %ecx,-0x50(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80b447:	0f b6 d0             	movzbl %al,%edx
  80b44a:	89 55 c0             	mov    %edx,-0x40(%ebp)
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80b44d:	0f b6 c0             	movzbl %al,%eax
  80b450:	66 89 45 b8          	mov    %ax,-0x48(%ebp)
    seg->tcphdr = seg->p->payload;
    seg->tcphdr->src = htons(pcb->local_port);
    seg->tcphdr->dest = htons(pcb->remote_port);
    seg->tcphdr->seqno = htonl(seqno);
    seg->tcphdr->urgp = 0;
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80b454:	0f b6 4d af          	movzbl -0x51(%ebp),%ecx
  80b458:	66 89 4d bc          	mov    %cx,-0x44(%ebp)
  80b45c:	89 7d d0             	mov    %edi,-0x30(%ebp)
  80b45f:	89 df                	mov    %ebx,%edi
  80b461:	eb 55                	jmp    80b4b8 <tcp_enqueue+0x170>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80b463:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b467:	75 ac                	jne    80b415 <tcp_enqueue+0xcd>
  80b469:	c7 44 24 08 3c 3a 81 	movl   $0x813a3c,0x8(%esp)
  80b470:	00 
  80b471:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  80b478:	00 
  80b479:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b480:	e8 8f 54 ff ff       	call   800914 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  80b485:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b489:	75 06                	jne    80b491 <tcp_enqueue+0x149>
  80b48b:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b48f:	74 84                	je     80b415 <tcp_enqueue+0xcd>
  80b491:	c7 44 24 08 78 3a 81 	movl   $0x813a78,0x8(%esp)
  80b498:	00 
  80b499:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  80b4a0:	00 
  80b4a1:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b4a8:	e8 67 54 ff ff       	call   800914 <_panic>
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  80b4ad:	0f b7 f6             	movzwl %si,%esi
  80b4b0:	01 75 cc             	add    %esi,-0x34(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  80b4b3:	01 75 c4             	add    %esi,-0x3c(%ebp)
  80b4b6:	89 df                	mov    %ebx,%edi
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80b4b8:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80b4bb:	0f b7 70 34          	movzwl 0x34(%eax),%esi

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80b4bf:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80b4c6:	e8 6d bd ff ff       	call   807238 <memp_malloc>
  80b4cb:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  80b4cd:	85 c0                	test   %eax,%eax
  80b4cf:	0f 84 d2 04 00 00    	je     80b9a7 <tcp_enqueue+0x65f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  80b4d5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  80b4db:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  80b4e2:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80b4e6:	75 05                	jne    80b4ed <tcp_enqueue+0x1a5>
  80b4e8:	89 45 c8             	mov    %eax,-0x38(%ebp)
  80b4eb:	eb 22                	jmp    80b50f <tcp_enqueue+0x1c7>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  80b4ed:	85 ff                	test   %edi,%edi
  80b4ef:	75 1c                	jne    80b50d <tcp_enqueue+0x1c5>
  80b4f1:	c7 44 24 08 57 3b 81 	movl   $0x813b57,0x8(%esp)
  80b4f8:	00 
  80b4f9:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80b500:	00 
  80b501:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b508:	e8 07 54 ff ff       	call   800914 <_panic>
      useg->next = seg;
  80b50d:	89 07                	mov    %eax,(%edi)
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80b50f:	66 39 75 d8          	cmp    %si,-0x28(%ebp)
  80b513:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  80b517:	0f 46 f2             	cmovbe %edx,%esi
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  80b51a:	80 7d bf 00          	cmpb   $0x0,-0x41(%ebp)
  80b51e:	74 69                	je     80b589 <tcp_enqueue+0x241>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80b520:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b527:	00 
  80b528:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  80b52b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80b52f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b536:	e8 fe c6 ff ff       	call   807c39 <pbuf_alloc>
  80b53b:	89 43 04             	mov    %eax,0x4(%ebx)
  80b53e:	85 c0                	test   %eax,%eax
  80b540:	0f 84 66 04 00 00    	je     80b9ac <tcp_enqueue+0x664>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80b546:	0f b7 55 b8          	movzwl -0x48(%ebp),%edx
  80b54a:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  80b54e:	73 1c                	jae    80b56c <tcp_enqueue+0x224>
  80b550:	c7 44 24 08 ac 3a 81 	movl   $0x813aac,0x8(%esp)
  80b557:	00 
  80b558:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  80b55f:	00 
  80b560:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b567:	e8 a8 53 ff ff       	call   800914 <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  80b56c:	89 04 24             	mov    %eax,(%esp)
  80b56f:	e8 ac bf ff ff       	call   807520 <pbuf_clen>
  80b574:	0f b6 c0             	movzbl %al,%eax
  80b577:	66 01 45 d6          	add    %ax,-0x2a(%ebp)
      seg->dataptr = seg->p->payload;
  80b57b:	8b 43 04             	mov    0x4(%ebx),%eax
  80b57e:	8b 40 04             	mov    0x4(%eax),%eax
  80b581:	89 43 08             	mov    %eax,0x8(%ebx)
  80b584:	e9 1e 01 00 00       	jmp    80b6a7 <tcp_enqueue+0x35f>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80b589:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  80b58d:	0f 84 8b 00 00 00    	je     80b61e <tcp_enqueue+0x2d6>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  80b593:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b59a:	00 
  80b59b:	0f b7 c6             	movzwl %si,%eax
  80b59e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b5a2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b5a9:	e8 8b c6 ff ff       	call   807c39 <pbuf_alloc>
  80b5ae:	89 43 04             	mov    %eax,0x4(%ebx)
  80b5b1:	85 c0                	test   %eax,%eax
  80b5b3:	0f 84 f9 03 00 00    	je     80b9b2 <tcp_enqueue+0x66a>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  80b5b9:	66 3b 70 0a          	cmp    0xa(%eax),%si
  80b5bd:	76 1c                	jbe    80b5db <tcp_enqueue+0x293>
  80b5bf:	c7 44 24 08 d4 3a 81 	movl   $0x813ad4,0x8(%esp)
  80b5c6:	00 
  80b5c7:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  80b5ce:	00 
  80b5cf:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b5d6:	e8 39 53 ff ff       	call   800914 <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80b5db:	89 04 24             	mov    %eax,(%esp)
  80b5de:	e8 3d bf ff ff       	call   807520 <pbuf_clen>
  80b5e3:	89 c7                	mov    %eax,%edi
      if (arg != NULL) {
  80b5e5:	80 7d b5 00          	cmpb   $0x0,-0x4b(%ebp)
  80b5e9:	74 1c                	je     80b607 <tcp_enqueue+0x2bf>
        MEMCPY(seg->p->payload, ptr, seglen);
  80b5eb:	0f b7 c6             	movzwl %si,%eax
  80b5ee:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b5f2:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  80b5f5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80b5f9:	8b 43 04             	mov    0x4(%ebx),%eax
  80b5fc:	8b 40 04             	mov    0x4(%eax),%eax
  80b5ff:	89 04 24             	mov    %eax,(%esp)
  80b602:	e8 6a 5d ff ff       	call   801371 <memcpy>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80b607:	89 fa                	mov    %edi,%edx
  80b609:	0f b6 c2             	movzbl %dl,%eax
  80b60c:	66 01 45 d6          	add    %ax,-0x2a(%ebp)
      if (arg != NULL) {
        MEMCPY(seg->p->payload, ptr, seglen);
      }
      seg->dataptr = seg->p->payload;
  80b610:	8b 43 04             	mov    0x4(%ebx),%eax
  80b613:	8b 40 04             	mov    0x4(%eax),%eax
  80b616:	89 43 08             	mov    %eax,0x8(%ebx)
  80b619:	e9 89 00 00 00       	jmp    80b6a7 <tcp_enqueue+0x35f>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  80b61e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80b625:	00 
  80b626:	0f b7 c6             	movzwl %si,%eax
  80b629:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b62d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b634:	e8 00 c6 ff ff       	call   807c39 <pbuf_alloc>
  80b639:	89 c7                	mov    %eax,%edi
  80b63b:	85 c0                	test   %eax,%eax
  80b63d:	0f 84 74 03 00 00    	je     80b9b7 <tcp_enqueue+0x66f>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
      /* reference the non-volatile payload data */
      p->payload = ptr;
  80b643:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  80b646:	89 48 04             	mov    %ecx,0x4(%eax)
      seg->dataptr = ptr;
  80b649:	89 4b 08             	mov    %ecx,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  80b64c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b653:	00 
  80b654:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80b65b:	00 
  80b65c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b663:	e8 d1 c5 ff ff       	call   807c39 <pbuf_alloc>
  80b668:	89 43 04             	mov    %eax,0x4(%ebx)
  80b66b:	85 c0                	test   %eax,%eax
  80b66d:	75 12                	jne    80b681 <tcp_enqueue+0x339>
  80b66f:	89 fb                	mov    %edi,%ebx
  80b671:	8b 7d d0             	mov    -0x30(%ebp),%edi
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  80b674:	89 1c 24             	mov    %ebx,(%esp)
  80b677:	e8 01 c3 ff ff       	call   80797d <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  80b67c:	e9 44 03 00 00       	jmp    80b9c5 <tcp_enqueue+0x67d>
      }
      queuelen += pbuf_clen(seg->p);
  80b681:	89 04 24             	mov    %eax,(%esp)
  80b684:	e8 97 be ff ff       	call   807520 <pbuf_clen>
  80b689:	0f b6 c0             	movzbl %al,%eax
  80b68c:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
  80b690:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  80b694:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  80b698:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80b69c:	8b 43 04             	mov    0x4(%ebx),%eax
  80b69f:	89 04 24             	mov    %eax,(%esp)
  80b6a2:	e8 a4 be ff ff       	call   80754b <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80b6a7:	66 83 7d d6 20       	cmpw   $0x20,-0x2a(%ebp)
  80b6ac:	0f 87 0a 03 00 00    	ja     80b9bc <tcp_enqueue+0x674>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  80b6b2:	66 89 73 0c          	mov    %si,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  80b6b6:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b6bd:	00 
  80b6be:	8b 43 04             	mov    0x4(%ebx),%eax
  80b6c1:	89 04 24             	mov    %eax,(%esp)
  80b6c4:	e8 4a bf ff ff       	call   807613 <pbuf_header>
  80b6c9:	84 c0                	test   %al,%al
  80b6cb:	0f 85 f1 02 00 00    	jne    80b9c2 <tcp_enqueue+0x67a>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  80b6d1:	8b 43 04             	mov    0x4(%ebx),%eax
  80b6d4:	8b 78 04             	mov    0x4(%eax),%edi
  80b6d7:	89 7b 10             	mov    %edi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  80b6da:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80b6dd:	0f b7 41 1c          	movzwl 0x1c(%ecx),%eax
  80b6e1:	89 04 24             	mov    %eax,(%esp)
  80b6e4:	e8 8a f0 ff ff       	call   80a773 <htons>
  80b6e9:	66 89 07             	mov    %ax,(%edi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  80b6ec:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b6ef:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b6f2:	0f b7 42 1e          	movzwl 0x1e(%edx),%eax
  80b6f6:	89 04 24             	mov    %eax,(%esp)
  80b6f9:	e8 75 f0 ff ff       	call   80a773 <htons>
  80b6fe:	66 89 47 02          	mov    %ax,0x2(%edi)
    seg->tcphdr->seqno = htonl(seqno);
  80b702:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b705:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  80b708:	89 0c 24             	mov    %ecx,(%esp)
  80b70b:	e8 84 f0 ff ff       	call   80a794 <htonl>
  80b710:	89 47 04             	mov    %eax,0x4(%edi)
    seg->tcphdr->urgp = 0;
  80b713:	8b 43 10             	mov    0x10(%ebx),%eax
  80b716:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80b71c:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b71f:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80b723:	89 04 24             	mov    %eax,(%esp)
  80b726:	e8 55 f0 ff ff       	call   80a780 <ntohs>
  80b72b:	83 e0 c0             	and    $0xffffffc0,%eax
  80b72e:	66 0b 45 bc          	or     -0x44(%ebp),%ax
  80b732:	0f b7 c0             	movzwl %ax,%eax
  80b735:	89 04 24             	mov    %eax,(%esp)
  80b738:	e8 36 f0 ff ff       	call   80a773 <htons>
  80b73d:	66 89 47 0c          	mov    %ax,0xc(%edi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  80b741:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80b745:	75 23                	jne    80b76a <tcp_enqueue+0x422>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  80b747:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b74a:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80b74e:	89 04 24             	mov    %eax,(%esp)
  80b751:	e8 2a f0 ff ff       	call   80a780 <ntohs>
  80b756:	83 e0 3f             	and    $0x3f,%eax
  80b759:	80 cc 50             	or     $0x50,%ah
  80b75c:	89 04 24             	mov    %eax,(%esp)
  80b75f:	e8 0f f0 ff ff       	call   80a773 <htons>
  80b764:	66 89 47 0c          	mov    %ax,0xc(%edi)
  80b768:	eb 3e                	jmp    80b7a8 <tcp_enqueue+0x460>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80b76a:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b76d:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80b771:	89 04 24             	mov    %eax,(%esp)
  80b774:	e8 07 f0 ff ff       	call   80a780 <ntohs>
  80b779:	83 e0 3f             	and    $0x3f,%eax
  80b77c:	66 0b 45 ba          	or     -0x46(%ebp),%ax
  80b780:	0f b7 c0             	movzwl %ax,%eax
  80b783:	89 04 24             	mov    %eax,(%esp)
  80b786:	e8 e8 ef ff ff       	call   80a773 <htons>
  80b78b:	66 89 47 0c          	mov    %ax,0xc(%edi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  80b78f:	8b 45 c0             	mov    -0x40(%ebp),%eax
  80b792:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b796:	8b 55 1c             	mov    0x1c(%ebp),%edx
  80b799:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b79d:	8b 43 08             	mov    0x8(%ebx),%eax
  80b7a0:	89 04 24             	mov    %eax,(%esp)
  80b7a3:	e8 c9 5b ff ff       	call   801371 <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  80b7a8:	66 29 75 d8          	sub    %si,-0x28(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  80b7ac:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80b7b0:	0f 84 f7 fc ff ff    	je     80b4ad <tcp_enqueue+0x165>
  80b7b6:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
  80b7bb:	0f 85 ec fc ff ff    	jne    80b4ad <tcp_enqueue+0x165>
  80b7c1:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b7c4:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  80b7c7:	8b 4f 74             	mov    0x74(%edi),%ecx
  80b7ca:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  80b7cd:	85 c9                	test   %ecx,%ecx
  80b7cf:	0f 84 1c 01 00 00    	je     80b8f1 <tcp_enqueue+0x5a9>
  80b7d5:	89 ca                	mov    %ecx,%edx
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  80b7d7:	89 d0                	mov    %edx,%eax
  80b7d9:	8b 12                	mov    (%edx),%edx
  80b7db:	85 d2                	test   %edx,%edx
  80b7dd:	75 f8                	jne    80b7d7 <tcp_enqueue+0x48f>
  80b7df:	89 45 d8             	mov    %eax,-0x28(%ebp)
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80b7e2:	85 c0                	test   %eax,%eax
  80b7e4:	0f 84 07 01 00 00    	je     80b8f1 <tcp_enqueue+0x5a9>
    TCP_TCPLEN(useg) != 0 &&
  80b7ea:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b7ee:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
  80b7f2:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b7f5:	8b 42 10             	mov    0x10(%edx),%eax
  80b7f8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b7fc:	89 04 24             	mov    %eax,(%esp)
  80b7ff:	e8 7c ef ff ff       	call   80a780 <ntohs>
  80b804:	a8 01                	test   $0x1,%al
  80b806:	75 1b                	jne    80b823 <tcp_enqueue+0x4db>
  80b808:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80b80b:	8b 41 10             	mov    0x10(%ecx),%eax
  80b80e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b812:	89 04 24             	mov    %eax,(%esp)
  80b815:	e8 66 ef ff ff       	call   80a780 <ntohs>
  80b81a:	ba 00 00 00 00       	mov    $0x0,%edx
  80b81f:	a8 02                	test   $0x2,%al
  80b821:	74 05                	je     80b828 <tcp_enqueue+0x4e0>
  80b823:	ba 01 00 00 00       	mov    $0x1,%edx
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80b828:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  80b82c:	01 c2                	add    %eax,%edx
  80b82e:	0f 84 ee 01 00 00    	je     80ba22 <tcp_enqueue+0x6da>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  80b834:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b837:	8b 42 10             	mov    0x10(%edx),%eax
  80b83a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b83e:	89 04 24             	mov    %eax,(%esp)
  80b841:	e8 3a ef ff ff       	call   80a780 <ntohs>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80b846:	a8 03                	test   $0x3,%al
  80b848:	0f 85 d4 01 00 00    	jne    80ba22 <tcp_enqueue+0x6da>
  80b84e:	f6 45 af 03          	testb  $0x3,-0x51(%ebp)
  80b852:	0f 85 ca 01 00 00    	jne    80ba22 <tcp_enqueue+0x6da>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  80b858:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80b85b:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  80b85f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80b862:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80b866:	01 c2                	add    %eax,%edx
  80b868:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80b86c:	39 c2                	cmp    %eax,%edx
  80b86e:	0f 8f ae 01 00 00    	jg     80ba22 <tcp_enqueue+0x6da>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  80b874:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80b87b:	ff 
  80b87c:	8b 55 c8             	mov    -0x38(%ebp),%edx
  80b87f:	8b 42 04             	mov    0x4(%edx),%eax
  80b882:	89 04 24             	mov    %eax,(%esp)
  80b885:	e8 89 bd ff ff       	call   807613 <pbuf_header>
  80b88a:	84 c0                	test   %al,%al
  80b88c:	74 1c                	je     80b8aa <tcp_enqueue+0x562>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80b88e:	c7 44 24 08 64 3b 81 	movl   $0x813b64,0x8(%esp)
  80b895:	00 
  80b896:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  80b89d:	00 
  80b89e:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b8a5:	e8 6a 50 ff ff       	call   800914 <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  80b8aa:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80b8ad:	8b 41 04             	mov    0x4(%ecx),%eax
  80b8b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b8b4:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b8b7:	8b 42 04             	mov    0x4(%edx),%eax
  80b8ba:	89 04 24             	mov    %eax,(%esp)
  80b8bd:	e8 89 bc ff ff       	call   80754b <pbuf_cat>
    useg->len += queue->len;
  80b8c2:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80b8c5:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80b8c9:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b8cc:	66 01 42 0c          	add    %ax,0xc(%edx)
    useg->next = queue->next;
  80b8d0:	8b 01                	mov    (%ecx),%eax
  80b8d2:	89 02                	mov    %eax,(%edx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  80b8d4:	39 4d cc             	cmp    %ecx,-0x34(%ebp)
  80b8d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80b8dc:	0f 44 d8             	cmove  %eax,%ebx
      seg = NULL;
    }
    memp_free(MEMP_TCP_SEG, queue);
  80b8df:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80b8e3:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80b8ea:	e8 05 b9 ff ff       	call   8071f4 <memp_free>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80b8ef:	eb 06                	jmp    80b8f7 <tcp_enqueue+0x5af>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80b8f1:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80b8f4:	89 4f 74             	mov    %ecx,0x74(%edi)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80b8f7:	f6 45 af 02          	testb  $0x2,-0x51(%ebp)
  80b8fb:	75 0c                	jne    80b909 <tcp_enqueue+0x5c1>
  80b8fd:	f6 45 af 01          	testb  $0x1,-0x51(%ebp)
  80b901:	0f 85 28 01 00 00    	jne    80ba2f <tcp_enqueue+0x6e7>
  80b907:	eb 0f                	jmp    80b918 <tcp_enqueue+0x5d0>
    ++len;
  80b909:	66 83 45 b6 01       	addw   $0x1,-0x4a(%ebp)
  }
  if (flags & TCP_FIN) {
  80b90e:	f6 45 af 01          	testb  $0x1,-0x51(%ebp)
  80b912:	74 04                	je     80b918 <tcp_enqueue+0x5d0>
    pcb->flags |= TF_FIN;
  80b914:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  80b918:	0f b7 45 b6          	movzwl -0x4a(%ebp),%eax
  80b91c:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  80b91f:	0f b7 45 b6          	movzwl -0x4a(%ebp),%eax
  80b923:	66 29 47 6e          	sub    %ax,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80b927:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
  80b92b:	66 89 57 70          	mov    %dx,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  80b92f:	66 85 d2             	test   %dx,%dx
  80b932:	74 28                	je     80b95c <tcp_enqueue+0x614>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80b934:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b938:	75 22                	jne    80b95c <tcp_enqueue+0x614>
  80b93a:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b93e:	75 1c                	jne    80b95c <tcp_enqueue+0x614>
  80b940:	c7 44 24 08 08 3b 81 	movl   $0x813b08,0x8(%esp)
  80b947:	00 
  80b948:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  80b94f:	00 
  80b950:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b957:	e8 b8 4f ff ff       	call   800914 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  80b95c:	85 db                	test   %ebx,%ebx
  80b95e:	0f 84 b1 00 00 00    	je     80ba15 <tcp_enqueue+0x6cd>
  80b964:	66 85 f6             	test   %si,%si
  80b967:	0f 84 a8 00 00 00    	je     80ba15 <tcp_enqueue+0x6cd>
  80b96d:	8b 5b 10             	mov    0x10(%ebx),%ebx
  80b970:	85 db                	test   %ebx,%ebx
  80b972:	0f 84 9d 00 00 00    	je     80ba15 <tcp_enqueue+0x6cd>
  80b978:	f6 45 98 02          	testb  $0x2,-0x68(%ebp)
  80b97c:	0f 85 93 00 00 00    	jne    80ba15 <tcp_enqueue+0x6cd>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  80b982:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b986:	89 04 24             	mov    %eax,(%esp)
  80b989:	e8 f2 ed ff ff       	call   80a780 <ntohs>
  80b98e:	83 c8 08             	or     $0x8,%eax
  80b991:	0f b7 c0             	movzwl %ax,%eax
  80b994:	89 04 24             	mov    %eax,(%esp)
  80b997:	e8 d7 ed ff ff       	call   80a773 <htons>
  80b99c:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  80b9a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9a5:	eb 73                	jmp    80ba1a <tcp_enqueue+0x6d2>
  80b9a7:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b9aa:	eb 19                	jmp    80b9c5 <tcp_enqueue+0x67d>
  80b9ac:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b9af:	90                   	nop
  80b9b0:	eb 13                	jmp    80b9c5 <tcp_enqueue+0x67d>
  80b9b2:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b9b5:	eb 0e                	jmp    80b9c5 <tcp_enqueue+0x67d>
  80b9b7:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b9ba:	eb 09                	jmp    80b9c5 <tcp_enqueue+0x67d>
  80b9bc:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b9bf:	90                   	nop
  80b9c0:	eb 03                	jmp    80b9c5 <tcp_enqueue+0x67d>
  80b9c2:	8b 7d d0             	mov    -0x30(%ebp),%edi
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  80b9c5:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  80b9c9:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80b9cd:	74 0b                	je     80b9da <tcp_enqueue+0x692>
    tcp_segs_free(queue);
  80b9cf:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80b9d2:	89 0c 24             	mov    %ecx,(%esp)
  80b9d5:	e8 5c cb ff ff       	call   808536 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  80b9da:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80b9df:	74 2d                	je     80ba0e <tcp_enqueue+0x6c6>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80b9e1:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b9e5:	75 27                	jne    80ba0e <tcp_enqueue+0x6c6>
  80b9e7:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b9eb:	90                   	nop
  80b9ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80b9f0:	75 1c                	jne    80ba0e <tcp_enqueue+0x6c6>
  80b9f2:	c7 44 24 08 08 3b 81 	movl   $0x813b08,0x8(%esp)
  80b9f9:	00 
  80b9fa:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  80ba01:	00 
  80ba02:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80ba09:	e8 06 4f ff ff       	call   800914 <_panic>
  80ba0e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ba13:	eb 05                	jmp    80ba1a <tcp_enqueue+0x6d2>
  80ba15:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  80ba1a:	83 c4 6c             	add    $0x6c,%esp
  80ba1d:	5b                   	pop    %ebx
  80ba1e:	5e                   	pop    %esi
  80ba1f:	5f                   	pop    %edi
  80ba20:	5d                   	pop    %ebp
  80ba21:	c3                   	ret    
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  80ba22:	8b 55 c8             	mov    -0x38(%ebp),%edx
  80ba25:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ba28:	89 10                	mov    %edx,(%eax)
  80ba2a:	e9 c8 fe ff ff       	jmp    80b8f7 <tcp_enqueue+0x5af>
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    ++len;
  80ba2f:	66 83 45 b6 01       	addw   $0x1,-0x4a(%ebp)
  80ba34:	e9 db fe ff ff       	jmp    80b914 <tcp_enqueue+0x5cc>

0080ba39 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  80ba39:	55                   	push   %ebp
  80ba3a:	89 e5                	mov    %esp,%ebp
  80ba3c:	83 ec 28             	sub    $0x28,%esp
  80ba3f:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80ba42:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80ba45:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ba48:	0f b7 5d 10          	movzwl 0x10(%ebp),%ebx
  80ba4c:	0f b6 75 14          	movzbl 0x14(%ebp),%esi
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  80ba50:	8b 51 10             	mov    0x10(%ecx),%edx
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  80ba53:	83 fa 04             	cmp    $0x4,%edx
  80ba56:	74 14                	je     80ba6c <tcp_write+0x33>
  80ba58:	83 fa 07             	cmp    $0x7,%edx
  80ba5b:	74 0f                	je     80ba6c <tcp_write+0x33>
  80ba5d:	83 fa 02             	cmp    $0x2,%edx
  80ba60:	74 0a                	je     80ba6c <tcp_write+0x33>
  80ba62:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  80ba67:	83 fa 03             	cmp    $0x3,%edx
  80ba6a:	75 42                	jne    80baae <tcp_write+0x75>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  80ba6c:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba71:	66 85 db             	test   %bx,%bx
  80ba74:	74 38                	je     80baae <tcp_write+0x75>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  80ba76:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80ba7d:	00 
  80ba7e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80ba85:	00 
  80ba86:	81 e6 ff 00 00 00    	and    $0xff,%esi
  80ba8c:	89 74 24 10          	mov    %esi,0x10(%esp)
  80ba90:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80ba97:	00 
  80ba98:	0f b7 db             	movzwl %bx,%ebx
  80ba9b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80ba9f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80baa2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80baa6:	89 0c 24             	mov    %ecx,(%esp)
  80baa9:	e8 9a f8 ff ff       	call   80b348 <tcp_enqueue>
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  80baae:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80bab1:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80bab4:	89 ec                	mov    %ebp,%esp
  80bab6:	5d                   	pop    %ebp
  80bab7:	c3                   	ret    

0080bab8 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  80bab8:	55                   	push   %ebp
  80bab9:	89 e5                	mov    %esp,%ebp
  80babb:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  80babe:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80bac5:	00 
  80bac6:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80bacd:	00 
  80bace:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  80bad5:	00 
  80bad6:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80bada:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80bade:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bae5:	00 
  80bae6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80baed:	00 
  80baee:	8b 45 08             	mov    0x8(%ebp),%eax
  80baf1:	89 04 24             	mov    %eax,(%esp)
  80baf4:	e8 4f f8 ff ff       	call   80b348 <tcp_enqueue>
}
  80baf9:	c9                   	leave  
  80bafa:	c3                   	ret    
  80bafb:	00 00                	add    %al,(%eax)
  80bafd:	00 00                	add    %al,(%eax)
	...

0080bb00 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80bb00:	55                   	push   %ebp
  80bb01:	89 e5                	mov    %esp,%ebp
  80bb03:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  80bb06:	8b 15 e4 37 81 00    	mov    0x8137e4,%edx
  80bb0c:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  80bb0f:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  80bb15:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80bb19:	5d                   	pop    %ebp
  80bb1a:	c3                   	ret    

0080bb1b <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80bb1b:	55                   	push   %ebp
  80bb1c:	89 e5                	mov    %esp,%ebp
  80bb1e:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80bb21:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bb24:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  80bb27:	8b 55 10             	mov    0x10(%ebp),%edx
  80bb2a:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80bb2d:	5d                   	pop    %ebp
  80bb2e:	c3                   	ret    

0080bb2f <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  80bb2f:	55                   	push   %ebp
  80bb30:	89 e5                	mov    %esp,%ebp
  80bb32:	53                   	push   %ebx
  80bb33:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  80bb36:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80bb3d:	e8 f6 b6 ff ff       	call   807238 <memp_malloc>
  80bb42:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  80bb44:	85 c0                	test   %eax,%eax
  80bb46:	74 1c                	je     80bb64 <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  80bb48:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80bb4f:	00 
  80bb50:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bb57:	00 
  80bb58:	89 04 24             	mov    %eax,(%esp)
  80bb5b:	e8 36 57 ff ff       	call   801296 <memset>
    pcb->ttl = UDP_TTL;
  80bb60:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  80bb64:	89 d8                	mov    %ebx,%eax
  80bb66:	83 c4 14             	add    $0x14,%esp
  80bb69:	5b                   	pop    %ebx
  80bb6a:	5d                   	pop    %ebp
  80bb6b:	c3                   	ret    

0080bb6c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80bb6c:	55                   	push   %ebp
  80bb6d:	89 e5                	mov    %esp,%ebp
  80bb6f:	83 ec 18             	sub    $0x18,%esp
  80bb72:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  80bb75:	8b 15 24 f0 b3 00    	mov    0xb3f024,%edx
  80bb7b:	39 ca                	cmp    %ecx,%edx
  80bb7d:	74 06                	je     80bb85 <udp_remove+0x19>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80bb7f:	85 d2                	test   %edx,%edx
  80bb81:	75 0e                	jne    80bb91 <udp_remove+0x25>
  80bb83:	eb 21                	jmp    80bba6 <udp_remove+0x3a>

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  80bb85:	8b 42 0c             	mov    0xc(%edx),%eax
  80bb88:	a3 24 f0 b3 00       	mov    %eax,0xb3f024
  80bb8d:	eb 17                	jmp    80bba6 <udp_remove+0x3a>
  80bb8f:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80bb91:	8b 42 0c             	mov    0xc(%edx),%eax
  80bb94:	85 c0                	test   %eax,%eax
  80bb96:	74 0e                	je     80bba6 <udp_remove+0x3a>
  80bb98:	39 c1                	cmp    %eax,%ecx
  80bb9a:	75 f3                	jne    80bb8f <udp_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80bb9c:	8b 41 0c             	mov    0xc(%ecx),%eax
  80bb9f:	89 42 0c             	mov    %eax,0xc(%edx)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80bba2:	85 c0                	test   %eax,%eax
  80bba4:	75 e9                	jne    80bb8f <udp_remove+0x23>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  80bba6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80bbaa:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80bbb1:	e8 3e b6 ff ff       	call   8071f4 <memp_free>
}
  80bbb6:	c9                   	leave  
  80bbb7:	c3                   	ret    

0080bbb8 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80bbb8:	55                   	push   %ebp
  80bbb9:	89 e5                	mov    %esp,%ebp
  80bbbb:	57                   	push   %edi
  80bbbc:	56                   	push   %esi
  80bbbd:	53                   	push   %ebx
  80bbbe:	83 ec 1c             	sub    $0x1c,%esp
  80bbc1:	8b 55 08             	mov    0x8(%ebp),%edx
  80bbc4:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80bbc7:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bbcb:	a1 24 f0 b3 00       	mov    0xb3f024,%eax
  80bbd0:	b9 00 00 00 00       	mov    $0x0,%ecx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80bbd5:	bb 01 00 00 00       	mov    $0x1,%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bbda:	85 c0                	test   %eax,%eax
  80bbdc:	74 2d                	je     80bc0b <udp_bind+0x53>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  80bbde:	39 c2                	cmp    %eax,%edx
  80bbe0:	75 22                	jne    80bc04 <udp_bind+0x4c>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80bbe2:	84 c9                	test   %cl,%cl
  80bbe4:	74 1c                	je     80bc02 <udp_bind+0x4a>
  80bbe6:	c7 44 24 08 78 3b 81 	movl   $0x813b78,0x8(%esp)
  80bbed:	00 
  80bbee:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  80bbf5:	00 
  80bbf6:	c7 04 24 84 3b 81 00 	movl   $0x813b84,(%esp)
  80bbfd:	e8 12 4d ff ff       	call   800914 <_panic>
  80bc02:	89 d9                	mov    %ebx,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bc04:	8b 40 0c             	mov    0xc(%eax),%eax
  80bc07:	85 c0                	test   %eax,%eax
  80bc09:	75 d3                	jne    80bbde <udp_bind+0x26>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  80bc0b:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc10:	85 ff                	test   %edi,%edi
  80bc12:	74 02                	je     80bc16 <udp_bind+0x5e>
  80bc14:	8b 07                	mov    (%edi),%eax
  80bc16:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  80bc18:	66 85 f6             	test   %si,%si
  80bc1b:	75 39                	jne    80bc56 <udp_bind+0x9e>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  80bc1d:	8b 3d 24 f0 b3 00    	mov    0xb3f024,%edi
  80bc23:	89 f8                	mov    %edi,%eax
  80bc25:	be 00 10 00 00       	mov    $0x1000,%esi
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80bc2a:	eb 13                	jmp    80bc3f <udp_bind+0x87>
      if (ipcb->local_port == port) {
  80bc2c:	0f b7 58 12          	movzwl 0x12(%eax),%ebx
  80bc30:	66 39 f3             	cmp    %si,%bx
  80bc33:	75 07                	jne    80bc3c <udp_bind+0x84>
        /* port is already used by another udp_pcb */
        port++;
  80bc35:	8d 73 01             	lea    0x1(%ebx),%esi
  80bc38:	89 f8                	mov    %edi,%eax
  80bc3a:	eb 03                	jmp    80bc3f <udp_bind+0x87>
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  80bc3c:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80bc3f:	85 c0                	test   %eax,%eax
  80bc41:	0f 95 c3             	setne  %bl
  80bc44:	74 07                	je     80bc4d <udp_bind+0x95>
  80bc46:	66 81 fe ff 7f       	cmp    $0x7fff,%si
  80bc4b:	75 df                	jne    80bc2c <udp_bind+0x74>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  80bc4d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80bc52:	84 db                	test   %bl,%bl
  80bc54:	75 20                	jne    80bc76 <udp_bind+0xbe>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  80bc56:	66 89 72 12          	mov    %si,0x12(%edx)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  80bc5a:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc5f:	84 c9                	test   %cl,%cl
  80bc61:	75 13                	jne    80bc76 <udp_bind+0xbe>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  80bc63:	a1 24 f0 b3 00       	mov    0xb3f024,%eax
  80bc68:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  80bc6b:	89 15 24 f0 b3 00    	mov    %edx,0xb3f024
  80bc71:	b8 00 00 00 00       	mov    $0x0,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  80bc76:	83 c4 1c             	add    $0x1c,%esp
  80bc79:	5b                   	pop    %ebx
  80bc7a:	5e                   	pop    %esi
  80bc7b:	5f                   	pop    %edi
  80bc7c:	5d                   	pop    %ebp
  80bc7d:	c3                   	ret    

0080bc7e <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80bc7e:	55                   	push   %ebp
  80bc7f:	89 e5                	mov    %esp,%ebp
  80bc81:	57                   	push   %edi
  80bc82:	56                   	push   %esi
  80bc83:	53                   	push   %ebx
  80bc84:	83 ec 1c             	sub    $0x1c,%esp
  80bc87:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bc8a:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80bc8d:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  80bc91:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80bc96:	75 18                	jne    80bcb0 <udp_connect+0x32>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80bc98:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bc9f:	00 
  80bca0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80bca4:	89 1c 24             	mov    %ebx,(%esp)
  80bca7:	e8 0c ff ff ff       	call   80bbb8 <udp_bind>
    if (err != ERR_OK)
  80bcac:	84 c0                	test   %al,%al
  80bcae:	75 48                	jne    80bcf8 <udp_connect+0x7a>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  80bcb0:	b8 00 00 00 00       	mov    $0x0,%eax
  80bcb5:	85 ff                	test   %edi,%edi
  80bcb7:	74 02                	je     80bcbb <udp_connect+0x3d>
  80bcb9:	8b 07                	mov    (%edi),%eax
  80bcbb:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  80bcbe:	66 89 73 14          	mov    %si,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  80bcc2:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bcc6:	8b 15 24 f0 b3 00    	mov    0xb3f024,%edx
  80bccc:	85 d2                	test   %edx,%edx
  80bcce:	74 13                	je     80bce3 <udp_connect+0x65>
    if (pcb == ipcb) {
  80bcd0:	89 d0                	mov    %edx,%eax
  80bcd2:	39 d3                	cmp    %edx,%ebx
  80bcd4:	75 06                	jne    80bcdc <udp_connect+0x5e>
  80bcd6:	eb 1b                	jmp    80bcf3 <udp_connect+0x75>
  80bcd8:	39 c3                	cmp    %eax,%ebx
  80bcda:	74 17                	je     80bcf3 <udp_connect+0x75>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bcdc:	8b 40 0c             	mov    0xc(%eax),%eax
  80bcdf:	85 c0                	test   %eax,%eax
  80bce1:	75 f5                	jne    80bcd8 <udp_connect+0x5a>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80bce3:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80bce6:	89 1d 24 f0 b3 00    	mov    %ebx,0xb3f024
  80bcec:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
  80bcf1:	eb 05                	jmp    80bcf8 <udp_connect+0x7a>
  80bcf3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80bcf8:	83 c4 1c             	add    $0x1c,%esp
  80bcfb:	5b                   	pop    %ebx
  80bcfc:	5e                   	pop    %esi
  80bcfd:	5f                   	pop    %edi
  80bcfe:	5d                   	pop    %ebp
  80bcff:	c3                   	ret    

0080bd00 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  80bd00:	55                   	push   %ebp
  80bd01:	89 e5                	mov    %esp,%ebp
  80bd03:	57                   	push   %edi
  80bd04:	56                   	push   %esi
  80bd05:	53                   	push   %ebx
  80bd06:	83 ec 3c             	sub    $0x3c,%esp
  80bd09:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bd0c:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  80bd10:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  80bd14:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80bd19:	75 1e                	jne    80bd39 <udp_sendto_if+0x39>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80bd1b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bd22:	00 
  80bd23:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80bd27:	89 1c 24             	mov    %ebx,(%esp)
  80bd2a:	e8 89 fe ff ff       	call   80bbb8 <udp_bind>
  80bd2f:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  80bd31:	84 c0                	test   %al,%al
  80bd33:	0f 85 6b 01 00 00    	jne    80bea4 <udp_sendto_if+0x1a4>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  80bd39:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80bd40:	00 
  80bd41:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bd44:	89 14 24             	mov    %edx,(%esp)
  80bd47:	e8 c7 b8 ff ff       	call   807613 <pbuf_header>
  80bd4c:	84 c0                	test   %al,%al
  80bd4e:	75 05                	jne    80bd55 <udp_sendto_if+0x55>
  80bd50:	8b 75 0c             	mov    0xc(%ebp),%esi
  80bd53:	eb 3a                	jmp    80bd8f <udp_sendto_if+0x8f>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  80bd55:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bd5c:	00 
  80bd5d:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80bd64:	00 
  80bd65:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80bd6c:	e8 c8 be ff ff       	call   807c39 <pbuf_alloc>
  80bd71:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80bd73:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80bd78:	85 c0                	test   %eax,%eax
  80bd7a:	0f 84 24 01 00 00    	je     80bea4 <udp_sendto_if+0x1a4>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80bd80:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bd83:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bd87:	89 34 24             	mov    %esi,(%esp)
  80bd8a:	e8 5d b8 ff ff       	call   8075ec <pbuf_chain>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  80bd8f:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  80bd94:	77 1c                	ja     80bdb2 <udp_sendto_if+0xb2>
  80bd96:	c7 44 24 08 ac 3b 81 	movl   $0x813bac,0x8(%esp)
  80bd9d:	00 
  80bd9e:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80bda5:	00 
  80bda6:	c7 04 24 84 3b 81 00 	movl   $0x813b84,(%esp)
  80bdad:	e8 62 4b ff ff       	call   800914 <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  80bdb2:	8b 7e 04             	mov    0x4(%esi),%edi
  udphdr->src = htons(pcb->local_port);
  80bdb5:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  80bdb9:	89 04 24             	mov    %eax,(%esp)
  80bdbc:	e8 b2 e9 ff ff       	call   80a773 <htons>
  80bdc1:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  80bdc4:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80bdc8:	89 04 24             	mov    %eax,(%esp)
  80bdcb:	e8 a3 e9 ff ff       	call   80a773 <htons>
  80bdd0:	66 89 47 02          	mov    %ax,0x2(%edi)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  80bdd4:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80bdda:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80bddd:	85 db                	test   %ebx,%ebx
  80bddf:	74 06                	je     80bde7 <udp_sendto_if+0xe7>
  80bde1:	8b 03                	mov    (%ebx),%eax
  80bde3:	85 c0                	test   %eax,%eax
  80bde5:	75 0b                	jne    80bdf2 <udp_sendto_if+0xf2>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80bde7:	8b 55 18             	mov    0x18(%ebp),%edx
  80bdea:	83 c2 04             	add    $0x4,%edx
  80bded:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  udphdr->dest = htons(dst_port);
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80bdf0:	eb 23                	jmp    80be15 <udp_sendto_if+0x115>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80bdf2:	8b 55 18             	mov    0x18(%ebp),%edx
  80bdf5:	3b 42 04             	cmp    0x4(%edx),%eax
  80bdf8:	74 1b                	je     80be15 <udp_sendto_if+0x115>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  80bdfa:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
  80bdff:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80be02:	0f 84 9c 00 00 00    	je     80bea4 <udp_sendto_if+0x1a4>
        /* free the header pbuf */
        pbuf_free(q);
  80be08:	89 34 24             	mov    %esi,(%esp)
  80be0b:	e8 6d bb ff ff       	call   80797d <pbuf_free>
  80be10:	e9 8f 00 00 00       	jmp    80bea4 <udp_sendto_if+0x1a4>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  80be15:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80be19:	89 04 24             	mov    %eax,(%esp)
  80be1c:	e8 52 e9 ff ff       	call   80a773 <htons>
  80be21:	66 89 47 04          	mov    %ax,0x4(%edi)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  80be25:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  80be29:	75 35                	jne    80be60 <udp_sendto_if+0x160>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80be2b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80be2f:	89 44 24 10          	mov    %eax,0x10(%esp)
  80be33:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80be3a:	00 
  80be3b:	8b 45 10             	mov    0x10(%ebp),%eax
  80be3e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80be42:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80be45:	89 54 24 04          	mov    %edx,0x4(%esp)
  80be49:	89 34 24             	mov    %esi,(%esp)
  80be4c:	e8 1f e6 ff ff       	call   80a470 <inet_chksum_pseudo>
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  80be51:	66 85 c0             	test   %ax,%ax
  80be54:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80be59:	0f 44 c2             	cmove  %edx,%eax
  80be5c:	66 89 47 06          	mov    %ax,0x6(%edi)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  80be60:	8b 45 18             	mov    0x18(%ebp),%eax
  80be63:	89 44 24 18          	mov    %eax,0x18(%esp)
  80be67:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  80be6e:	00 
  80be6f:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80be73:	89 44 24 10          	mov    %eax,0x10(%esp)
  80be77:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80be7b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80be7f:	8b 55 10             	mov    0x10(%ebp),%edx
  80be82:	89 54 24 08          	mov    %edx,0x8(%esp)
  80be86:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80be89:	89 44 24 04          	mov    %eax,0x4(%esp)
  80be8d:	89 34 24             	mov    %esi,(%esp)
  80be90:	e8 1b d5 ff ff       	call   8093b0 <ip_output_if>
  80be95:	89 c7                	mov    %eax,%edi
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  80be97:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80be9a:	74 08                	je     80bea4 <udp_sendto_if+0x1a4>
    /* free the header pbuf */
    pbuf_free(q);
  80be9c:	89 34 24             	mov    %esi,(%esp)
  80be9f:	e8 d9 ba ff ff       	call   80797d <pbuf_free>
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  80bea4:	89 f8                	mov    %edi,%eax
  80bea6:	83 c4 3c             	add    $0x3c,%esp
  80bea9:	5b                   	pop    %ebx
  80beaa:	5e                   	pop    %esi
  80beab:	5f                   	pop    %edi
  80beac:	5d                   	pop    %ebp
  80bead:	c3                   	ret    

0080beae <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  80beae:	55                   	push   %ebp
  80beaf:	89 e5                	mov    %esp,%ebp
  80beb1:	83 ec 28             	sub    $0x28,%esp
  80beb4:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80beb7:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80beba:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80bebd:	0f b7 75 14          	movzwl 0x14(%ebp),%esi

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  80bec1:	89 1c 24             	mov    %ebx,(%esp)
  80bec4:	e8 98 d6 ff ff       	call   809561 <ip_route>
  80bec9:	89 c2                	mov    %eax,%edx
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  80becb:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80bed0:	85 d2                	test   %edx,%edx
  80bed2:	74 21                	je     80bef5 <udp_sendto+0x47>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80bed4:	89 54 24 10          	mov    %edx,0x10(%esp)
  80bed8:	0f b7 f6             	movzwl %si,%esi
  80bedb:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80bedf:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80bee3:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bee6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80beea:	8b 45 08             	mov    0x8(%ebp),%eax
  80beed:	89 04 24             	mov    %eax,(%esp)
  80bef0:	e8 0b fe ff ff       	call   80bd00 <udp_sendto_if>
}
  80bef5:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80bef8:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80befb:	89 ec                	mov    %ebp,%esp
  80befd:	5d                   	pop    %ebp
  80befe:	c3                   	ret    

0080beff <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  80beff:	55                   	push   %ebp
  80bf00:	89 e5                	mov    %esp,%ebp
  80bf02:	83 ec 18             	sub    $0x18,%esp
  80bf05:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  80bf08:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  80bf0c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80bf10:	8d 50 04             	lea    0x4(%eax),%edx
  80bf13:	89 54 24 08          	mov    %edx,0x8(%esp)
  80bf17:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bf1a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80bf1e:	89 04 24             	mov    %eax,(%esp)
  80bf21:	e8 88 ff ff ff       	call   80beae <udp_sendto>
}
  80bf26:	c9                   	leave  
  80bf27:	c3                   	ret    

0080bf28 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  80bf28:	55                   	push   %ebp
  80bf29:	89 e5                	mov    %esp,%ebp
  80bf2b:	57                   	push   %edi
  80bf2c:	56                   	push   %esi
  80bf2d:	53                   	push   %ebx
  80bf2e:	83 ec 4c             	sub    $0x4c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  80bf31:	8b 45 08             	mov    0x8(%ebp),%eax
  80bf34:	8b 40 04             	mov    0x4(%eax),%eax
  80bf37:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  80bf3a:	8b 55 08             	mov    0x8(%ebp),%edx
  80bf3d:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  80bf41:	0f b7 00             	movzwl (%eax),%eax
  80bf44:	89 04 24             	mov    %eax,(%esp)
  80bf47:	e8 34 e8 ff ff       	call   80a780 <ntohs>
  80bf4c:	0f b6 c4             	movzbl %ah,%eax
  80bf4f:	83 e0 0f             	and    $0xf,%eax
  80bf52:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80bf59:	39 c3                	cmp    %eax,%ebx
  80bf5b:	7c 2b                	jl     80bf88 <udp_input+0x60>
  80bf5d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80bf60:	0f b7 02             	movzwl (%edx),%eax
  80bf63:	89 04 24             	mov    %eax,(%esp)
  80bf66:	e8 15 e8 ff ff       	call   80a780 <ntohs>
  80bf6b:	66 c1 e8 06          	shr    $0x6,%ax
  80bf6f:	83 e0 3c             	and    $0x3c,%eax
  80bf72:	f7 d8                	neg    %eax
  80bf74:	98                   	cwtl   
  80bf75:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bf79:	8b 45 08             	mov    0x8(%ebp),%eax
  80bf7c:	89 04 24             	mov    %eax,(%esp)
  80bf7f:	e8 8f b6 ff ff       	call   807613 <pbuf_header>
  80bf84:	84 c0                	test   %al,%al
  80bf86:	74 10                	je     80bf98 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  80bf88:	8b 55 08             	mov    0x8(%ebp),%edx
  80bf8b:	89 14 24             	mov    %edx,(%esp)
  80bf8e:	e8 ea b9 ff ff       	call   80797d <pbuf_free>
    goto end;
  80bf93:	e9 f1 02 00 00       	jmp    80c289 <udp_input+0x361>
  }

  udphdr = (struct udp_hdr *)p->payload;
  80bf98:	8b 45 08             	mov    0x8(%ebp),%eax
  80bf9b:	8b 40 04             	mov    0x4(%eax),%eax
  80bf9e:	89 45 d8             	mov    %eax,-0x28(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80bfa1:	0f b7 00             	movzwl (%eax),%eax
  80bfa4:	89 04 24             	mov    %eax,(%esp)
  80bfa7:	e8 d4 e7 ff ff       	call   80a780 <ntohs>
  80bfac:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  dest = ntohs(udphdr->dest);
  80bfb0:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80bfb3:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80bfb7:	89 04 24             	mov    %eax,(%esp)
  80bfba:	e8 c1 e7 ff ff       	call   80a780 <ntohs>
  80bfbf:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  80bfc1:	66 83 f8 44          	cmp    $0x44,%ax
  80bfc5:	75 49                	jne    80c010 <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  80bfc7:	66 83 7d de 43       	cmpw   $0x43,-0x22(%ebp)
  80bfcc:	0f 85 f9 00 00 00    	jne    80c0cb <udp_input+0x1a3>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80bfd2:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bfd5:	8b 42 20             	mov    0x20(%edx),%eax
  80bfd8:	85 c0                	test   %eax,%eax
  80bfda:	0f 84 eb 00 00 00    	je     80c0cb <udp_input+0x1a3>
  80bfe0:	8b 58 08             	mov    0x8(%eax),%ebx
  80bfe3:	85 db                	test   %ebx,%ebx
  80bfe5:	0f 84 e5 00 00 00    	je     80c0d0 <udp_input+0x1a8>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80bfeb:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80bfee:	0f 84 ee 00 00 00    	je     80c0e2 <udp_input+0x1ba>
  80bff4:	8b 43 04             	mov    0x4(%ebx),%eax
  80bff7:	85 c0                	test   %eax,%eax
  80bff9:	0f 84 e3 00 00 00    	je     80c0e2 <udp_input+0x1ba>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  80bfff:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c002:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c005:	0f 85 c0 00 00 00    	jne    80c0cb <udp_input+0x1a3>
  80c00b:	e9 d2 00 00 00       	jmp    80c0e2 <udp_input+0x1ba>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c010:	8b 1d 24 f0 b3 00    	mov    0xb3f024,%ebx
  80c016:	85 db                	test   %ebx,%ebx
  80c018:	0f 84 5f 02 00 00    	je     80c27d <udp_input+0x355>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80c01e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c021:	83 c0 10             	add    $0x10,%eax
  80c024:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80c027:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80c02e:	bf 00 00 00 00       	mov    $0x0,%edi
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c033:	66 3b 73 12          	cmp    0x12(%ebx),%si
  80c037:	75 75                	jne    80c0ae <udp_input+0x186>
          (ip_addr_isany(&pcb->local_ip) ||
  80c039:	85 db                	test   %ebx,%ebx
  80c03b:	74 24                	je     80c061 <udp_input+0x139>
  80c03d:	8b 03                	mov    (%ebx),%eax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c03f:	85 c0                	test   %eax,%eax
  80c041:	74 1e                	je     80c061 <udp_input+0x139>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  80c043:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c046:	3b 42 10             	cmp    0x10(%edx),%eax
  80c049:	74 16                	je     80c061 <udp_input+0x139>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80c04b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c04e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c052:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80c055:	89 14 24             	mov    %edx,(%esp)
  80c058:	e8 0b d3 ff ff       	call   809368 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c05d:	84 c0                	test   %al,%al
  80c05f:	74 4d                	je     80c0ae <udp_input+0x186>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  80c061:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80c065:	0f 85 fe 01 00 00    	jne    80c269 <udp_input+0x341>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80c06b:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  80c06f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80c072:	0f 44 c3             	cmove  %ebx,%eax
  80c075:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80c078:	e9 ec 01 00 00       	jmp    80c269 <udp_input+0x341>
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  80c07d:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80c080:	74 0f                	je     80c091 <udp_input+0x169>
  80c082:	8b 43 04             	mov    0x4(%ebx),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80c085:	85 c0                	test   %eax,%eax
  80c087:	74 08                	je     80c091 <udp_input+0x169>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  80c089:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c08c:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c08f:	75 1d                	jne    80c0ae <udp_input+0x186>
  80c091:	89 d8                	mov    %ebx,%eax
        /* the first fully matching PCB */
        if (prev != NULL) {
  80c093:	85 ff                	test   %edi,%edi
  80c095:	74 27                	je     80c0be <udp_input+0x196>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  80c097:	8b 53 0c             	mov    0xc(%ebx),%edx
  80c09a:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  80c09d:	8b 15 24 f0 b3 00    	mov    0xb3f024,%edx
  80c0a3:	89 53 0c             	mov    %edx,0xc(%ebx)
          udp_pcbs = pcb;
  80c0a6:	89 1d 24 f0 b3 00    	mov    %ebx,0xb3f024
  80c0ac:	eb 10                	jmp    80c0be <udp_input+0x196>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c0ae:	8b 43 0c             	mov    0xc(%ebx),%eax
  80c0b1:	85 c0                	test   %eax,%eax
  80c0b3:	74 0d                	je     80c0c2 <udp_input+0x19a>
  80c0b5:	89 df                	mov    %ebx,%edi
  80c0b7:	89 c3                	mov    %eax,%ebx
  80c0b9:	e9 75 ff ff ff       	jmp    80c033 <udp_input+0x10b>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  80c0be:	85 c0                	test   %eax,%eax
  80c0c0:	75 20                	jne    80c0e2 <udp_input+0x1ba>
  80c0c2:	8b 5d e0             	mov    -0x20(%ebp),%ebx
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80c0c5:	85 db                	test   %ebx,%ebx
  80c0c7:	75 19                	jne    80c0e2 <udp_input+0x1ba>
  80c0c9:	eb 05                	jmp    80c0d0 <udp_input+0x1a8>
  80c0cb:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c0d0:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c0d3:	8b 42 04             	mov    0x4(%edx),%eax
  80c0d6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c0d9:	3b 42 10             	cmp    0x10(%edx),%eax
  80c0dc:	0f 85 7a 01 00 00    	jne    80c25c <udp_input+0x334>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  80c0e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80c0e5:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80c0ea:	74 44                	je     80c130 <udp_input+0x208>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80c0ec:	8b 55 08             	mov    0x8(%ebp),%edx
  80c0ef:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80c0f3:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c0f7:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80c0fe:	00 
  80c0ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c102:	83 c0 10             	add    $0x10,%eax
  80c105:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c109:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c10c:	83 c0 0c             	add    $0xc,%eax
  80c10f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c113:	89 14 24             	mov    %edx,(%esp)
  80c116:	e8 55 e3 ff ff       	call   80a470 <inet_chksum_pseudo>
  80c11b:	66 85 c0             	test   %ax,%ax
  80c11e:	74 10                	je     80c130 <udp_input+0x208>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  80c120:	8b 45 08             	mov    0x8(%ebp),%eax
  80c123:	89 04 24             	mov    %eax,(%esp)
  80c126:	e8 52 b8 ff ff       	call   80797d <pbuf_free>
          goto end;
  80c12b:	e9 59 01 00 00       	jmp    80c289 <udp_input+0x361>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  80c130:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  80c137:	ff 
  80c138:	8b 55 08             	mov    0x8(%ebp),%edx
  80c13b:	89 14 24             	mov    %edx,(%esp)
  80c13e:	e8 d0 b4 ff ff       	call   807613 <pbuf_header>
  80c143:	84 c0                	test   %al,%al
  80c145:	74 1c                	je     80c163 <udp_input+0x23b>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80c147:	c7 44 24 08 64 3b 81 	movl   $0x813b64,0x8(%esp)
  80c14e:	00 
  80c14f:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80c156:	00 
  80c157:	c7 04 24 84 3b 81 00 	movl   $0x813b84,(%esp)
  80c15e:	e8 b1 47 ff ff       	call   800914 <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  80c163:	85 db                	test   %ebx,%ebx
  80c165:	74 41                	je     80c1a8 <udp_input+0x280>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  80c167:	8b 43 18             	mov    0x18(%ebx),%eax
  80c16a:	85 c0                	test   %eax,%eax
  80c16c:	74 2a                	je     80c198 <udp_input+0x270>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  80c16e:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  80c172:	89 54 24 10          	mov    %edx,0x10(%esp)
  80c176:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c179:	83 c2 0c             	add    $0xc,%edx
  80c17c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80c180:	8b 55 08             	mov    0x8(%ebp),%edx
  80c183:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c187:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c18b:	8b 53 1c             	mov    0x1c(%ebx),%edx
  80c18e:	89 14 24             	mov    %edx,(%esp)
  80c191:	ff d0                	call   *%eax
  80c193:	e9 f1 00 00 00       	jmp    80c289 <udp_input+0x361>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  80c198:	8b 45 08             	mov    0x8(%ebp),%eax
  80c19b:	89 04 24             	mov    %eax,(%esp)
  80c19e:	e8 da b7 ff ff       	call   80797d <pbuf_free>
        goto end;
  80c1a3:	e9 e1 00 00 00       	jmp    80c289 <udp_input+0x361>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80c1a8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c1ab:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c1af:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c1b2:	83 c0 10             	add    $0x10,%eax
  80c1b5:	89 04 24             	mov    %eax,(%esp)
  80c1b8:	e8 ab d1 ff ff       	call   809368 <ip_addr_isbroadcast>
  80c1bd:	84 c0                	test   %al,%al
  80c1bf:	0f 85 8a 00 00 00    	jne    80c24f <udp_input+0x327>
          !ip_addr_ismulticast(&iphdr->dest)) {
  80c1c5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c1c8:	8b 70 10             	mov    0x10(%eax),%esi
  80c1cb:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80c1d2:	e8 de e7 ff ff       	call   80a9b5 <ntohl>
  80c1d7:	89 c3                	mov    %eax,%ebx
  80c1d9:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c1e0:	e8 d0 e7 ff ff       	call   80a9b5 <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80c1e5:	21 f3                	and    %esi,%ebx
  80c1e7:	39 c3                	cmp    %eax,%ebx
  80c1e9:	74 64                	je     80c24f <udp_input+0x327>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  80c1eb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c1ee:	0f b7 02             	movzwl (%edx),%eax
  80c1f1:	89 04 24             	mov    %eax,(%esp)
  80c1f4:	e8 87 e5 ff ff       	call   80a780 <ntohs>
  80c1f9:	0f b6 c4             	movzbl %ah,%eax
  80c1fc:	83 e0 0f             	and    $0xf,%eax
  80c1ff:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80c206:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c20a:	8b 45 08             	mov    0x8(%ebp),%eax
  80c20d:	89 04 24             	mov    %eax,(%esp)
  80c210:	e8 fe b3 ff ff       	call   807613 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  80c215:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c218:	8b 55 08             	mov    0x8(%ebp),%edx
  80c21b:	39 42 04             	cmp    %eax,0x4(%edx)
  80c21e:	74 1c                	je     80c23c <udp_input+0x314>
  80c220:	c7 44 24 08 98 3b 81 	movl   $0x813b98,0x8(%esp)
  80c227:	00 
  80c228:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  80c22f:	00 
  80c230:	c7 04 24 84 3b 81 00 	movl   $0x813b84,(%esp)
  80c237:	e8 d8 46 ff ff       	call   800914 <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  80c23c:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80c243:	00 
  80c244:	8b 55 08             	mov    0x8(%ebp),%edx
  80c247:	89 14 24             	mov    %edx,(%esp)
  80c24a:	e8 e3 55 00 00       	call   811832 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  80c24f:	8b 45 08             	mov    0x8(%ebp),%eax
  80c252:	89 04 24             	mov    %eax,(%esp)
  80c255:	e8 23 b7 ff ff       	call   80797d <pbuf_free>
  80c25a:	eb 2d                	jmp    80c289 <udp_input+0x361>
    }
  } else {
    pbuf_free(p);
  80c25c:	8b 55 08             	mov    0x8(%ebp),%edx
  80c25f:	89 14 24             	mov    %edx,(%esp)
  80c262:	e8 16 b7 ff ff       	call   80797d <pbuf_free>
  80c267:	eb 20                	jmp    80c289 <udp_input+0x361>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  80c269:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  80c26d:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  80c271:	0f 85 37 fe ff ff    	jne    80c0ae <udp_input+0x186>
  80c277:	90                   	nop
  80c278:	e9 00 fe ff ff       	jmp    80c07d <udp_input+0x155>
  80c27d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80c284:	e9 39 fe ff ff       	jmp    80c0c2 <udp_input+0x19a>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80c289:	83 c4 4c             	add    $0x4c,%esp
  80c28c:	5b                   	pop    %ebx
  80c28d:	5e                   	pop    %esi
  80c28e:	5f                   	pop    %edi
  80c28f:	5d                   	pop    %ebp
  80c290:	c3                   	ret    
	...

0080c2a0 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  80c2a0:	55                   	push   %ebp
  80c2a1:	89 e5                	mov    %esp,%ebp
  80c2a3:	57                   	push   %edi
  80c2a4:	56                   	push   %esi
  80c2a5:	53                   	push   %ebx
  80c2a6:	83 ec 2c             	sub    $0x2c,%esp
  80c2a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c2ac:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80c2af:	89 ce                	mov    %ecx,%esi
  80c2b1:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  80c2b4:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c2b7:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80c2bb:	74 1c                	je     80c2d9 <etharp_send_ip+0x39>
  80c2bd:	c7 44 24 08 dc 3b 81 	movl   $0x813bdc,0x8(%esp)
  80c2c4:	00 
  80c2c5:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  80c2cc:	00 
  80c2cd:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c2d4:	e8 3b 46 ff ff       	call   800914 <_panic>
  80c2d9:	ba 06 00 00 00       	mov    $0x6,%edx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  80c2de:	83 ea 01             	sub    $0x1,%edx
    ethhdr->dest.addr[k] = dst->addr[k];
  80c2e1:	0f b6 c2             	movzbl %dl,%eax
  80c2e4:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80c2e8:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80c2eb:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c2ef:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  80c2f3:	84 d2                	test   %dl,%dl
  80c2f5:	75 e7                	jne    80c2de <etharp_send_ip+0x3e>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80c2f7:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c2fe:	e8 70 e4 ff ff       	call   80a773 <htons>
  80c303:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  80c307:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80c30a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c30e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c311:	89 14 24             	mov    %edx,(%esp)
  80c314:	ff 52 18             	call   *0x18(%edx)
}
  80c317:	83 c4 2c             	add    $0x2c,%esp
  80c31a:	5b                   	pop    %ebx
  80c31b:	5e                   	pop    %esi
  80c31c:	5f                   	pop    %edi
  80c31d:	5d                   	pop    %ebp
  80c31e:	c3                   	ret    

0080c31f <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80c31f:	55                   	push   %ebp
  80c320:	89 e5                	mov    %esp,%ebp
  80c322:	57                   	push   %edi
  80c323:	56                   	push   %esi
  80c324:	53                   	push   %ebx
  80c325:	83 ec 3c             	sub    $0x3c,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  80c328:	8b 75 08             	mov    0x8(%ebp),%esi
  80c32b:	83 c6 25             	add    $0x25,%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80c32e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c335:	00 
  80c336:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  80c33d:	00 
  80c33e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80c345:	e8 ef b8 ff ff       	call   807c39 <pbuf_alloc>
  80c34a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  80c34d:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80c352:	85 c0                	test   %eax,%eax
  80c354:	0f 84 02 01 00 00    	je     80c45c <etharp_request+0x13d>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80c35a:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  80c35f:	77 1c                	ja     80c37d <etharp_request+0x5e>
  80c361:	c7 44 24 08 20 3c 81 	movl   $0x813c20,0x8(%esp)
  80c368:	00 
  80c369:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  80c370:	00 
  80c371:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c378:	e8 97 45 ff ff       	call   800914 <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  80c37d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c380:	8b 5a 04             	mov    0x4(%edx),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80c383:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c38a:	e8 e4 e3 ff ff       	call   80a773 <htons>
  80c38f:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c393:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80c396:	80 79 24 06          	cmpb   $0x6,0x24(%ecx)
  80c39a:	74 1c                	je     80c3b8 <etharp_request+0x99>
  80c39c:	c7 44 24 08 dc 3b 81 	movl   $0x813bdc,0x8(%esp)
  80c3a3:	00 
  80c3a4:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  80c3ab:	00 
  80c3ac:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c3b3:	e8 5c 45 ff ff       	call   800914 <_panic>
  80c3b8:	ba 06 00 00 00       	mov    $0x6,%edx
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c3bd:	bf 41 3d 81 00       	mov    $0x813d41,%edi
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80c3c2:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80c3c5:	0f b6 c2             	movzbl %dl,%eax
  80c3c8:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c3cc:	88 4c 18 16          	mov    %cl,0x16(%eax,%ebx,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c3d0:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80c3d4:	88 4c 18 20          	mov    %cl,0x20(%eax,%ebx,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80c3d8:	0f b6 88 3b 3d 81 00 	movzbl 0x813d3b(%eax),%ecx
  80c3df:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80c3e2:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c3e6:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  80c3ea:	84 d2                	test   %dl,%dl
  80c3ec:	75 d4                	jne    80c3c2 <etharp_request+0xa3>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80c3ee:	8b 55 08             	mov    0x8(%ebp),%edx
  80c3f1:	8b 42 04             	mov    0x4(%edx),%eax
  80c3f4:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80c3f7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c3fa:	8b 00                	mov    (%eax),%eax
  80c3fc:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80c3ff:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c406:	e8 68 e3 ff ff       	call   80a773 <htons>
  80c40b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80c40f:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c416:	e8 58 e3 ff ff       	call   80a773 <htons>
  80c41b:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80c41f:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80c426:	e8 48 e3 ff ff       	call   80a773 <htons>
  80c42b:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80c42f:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80c436:	e8 38 e3 ff ff       	call   80a773 <htons>
  80c43b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80c43f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80c442:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80c446:	8b 45 08             	mov    0x8(%ebp),%eax
  80c449:	89 04 24             	mov    %eax,(%esp)
  80c44c:	ff 50 18             	call   *0x18(%eax)
  80c44f:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80c451:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80c454:	89 0c 24             	mov    %ecx,(%esp)
  80c457:	e8 21 b5 ff ff       	call   80797d <pbuf_free>
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80c45c:	89 d8                	mov    %ebx,%eax
  80c45e:	83 c4 3c             	add    $0x3c,%esp
  80c461:	5b                   	pop    %ebx
  80c462:	5e                   	pop    %esi
  80c463:	5f                   	pop    %edi
  80c464:	5d                   	pop    %ebp
  80c465:	c3                   	ret    

0080c466 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  80c466:	55                   	push   %ebp
  80c467:	89 e5                	mov    %esp,%ebp
  80c469:	56                   	push   %esi
  80c46a:	53                   	push   %ebx
  80c46b:	83 ec 10             	sub    $0x10,%esp
  80c46e:	89 c6                	mov    %eax,%esi
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  80c470:	85 c0                	test   %eax,%eax
  80c472:	75 1c                	jne    80c490 <free_etharp_q+0x2a>
  80c474:	c7 44 24 08 8f 34 81 	movl   $0x81348f,0x8(%esp)
  80c47b:	00 
  80c47c:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  80c483:	00 
  80c484:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c48b:	e8 84 44 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80c490:	8b 40 04             	mov    0x4(%eax),%eax
  80c493:	85 c0                	test   %eax,%eax
  80c495:	74 04                	je     80c49b <free_etharp_q+0x35>
  while (q) {
    r = q;
    q = q->next;
  80c497:	8b 1e                	mov    (%esi),%ebx
  80c499:	eb 45                	jmp    80c4e0 <free_etharp_q+0x7a>
static void
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80c49b:	c7 44 24 08 dd 3c 81 	movl   $0x813cdd,0x8(%esp)
  80c4a2:	00 
  80c4a3:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  80c4aa:	00 
  80c4ab:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c4b2:	e8 5d 44 ff ff       	call   800914 <_panic>
  while (q) {
    r = q;
    q = q->next;
  80c4b7:	8b 13                	mov    (%ebx),%edx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80c4b9:	8b 43 04             	mov    0x4(%ebx),%eax
  80c4bc:	85 c0                	test   %eax,%eax
  80c4be:	75 1c                	jne    80c4dc <free_etharp_q+0x76>
  80c4c0:	c7 44 24 08 ea 3c 81 	movl   $0x813cea,0x8(%esp)
  80c4c7:	00 
  80c4c8:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80c4cf:	00 
  80c4d0:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c4d7:	e8 38 44 ff ff       	call   800914 <_panic>
  80c4dc:	89 de                	mov    %ebx,%esi
  80c4de:	89 d3                	mov    %edx,%ebx
    pbuf_free(r->p);
  80c4e0:	89 04 24             	mov    %eax,(%esp)
  80c4e3:	e8 95 b4 ff ff       	call   80797d <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80c4e8:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c4ec:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80c4f3:	e8 fc ac ff ff       	call   8071f4 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  80c4f8:	85 db                	test   %ebx,%ebx
  80c4fa:	75 bb                	jne    80c4b7 <free_etharp_q+0x51>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  80c4fc:	83 c4 10             	add    $0x10,%esp
  80c4ff:	5b                   	pop    %ebx
  80c500:	5e                   	pop    %esi
  80c501:	5d                   	pop    %ebp
  80c502:	c3                   	ret    

0080c503 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80c503:	55                   	push   %ebp
  80c504:	89 e5                	mov    %esp,%ebp
  80c506:	57                   	push   %edi
  80c507:	56                   	push   %esi
  80c508:	53                   	push   %ebx
  80c509:	83 ec 3c             	sub    $0x3c,%esp
  80c50c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80c50f:	88 55 dd             	mov    %dl,-0x23(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  80c512:	85 c0                	test   %eax,%eax
  80c514:	74 16                	je     80c52c <find_entry+0x29>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80c516:	0f b6 05 78 5b b3 00 	movzbl 0xb35b78,%eax
  80c51d:	0f b6 d0             	movzbl %al,%edx
  80c520:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80c523:	83 b9 70 5a b3 00 02 	cmpl   $0x2,0xb35a70(%ecx)
  80c52a:	74 2a                	je     80c556 <find_entry+0x53>
  80c52c:	ba 74 5a b3 00       	mov    $0xb35a74,%edx
  80c531:	be 00 00 00 00       	mov    $0x0,%esi
  80c536:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  80c53a:	bf 00 00 00 00       	mov    $0x0,%edi
  80c53f:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80c543:	b8 00 00 00 00       	mov    $0x0,%eax
  80c548:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80c54c:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  80c550:	c6 45 dc 0a          	movb   $0xa,-0x24(%ebp)
  80c554:	eb 22                	jmp    80c578 <find_entry+0x75>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80c556:	6b d2 1c             	imul   $0x1c,%edx,%edx
  80c559:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80c55c:	8b 0b                	mov    (%ebx),%ecx
  80c55e:	3b 8a 64 5a b3 00    	cmp    0xb35a64(%edx),%ecx
  80c564:	75 c6                	jne    80c52c <find_entry+0x29>
  80c566:	e9 c4 01 00 00       	jmp    80c72f <find_entry+0x22c>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  80c56b:	89 ce                	mov    %ecx,%esi
  80c56d:	0f b6 7d d7          	movzbl -0x29(%ebp),%edi
  80c571:	0f b6 4d e6          	movzbl -0x1a(%ebp),%ecx
  80c575:	88 4d e7             	mov    %cl,-0x19(%ebp)
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80c578:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  80c57c:	75 1c                	jne    80c59a <find_entry+0x97>
  80c57e:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  80c582:	75 16                	jne    80c59a <find_entry+0x97>
  80c584:	88 45 e5             	mov    %al,-0x1b(%ebp)
  80c587:	89 f1                	mov    %esi,%ecx
  80c589:	89 fb                	mov    %edi,%ebx
  80c58b:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80c58e:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80c592:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80c595:	e9 a0 00 00 00       	jmp    80c63a <find_entry+0x137>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80c59a:	8b 4a fc             	mov    -0x4(%edx),%ecx
  80c59d:	83 f9 01             	cmp    $0x1,%ecx
  80c5a0:	75 51                	jne    80c5f3 <find_entry+0xf0>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80c5a2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80c5a6:	74 14                	je     80c5bc <find_entry+0xb9>
  80c5a8:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80c5ab:	8b 0b                	mov    (%ebx),%ecx
  80c5ad:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  80c5b0:	75 0a                	jne    80c5bc <find_entry+0xb9>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80c5b2:	a2 78 5b b3 00       	mov    %al,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80c5b7:	e9 73 01 00 00       	jmp    80c72f <find_entry+0x22c>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  80c5bc:	83 7a ec 00          	cmpl   $0x0,-0x14(%edx)
  80c5c0:	74 1a                	je     80c5dc <find_entry+0xd9>
        if (arp_table[i].ctime >= age_queue) {
  80c5c2:	0f b6 0a             	movzbl (%edx),%ecx
  80c5c5:	89 f3                	mov    %esi,%ebx
  80c5c7:	38 cb                	cmp    %cl,%bl
  80c5c9:	77 61                	ja     80c62c <find_entry+0x129>
  80c5cb:	88 45 df             	mov    %al,-0x21(%ebp)
  80c5ce:	89 fb                	mov    %edi,%ebx
  80c5d0:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80c5d3:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80c5d7:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80c5da:	eb 5e                	jmp    80c63a <find_entry+0x137>
          age_queue = arp_table[i].ctime;
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  80c5dc:	0f b6 0a             	movzbl (%edx),%ecx
  80c5df:	88 4d e6             	mov    %cl,-0x1a(%ebp)
  80c5e2:	38 4d e7             	cmp    %cl,-0x19(%ebp)
  80c5e5:	77 45                	ja     80c62c <find_entry+0x129>
  80c5e7:	88 45 dc             	mov    %al,-0x24(%ebp)
  80c5ea:	89 f1                	mov    %esi,%ecx
  80c5ec:	89 fb                	mov    %edi,%ebx
  80c5ee:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80c5f1:	eb 47                	jmp    80c63a <find_entry+0x137>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80c5f3:	83 f9 02             	cmp    $0x2,%ecx
  80c5f6:	75 34                	jne    80c62c <find_entry+0x129>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80c5f8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80c5fc:	74 14                	je     80c612 <find_entry+0x10f>
  80c5fe:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80c601:	8b 0b                	mov    (%ebx),%ecx
  80c603:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  80c606:	75 0a                	jne    80c612 <find_entry+0x10f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80c608:	a2 78 5b b3 00       	mov    %al,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80c60d:	e9 1d 01 00 00       	jmp    80c72f <find_entry+0x22c>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  80c612:	0f b6 0a             	movzbl (%edx),%ecx
  80c615:	88 4d d7             	mov    %cl,-0x29(%ebp)
  80c618:	89 fb                	mov    %edi,%ebx
  80c61a:	38 cb                	cmp    %cl,%bl
  80c61c:	77 0e                	ja     80c62c <find_entry+0x129>
  80c61e:	88 45 de             	mov    %al,-0x22(%ebp)
  80c621:	89 f1                	mov    %esi,%ecx
  80c623:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80c627:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80c62a:	eb 0e                	jmp    80c63a <find_entry+0x137>
  80c62c:	89 f1                	mov    %esi,%ecx
  80c62e:	89 fb                	mov    %edi,%ebx
  80c630:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80c633:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80c637:	88 5d e6             	mov    %bl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80c63a:	83 c0 01             	add    $0x1,%eax
  80c63d:	83 c2 1c             	add    $0x1c,%edx
  80c640:	3c 0a                	cmp    $0xa,%al
  80c642:	0f 85 23 ff ff ff    	jne    80c56b <find_entry+0x68>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80c648:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  80c64c:	75 0a                	jne    80c658 <find_entry+0x155>
  80c64e:	f6 45 dd 01          	testb  $0x1,-0x23(%ebp)
  80c652:	0f 84 d2 00 00 00    	je     80c72a <find_entry+0x227>
  80c658:	f6 45 dd 02          	testb  $0x2,-0x23(%ebp)
  80c65c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c660:	0f 85 c4 00 00 00    	jne    80c72a <find_entry+0x227>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  80c666:	0f b6 5d e5          	movzbl -0x1b(%ebp),%ebx
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  80c66a:	80 fb 09             	cmp    $0x9,%bl
  80c66d:	8d 76 00             	lea    0x0(%esi),%esi
  80c670:	7e 62                	jle    80c6d4 <find_entry+0x1d1>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  80c672:	80 7d de 09          	cmpb   $0x9,-0x22(%ebp)
  80c676:	7f 2f                	jg     80c6a7 <find_entry+0x1a4>
    /* recycle oldest stable*/
    i = old_stable;
  80c678:	0f b6 5d de          	movzbl -0x22(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80c67c:	0f b6 c3             	movzbl %bl,%eax
  80c67f:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80c682:	83 b8 60 5a b3 00 00 	cmpl   $0x0,0xb35a60(%eax)
  80c689:	74 49                	je     80c6d4 <find_entry+0x1d1>
  80c68b:	c7 44 24 08 f7 3c 81 	movl   $0x813cf7,0x8(%esp)
  80c692:	00 
  80c693:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  80c69a:	00 
  80c69b:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c6a2:	e8 6d 42 ff ff       	call   800914 <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
    /* recycle oldest pending */
    i = old_pending;
  80c6a7:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  80c6ab:	80 fb 09             	cmp    $0x9,%bl
  80c6ae:	7e 24                	jle    80c6d4 <find_entry+0x1d1>
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  80c6b0:	80 7d df 09          	cmpb   $0x9,-0x21(%ebp)
  80c6b4:	7f 74                	jg     80c72a <find_entry+0x227>
    /* recycle oldest pending */
    i = old_queue;
  80c6b6:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  80c6ba:	0f b6 f3             	movzbl %bl,%esi
  80c6bd:	bf 60 5a b3 00       	mov    $0xb35a60,%edi
  80c6c2:	6b f6 1c             	imul   $0x1c,%esi,%esi
  80c6c5:	8b 04 3e             	mov    (%esi,%edi,1),%eax
  80c6c8:	e8 99 fd ff ff       	call   80c466 <free_etharp_q>
    arp_table[i].q = NULL;
  80c6cd:	c7 04 3e 00 00 00 00 	movl   $0x0,(%esi,%edi,1)
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  80c6d4:	80 fb 09             	cmp    $0x9,%bl
  80c6d7:	76 1c                	jbe    80c6f5 <find_entry+0x1f2>
  80c6d9:	c7 44 24 08 0e 3d 81 	movl   $0x813d0e,0x8(%esp)
  80c6e0:	00 
  80c6e1:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  80c6e8:	00 
  80c6e9:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c6f0:	e8 1f 42 ff ff       	call   800914 <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  80c6f5:	0f b6 c3             	movzbl %bl,%eax
  80c6f8:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80c6fb:	c7 82 70 5a b3 00 00 	movl   $0x0,0xb35a70(%edx)
  80c702:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  80c705:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80c709:	74 0b                	je     80c716 <find_entry+0x213>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  80c70b:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80c70e:	8b 0e                	mov    (%esi),%ecx
  80c710:	89 8a 64 5a b3 00    	mov    %ecx,0xb35a64(%edx)
  }
  arp_table[i].ctime = 0;
  80c716:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80c719:	c6 80 74 5a b3 00 00 	movb   $0x0,0xb35a74(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80c720:	88 1d 78 5b b3 00    	mov    %bl,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  80c726:	89 d8                	mov    %ebx,%eax
  80c728:	eb 05                	jmp    80c72f <find_entry+0x22c>
  80c72a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80c72f:	83 c4 3c             	add    $0x3c,%esp
  80c732:	5b                   	pop    %ebx
  80c733:	5e                   	pop    %esi
  80c734:	5f                   	pop    %edi
  80c735:	5d                   	pop    %ebp
  80c736:	c3                   	ret    

0080c737 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80c737:	55                   	push   %ebp
  80c738:	89 e5                	mov    %esp,%ebp
  80c73a:	83 ec 38             	sub    $0x38,%esp
  80c73d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80c740:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80c743:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80c746:	8b 75 08             	mov    0x8(%ebp),%esi
  80c749:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80c74c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c750:	89 1c 24             	mov    %ebx,(%esp)
  80c753:	e8 10 cc ff ff       	call   809368 <ip_addr_isbroadcast>
  80c758:	84 c0                	test   %al,%al
  80c75a:	0f 85 c4 01 00 00    	jne    80c924 <etharp_query+0x1ed>
      ip_addr_ismulticast(ipaddr) ||
  80c760:	8b 03                	mov    (%ebx),%eax
  80c762:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c765:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80c76c:	e8 44 e2 ff ff       	call   80a9b5 <ntohl>
  80c771:	89 c7                	mov    %eax,%edi
  80c773:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c77a:	e8 36 e2 ff ff       	call   80a9b5 <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80c77f:	23 7d e4             	and    -0x1c(%ebp),%edi
  80c782:	39 c7                	cmp    %eax,%edi
  80c784:	0f 84 9a 01 00 00    	je     80c924 <etharp_query+0x1ed>
  80c78a:	85 db                	test   %ebx,%ebx
  80c78c:	0f 84 92 01 00 00    	je     80c924 <etharp_query+0x1ed>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
  80c792:	83 3b 00             	cmpl   $0x0,(%ebx)
  80c795:	0f 84 89 01 00 00    	je     80c924 <etharp_query+0x1ed>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80c79b:	ba 01 00 00 00       	mov    $0x1,%edx
  80c7a0:	89 d8                	mov    %ebx,%eax
  80c7a2:	e8 5c fd ff ff       	call   80c503 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80c7a7:	84 c0                	test   %al,%al
  80c7a9:	0f 88 80 01 00 00    	js     80c92f <etharp_query+0x1f8>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80c7af:	0f be f8             	movsbl %al,%edi
  80c7b2:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80c7b5:	8b 80 70 5a b3 00    	mov    0xb35a70(%eax),%eax
  80c7bb:	85 c0                	test   %eax,%eax
  80c7bd:	75 0f                	jne    80c7ce <etharp_query+0x97>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80c7bf:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80c7c2:	c7 80 70 5a b3 00 01 	movl   $0x1,0xb35a70(%eax)
  80c7c9:	00 00 00 
  80c7cc:	eb 33                	jmp    80c801 <etharp_query+0xca>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80c7ce:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c7d1:	83 fa 01             	cmp    $0x1,%edx
  80c7d4:	76 1c                	jbe    80c7f2 <etharp_query+0xbb>
  80c7d6:	c7 44 24 08 54 3c 81 	movl   $0x813c54,0x8(%esp)
  80c7dd:	00 
  80c7de:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80c7e5:	00 
  80c7e6:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c7ed:	e8 22 41 ff ff       	call   800914 <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80c7f2:	83 f8 01             	cmp    $0x1,%eax
  80c7f5:	74 0a                	je     80c801 <etharp_query+0xca>
  80c7f7:	c6 45 e4 ff          	movb   $0xff,-0x1c(%ebp)
  80c7fb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80c7ff:	75 0f                	jne    80c810 <etharp_query+0xd9>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80c801:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c805:	89 34 24             	mov    %esi,(%esp)
  80c808:	e8 12 fb ff ff       	call   80c31f <etharp_request>
  80c80d:	88 45 e4             	mov    %al,-0x1c(%ebp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80c810:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80c814:	0f 84 11 01 00 00    	je     80c92b <etharp_query+0x1f4>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80c81a:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80c81d:	8b 80 70 5a b3 00    	mov    0xb35a70(%eax),%eax
  80c823:	83 f8 02             	cmp    $0x2,%eax
  80c826:	75 1d                	jne    80c845 <etharp_query+0x10e>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80c828:	8d 4e 25             	lea    0x25(%esi),%ecx
  80c82b:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80c82e:	05 68 5a b3 00       	add    $0xb35a68,%eax
  80c833:	89 04 24             	mov    %eax,(%esp)
  80c836:	8b 55 10             	mov    0x10(%ebp),%edx
  80c839:	89 f0                	mov    %esi,%eax
  80c83b:	e8 60 fa ff ff       	call   80c2a0 <etharp_send_ip>
  80c840:	e9 ea 00 00 00       	jmp    80c92f <etharp_query+0x1f8>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80c845:	83 f8 01             	cmp    $0x1,%eax
  80c848:	0f 85 dd 00 00 00    	jne    80c92b <etharp_query+0x1f4>
  80c84e:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80c851:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80c855:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  80c859:	75 21                	jne    80c87c <etharp_query+0x145>
  80c85b:	83 38 00             	cmpl   $0x0,(%eax)
  80c85e:	74 1c                	je     80c87c <etharp_query+0x145>
  80c860:	c7 44 24 08 21 3d 81 	movl   $0x813d21,0x8(%esp)
  80c867:	00 
  80c868:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80c86f:	00 
  80c870:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c877:	e8 98 40 ff ff       	call   800914 <_panic>
        if(p->type != PBUF_ROM) {
  80c87c:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80c880:	75 0b                	jne    80c88d <etharp_query+0x156>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80c882:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80c884:	85 c0                	test   %eax,%eax
  80c886:	75 c9                	jne    80c851 <etharp_query+0x11a>
  80c888:	e9 af 00 00 00       	jmp    80c93c <etharp_query+0x205>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80c88d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c894:	00 
  80c895:	0f b7 d2             	movzwl %dx,%edx
  80c898:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c89c:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80c8a3:	e8 91 b3 ff ff       	call   807c39 <pbuf_alloc>
  80c8a8:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  80c8aa:	85 c0                	test   %eax,%eax
  80c8ac:	74 7d                	je     80c92b <etharp_query+0x1f4>
          if (pbuf_copy(p, q) != ERR_OK) {
  80c8ae:	8b 45 10             	mov    0x10(%ebp),%eax
  80c8b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c8b5:	89 1c 24             	mov    %ebx,(%esp)
  80c8b8:	e8 17 af ff ff       	call   8077d4 <pbuf_copy>
  80c8bd:	84 c0                	test   %al,%al
  80c8bf:	74 0e                	je     80c8cf <etharp_query+0x198>
            pbuf_free(p);
  80c8c1:	89 1c 24             	mov    %ebx,(%esp)
  80c8c4:	e8 b4 b0 ff ff       	call   80797d <pbuf_free>
  80c8c9:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80c8cd:	eb 60                	jmp    80c92f <etharp_query+0x1f8>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80c8cf:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80c8d6:	e8 5d a9 ff ff       	call   807238 <memp_malloc>
        if (new_entry != NULL) {
  80c8db:	85 c0                	test   %eax,%eax
  80c8dd:	74 37                	je     80c916 <etharp_query+0x1df>
          new_entry->next = 0;
  80c8df:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80c8e5:	89 58 04             	mov    %ebx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80c8e8:	6b d7 1c             	imul   $0x1c,%edi,%edx
  80c8eb:	8b 92 60 5a b3 00    	mov    0xb35a60(%edx),%edx
  80c8f1:	85 d2                	test   %edx,%edx
  80c8f3:	74 11                	je     80c906 <etharp_query+0x1cf>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80c8f5:	89 d1                	mov    %edx,%ecx
  80c8f7:	8b 12                	mov    (%edx),%edx
  80c8f9:	85 d2                	test   %edx,%edx
  80c8fb:	75 f8                	jne    80c8f5 <etharp_query+0x1be>
              r = r->next;
            }
            r->next = new_entry;
  80c8fd:	89 01                	mov    %eax,(%ecx)
  80c8ff:	b8 00 00 00 00       	mov    $0x0,%eax
  80c904:	eb 29                	jmp    80c92f <etharp_query+0x1f8>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80c906:	6b ff 1c             	imul   $0x1c,%edi,%edi
  80c909:	89 87 60 5a b3 00    	mov    %eax,0xb35a60(%edi)
  80c90f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c914:	eb 19                	jmp    80c92f <etharp_query+0x1f8>
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80c916:	89 1c 24             	mov    %ebx,(%esp)
  80c919:	e8 5f b0 ff ff       	call   80797d <pbuf_free>
  80c91e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
  80c922:	eb 0b                	jmp    80c92f <etharp_query+0x1f8>
  80c924:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80c929:	eb 04                	jmp    80c92f <etharp_query+0x1f8>
  80c92b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80c92f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80c932:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80c935:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80c938:	89 ec                	mov    %ebp,%esp
  80c93a:	5d                   	pop    %ebp
  80c93b:	c3                   	ret    
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80c93c:	8b 45 10             	mov    0x10(%ebp),%eax
  80c93f:	89 04 24             	mov    %eax,(%esp)
  80c942:	e8 f3 ab ff ff       	call   80753a <pbuf_ref>
  80c947:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80c94a:	eb 83                	jmp    80c8cf <etharp_query+0x198>

0080c94c <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80c94c:	55                   	push   %ebp
  80c94d:	89 e5                	mov    %esp,%ebp
  80c94f:	83 ec 48             	sub    $0x48,%esp
  80c952:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80c955:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80c958:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80c95b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c95e:	8b 75 0c             	mov    0xc(%ebp),%esi
  80c961:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80c964:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80c96b:	00 
  80c96c:	89 34 24             	mov    %esi,(%esp)
  80c96f:	e8 9f ac ff ff       	call   807613 <pbuf_header>
  80c974:	89 c2                	mov    %eax,%edx
  80c976:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80c97b:	84 d2                	test   %dl,%dl
  80c97d:	0f 85 bd 00 00 00    	jne    80ca40 <etharp_output+0xf4>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80c983:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c987:	89 3c 24             	mov    %edi,(%esp)
  80c98a:	e8 d9 c9 ff ff       	call   809368 <ip_addr_isbroadcast>
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80c98f:	ba 3b 3d 81 00       	mov    $0x813d3b,%edx
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80c994:	84 c0                	test   %al,%al
  80c996:	0f 85 95 00 00 00    	jne    80ca31 <etharp_output+0xe5>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80c99c:	8b 07                	mov    (%edi),%eax
  80c99e:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80c9a1:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80c9a8:	e8 08 e0 ff ff       	call   80a9b5 <ntohl>
  80c9ad:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80c9b0:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c9b7:	e8 f9 df ff ff       	call   80a9b5 <ntohl>
  80c9bc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80c9bf:	23 55 d0             	and    -0x30(%ebp),%edx
  80c9c2:	39 c2                	cmp    %eax,%edx
  80c9c4:	75 41                	jne    80ca07 <etharp_output+0xbb>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80c9c6:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80c9ca:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80c9ce:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80c9d2:	8b 07                	mov    (%edi),%eax
  80c9d4:	89 04 24             	mov    %eax,(%esp)
  80c9d7:	e8 d9 df ff ff       	call   80a9b5 <ntohl>
  80c9dc:	c1 e8 10             	shr    $0x10,%eax
  80c9df:	83 e0 7f             	and    $0x7f,%eax
  80c9e2:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80c9e5:	8b 07                	mov    (%edi),%eax
  80c9e7:	89 04 24             	mov    %eax,(%esp)
  80c9ea:	e8 c6 df ff ff       	call   80a9b5 <ntohl>
  80c9ef:	c1 e8 08             	shr    $0x8,%eax
  80c9f2:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80c9f5:	8b 07                	mov    (%edi),%eax
  80c9f7:	89 04 24             	mov    %eax,(%esp)
  80c9fa:	e8 b6 df ff ff       	call   80a9b5 <ntohl>
  80c9ff:	88 45 e7             	mov    %al,-0x19(%ebp)
  80ca02:	8d 55 e2             	lea    -0x1e(%ebp),%edx
  80ca05:	eb 2a                	jmp    80ca31 <etharp_output+0xe5>
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80ca07:	8b 43 04             	mov    0x4(%ebx),%eax
  80ca0a:	33 07                	xor    (%edi),%eax
  80ca0c:	85 43 08             	test   %eax,0x8(%ebx)
  80ca0f:	74 0e                	je     80ca1f <etharp_output+0xd3>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80ca11:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80ca16:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80ca1a:	74 24                	je     80ca40 <etharp_output+0xf4>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80ca1c:	8d 7b 0c             	lea    0xc(%ebx),%edi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80ca1f:	89 74 24 08          	mov    %esi,0x8(%esp)
  80ca23:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80ca27:	89 1c 24             	mov    %ebx,(%esp)
  80ca2a:	e8 08 fd ff ff       	call   80c737 <etharp_query>
  80ca2f:	eb 0f                	jmp    80ca40 <etharp_output+0xf4>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80ca31:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80ca34:	89 14 24             	mov    %edx,(%esp)
  80ca37:	89 f2                	mov    %esi,%edx
  80ca39:	89 d8                	mov    %ebx,%eax
  80ca3b:	e8 60 f8 ff ff       	call   80c2a0 <etharp_send_ip>
}
  80ca40:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ca43:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ca46:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ca49:	89 ec                	mov    %ebp,%esp
  80ca4b:	5d                   	pop    %ebp
  80ca4c:	c3                   	ret    

0080ca4d <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80ca4d:	55                   	push   %ebp
  80ca4e:	89 e5                	mov    %esp,%ebp
  80ca50:	53                   	push   %ebx
  80ca51:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  80ca54:	ba 02 00 00 00       	mov    $0x2,%edx
  80ca59:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ca5c:	e8 a2 fa ff ff       	call   80c503 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80ca61:	84 c0                	test   %al,%al
  80ca63:	78 29                	js     80ca8e <etharp_find_addr+0x41>
  80ca65:	0f be d0             	movsbl %al,%edx
  80ca68:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80ca6b:	83 b9 70 5a b3 00 02 	cmpl   $0x2,0xb35a70(%ecx)
  80ca72:	75 1a                	jne    80ca8e <etharp_find_addr+0x41>
      *eth_ret = &arp_table[i].ethaddr;
  80ca74:	89 ca                	mov    %ecx,%edx
  80ca76:	81 c2 60 5a b3 00    	add    $0xb35a60,%edx
  80ca7c:	8d 5a 08             	lea    0x8(%edx),%ebx
  80ca7f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80ca82:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  80ca84:	83 c2 04             	add    $0x4,%edx
  80ca87:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80ca8a:	89 11                	mov    %edx,(%ecx)
      return i;
  80ca8c:	eb 05                	jmp    80ca93 <etharp_find_addr+0x46>
  80ca8e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
  return -1;
}
  80ca93:	83 c4 04             	add    $0x4,%esp
  80ca96:	5b                   	pop    %ebx
  80ca97:	5d                   	pop    %ebp
  80ca98:	c3                   	ret    

0080ca99 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  80ca99:	55                   	push   %ebp
  80ca9a:	89 e5                	mov    %esp,%ebp
  80ca9c:	57                   	push   %edi
  80ca9d:	56                   	push   %esi
  80ca9e:	53                   	push   %ebx
  80ca9f:	83 ec 0c             	sub    $0xc,%esp
  80caa2:	bb 00 00 00 00       	mov    $0x0,%ebx
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80caa7:	be 74 5a b3 00       	mov    $0xb35a74,%esi
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80caac:	bf 70 5a b3 00       	mov    $0xb35a70,%edi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80cab1:	0f b6 14 33          	movzbl (%ebx,%esi,1),%edx
  80cab5:	83 c2 01             	add    $0x1,%edx
  80cab8:	88 14 33             	mov    %dl,(%ebx,%esi,1)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80cabb:	8b 04 3b             	mov    (%ebx,%edi,1),%eax
  80cabe:	83 f8 02             	cmp    $0x2,%eax
  80cac1:	75 07                	jne    80caca <etharp_tmr+0x31>
  80cac3:	80 fa ef             	cmp    $0xef,%dl
  80cac6:	77 12                	ja     80cada <etharp_tmr+0x41>
  80cac8:	eb 30                	jmp    80cafa <etharp_tmr+0x61>
  80caca:	83 f8 01             	cmp    $0x1,%eax
  80cacd:	8d 76 00             	lea    0x0(%esi),%esi
  80cad0:	75 28                	jne    80cafa <etharp_tmr+0x61>
  80cad2:	80 fa 01             	cmp    $0x1,%dl
  80cad5:	8d 76 00             	lea    0x0(%esi),%esi
  80cad8:	76 20                	jbe    80cafa <etharp_tmr+0x61>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  80cada:	8b 83 60 5a b3 00    	mov    0xb35a60(%ebx),%eax
  80cae0:	85 c0                	test   %eax,%eax
  80cae2:	74 0f                	je     80caf3 <etharp_tmr+0x5a>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  80cae4:	e8 7d f9 ff ff       	call   80c466 <free_etharp_q>
        arp_table[i].q = NULL;
  80cae9:	c7 83 60 5a b3 00 00 	movl   $0x0,0xb35a60(%ebx)
  80caf0:	00 00 00 
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  80caf3:	c7 04 3b 00 00 00 00 	movl   $0x0,(%ebx,%edi,1)
  80cafa:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80cafd:	81 fb 18 01 00 00    	cmp    $0x118,%ebx
  80cb03:	75 ac                	jne    80cab1 <etharp_tmr+0x18>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  80cb05:	83 c4 0c             	add    $0xc,%esp
  80cb08:	5b                   	pop    %ebx
  80cb09:	5e                   	pop    %esi
  80cb0a:	5f                   	pop    %edi
  80cb0b:	5d                   	pop    %ebp
  80cb0c:	c3                   	ret    

0080cb0d <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80cb0d:	55                   	push   %ebp
  80cb0e:	89 e5                	mov    %esp,%ebp
  80cb10:	83 ec 38             	sub    $0x38,%esp
  80cb13:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80cb16:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80cb19:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80cb1c:	89 c6                	mov    %eax,%esi
  80cb1e:	89 d3                	mov    %edx,%ebx
  80cb20:	89 cf                	mov    %ecx,%edi
  80cb22:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
  80cb26:	88 45 e4             	mov    %al,-0x1c(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80cb29:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80cb2d:	74 1c                	je     80cb4b <update_arp_entry+0x3e>
  80cb2f:	c7 44 24 08 7c 3c 81 	movl   $0x813c7c,0x8(%esp)
  80cb36:	00 
  80cb37:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  80cb3e:	00 
  80cb3f:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80cb46:	e8 c9 3d ff ff       	call   800914 <_panic>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80cb4b:	85 d2                	test   %edx,%edx
  80cb4d:	0f 84 14 01 00 00    	je     80cc67 <update_arp_entry+0x15a>
  80cb53:	83 3a 00             	cmpl   $0x0,(%edx)
  80cb56:	0f 84 0b 01 00 00    	je     80cc67 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
  80cb5c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cb60:	89 14 24             	mov    %edx,(%esp)
  80cb63:	e8 00 c8 ff ff       	call   809368 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80cb68:	84 c0                	test   %al,%al
  80cb6a:	0f 85 f7 00 00 00    	jne    80cc67 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  80cb70:	8b 13                	mov    (%ebx),%edx
  80cb72:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80cb75:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80cb7c:	e8 34 de ff ff       	call   80a9b5 <ntohl>
  80cb81:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80cb84:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80cb8b:	e8 25 de ff ff       	call   80a9b5 <ntohl>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80cb90:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80cb93:	23 55 e0             	and    -0x20(%ebp),%edx
  80cb96:	39 c2                	cmp    %eax,%edx
  80cb98:	0f 84 c9 00 00 00    	je     80cc67 <update_arp_entry+0x15a>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80cb9e:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
  80cba2:	89 d8                	mov    %ebx,%eax
  80cba4:	e8 5a f9 ff ff       	call   80c503 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  80cba9:	84 c0                	test   %al,%al
  80cbab:	0f 88 bb 00 00 00    	js     80cc6c <update_arp_entry+0x15f>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  80cbb1:	0f be c0             	movsbl %al,%eax
  80cbb4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80cbb7:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80cbba:	c7 80 70 5a b3 00 02 	movl   $0x2,0xb35a70(%eax)
  80cbc1:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80cbc4:	89 b0 78 5a b3 00    	mov    %esi,0xb35a78(%eax)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80cbca:	0f b6 5f 05          	movzbl 0x5(%edi),%ebx
  80cbce:	88 98 6d 5a b3 00    	mov    %bl,0xb35a6d(%eax)
  80cbd4:	6b 4d e0 07          	imul   $0x7,-0x20(%ebp),%ecx
  80cbd8:	bb 60 5a b3 00       	mov    $0xb35a60,%ebx
  80cbdd:	0f b6 57 04          	movzbl 0x4(%edi),%edx
  80cbe1:	88 54 8b 0c          	mov    %dl,0xc(%ebx,%ecx,4)
  80cbe5:	0f b6 4f 03          	movzbl 0x3(%edi),%ecx
  80cbe9:	88 88 6b 5a b3 00    	mov    %cl,0xb35a6b(%eax)
  80cbef:	6b 4d e0 0e          	imul   $0xe,-0x20(%ebp),%ecx
  80cbf3:	0f b6 57 02          	movzbl 0x2(%edi),%edx
  80cbf7:	88 54 4b 0a          	mov    %dl,0xa(%ebx,%ecx,2)
  80cbfb:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
  80cbff:	88 88 69 5a b3 00    	mov    %cl,0xb35a69(%eax)
  80cc05:	0f b6 0f             	movzbl (%edi),%ecx
  80cc08:	88 4c 18 08          	mov    %cl,0x8(%eax,%ebx,1)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  80cc0c:	c6 80 74 5a b3 00 00 	movb   $0x0,0xb35a74(%eax)
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80cc13:	8d 4e 25             	lea    0x25(%esi),%ecx
  80cc16:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80cc19:	6b 45 e0 1c          	imul   $0x1c,-0x20(%ebp),%eax
  80cc1d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80cc20:	eb 39                	jmp    80cc5b <update_arp_entry+0x14e>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  80cc22:	8b 10                	mov    (%eax),%edx
  80cc24:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80cc27:	89 14 19             	mov    %edx,(%ecx,%ebx,1)
    /* get the packet pointer */
    p = q->p;
  80cc2a:	8b 50 04             	mov    0x4(%eax),%edx
  80cc2d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  80cc30:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cc34:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80cc3b:	e8 b4 a5 ff ff       	call   8071f4 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80cc40:	89 3c 24             	mov    %edi,(%esp)
  80cc43:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80cc46:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cc49:	89 f0                	mov    %esi,%eax
  80cc4b:	e8 50 f6 ff ff       	call   80c2a0 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80cc50:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80cc53:	89 0c 24             	mov    %ecx,(%esp)
  80cc56:	e8 22 ad ff ff       	call   80797d <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80cc5b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80cc5e:	8b 04 1a             	mov    (%edx,%ebx,1),%eax
  80cc61:	85 c0                	test   %eax,%eax
  80cc63:	75 bd                	jne    80cc22 <update_arp_entry+0x115>
  80cc65:	eb 05                	jmp    80cc6c <update_arp_entry+0x15f>
  80cc67:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  80cc6c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80cc6f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80cc72:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80cc75:	89 ec                	mov    %ebp,%esp
  80cc77:	5d                   	pop    %ebp
  80cc78:	c3                   	ret    

0080cc79 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  80cc79:	55                   	push   %ebp
  80cc7a:	89 e5                	mov    %esp,%ebp
  80cc7c:	83 ec 18             	sub    $0x18,%esp
  80cc7f:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80cc82:	85 c0                	test   %eax,%eax
  80cc84:	75 1c                	jne    80cca2 <etharp_ip_input+0x29>
  80cc86:	c7 44 24 08 3b 2f 81 	movl   $0x812f3b,0x8(%esp)
  80cc8d:	00 
  80cc8e:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  80cc95:	00 
  80cc96:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80cc9d:	e8 72 3c ff ff       	call   800914 <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80cca2:	8b 55 0c             	mov    0xc(%ebp),%edx
  80cca5:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80cca8:	8b 48 04             	mov    0x4(%eax),%ecx
  80ccab:	33 4a 1c             	xor    0x1c(%edx),%ecx
  80ccae:	85 48 08             	test   %ecx,0x8(%eax)
  80ccb1:	75 12                	jne    80ccc5 <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80ccb3:	8d 4a 06             	lea    0x6(%edx),%ecx
  80ccb6:	83 c2 1c             	add    $0x1c,%edx
  80ccb9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ccc0:	e8 48 fe ff ff       	call   80cb0d <update_arp_entry>
}
  80ccc5:	c9                   	leave  
  80ccc6:	c3                   	ret    

0080ccc7 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80ccc7:	55                   	push   %ebp
  80ccc8:	89 e5                	mov    %esp,%ebp
  80ccca:	83 ec 38             	sub    $0x38,%esp
  80cccd:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ccd0:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ccd3:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80ccd6:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80ccd9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80ccdd:	75 1c                	jne    80ccfb <etharp_arp_input+0x34>
  80ccdf:	c7 44 24 08 3b 2f 81 	movl   $0x812f3b,0x8(%esp)
  80cce6:	00 
  80cce7:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80ccee:	00 
  80ccef:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80ccf6:	e8 19 3c ff ff       	call   800914 <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  80ccfb:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  80cd00:	77 0d                	ja     80cd0f <etharp_arp_input+0x48>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80cd02:	89 1c 24             	mov    %ebx,(%esp)
  80cd05:	e8 73 ac ff ff       	call   80797d <pbuf_free>
    return;
  80cd0a:	e9 ab 01 00 00       	jmp    80ceba <etharp_arp_input+0x1f3>
  }

  hdr = p->payload;
  80cd0f:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80cd12:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  80cd16:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80cd1d:	e8 51 da ff ff       	call   80a773 <htons>
  80cd22:	66 39 c7             	cmp    %ax,%di
  80cd25:	75 3f                	jne    80cd66 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80cd27:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  80cd2b:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80cd32:	e8 3c da ff ff       	call   80a773 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80cd37:	66 39 c7             	cmp    %ax,%di
  80cd3a:	75 2a                	jne    80cd66 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80cd3c:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  80cd40:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80cd47:	e8 27 da ff ff       	call   80a773 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80cd4c:	66 39 c7             	cmp    %ax,%di
  80cd4f:	75 15                	jne    80cd66 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80cd51:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  80cd55:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80cd5c:	e8 12 da ff ff       	call   80a773 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80cd61:	66 39 c7             	cmp    %ax,%di
  80cd64:	74 0f                	je     80cd75 <etharp_arp_input+0xae>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80cd66:	89 1c 24             	mov    %ebx,(%esp)
  80cd69:	e8 0f ac ff ff       	call   80797d <pbuf_free>
    return;
  80cd6e:	66 90                	xchg   %ax,%ax
  80cd70:	e9 45 01 00 00       	jmp    80ceba <etharp_arp_input+0x1f3>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80cd75:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80cd7c:	00 
  80cd7d:	8d 46 1c             	lea    0x1c(%esi),%eax
  80cd80:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cd84:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80cd87:	89 04 24             	mov    %eax,(%esp)
  80cd8a:	e8 e2 45 ff ff       	call   801371 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80cd8f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80cd96:	00 
  80cd97:	8d 46 26             	lea    0x26(%esi),%eax
  80cd9a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cd9e:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80cda1:	89 04 24             	mov    %eax,(%esp)
  80cda4:	e8 c8 45 ff ff       	call   801371 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80cda9:	8b 55 08             	mov    0x8(%ebp),%edx
  80cdac:	8b 42 04             	mov    0x4(%edx),%eax

  /* ARP message directed to us? */
  if (for_us) {
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80cdaf:	bf 00 00 00 00       	mov    $0x0,%edi
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80cdb4:	85 c0                	test   %eax,%eax
  80cdb6:	74 21                	je     80cdd9 <etharp_arp_input+0x112>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  80cdb8:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  80cdbb:	0f 94 c0             	sete   %al
  80cdbe:	89 c7                	mov    %eax,%edi
  80cdc0:	75 17                	jne    80cdd9 <etharp_arp_input+0x112>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80cdc2:	8d 4e 16             	lea    0x16(%esi),%ecx
  80cdc5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80cdc8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80cdcf:	8b 45 08             	mov    0x8(%ebp),%eax
  80cdd2:	e8 36 fd ff ff       	call   80cb0d <update_arp_entry>
  80cdd7:	eb 15                	jmp    80cdee <etharp_arp_input+0x127>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80cdd9:	8d 4e 16             	lea    0x16(%esi),%ecx
  80cddc:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80cddf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80cde6:	8b 45 08             	mov    0x8(%ebp),%eax
  80cde9:	e8 1f fd ff ff       	call   80cb0d <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80cdee:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  80cdf2:	89 04 24             	mov    %eax,(%esp)
  80cdf5:	e8 79 d9 ff ff       	call   80a773 <htons>
  80cdfa:	66 83 f8 01          	cmp    $0x1,%ax
  80cdfe:	74 15                	je     80ce15 <etharp_arp_input+0x14e>
  80ce00:	66 83 f8 02          	cmp    $0x2,%ax
  80ce04:	0f 85 a8 00 00 00    	jne    80ceb2 <etharp_arp_input+0x1eb>
  80ce0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80ce10:	e9 8b 00 00 00       	jmp    80cea0 <etharp_arp_input+0x1d9>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  80ce15:	89 fa                	mov    %edi,%edx
  80ce17:	84 d2                	test   %dl,%dl
  80ce19:	0f 84 93 00 00 00    	je     80ceb2 <etharp_arp_input+0x1eb>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  80ce1f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80ce26:	e8 48 d9 ff ff       	call   80a773 <htons>
  80ce2b:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  80ce2f:	8b 46 1c             	mov    0x1c(%esi),%eax
  80ce32:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80ce35:	8b 55 08             	mov    0x8(%ebp),%edx
  80ce38:	8b 42 04             	mov    0x4(%edx),%eax
  80ce3b:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80ce3e:	ba 06 00 00 00       	mov    $0x6,%edx
  80ce43:	8b 45 08             	mov    0x8(%ebp),%eax
  80ce46:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80ce4a:	74 1c                	je     80ce68 <etharp_arp_input+0x1a1>
  80ce4c:	c7 44 24 08 dc 3b 81 	movl   $0x813bdc,0x8(%esp)
  80ce53:	00 
  80ce54:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  80ce5b:	00 
  80ce5c:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80ce63:	e8 ac 3a ff ff       	call   800914 <_panic>
  80ce68:	8b 7d 0c             	mov    0xc(%ebp),%edi
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  80ce6b:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80ce6e:	0f b6 c2             	movzbl %dl,%eax
  80ce71:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  80ce76:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80ce7a:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80ce7d:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80ce81:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  80ce85:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80ce89:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  80ce8d:	84 d2                	test   %dl,%dl
  80ce8f:	75 da                	jne    80ce6b <etharp_arp_input+0x1a4>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  80ce91:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ce95:	8b 55 08             	mov    0x8(%ebp),%edx
  80ce98:	89 14 24             	mov    %edx,(%esp)
  80ce9b:	ff 52 18             	call   *0x18(%edx)
  80ce9e:	eb 12                	jmp    80ceb2 <etharp_arp_input+0x1eb>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  80cea0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80cea3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cea7:	8b 45 08             	mov    0x8(%ebp),%eax
  80ceaa:	89 04 24             	mov    %eax,(%esp)
  80cead:	e8 75 90 ff ff       	call   805f27 <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  80ceb2:	89 1c 24             	mov    %ebx,(%esp)
  80ceb5:	e8 c3 aa ff ff       	call   80797d <pbuf_free>
}
  80ceba:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80cebd:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80cec0:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80cec3:	89 ec                	mov    %ebp,%esp
  80cec5:	5d                   	pop    %ebp
  80cec6:	c3                   	ret    

0080cec7 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80cec7:	55                   	push   %ebp
  80cec8:	89 e5                	mov    %esp,%ebp
  80ceca:	83 ec 18             	sub    $0x18,%esp
  80cecd:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80ced0:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80ced3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ced6:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80ced9:	8b 43 04             	mov    0x4(%ebx),%eax
  80cedc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cee0:	89 04 24             	mov    %eax,(%esp)
  80cee3:	e8 8b d8 ff ff       	call   80a773 <htons>
  80cee8:	66 3d 00 08          	cmp    $0x800,%ax
  80ceec:	74 0c                	je     80cefa <ethernet_input+0x33>
  80ceee:	66 3d 06 08          	cmp    $0x806,%ax
  80cef2:	75 65                	jne    80cf59 <ethernet_input+0x92>
  80cef4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80cef8:	eb 4a                	jmp    80cf44 <ethernet_input+0x7d>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80cefa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80cefe:	89 34 24             	mov    %esi,(%esp)
  80cf01:	e8 73 fd ff ff       	call   80cc79 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80cf06:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80cf0d:	ff 
  80cf0e:	89 1c 24             	mov    %ebx,(%esp)
  80cf11:	e8 fd a6 ff ff       	call   807613 <pbuf_header>
  80cf16:	84 c0                	test   %al,%al
  80cf18:	74 1c                	je     80cf36 <ethernet_input+0x6f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80cf1a:	c7 44 24 08 a4 3c 81 	movl   $0x813ca4,0x8(%esp)
  80cf21:	00 
  80cf22:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80cf29:	00 
  80cf2a:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80cf31:	e8 de 39 ff ff       	call   800914 <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80cf36:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cf3a:	89 1c 24             	mov    %ebx,(%esp)
  80cf3d:	e8 f2 c6 ff ff       	call   809634 <ip_input>
      }
      break;
  80cf42:	eb 1d                	jmp    80cf61 <ethernet_input+0x9a>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80cf44:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80cf48:	8d 46 25             	lea    0x25(%esi),%eax
  80cf4b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cf4f:	89 34 24             	mov    %esi,(%esp)
  80cf52:	e8 70 fd ff ff       	call   80ccc7 <etharp_arp_input>
      break;
  80cf57:	eb 08                	jmp    80cf61 <ethernet_input+0x9a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80cf59:	89 1c 24             	mov    %ebx,(%esp)
  80cf5c:	e8 1c aa ff ff       	call   80797d <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80cf61:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf66:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80cf69:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80cf6c:	89 ec                	mov    %ebp,%esp
  80cf6e:	5d                   	pop    %ebp
  80cf6f:	c3                   	ret    

0080cf70 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80cf70:	55                   	push   %ebp
  80cf71:	89 e5                	mov    %esp,%ebp
  80cf73:	56                   	push   %esi
  80cf74:	53                   	push   %ebx
  80cf75:	b8 80 5b b3 00       	mov    $0xb35b80,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80cf7a:	be 80 6f b3 00       	mov    $0xb36f80,%esi
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80cf7f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80cf85:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80cf87:	8b 15 80 6f b3 00    	mov    0xb36f80,%edx
  80cf8d:	89 50 0c             	mov    %edx,0xc(%eax)
  80cf90:	85 d2                	test   %edx,%edx
  80cf92:	74 06                	je     80cf9a <sys_init+0x2a>
  80cf94:	8d 58 0c             	lea    0xc(%eax),%ebx
  80cf97:	89 5a 10             	mov    %ebx,0x10(%edx)
  80cf9a:	89 0d 80 6f b3 00    	mov    %ecx,0xb36f80
  80cfa0:	c7 40 10 80 6f b3 00 	movl   $0xb36f80,0x10(%eax)
  80cfa7:	83 c0 14             	add    $0x14,%eax

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80cfaa:	39 f0                	cmp    %esi,%eax
  80cfac:	75 d1                	jne    80cf7f <sys_init+0xf>
  80cfae:	b8 a0 6f b3 00       	mov    $0xb36fa0,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80cfb3:	be a0 bd b3 00       	mov    $0xb3bda0,%esi
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80cfb8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80cfbe:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80cfc0:	8b 15 a0 bd b3 00    	mov    0xb3bda0,%edx
  80cfc6:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80cfcc:	85 d2                	test   %edx,%edx
  80cfce:	74 0c                	je     80cfdc <sys_init+0x6c>
  80cfd0:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  80cfd6:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  80cfdc:	89 0d a0 bd b3 00    	mov    %ecx,0xb3bda0
  80cfe2:	c7 80 98 00 00 00 a0 	movl   $0xb3bda0,0x98(%eax)
  80cfe9:	bd b3 00 
  80cfec:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80cff1:	39 f0                	cmp    %esi,%eax
  80cff3:	75 c3                	jne    80cfb8 <sys_init+0x48>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  80cff5:	5b                   	pop    %ebx
  80cff6:	5e                   	pop    %esi
  80cff7:	5d                   	pop    %ebp
  80cff8:	c3                   	ret    

0080cff9 <lwip_core_lock>:
    return &t->tmo;
}

void
lwip_core_lock(void)
{
  80cff9:	55                   	push   %ebp
  80cffa:	89 e5                	mov    %esp,%ebp
}
  80cffc:	5d                   	pop    %ebp
  80cffd:	c3                   	ret    

0080cffe <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80cffe:	55                   	push   %ebp
  80cfff:	89 e5                	mov    %esp,%ebp
}
  80d001:	5d                   	pop    %ebp
  80d002:	c3                   	ret    

0080d003 <sys_sem_free>:
    return se - &sems[0];
}

void
sys_sem_free(sys_sem_t sem)
{
  80d003:	55                   	push   %ebp
  80d004:	89 e5                	mov    %esp,%ebp
  80d006:	56                   	push   %esi
  80d007:	53                   	push   %ebx
  80d008:	83 ec 10             	sub    $0x10,%esp
  80d00b:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80d00e:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80d011:	83 3c 95 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%edx,4)
  80d018:	00 
  80d019:	74 24                	je     80d03f <sys_sem_free+0x3c>
  80d01b:	c7 44 24 0c 47 3d 81 	movl   $0x813d47,0xc(%esp)
  80d022:	00 
  80d023:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d02a:	00 
  80d02b:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80d032:	00 
  80d033:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d03a:	e8 d5 38 ff ff       	call   800914 <_panic>
    sems[sem].freed = 1;
  80d03f:	b9 80 5b b3 00       	mov    $0xb35b80,%ecx
  80d044:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80d04b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  80d04e:	c7 04 99 01 00 00 00 	movl   $0x1,(%ecx,%ebx,4)
    sems[sem].gen++;
  80d055:	c1 e3 02             	shl    $0x2,%ebx
  80d058:	8b 74 0b 04          	mov    0x4(%ebx,%ecx,1),%esi
  80d05c:	83 c6 01             	add    $0x1,%esi
  80d05f:	89 74 0b 04          	mov    %esi,0x4(%ebx,%ecx,1)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80d063:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80d066:	8d 04 85 80 5b b3 00 	lea    0xb35b80(,%eax,4),%eax
  80d06d:	8b 15 80 6f b3 00    	mov    0xb36f80,%edx
  80d073:	89 50 0c             	mov    %edx,0xc(%eax)
  80d076:	85 d2                	test   %edx,%edx
  80d078:	74 06                	je     80d080 <sys_sem_free+0x7d>
  80d07a:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d07d:	89 4a 10             	mov    %ecx,0x10(%edx)
  80d080:	a3 80 6f b3 00       	mov    %eax,0xb36f80
  80d085:	c7 40 10 80 6f b3 00 	movl   $0xb36f80,0x10(%eax)
}
  80d08c:	83 c4 10             	add    $0x10,%esp
  80d08f:	5b                   	pop    %ebx
  80d090:	5e                   	pop    %esi
  80d091:	5d                   	pop    %ebp
  80d092:	c3                   	ret    

0080d093 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80d093:	55                   	push   %ebp
  80d094:	89 e5                	mov    %esp,%ebp
  80d096:	56                   	push   %esi
  80d097:	53                   	push   %ebx
  80d098:	83 ec 10             	sub    $0x10,%esp
  80d09b:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80d09e:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d0a4:	83 b8 a0 6f b3 00 00 	cmpl   $0x0,0xb36fa0(%eax)
  80d0ab:	74 24                	je     80d0d1 <sys_mbox_free+0x3e>
  80d0ad:	c7 44 24 0c 75 3d 81 	movl   $0x813d75,0xc(%esp)
  80d0b4:	00 
  80d0b5:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d0bc:	00 
  80d0bd:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  80d0c4:	00 
  80d0c5:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d0cc:	e8 43 38 ff ff       	call   800914 <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80d0d1:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80d0d7:	8b 83 2c 70 b3 00    	mov    0xb3702c(%ebx),%eax
  80d0dd:	89 04 24             	mov    %eax,(%esp)
  80d0e0:	e8 1e ff ff ff       	call   80d003 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80d0e5:	8b 83 30 70 b3 00    	mov    0xb37030(%ebx),%eax
  80d0eb:	89 04 24             	mov    %eax,(%esp)
  80d0ee:	e8 10 ff ff ff       	call   80d003 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80d0f3:	81 c3 a0 6f b3 00    	add    $0xb36fa0,%ebx
  80d0f9:	a1 a0 bd b3 00       	mov    0xb3bda0,%eax
  80d0fe:	89 83 94 00 00 00    	mov    %eax,0x94(%ebx)
  80d104:	85 c0                	test   %eax,%eax
  80d106:	74 0c                	je     80d114 <sys_mbox_free+0x81>
  80d108:	8d 93 94 00 00 00    	lea    0x94(%ebx),%edx
  80d10e:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80d114:	89 1d a0 bd b3 00    	mov    %ebx,0xb3bda0
  80d11a:	c7 83 98 00 00 00 a0 	movl   $0xb3bda0,0x98(%ebx)
  80d121:	bd b3 00 
    mboxes[mbox].freed = 1;
  80d124:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80d12a:	c7 86 a0 6f b3 00 01 	movl   $0x1,0xb36fa0(%esi)
  80d131:	00 00 00 
}
  80d134:	83 c4 10             	add    $0x10,%esp
  80d137:	5b                   	pop    %ebx
  80d138:	5e                   	pop    %esi
  80d139:	5d                   	pop    %ebp
  80d13a:	c3                   	ret    

0080d13b <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80d13b:	55                   	push   %ebp
  80d13c:	89 e5                	mov    %esp,%ebp
  80d13e:	57                   	push   %edi
  80d13f:	56                   	push   %esi
  80d140:	53                   	push   %ebx
  80d141:	83 ec 1c             	sub    $0x1c,%esp
    thread_id_t tid = thread_id();
  80d144:	e8 0a 08 00 00       	call   80d953 <thread_id>
  80d149:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d14b:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d150:	f7 e2                	mul    %edx
  80d152:	c1 ea 08             	shr    $0x8,%edx
  80d155:	89 d0                	mov    %edx,%eax
  80d157:	c1 e0 08             	shl    $0x8,%eax
  80d15a:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80d15d:	89 f0                	mov    %esi,%eax
  80d15f:	29 d0                	sub    %edx,%eax
  80d161:	8d 3c 85 c0 bd b3 00 	lea    0xb3bdc0(,%eax,4),%edi
  80d168:	8b 1f                	mov    (%edi),%ebx
  80d16a:	85 db                	test   %ebx,%ebx
  80d16c:	74 24                	je     80d192 <sys_arch_timeouts+0x57>
	if (t->tid == tid)
  80d16e:	3b 33                	cmp    (%ebx),%esi
  80d170:	75 14                	jne    80d186 <sys_arch_timeouts+0x4b>
  80d172:	e9 b4 00 00 00       	jmp    80d22b <sys_arch_timeouts+0xf0>
  80d177:	3b 33                	cmp    (%ebx),%esi
  80d179:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80d180:	0f 84 a5 00 00 00    	je     80d22b <sys_arch_timeouts+0xf0>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d186:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80d189:	85 db                	test   %ebx,%ebx
  80d18b:	90                   	nop
  80d18c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80d190:	75 e5                	jne    80d177 <sys_arch_timeouts+0x3c>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80d192:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80d199:	e8 c5 5b ff ff       	call   802d63 <malloc>
  80d19e:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80d1a0:	85 c0                	test   %eax,%eax
  80d1a2:	75 1c                	jne    80d1c0 <sys_arch_timeouts+0x85>
	panic("sys_arch_timeouts: cannot malloc");
  80d1a4:	c7 44 24 08 d8 3d 81 	movl   $0x813dd8,0x8(%esp)
  80d1ab:	00 
  80d1ac:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  80d1b3:	00 
  80d1b4:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d1bb:	e8 54 37 ff ff       	call   800914 <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80d1c0:	c7 04 24 36 d2 80 00 	movl   $0x80d236,(%esp)
  80d1c7:	e8 da 07 00 00       	call   80d9a6 <thread_onhalt>
    if (r < 0)
  80d1cc:	85 c0                	test   %eax,%eax
  80d1ce:	79 28                	jns    80d1f8 <sys_arch_timeouts+0xbd>
	panic("thread_onhalt failed: %s", e2s(r));
  80d1d0:	89 04 24             	mov    %eax,(%esp)
  80d1d3:	e8 40 0b 00 00       	call   80dd18 <e2s>
  80d1d8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d1dc:	c7 44 24 08 89 3d 81 	movl   $0x813d89,0x8(%esp)
  80d1e3:	00 
  80d1e4:	c7 44 24 04 31 01 00 	movl   $0x131,0x4(%esp)
  80d1eb:	00 
  80d1ec:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d1f3:	e8 1c 37 ff ff       	call   800914 <_panic>

    t->tid = tid;
  80d1f8:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80d1fa:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d201:	00 
  80d202:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80d209:	00 
  80d20a:	8d 43 04             	lea    0x4(%ebx),%eax
  80d20d:	89 04 24             	mov    %eax,(%esp)
  80d210:	e8 81 40 ff ff       	call   801296 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80d215:	8b 07                	mov    (%edi),%eax
  80d217:	89 43 08             	mov    %eax,0x8(%ebx)
  80d21a:	85 c0                	test   %eax,%eax
  80d21c:	74 08                	je     80d226 <sys_arch_timeouts+0xeb>
  80d21e:	8b 07                	mov    (%edi),%eax
  80d220:	8d 53 08             	lea    0x8(%ebx),%edx
  80d223:	89 50 0c             	mov    %edx,0xc(%eax)
  80d226:	89 1f                	mov    %ebx,(%edi)
  80d228:	89 7b 0c             	mov    %edi,0xc(%ebx)
  80d22b:	8d 43 04             	lea    0x4(%ebx),%eax

out:
    return &t->tmo;
}
  80d22e:	83 c4 1c             	add    $0x1c,%esp
  80d231:	5b                   	pop    %ebx
  80d232:	5e                   	pop    %esi
  80d233:	5f                   	pop    %edi
  80d234:	5d                   	pop    %ebp
  80d235:	c3                   	ret    

0080d236 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80d236:	55                   	push   %ebp
  80d237:	89 e5                	mov    %esp,%ebp
  80d239:	83 ec 18             	sub    $0x18,%esp
  80d23c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d23f:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d244:	89 c8                	mov    %ecx,%eax
  80d246:	f7 e2                	mul    %edx
  80d248:	c1 ea 08             	shr    $0x8,%edx
  80d24b:	89 d0                	mov    %edx,%eax
  80d24d:	c1 e0 08             	shl    $0x8,%eax
  80d250:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80d253:	89 c8                	mov    %ecx,%eax
  80d255:	29 d0                	sub    %edx,%eax
  80d257:	8b 04 85 c0 bd b3 00 	mov    0xb3bdc0(,%eax,4),%eax
  80d25e:	85 c0                	test   %eax,%eax
  80d260:	74 36                	je     80d298 <timeout_cleanup+0x62>
	if (t->tid == tid) {
  80d262:	39 08                	cmp    %ecx,(%eax)
  80d264:	75 2b                	jne    80d291 <timeout_cleanup+0x5b>
  80d266:	eb 0a                	jmp    80d272 <timeout_cleanup+0x3c>
  80d268:	39 08                	cmp    %ecx,(%eax)
  80d26a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80d270:	75 1f                	jne    80d291 <timeout_cleanup+0x5b>
	    LIST_REMOVE(t, link);
  80d272:	8b 50 08             	mov    0x8(%eax),%edx
  80d275:	85 d2                	test   %edx,%edx
  80d277:	74 06                	je     80d27f <timeout_cleanup+0x49>
  80d279:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d27c:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80d27f:	8b 50 0c             	mov    0xc(%eax),%edx
  80d282:	8b 48 08             	mov    0x8(%eax),%ecx
  80d285:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  80d287:	89 04 24             	mov    %eax,(%esp)
  80d28a:	e8 01 5a ff ff       	call   802c90 <free>
	    goto done;
  80d28f:	eb 07                	jmp    80d298 <timeout_cleanup+0x62>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d291:	8b 40 08             	mov    0x8(%eax),%eax
  80d294:	85 c0                	test   %eax,%eax
  80d296:	75 d0                	jne    80d268 <timeout_cleanup+0x32>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80d298:	c9                   	leave  
  80d299:	c3                   	ret    

0080d29a <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80d29a:	55                   	push   %ebp
  80d29b:	89 e5                	mov    %esp,%ebp
  80d29d:	53                   	push   %ebx
  80d29e:	83 ec 14             	sub    $0x14,%esp
  80d2a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80d2a4:	8b 43 04             	mov    0x4(%ebx),%eax
  80d2a7:	89 04 24             	mov    %eax,(%esp)
  80d2aa:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80d2ac:	89 1c 24             	mov    %ebx,(%esp)
  80d2af:	e8 dc 59 ff ff       	call   802c90 <free>
}
  80d2b4:	83 c4 14             	add    $0x14,%esp
  80d2b7:	5b                   	pop    %ebx
  80d2b8:	5d                   	pop    %ebp
  80d2b9:	c3                   	ret    

0080d2ba <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80d2ba:	55                   	push   %ebp
  80d2bb:	89 e5                	mov    %esp,%ebp
  80d2bd:	53                   	push   %ebx
  80d2be:	83 ec 24             	sub    $0x24,%esp
  80d2c1:	8b 5d 14             	mov    0x14(%ebp),%ebx
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80d2c4:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80d2cb:	e8 93 5a ff ff       	call   802d63 <malloc>
    if (lt == 0)
  80d2d0:	85 c0                	test   %eax,%eax
  80d2d2:	75 1c                	jne    80d2f0 <sys_thread_new+0x36>
	panic("sys_thread_new: cannot allocate thread struct");
  80d2d4:	c7 44 24 08 fc 3d 81 	movl   $0x813dfc,0x8(%esp)
  80d2db:	00 
  80d2dc:	c7 44 24 04 fe 00 00 	movl   $0xfe,0x4(%esp)
  80d2e3:	00 
  80d2e4:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d2eb:	e8 24 36 ff ff       	call   800914 <_panic>

    if (stacksize > PGSIZE)
  80d2f0:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  80d2f6:	7e 20                	jle    80d318 <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80d2f8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80d2fc:	c7 44 24 08 a2 3d 81 	movl   $0x813da2,0x8(%esp)
  80d303:	00 
  80d304:	c7 44 24 04 01 01 00 	movl   $0x101,0x4(%esp)
  80d30b:	00 
  80d30c:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d313:	e8 fc 35 ff ff       	call   800914 <_panic>

    lt->func = thread;
  80d318:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d31b:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80d31d:	8b 55 10             	mov    0x10(%ebp),%edx
  80d320:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80d323:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d327:	c7 44 24 08 9a d2 80 	movl   $0x80d29a,0x8(%esp)
  80d32e:	00 
  80d32f:	8b 45 08             	mov    0x8(%ebp),%eax
  80d332:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d336:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80d339:	89 04 24             	mov    %eax,(%esp)
  80d33c:	e8 d6 07 00 00       	call   80db17 <thread_create>

    if (r < 0)
  80d341:	85 c0                	test   %eax,%eax
  80d343:	79 28                	jns    80d36d <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80d345:	89 04 24             	mov    %eax,(%esp)
  80d348:	e8 cb 09 00 00       	call   80dd18 <e2s>
  80d34d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d351:	c7 44 24 08 2c 3e 81 	movl   $0x813e2c,0x8(%esp)
  80d358:	00 
  80d359:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80d360:	00 
  80d361:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d368:	e8 a7 35 ff ff       	call   800914 <_panic>

    return tid;
}
  80d36d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80d370:	83 c4 24             	add    $0x24,%esp
  80d373:	5b                   	pop    %ebx
  80d374:	5d                   	pop    %ebp
  80d375:	c3                   	ret    

0080d376 <sys_arch_sem_wait>:
    }
}

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80d376:	55                   	push   %ebp
  80d377:	89 e5                	mov    %esp,%ebp
  80d379:	57                   	push   %edi
  80d37a:	56                   	push   %esi
  80d37b:	53                   	push   %ebx
  80d37c:	83 ec 3c             	sub    $0x3c,%esp
    assert(!sems[sem].freed);
  80d37f:	8b 55 08             	mov    0x8(%ebp),%edx
  80d382:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d385:	83 3c 85 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%eax,4)
  80d38c:	00 
  80d38d:	74 24                	je     80d3b3 <sys_arch_sem_wait+0x3d>
  80d38f:	c7 44 24 0c 47 3d 81 	movl   $0x813d47,0xc(%esp)
  80d396:	00 
  80d397:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d39e:	00 
  80d39f:	c7 44 24 04 ad 00 00 	movl   $0xad,0x4(%esp)
  80d3a6:	00 
  80d3a7:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d3ae:	e8 61 35 ff ff       	call   800914 <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80d3b3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d3b6:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80d3b9:	8b 04 85 84 5b b3 00 	mov    0xb35b84(,%eax,4),%eax
  80d3c0:	89 45 dc             	mov    %eax,-0x24(%ebp)

    while (tm_msec == 0 || waited < tm_msec) {
  80d3c3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80d3c7:	0f 94 45 d7          	sete   -0x29(%ebp)
  80d3cb:	0f 95 45 e3          	setne  -0x1d(%ebp)
  80d3cf:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80d3d3:	75 0a                	jne    80d3df <sys_arch_sem_wait+0x69>
  80d3d5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80d3d9:	0f 84 d7 00 00 00    	je     80d4b6 <sys_arch_sem_wait+0x140>
	if (sems[sem].counter > 0) {
  80d3df:	8b 55 08             	mov    0x8(%ebp),%edx
  80d3e2:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d3e5:	0f b7 04 85 88 5b b3 	movzwl 0xb35b88(,%eax,4),%eax
  80d3ec:	00 
  80d3ed:	bf 00 00 00 00       	mov    $0x0,%edi
  80d3f2:	66 85 c0             	test   %ax,%ax
  80d3f5:	75 17                	jne    80d40e <sys_arch_sem_wait+0x98>
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80d3f7:	83 7d 0c fe          	cmpl   $0xfffffffe,0xc(%ebp)
  80d3fb:	75 27                	jne    80d424 <sys_arch_sem_wait+0xae>
  80d3fd:	e9 b4 00 00 00       	jmp    80d4b6 <sys_arch_sem_wait+0x140>
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80d402:	0f b7 83 88 5b b3 00 	movzwl 0xb35b88(%ebx),%eax
  80d409:	66 85 c0             	test   %ax,%ax
  80d40c:	74 31                	je     80d43f <sys_arch_sem_wait+0xc9>
	    sems[sem].counter--;
  80d40e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d411:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80d414:	83 e8 01             	sub    $0x1,%eax
  80d417:	66 89 04 95 88 5b b3 	mov    %ax,0xb35b88(,%edx,4)
  80d41e:	00 
	    return waited;
  80d41f:	e9 97 00 00 00       	jmp    80d4bb <sys_arch_sem_wait+0x145>
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80d424:	8b 55 08             	mov    0x8(%ebp),%edx
  80d427:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d42a:	8d 04 85 88 5b b3 00 	lea    0xb35b88(,%eax,4),%eax
  80d431:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80d434:	bf 00 00 00 00       	mov    $0x0,%edi
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
  80d439:	8d 1c 92             	lea    (%edx,%edx,4),%ebx
  80d43c:	c1 e3 02             	shl    $0x2,%ebx
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80d43f:	e8 66 41 ff ff       	call   8015aa <sys_time_msec>
  80d444:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80d447:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80d44c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80d450:	74 08                	je     80d45a <sys_arch_sem_wait+0xe4>
  80d452:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d455:	03 45 0c             	add    0xc(%ebp),%eax
  80d458:	29 f8                	sub    %edi,%eax
	    sems[sem].waiters = 1;
  80d45a:	be 80 5b b3 00       	mov    $0xb35b80,%esi
  80d45f:	66 c7 44 33 0a 01 00 	movw   $0x1,0xa(%ebx,%esi,1)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80d466:	89 44 24 08          	mov    %eax,0x8(%esp)
  80d46a:	8b 44 33 08          	mov    0x8(%ebx,%esi,1),%eax
  80d46e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d472:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80d475:	89 0c 24             	mov    %ecx,(%esp)
  80d478:	e8 e2 07 00 00       	call   80dc5f <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80d47d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80d480:	39 44 33 04          	cmp    %eax,0x4(%ebx,%esi,1)
  80d484:	74 13                	je     80d499 <sys_arch_sem_wait+0x123>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80d486:	c7 04 24 58 3e 81 00 	movl   $0x813e58,(%esp)
  80d48d:	e8 3b 35 ff ff       	call   8009cd <cprintf>
  80d492:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		return SYS_ARCH_TIMEOUT;
  80d497:	eb 22                	jmp    80d4bb <sys_arch_sem_wait+0x145>
	    }
	    uint32_t b = sys_time_msec();
  80d499:	e8 0c 41 ff ff       	call   8015aa <sys_time_msec>
	    waited += (b - a);
  80d49e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80d4a1:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80d4a3:	39 7d 0c             	cmp    %edi,0xc(%ebp)
  80d4a6:	0f 87 56 ff ff ff    	ja     80d402 <sys_arch_sem_wait+0x8c>
  80d4ac:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80d4b0:	0f 85 4c ff ff ff    	jne    80d402 <sys_arch_sem_wait+0x8c>
  80d4b6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80d4bb:	89 f8                	mov    %edi,%eax
  80d4bd:	83 c4 3c             	add    $0x3c,%esp
  80d4c0:	5b                   	pop    %ebx
  80d4c1:	5e                   	pop    %esi
  80d4c2:	5f                   	pop    %edi
  80d4c3:	5d                   	pop    %ebp
  80d4c4:	c3                   	ret    

0080d4c5 <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80d4c5:	55                   	push   %ebp
  80d4c6:	89 e5                	mov    %esp,%ebp
  80d4c8:	53                   	push   %ebx
  80d4c9:	83 ec 14             	sub    $0x14,%esp
  80d4cc:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80d4d0:	a1 80 6f b3 00       	mov    0xb36f80,%eax
    if (!se) {
  80d4d5:	85 c0                	test   %eax,%eax
  80d4d7:	75 13                	jne    80d4ec <sys_sem_new+0x27>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80d4d9:	c7 04 24 84 3e 81 00 	movl   $0x813e84,(%esp)
  80d4e0:	e8 e8 34 ff ff       	call   8009cd <cprintf>
  80d4e5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return SYS_SEM_NULL;
  80d4ea:	eb 5d                	jmp    80d549 <sys_sem_new+0x84>
    }
    LIST_REMOVE(se, link);
  80d4ec:	8b 50 0c             	mov    0xc(%eax),%edx
  80d4ef:	85 d2                	test   %edx,%edx
  80d4f1:	74 06                	je     80d4f9 <sys_sem_new+0x34>
  80d4f3:	8b 58 10             	mov    0x10(%eax),%ebx
  80d4f6:	89 5a 10             	mov    %ebx,0x10(%edx)
  80d4f9:	8b 50 10             	mov    0x10(%eax),%edx
  80d4fc:	8b 58 0c             	mov    0xc(%eax),%ebx
  80d4ff:	89 1a                	mov    %ebx,(%edx)
    assert(se->freed);
  80d501:	83 38 00             	cmpl   $0x0,(%eax)
  80d504:	75 24                	jne    80d52a <sys_sem_new+0x65>
  80d506:	c7 44 24 0c b1 3d 81 	movl   $0x813db1,0xc(%esp)
  80d50d:	00 
  80d50e:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d515:	00 
  80d516:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80d51d:	00 
  80d51e:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d525:	e8 ea 33 ff ff       	call   800914 <_panic>
    se->freed = 0;
  80d52a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80d530:	0f b6 c9             	movzbl %cl,%ecx
  80d533:	66 89 48 08          	mov    %cx,0x8(%eax)
    se->gen++;
  80d537:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80d53b:	2d 80 5b b3 00       	sub    $0xb35b80,%eax
  80d540:	c1 f8 02             	sar    $0x2,%eax
  80d543:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80d549:	83 c4 14             	add    $0x14,%esp
  80d54c:	5b                   	pop    %ebx
  80d54d:	5d                   	pop    %ebp
  80d54e:	c3                   	ret    

0080d54f <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80d54f:	55                   	push   %ebp
  80d550:	89 e5                	mov    %esp,%ebp
  80d552:	56                   	push   %esi
  80d553:	53                   	push   %ebx
  80d554:	83 ec 10             	sub    $0x10,%esp
    assert(size < MBOXSLOTS);
  80d557:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80d55b:	7e 24                	jle    80d581 <sys_mbox_new+0x32>
  80d55d:	c7 44 24 0c bb 3d 81 	movl   $0x813dbb,0xc(%esp)
  80d564:	00 
  80d565:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d56c:	00 
  80d56d:	c7 44 24 04 46 00 00 	movl   $0x46,0x4(%esp)
  80d574:	00 
  80d575:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d57c:	e8 93 33 ff ff       	call   800914 <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80d581:	8b 1d a0 bd b3 00    	mov    0xb3bda0,%ebx
    if (!mbe) {
  80d587:	85 db                	test   %ebx,%ebx
  80d589:	75 16                	jne    80d5a1 <sys_mbox_new+0x52>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80d58b:	c7 04 24 ac 3e 81 00 	movl   $0x813eac,(%esp)
  80d592:	e8 36 34 ff ff       	call   8009cd <cprintf>
  80d597:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
  80d59c:	e9 bd 00 00 00       	jmp    80d65e <sys_mbox_new+0x10f>
    }
    LIST_REMOVE(mbe, link);
  80d5a1:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80d5a7:	85 c0                	test   %eax,%eax
  80d5a9:	74 0c                	je     80d5b7 <sys_mbox_new+0x68>
  80d5ab:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80d5b1:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80d5b7:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d5bd:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80d5c3:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80d5c5:	83 3b 00             	cmpl   $0x0,(%ebx)
  80d5c8:	75 24                	jne    80d5ee <sys_mbox_new+0x9f>
  80d5ca:	c7 44 24 0c cc 3d 81 	movl   $0x813dcc,0xc(%esp)
  80d5d1:	00 
  80d5d2:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d5d9:	00 
  80d5da:	c7 44 24 04 4d 00 00 	movl   $0x4d,0x4(%esp)
  80d5e1:	00 
  80d5e2:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d5e9:	e8 26 33 ff ff       	call   800914 <_panic>
    mbe->freed = 0;
  80d5ee:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80d5f4:	89 de                	mov    %ebx,%esi
  80d5f6:	81 ee a0 6f b3 00    	sub    $0xb36fa0,%esi
  80d5fc:	c1 fe 02             	sar    $0x2,%esi
  80d5ff:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
    mbe->head = -1;
  80d605:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80d60c:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80d613:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80d61a:	e8 a6 fe ff ff       	call   80d4c5 <sys_sem_new>
  80d61f:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80d625:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80d62c:	e8 94 fe ff ff       	call   80d4c5 <sys_sem_new>
  80d631:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80d637:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80d63e:	74 05                	je     80d645 <sys_mbox_new+0xf6>
  80d640:	83 f8 ff             	cmp    $0xffffffff,%eax
  80d643:	75 19                	jne    80d65e <sys_mbox_new+0x10f>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80d645:	89 34 24             	mov    %esi,(%esp)
  80d648:	e8 46 fa ff ff       	call   80d093 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80d64d:	c7 04 24 d4 3e 81 00 	movl   $0x813ed4,(%esp)
  80d654:	e8 74 33 ff ff       	call   8009cd <cprintf>
  80d659:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
    }
    return i;
}
  80d65e:	89 f0                	mov    %esi,%eax
  80d660:	83 c4 10             	add    $0x10,%esp
  80d663:	5b                   	pop    %ebx
  80d664:	5e                   	pop    %esi
  80d665:	5d                   	pop    %ebp
  80d666:	c3                   	ret    

0080d667 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80d667:	55                   	push   %ebp
  80d668:	89 e5                	mov    %esp,%ebp
  80d66a:	83 ec 18             	sub    $0x18,%esp
  80d66d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80d670:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80d673:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80d676:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80d679:	83 3c 95 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%edx,4)
  80d680:	00 
  80d681:	74 24                	je     80d6a7 <sys_sem_signal+0x40>
  80d683:	c7 44 24 0c 47 3d 81 	movl   $0x813d47,0xc(%esp)
  80d68a:	00 
  80d68b:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d692:	00 
  80d693:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
  80d69a:	00 
  80d69b:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d6a2:	e8 6d 32 ff ff       	call   800914 <_panic>
    sems[sem].counter++;
  80d6a7:	ba 80 5b b3 00       	mov    $0xb35b80,%edx
  80d6ac:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  80d6b3:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
  80d6b6:	c1 e3 02             	shl    $0x2,%ebx
  80d6b9:	0f b7 74 13 08       	movzwl 0x8(%ebx,%edx,1),%esi
  80d6be:	83 c6 01             	add    $0x1,%esi
  80d6c1:	66 89 74 13 08       	mov    %si,0x8(%ebx,%edx,1)
    if (sems[sem].waiters) {
  80d6c6:	01 c1                	add    %eax,%ecx
  80d6c8:	66 83 7c 8a 0a 00    	cmpw   $0x0,0xa(%edx,%ecx,4)
  80d6ce:	74 19                	je     80d6e9 <sys_sem_signal+0x82>
	sems[sem].waiters = 0;
  80d6d0:	66 c7 04 8d 8a 5b b3 	movw   $0x0,0xb35b8a(,%ecx,4)
  80d6d7:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80d6da:	8d 04 8d 88 5b b3 00 	lea    0xb35b88(,%ecx,4),%eax
  80d6e1:	89 04 24             	mov    %eax,(%esp)
  80d6e4:	e8 76 02 00 00       	call   80d95f <thread_wakeup>
    }
}
  80d6e9:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80d6ec:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80d6ef:	89 ec                	mov    %ebp,%esp
  80d6f1:	5d                   	pop    %ebp
  80d6f2:	c3                   	ret    

0080d6f3 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80d6f3:	55                   	push   %ebp
  80d6f4:	89 e5                	mov    %esp,%ebp
  80d6f6:	83 ec 28             	sub    $0x28,%esp
  80d6f9:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80d6fc:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80d6ff:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80d702:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80d705:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80d708:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80d70e:	83 b8 a0 6f b3 00 00 	cmpl   $0x0,0xb36fa0(%eax)
  80d715:	74 24                	je     80d73b <sys_arch_mbox_fetch+0x48>
  80d717:	c7 44 24 0c 75 3d 81 	movl   $0x813d75,0xc(%esp)
  80d71e:	00 
  80d71f:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d726:	00 
  80d727:	c7 44 24 04 cf 00 00 	movl   $0xcf,0x4(%esp)
  80d72e:	00 
  80d72f:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d736:	e8 d9 31 ff ff       	call   800914 <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80d73b:	8b 45 10             	mov    0x10(%ebp),%eax
  80d73e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d742:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80d748:	8b 80 2c 70 b3 00    	mov    0xb3702c(%eax),%eax
  80d74e:	89 04 24             	mov    %eax,(%esp)
  80d751:	e8 20 fc ff ff       	call   80d376 <sys_arch_sem_wait>
  80d756:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80d758:	83 f8 ff             	cmp    $0xffffffff,%eax
  80d75b:	0f 84 85 00 00 00    	je     80d7e6 <sys_arch_mbox_fetch+0xf3>
	return waited;

    int slot = mboxes[mbox].head;
  80d761:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80d767:	8b 80 a4 6f b3 00    	mov    0xb36fa4(%eax),%eax
    if (slot == -1)
  80d76d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80d770:	75 1c                	jne    80d78e <sys_arch_mbox_fetch+0x9b>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80d772:	c7 44 24 08 00 3f 81 	movl   $0x813f00,0x8(%esp)
  80d779:	00 
  80d77a:	c7 44 24 04 d7 00 00 	movl   $0xd7,0x4(%esp)
  80d781:	00 
  80d782:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d789:	e8 86 31 ff ff       	call   800914 <_panic>
    if (msg)
  80d78e:	85 ff                	test   %edi,%edi
  80d790:	74 0e                	je     80d7a0 <sys_arch_mbox_fetch+0xad>
	*msg = mboxes[mbox].msg[slot];
  80d792:	6b d3 27             	imul   $0x27,%ebx,%edx
  80d795:	01 c2                	add    %eax,%edx
  80d797:	8b 14 95 ac 6f b3 00 	mov    0xb36fac(,%edx,4),%edx
  80d79e:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80d7a0:	8d 48 01             	lea    0x1(%eax),%ecx
  80d7a3:	89 ca                	mov    %ecx,%edx
  80d7a5:	c1 fa 1f             	sar    $0x1f,%edx
  80d7a8:	c1 ea 1b             	shr    $0x1b,%edx
  80d7ab:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  80d7ae:	83 e0 1f             	and    $0x1f,%eax
  80d7b1:	29 d0                	sub    %edx,%eax
  80d7b3:	ba a0 6f b3 00       	mov    $0xb36fa0,%edx
  80d7b8:	69 cb 9c 00 00 00    	imul   $0x9c,%ebx,%ecx
  80d7be:	89 44 11 04          	mov    %eax,0x4(%ecx,%edx,1)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80d7c2:	3b 44 11 08          	cmp    0x8(%ecx,%edx,1),%eax
  80d7c6:	75 0a                	jne    80d7d2 <sys_arch_mbox_fetch+0xdf>
	mboxes[mbox].head = -1;
  80d7c8:	c7 81 a4 6f b3 00 ff 	movl   $0xffffffff,0xb36fa4(%ecx)
  80d7cf:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80d7d2:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80d7d8:	8b 83 30 70 b3 00    	mov    0xb37030(%ebx),%eax
  80d7de:	89 04 24             	mov    %eax,(%esp)
  80d7e1:	e8 81 fe ff ff       	call   80d667 <sys_sem_signal>
    return waited;
}
  80d7e6:	89 f0                	mov    %esi,%eax
  80d7e8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d7eb:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d7ee:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d7f1:	89 ec                	mov    %ebp,%esp
  80d7f3:	5d                   	pop    %ebp
  80d7f4:	c3                   	ret    

0080d7f5 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80d7f5:	55                   	push   %ebp
  80d7f6:	89 e5                	mov    %esp,%ebp
  80d7f8:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80d7fb:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80d802:	ff 
  80d803:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d806:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d80a:	8b 45 08             	mov    0x8(%ebp),%eax
  80d80d:	89 04 24             	mov    %eax,(%esp)
  80d810:	e8 de fe ff ff       	call   80d6f3 <sys_arch_mbox_fetch>
}
  80d815:	c9                   	leave  
  80d816:	c3                   	ret    

0080d817 <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80d817:	55                   	push   %ebp
  80d818:	89 e5                	mov    %esp,%ebp
  80d81a:	83 ec 28             	sub    $0x28,%esp
  80d81d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80d820:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80d823:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80d826:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80d829:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d82f:	83 b8 a0 6f b3 00 00 	cmpl   $0x0,0xb36fa0(%eax)
  80d836:	74 24                	je     80d85c <sys_mbox_trypost+0x45>
  80d838:	c7 44 24 0c 75 3d 81 	movl   $0x813d75,0xc(%esp)
  80d83f:	00 
  80d840:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d847:	00 
  80d848:	c7 44 24 04 73 00 00 	movl   $0x73,0x4(%esp)
  80d84f:	00 
  80d850:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d857:	e8 b8 30 ff ff       	call   800914 <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80d85c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80d863:	00 
  80d864:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80d86a:	8b 83 30 70 b3 00    	mov    0xb37030(%ebx),%eax
  80d870:	89 04 24             	mov    %eax,(%esp)
  80d873:	e8 fe fa ff ff       	call   80d376 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80d878:	b9 a0 6f b3 00       	mov    $0xb36fa0,%ecx
  80d87d:	8b 54 0b 08          	mov    0x8(%ebx,%ecx,1),%edx
  80d881:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80d886:	3b 54 0b 04          	cmp    0x4(%ebx,%ecx,1),%edx
  80d88a:	74 4c                	je     80d8d8 <sys_mbox_trypost+0xc1>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80d88c:	89 c8                	mov    %ecx,%eax
  80d88e:	89 d9                	mov    %ebx,%ecx
  80d890:	8d 7a 01             	lea    0x1(%edx),%edi
  80d893:	89 fb                	mov    %edi,%ebx
  80d895:	c1 fb 1f             	sar    $0x1f,%ebx
  80d898:	c1 eb 1b             	shr    $0x1b,%ebx
  80d89b:	01 df                	add    %ebx,%edi
  80d89d:	83 e7 1f             	and    $0x1f,%edi
  80d8a0:	29 df                	sub    %ebx,%edi
  80d8a2:	89 7c 01 08          	mov    %edi,0x8(%ecx,%eax,1)
    mboxes[mbox].msg[slot] = msg;
  80d8a6:	6b de 27             	imul   $0x27,%esi,%ebx
  80d8a9:	01 d3                	add    %edx,%ebx
  80d8ab:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80d8ae:	89 7c 98 0c          	mov    %edi,0xc(%eax,%ebx,4)

    if (mboxes[mbox].head == -1)
  80d8b2:	83 7c 01 04 ff       	cmpl   $0xffffffff,0x4(%ecx,%eax,1)
  80d8b7:	75 06                	jne    80d8bf <sys_mbox_trypost+0xa8>
	mboxes[mbox].head = slot;
  80d8b9:	89 91 a4 6f b3 00    	mov    %edx,0xb36fa4(%ecx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80d8bf:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80d8c5:	8b 86 2c 70 b3 00    	mov    0xb3702c(%esi),%eax
  80d8cb:	89 04 24             	mov    %eax,(%esp)
  80d8ce:	e8 94 fd ff ff       	call   80d667 <sys_sem_signal>
  80d8d3:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80d8d8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d8db:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d8de:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d8e1:	89 ec                	mov    %ebp,%esp
  80d8e3:	5d                   	pop    %ebp
  80d8e4:	c3                   	ret    

0080d8e5 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80d8e5:	55                   	push   %ebp
  80d8e6:	89 e5                	mov    %esp,%ebp
  80d8e8:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80d8eb:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d8ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d8f2:	8b 45 08             	mov    0x8(%ebp),%eax
  80d8f5:	89 04 24             	mov    %eax,(%esp)
  80d8f8:	e8 1a ff ff ff       	call   80d817 <sys_mbox_trypost>
  80d8fd:	84 c0                	test   %al,%al
  80d8ff:	74 24                	je     80d925 <sys_mbox_post+0x40>
  80d901:	c7 44 24 0c 28 3f 81 	movl   $0x813f28,0xc(%esp)
  80d908:	00 
  80d909:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d910:	00 
  80d911:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
  80d918:	00 
  80d919:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d920:	e8 ef 2f ff ff       	call   800914 <_panic>
}
  80d925:	c9                   	leave  
  80d926:	c3                   	ret    
	...

0080d930 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80d930:	55                   	push   %ebp
  80d931:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80d933:	c7 05 cc c1 b3 00 00 	movl   $0x0,0xb3c1cc
  80d93a:	00 00 00 
    tq->tq_last = 0;
  80d93d:	c7 05 d0 c1 b3 00 00 	movl   $0x0,0xb3c1d0
  80d944:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80d947:	c7 05 c4 c1 b3 00 00 	movl   $0x0,0xb3c1c4
  80d94e:	00 00 00 
}
  80d951:	5d                   	pop    %ebp
  80d952:	c3                   	ret    

0080d953 <thread_id>:

uint32_t
thread_id(void) {
  80d953:	55                   	push   %ebp
  80d954:	89 e5                	mov    %esp,%ebp
  80d956:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80d95b:	8b 00                	mov    (%eax),%eax
    return cur_tc->tc_tid;
}
  80d95d:	5d                   	pop    %ebp
  80d95e:	c3                   	ret    

0080d95f <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80d95f:	55                   	push   %ebp
  80d960:	89 e5                	mov    %esp,%ebp
  80d962:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80d965:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
    while (tc) {
  80d96a:	85 c0                	test   %eax,%eax
  80d96c:	74 10                	je     80d97e <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80d96e:	39 50 48             	cmp    %edx,0x48(%eax)
  80d971:	75 04                	jne    80d977 <thread_wakeup+0x18>
	    tc->tc_wakeup = 1;
  80d973:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80d977:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80d97a:	85 c0                	test   %eax,%eax
  80d97c:	75 f0                	jne    80d96e <thread_wakeup+0xf>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80d97e:	5d                   	pop    %ebp
  80d97f:	90                   	nop
  80d980:	c3                   	ret    

0080d981 <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80d981:	55                   	push   %ebp
  80d982:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80d984:	8b 15 cc c1 b3 00    	mov    0xb3c1cc,%edx
    int n = 0;
    while (tc) {
  80d98a:	b8 00 00 00 00       	mov    $0x0,%eax
  80d98f:	85 d2                	test   %edx,%edx
  80d991:	74 11                	je     80d9a4 <thread_wakeups_pending+0x23>
	if (tc->tc_wakeup)
  80d993:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80d997:	80 f9 01             	cmp    $0x1,%cl
  80d99a:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80d99d:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80d9a0:	85 d2                	test   %edx,%edx
  80d9a2:	75 ef                	jne    80d993 <thread_wakeups_pending+0x12>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80d9a4:	5d                   	pop    %ebp
  80d9a5:	c3                   	ret    

0080d9a6 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80d9a6:	55                   	push   %ebp
  80d9a7:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80d9a9:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80d9af:	8b 4a 60             	mov    0x60(%edx),%ecx
  80d9b2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80d9b7:	83 f9 03             	cmp    $0x3,%ecx
  80d9ba:	7f 12                	jg     80d9ce <thread_onhalt+0x28>
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80d9bc:	8b 45 08             	mov    0x8(%ebp),%eax
  80d9bf:	89 44 8a 50          	mov    %eax,0x50(%edx,%ecx,4)
  80d9c3:	83 c1 01             	add    $0x1,%ecx
  80d9c6:	89 4a 60             	mov    %ecx,0x60(%edx)
  80d9c9:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80d9ce:	5d                   	pop    %ebp
  80d9cf:	c3                   	ret    

0080d9d0 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80d9d0:	55                   	push   %ebp
  80d9d1:	89 e5                	mov    %esp,%ebp
  80d9d3:	53                   	push   %ebx
  80d9d4:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80d9d7:	8b 1d cc c1 b3 00    	mov    0xb3c1cc,%ebx
  80d9dd:	85 db                	test   %ebx,%ebx
  80d9df:	74 69                	je     80da4a <thread_yield+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80d9e1:	8b 43 64             	mov    0x64(%ebx),%eax
  80d9e4:	a3 cc c1 b3 00       	mov    %eax,0xb3c1cc
    tc->tc_queue_link = 0;
  80d9e9:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80d9f0:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80d9f5:	85 c0                	test   %eax,%eax
  80d9f7:	74 3e                	je     80da37 <thread_yield+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80d9f9:	83 c0 30             	add    $0x30,%eax
  80d9fc:	89 04 24             	mov    %eax,(%esp)
  80d9ff:	e8 cc 02 00 00       	call   80dcd0 <jos_setjmp>
  80da04:	85 c0                	test   %eax,%eax
  80da06:	75 42                	jne    80da4a <thread_yield+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80da08:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80da0d:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80da14:	83 3d cc c1 b3 00 00 	cmpl   $0x0,0xb3c1cc
  80da1b:	75 0c                	jne    80da29 <thread_yield+0x59>
	tq->tq_first = tc;
  80da1d:	a3 cc c1 b3 00       	mov    %eax,0xb3c1cc
	tq->tq_last = tc;
  80da22:	a3 d0 c1 b3 00       	mov    %eax,0xb3c1d0
  80da27:	eb 0e                	jmp    80da37 <thread_yield+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80da29:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
  80da2f:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80da32:	a3 d0 c1 b3 00       	mov    %eax,0xb3c1d0
    }

    cur_tc = next_tc;
  80da37:	89 1d c8 c1 b3 00    	mov    %ebx,0xb3c1c8
    jos_longjmp(&cur_tc->tc_jb, 1);
  80da3d:	8d 43 30             	lea    0x30(%ebx),%eax
  80da40:	ba 01 00 00 00       	mov    $0x1,%edx
  80da45:	e8 b6 02 00 00       	call   80dd00 <jos_longjmp>
}
  80da4a:	83 c4 14             	add    $0x14,%esp
  80da4d:	5b                   	pop    %ebx
  80da4e:	5d                   	pop    %ebp
  80da4f:	c3                   	ret    

0080da50 <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80da50:	55                   	push   %ebp
  80da51:	89 e5                	mov    %esp,%ebp
  80da53:	56                   	push   %esi
  80da54:	53                   	push   %ebx
  80da55:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80da58:	8b 1d d4 c1 b3 00    	mov    0xb3c1d4,%ebx
  80da5e:	85 db                	test   %ebx,%ebx
  80da60:	0f 84 88 00 00 00    	je     80daee <thread_halt+0x9e>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80da66:	8b 43 64             	mov    0x64(%ebx),%eax
  80da69:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
    tc->tc_queue_link = 0;
  80da6e:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80da75:	83 7b 60 00          	cmpl   $0x0,0x60(%ebx)
  80da79:	7e 16                	jle    80da91 <thread_halt+0x41>
  80da7b:	be 00 00 00 00       	mov    $0x0,%esi
	tc->tc_onhalt[i](tc->tc_tid);
  80da80:	8b 03                	mov    (%ebx),%eax
  80da82:	89 04 24             	mov    %eax,(%esp)
  80da85:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80da89:	83 c6 01             	add    $0x1,%esi
  80da8c:	3b 73 60             	cmp    0x60(%ebx),%esi
  80da8f:	7c ef                	jl     80da80 <thread_halt+0x30>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80da91:	8b 43 04             	mov    0x4(%ebx),%eax
  80da94:	89 04 24             	mov    %eax,(%esp)
  80da97:	e8 f4 51 ff ff       	call   802c90 <free>
    free(tc);
  80da9c:	89 1c 24             	mov    %ebx,(%esp)
  80da9f:	e8 ec 51 ff ff       	call   802c90 <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80daa4:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80daa9:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80dab0:	83 3d d4 c1 b3 00 00 	cmpl   $0x0,0xb3c1d4
  80dab7:	75 0c                	jne    80dac5 <thread_halt+0x75>
	tq->tq_first = tc;
  80dab9:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
	tq->tq_last = tc;
  80dabe:	a3 d8 c1 b3 00       	mov    %eax,0xb3c1d8
  80dac3:	eb 0e                	jmp    80dad3 <thread_halt+0x83>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80dac5:	8b 15 d8 c1 b3 00    	mov    0xb3c1d8,%edx
  80dacb:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80dace:	a3 d8 c1 b3 00       	mov    %eax,0xb3c1d8
    cur_tc = NULL;
  80dad3:	c7 05 c8 c1 b3 00 00 	movl   $0x0,0xb3c1c8
  80dada:	00 00 00 
    thread_yield();
  80dadd:	e8 ee fe ff ff       	call   80d9d0 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80dae2:	e8 11 2e ff ff       	call   8008f8 <exit>
}
  80dae7:	83 c4 10             	add    $0x10,%esp
  80daea:	5b                   	pop    %ebx
  80daeb:	5e                   	pop    %esi
  80daec:	5d                   	pop    %ebp
  80daed:	c3                   	ret    
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80daee:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80daf3:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
  80dafa:	eb bd                	jmp    80dab9 <thread_halt+0x69>

0080dafc <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80dafc:	55                   	push   %ebp
  80dafd:	89 e5                	mov    %esp,%ebp
  80daff:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80db02:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80db07:	8b 50 2c             	mov    0x2c(%eax),%edx
  80db0a:	89 14 24             	mov    %edx,(%esp)
  80db0d:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80db10:	e8 3b ff ff ff       	call   80da50 <thread_halt>
}
  80db15:	c9                   	leave  
  80db16:	c3                   	ret    

0080db17 <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80db17:	55                   	push   %ebp
  80db18:	89 e5                	mov    %esp,%ebp
  80db1a:	57                   	push   %edi
  80db1b:	56                   	push   %esi
  80db1c:	53                   	push   %ebx
  80db1d:	83 ec 1c             	sub    $0x1c,%esp
  80db20:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80db23:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80db2a:	e8 34 52 ff ff       	call   802d63 <malloc>
  80db2f:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80db31:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80db36:	85 db                	test   %ebx,%ebx
  80db38:	0f 84 19 01 00 00    	je     80dc57 <thread_create+0x140>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80db3e:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80db45:	00 
  80db46:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80db4d:	00 
  80db4e:	89 1c 24             	mov    %ebx,(%esp)
  80db51:	e8 40 37 ff ff       	call   801296 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80db56:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80db5d:	00 
  80db5e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80db61:	89 44 24 04          	mov    %eax,0x4(%esp)
  80db65:	8d 43 08             	lea    0x8(%ebx),%eax
  80db68:	89 04 24             	mov    %eax,(%esp)
  80db6b:	e8 e6 35 ff ff       	call   801156 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80db70:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80db74:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80db79:	8d 50 01             	lea    0x1(%eax),%edx
  80db7c:	89 15 c4 c1 b3 00    	mov    %edx,0xb3c1c4
    if (max_tid == (uint32_t)~0)
  80db82:	83 fa ff             	cmp    $0xffffffff,%edx
  80db85:	75 1c                	jne    80dba3 <thread_create+0x8c>
	panic("alloc_tid: no more thread ids");
  80db87:	c7 44 24 08 4e 3f 81 	movl   $0x813f4e,0x8(%esp)
  80db8e:	00 
  80db8f:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80db96:	00 
  80db97:	c7 04 24 6c 3f 81 00 	movl   $0x813f6c,(%esp)
  80db9e:	e8 71 2d ff ff       	call   800914 <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80dba3:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80dba5:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80dbac:	e8 b2 51 ff ff       	call   802d63 <malloc>
  80dbb1:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80dbb4:	85 c0                	test   %eax,%eax
  80dbb6:	75 12                	jne    80dbca <thread_create+0xb3>
	free(tc);
  80dbb8:	89 1c 24             	mov    %ebx,(%esp)
  80dbbb:	e8 d0 50 ff ff       	call   802c90 <free>
  80dbc0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	return -E_NO_MEM;
  80dbc5:	e9 8d 00 00 00       	jmp    80dc57 <thread_create+0x140>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80dbca:	8d b0 fc 0f 00 00    	lea    0xffc(%eax),%esi
    memset(stacktop, 0, 4);
  80dbd0:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80dbd7:	00 
  80dbd8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80dbdf:	00 
  80dbe0:	89 34 24             	mov    %esi,(%esp)
  80dbe3:	e8 ae 36 ff ff       	call   801296 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80dbe8:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80dbef:	00 
  80dbf0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80dbf7:	00 
  80dbf8:	8d 43 30             	lea    0x30(%ebx),%eax
  80dbfb:	89 04 24             	mov    %eax,(%esp)
  80dbfe:	e8 93 36 ff ff       	call   801296 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80dc03:	89 73 34             	mov    %esi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80dc06:	c7 43 30 fc da 80 00 	movl   $0x80dafc,0x30(%ebx)
    tc->tc_entry = entry;
  80dc0d:	8b 45 10             	mov    0x10(%ebp),%eax
  80dc10:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80dc13:	8b 45 14             	mov    0x14(%ebp),%eax
  80dc16:	89 43 2c             	mov    %eax,0x2c(%ebx)
  80dc19:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80dc20:	83 3d cc c1 b3 00 00 	cmpl   $0x0,0xb3c1cc
  80dc27:	75 0e                	jne    80dc37 <thread_create+0x120>
	tq->tq_first = tc;
  80dc29:	89 1d cc c1 b3 00    	mov    %ebx,0xb3c1cc
	tq->tq_last = tc;
  80dc2f:	89 1d d0 c1 b3 00    	mov    %ebx,0xb3c1d0
  80dc35:	eb 0e                	jmp    80dc45 <thread_create+0x12e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80dc37:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80dc3c:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80dc3f:	89 1d d0 c1 b3 00    	mov    %ebx,0xb3c1d0

    threadq_push(&thread_queue, tc);

    if (tid)
  80dc45:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc4a:	85 ff                	test   %edi,%edi
  80dc4c:	74 09                	je     80dc57 <thread_create+0x140>
	*tid = tc->tc_tid;
  80dc4e:	8b 03                	mov    (%ebx),%eax
  80dc50:	89 07                	mov    %eax,(%edi)
  80dc52:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80dc57:	83 c4 1c             	add    $0x1c,%esp
  80dc5a:	5b                   	pop    %ebx
  80dc5b:	5e                   	pop    %esi
  80dc5c:	5f                   	pop    %edi
  80dc5d:	5d                   	pop    %ebp
  80dc5e:	c3                   	ret    

0080dc5f <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80dc5f:	55                   	push   %ebp
  80dc60:	89 e5                	mov    %esp,%ebp
  80dc62:	57                   	push   %edi
  80dc63:	56                   	push   %esi
  80dc64:	53                   	push   %ebx
  80dc65:	83 ec 0c             	sub    $0xc,%esp
  80dc68:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dc6b:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80dc6e:	e8 37 39 ff ff       	call   8015aa <sys_time_msec>
  80dc73:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80dc75:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80dc7a:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80dc7d:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)

    while (p < msec) {
  80dc81:	39 fe                	cmp    %edi,%esi
  80dc83:	72 06                	jb     80dc8b <thread_wait+0x2c>
  80dc85:	eb 2d                	jmp    80dcb4 <thread_wait+0x55>
	if (p < s)
  80dc87:	39 c6                	cmp    %eax,%esi
  80dc89:	77 29                	ja     80dcb4 <thread_wait+0x55>
	    break;
	if (addr && *addr != val)
  80dc8b:	85 db                	test   %ebx,%ebx
  80dc8d:	8d 76 00             	lea    0x0(%esi),%esi
  80dc90:	74 07                	je     80dc99 <thread_wait+0x3a>
  80dc92:	8b 03                	mov    (%ebx),%eax
  80dc94:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80dc97:	75 1b                	jne    80dcb4 <thread_wait+0x55>
	    break;
	if (cur_tc->tc_wakeup)
  80dc99:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80dc9e:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80dca2:	84 c0                	test   %al,%al
  80dca4:	75 0e                	jne    80dcb4 <thread_wait+0x55>
	    break;

	thread_yield();
  80dca6:	e8 25 fd ff ff       	call   80d9d0 <thread_yield>
	p = sys_time_msec();
  80dcab:	e8 fa 38 ff ff       	call   8015aa <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80dcb0:	39 c7                	cmp    %eax,%edi
  80dcb2:	77 d3                	ja     80dc87 <thread_wait+0x28>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80dcb4:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80dcb9:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80dcc0:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80dcc4:	83 c4 0c             	add    $0xc,%esp
  80dcc7:	5b                   	pop    %ebx
  80dcc8:	5e                   	pop    %esi
  80dcc9:	5f                   	pop    %edi
  80dcca:	5d                   	pop    %ebp
  80dccb:	c3                   	ret    
  80dccc:	00 00                	add    %al,(%eax)
	...

0080dcd0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80dcd0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80dcd4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80dcd7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80dcd9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80dcdd:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80dce0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80dce3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80dce6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80dce9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80dcec:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80dcf1:	c3                   	ret    
  80dcf2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80dcf9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080dd00 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80dd00:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80dd02:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80dd05:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80dd08:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80dd0b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80dd0e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80dd11:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80dd13:	ff e1                	jmp    *%ecx
  80dd15:	00 00                	add    %al,(%eax)
	...

0080dd18 <e2s>:
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
  80dd18:	55                   	push   %ebp
  80dd19:	89 e5                	mov    %esp,%ebp
  80dd1b:	8b 45 08             	mov    0x8(%ebp),%eax
  80dd1e:	8b 04 85 60 50 81 00 	mov    0x815060(,%eax,4),%eax
	return sys_errlist[err];
}
  80dd25:	5d                   	pop    %ebp
  80dd26:	c3                   	ret    

0080dd27 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80dd27:	55                   	push   %ebp
  80dd28:	89 e5                	mov    %esp,%ebp
  80dd2a:	83 ec 18             	sub    $0x18,%esp
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80dd2d:	a1 20 c2 b3 00       	mov    0xb3c220,%eax
  80dd32:	89 04 24             	mov    %eax,(%esp)
  80dd35:	e8 de ff ff ff       	call   80dd18 <e2s>
  80dd3a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80dd3e:	8b 45 08             	mov    0x8(%ebp),%eax
  80dd41:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dd45:	c7 04 24 87 3f 81 00 	movl   $0x813f87,(%esp)
  80dd4c:	e8 7c 2c ff ff       	call   8009cd <cprintf>
}
  80dd51:	c9                   	leave  
  80dd52:	c3                   	ret    
	...

0080dd60 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80dd60:	55                   	push   %ebp
  80dd61:	89 e5                	mov    %esp,%ebp
  80dd63:	83 ec 38             	sub    $0x38,%esp
  80dd66:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80dd69:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80dd6c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80dd6f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80dd72:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80dd79:	e8 62 8e ff ff       	call   806be0 <mem_malloc>
  80dd7e:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80dd80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80dd85:	85 f6                	test   %esi,%esi
  80dd87:	0f 84 8a 00 00 00    	je     80de17 <jif_init+0xb7>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80dd8d:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80dd90:	89 73 1c             	mov    %esi,0x1c(%ebx)
    netif->output = jif_output;
  80dd93:	c7 43 14 39 df 80 00 	movl   $0x80df39,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80dd9a:	c7 43 18 24 de 80 00 	movl   $0x80de24,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80dda1:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80dda8:	00 
  80dda9:	c7 44 24 04 f7 28 81 	movl   $0x8128f7,0x4(%esp)
  80ddb0:	00 
  80ddb1:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80ddb4:	89 04 24             	mov    %eax,(%esp)
  80ddb7:	e8 b5 35 ff ff       	call   801371 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80ddbc:	8d 43 25             	lea    0x25(%ebx),%eax
  80ddbf:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80ddc1:	8b 07                	mov    (%edi),%eax
  80ddc3:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80ddc6:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80ddca:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80ddd0:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80ddd4:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80ddd8:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80dddc:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80dde0:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80dde4:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80dde8:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80ddec:	c7 04 24 ac 1f 81 00 	movl   $0x811fac,(%esp)
  80ddf3:	e8 98 cb ff ff       	call   80a990 <inet_addr>
  80ddf8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80ddfb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80de02:	00 
  80de03:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80de06:	89 44 24 04          	mov    %eax,0x4(%esp)
  80de0a:	89 1c 24             	mov    %ebx,(%esp)
  80de0d:	e8 25 e9 ff ff       	call   80c737 <etharp_query>
  80de12:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80de17:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80de1a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80de1d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80de20:	89 ec                	mov    %ebp,%esp
  80de22:	5d                   	pop    %ebp
  80de23:	c3                   	ret    

0080de24 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80de24:	55                   	push   %ebp
  80de25:	89 e5                	mov    %esp,%ebp
  80de27:	57                   	push   %edi
  80de28:	56                   	push   %esi
  80de29:	53                   	push   %ebx
  80de2a:	83 ec 2c             	sub    $0x2c,%esp
  80de2d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80de30:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80de37:	00 
  80de38:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80de3f:	10 
  80de40:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80de47:	e8 21 39 ff ff       	call   80176d <sys_page_alloc>
    if (r < 0)
  80de4c:	85 c0                	test   %eax,%eax
  80de4e:	79 1c                	jns    80de6c <low_level_output+0x48>
	panic("jif: could not allocate page of memory");
  80de50:	c7 44 24 08 80 44 81 	movl   $0x814480,0x8(%esp)
  80de57:	00 
  80de58:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80de5f:	00 
  80de60:	c7 04 24 69 44 81 00 	movl   $0x814469,(%esp)
  80de67:	e8 a8 2a ff ff       	call   800914 <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80de6c:	8b 45 08             	mov    0x8(%ebp),%eax
  80de6f:	8b 78 1c             	mov    0x1c(%eax),%edi

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80de72:	be 00 00 00 00       	mov    $0x0,%esi
  80de77:	85 db                	test   %ebx,%ebx
  80de79:	74 74                	je     80deef <low_level_output+0xcb>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80de7b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80de7f:	0f b7 d0             	movzwl %ax,%edx
  80de82:	81 fa d0 07 00 00    	cmp    $0x7d0,%edx
  80de88:	7e 38                	jle    80dec2 <low_level_output+0x9e>
  80de8a:	eb 12                	jmp    80de9e <low_level_output+0x7a>
  80de8c:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80de90:	0f b7 d0             	movzwl %ax,%edx
  80de93:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
  80de96:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80de9c:	7e 29                	jle    80dec7 <low_level_output+0xa3>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80de9e:	89 74 24 10          	mov    %esi,0x10(%esp)
  80dea2:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80dea6:	c7 44 24 08 a8 44 81 	movl   $0x8144a8,0x8(%esp)
  80dead:	00 
  80deae:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  80deb5:	00 
  80deb6:	c7 04 24 69 44 81 00 	movl   $0x814469,(%esp)
  80debd:	e8 52 2a ff ff       	call   800914 <_panic>
  80dec2:	be 00 00 00 00       	mov    $0x0,%esi
	memcpy(&txbuf[txsize], q->payload, q->len);
  80dec7:	8d 96 04 00 00 10    	lea    0x10000004(%esi),%edx
  80decd:	0f b7 c0             	movzwl %ax,%eax
  80ded0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ded4:	8b 43 04             	mov    0x4(%ebx),%eax
  80ded7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dedb:	89 14 24             	mov    %edx,(%esp)
  80dede:	e8 8e 34 ff ff       	call   801371 <memcpy>
	txsize += q->len;
  80dee3:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80dee7:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80dee9:	8b 1b                	mov    (%ebx),%ebx
  80deeb:	85 db                	test   %ebx,%ebx
  80deed:	75 9d                	jne    80de8c <low_level_output+0x68>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80deef:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80def5:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80defc:	00 
  80defd:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80df04:	10 
  80df05:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80df0c:	00 
  80df0d:	8b 47 04             	mov    0x4(%edi),%eax
  80df10:	89 04 24             	mov    %eax,(%esp)
  80df13:	e8 7c 3e ff ff       	call   801d94 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80df18:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80df1f:	10 
  80df20:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80df27:	e8 d0 37 ff ff       	call   8016fc <sys_page_unmap>

    return ERR_OK;
}
  80df2c:	b8 00 00 00 00       	mov    $0x0,%eax
  80df31:	83 c4 2c             	add    $0x2c,%esp
  80df34:	5b                   	pop    %ebx
  80df35:	5e                   	pop    %esi
  80df36:	5f                   	pop    %edi
  80df37:	5d                   	pop    %ebp
  80df38:	c3                   	ret    

0080df39 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80df39:	55                   	push   %ebp
  80df3a:	89 e5                	mov    %esp,%ebp
  80df3c:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80df3f:	8b 45 10             	mov    0x10(%ebp),%eax
  80df42:	89 44 24 08          	mov    %eax,0x8(%esp)
  80df46:	8b 45 0c             	mov    0xc(%ebp),%eax
  80df49:	89 44 24 04          	mov    %eax,0x4(%esp)
  80df4d:	8b 45 08             	mov    0x8(%ebp),%eax
  80df50:	89 04 24             	mov    %eax,(%esp)
  80df53:	e8 f4 e9 ff ff       	call   80c94c <etharp_output>
}
  80df58:	c9                   	leave  
  80df59:	c3                   	ret    

0080df5a <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80df5a:	55                   	push   %ebp
  80df5b:	89 e5                	mov    %esp,%ebp
  80df5d:	57                   	push   %edi
  80df5e:	56                   	push   %esi
  80df5f:	53                   	push   %ebx
  80df60:	83 ec 2c             	sub    $0x2c,%esp
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80df63:	8b 45 08             	mov    0x8(%ebp),%eax
  80df66:	8b 40 1c             	mov    0x1c(%eax),%eax
  80df69:	89 45 d8             	mov    %eax,-0x28(%ebp)
 *
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  80df6c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    s16_t len = pkt->jp_len;
  80df6f:	0f b7 33             	movzwl (%ebx),%esi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80df72:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80df79:	00 
  80df7a:	0f b7 c6             	movzwl %si,%eax
  80df7d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80df81:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80df88:	e8 ac 9c ff ff       	call   807c39 <pbuf_alloc>
  80df8d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80df90:	85 c0                	test   %eax,%eax
  80df92:	0f 84 ca 00 00 00    	je     80e062 <jif_input+0x108>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80df98:	83 c3 04             	add    $0x4,%ebx
  80df9b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80df9e:	89 c3                	mov    %eax,%ebx
  80dfa0:	bf 00 00 00 00       	mov    $0x0,%edi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80dfa5:	0f bf f6             	movswl %si,%esi
  80dfa8:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80dfab:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80dfaf:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80dfb2:	29 fe                	sub    %edi,%esi
  80dfb4:	39 c6                	cmp    %eax,%esi
  80dfb6:	0f 4f f0             	cmovg  %eax,%esi
	if (bytes > (len - copied))
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80dfb9:	89 74 24 08          	mov    %esi,0x8(%esp)
  80dfbd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80dfc0:	01 f8                	add    %edi,%eax
  80dfc2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dfc6:	8b 43 04             	mov    0x4(%ebx),%eax
  80dfc9:	89 04 24             	mov    %eax,(%esp)
  80dfcc:	e8 a0 33 ff ff       	call   801371 <memcpy>
	copied += bytes;
  80dfd1:	01 f7                	add    %esi,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80dfd3:	8b 1b                	mov    (%ebx),%ebx
  80dfd5:	85 db                	test   %ebx,%ebx
  80dfd7:	75 d2                	jne    80dfab <jif_input+0x51>
  80dfd9:	eb 61                	jmp    80e03c <jif_input+0xe2>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80dfdb:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80dfde:	89 54 24 04          	mov    %edx,0x4(%esp)
  80dfe2:	8b 45 08             	mov    0x8(%ebp),%eax
  80dfe5:	89 04 24             	mov    %eax,(%esp)
  80dfe8:	e8 8c ec ff ff       	call   80cc79 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80dfed:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80dff4:	ff 
  80dff5:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80dff8:	89 14 24             	mov    %edx,(%esp)
  80dffb:	e8 13 96 ff ff       	call   807613 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80e000:	8b 45 08             	mov    0x8(%ebp),%eax
  80e003:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e007:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e00a:	89 14 24             	mov    %edx,(%esp)
  80e00d:	ff 50 10             	call   *0x10(%eax)
	break;
  80e010:	eb 50                	jmp    80e062 <jif_input+0x108>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80e012:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80e015:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e019:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80e01c:	8b 02                	mov    (%edx),%eax
  80e01e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e022:	8b 45 08             	mov    0x8(%ebp),%eax
  80e025:	89 04 24             	mov    %eax,(%esp)
  80e028:	e8 9a ec ff ff       	call   80ccc7 <etharp_arp_input>
	break;
  80e02d:	eb 33                	jmp    80e062 <jif_input+0x108>

    default:
	pbuf_free(p);
  80e02f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e032:	89 14 24             	mov    %edx,(%esp)
  80e035:	e8 43 99 ff ff       	call   80797d <pbuf_free>
  80e03a:	eb 26                	jmp    80e062 <jif_input+0x108>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80e03c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e03f:	8b 42 04             	mov    0x4(%edx),%eax
  80e042:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80e046:	89 04 24             	mov    %eax,(%esp)
  80e049:	e8 25 c7 ff ff       	call   80a773 <htons>
  80e04e:	66 3d 00 08          	cmp    $0x800,%ax
  80e052:	74 87                	je     80dfdb <jif_input+0x81>
  80e054:	66 3d 06 08          	cmp    $0x806,%ax
  80e058:	75 d5                	jne    80e02f <jif_input+0xd5>
  80e05a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80e060:	eb b0                	jmp    80e012 <jif_input+0xb8>
	break;

    default:
	pbuf_free(p);
    }
}
  80e062:	83 c4 2c             	add    $0x2c,%esp
  80e065:	5b                   	pop    %ebx
  80e066:	5e                   	pop    %esi
  80e067:	5f                   	pop    %edi
  80e068:	5d                   	pop    %ebp
  80e069:	c3                   	ret    
  80e06a:	00 00                	add    %al,(%eax)
  80e06c:	00 00                	add    %al,(%eax)
	...

0080e070 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80e070:	55                   	push   %ebp
  80e071:	89 e5                	mov    %esp,%ebp
  80e073:	83 ec 18             	sub    $0x18,%esp
  80e076:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80e079:	85 c0                	test   %eax,%eax
  80e07b:	75 1c                	jne    80e099 <netconn_type+0x29>
  80e07d:	c7 44 24 08 d1 44 81 	movl   $0x8144d1,0x8(%esp)
  80e084:	00 
  80e085:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80e08c:	00 
  80e08d:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e094:	e8 7b 28 ff ff       	call   800914 <_panic>
  80e099:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80e09b:	c9                   	leave  
  80e09c:	c3                   	ret    

0080e09d <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80e09d:	55                   	push   %ebp
  80e09e:	89 e5                	mov    %esp,%ebp
  80e0a0:	53                   	push   %ebx
  80e0a1:	83 ec 34             	sub    $0x34,%esp
  80e0a4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e0a7:	85 db                	test   %ebx,%ebx
  80e0a9:	75 1c                	jne    80e0c7 <netconn_close+0x2a>
  80e0ab:	c7 44 24 08 03 45 81 	movl   $0x814503,0x8(%esp)
  80e0b2:	00 
  80e0b3:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80e0ba:	00 
  80e0bb:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e0c2:	e8 4d 28 ff ff       	call   800914 <_panic>

  msg.function = do_close;
  80e0c7:	c7 45 e4 af ea 80 00 	movl   $0x80eaaf,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e0ce:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80e0d1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e0d4:	89 04 24             	mov    %eax,(%esp)
  80e0d7:	e8 ab 6b ff ff       	call   804c87 <tcpip_apimsg>
  80e0dc:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e0e0:	83 c4 34             	add    $0x34,%esp
  80e0e3:	5b                   	pop    %ebx
  80e0e4:	5d                   	pop    %ebp
  80e0e5:	c3                   	ret    

0080e0e6 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80e0e6:	55                   	push   %ebp
  80e0e7:	89 e5                	mov    %esp,%ebp
  80e0e9:	53                   	push   %ebx
  80e0ea:	83 ec 34             	sub    $0x34,%esp
  80e0ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e0f0:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e0f4:	85 db                	test   %ebx,%ebx
  80e0f6:	75 1c                	jne    80e114 <netconn_write+0x2e>
  80e0f8:	c7 44 24 08 1f 45 81 	movl   $0x81451f,0x8(%esp)
  80e0ff:	00 
  80e100:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80e107:	00 
  80e108:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e10f:	e8 00 28 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80e114:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e117:	74 1c                	je     80e135 <netconn_write+0x4f>
  80e119:	c7 44 24 08 6c 46 81 	movl   $0x81466c,0x8(%esp)
  80e120:	00 
  80e121:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80e128:	00 
  80e129:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e130:	e8 df 27 ff ff       	call   800914 <_panic>

  msg.function = do_write;
  80e135:	c7 45 e4 2e ee 80 00 	movl   $0x80ee2e,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e13c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80e13f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e142:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80e145:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80e148:	8b 45 10             	mov    0x10(%ebp),%eax
  80e14b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80e14e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e151:	89 04 24             	mov    %eax,(%esp)
  80e154:	e8 2e 6b ff ff       	call   804c87 <tcpip_apimsg>
  80e159:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e15d:	83 c4 34             	add    $0x34,%esp
  80e160:	5b                   	pop    %ebx
  80e161:	5d                   	pop    %ebp
  80e162:	c3                   	ret    

0080e163 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80e163:	55                   	push   %ebp
  80e164:	89 e5                	mov    %esp,%ebp
  80e166:	53                   	push   %ebx
  80e167:	83 ec 34             	sub    $0x34,%esp
  80e16a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e16d:	85 db                	test   %ebx,%ebx
  80e16f:	75 1c                	jne    80e18d <netconn_send+0x2a>
  80e171:	c7 44 24 08 3b 45 81 	movl   $0x81453b,0x8(%esp)
  80e178:	00 
  80e179:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80e180:	00 
  80e181:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e188:	e8 87 27 ff ff       	call   800914 <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80e18d:	c7 45 e4 bc ee 80 00 	movl   $0x80eebc,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e194:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80e197:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e19a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80e19d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e1a0:	89 04 24             	mov    %eax,(%esp)
  80e1a3:	e8 df 6a ff ff       	call   804c87 <tcpip_apimsg>
  80e1a8:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e1ac:	83 c4 34             	add    $0x34,%esp
  80e1af:	5b                   	pop    %ebx
  80e1b0:	5d                   	pop    %ebp
  80e1b1:	c3                   	ret    

0080e1b2 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80e1b2:	55                   	push   %ebp
  80e1b3:	89 e5                	mov    %esp,%ebp
  80e1b5:	83 ec 18             	sub    $0x18,%esp
  80e1b8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e1bb:	0f b7 4d 14          	movzwl 0x14(%ebp),%ecx
  if (buf != NULL) {
  80e1bf:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80e1c4:	85 d2                	test   %edx,%edx
  80e1c6:	74 19                	je     80e1e1 <netconn_sendto+0x2f>
    buf->addr = addr;
  80e1c8:	8b 45 10             	mov    0x10(%ebp),%eax
  80e1cb:	89 42 08             	mov    %eax,0x8(%edx)
    buf->port = port;
  80e1ce:	66 89 4a 0c          	mov    %cx,0xc(%edx)
    return netconn_send(conn, buf);
  80e1d2:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e1d6:	8b 45 08             	mov    0x8(%ebp),%eax
  80e1d9:	89 04 24             	mov    %eax,(%esp)
  80e1dc:	e8 82 ff ff ff       	call   80e163 <netconn_send>
  }
  return ERR_VAL;
}
  80e1e1:	c9                   	leave  
  80e1e2:	c3                   	ret    

0080e1e3 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80e1e3:	55                   	push   %ebp
  80e1e4:	89 e5                	mov    %esp,%ebp
  80e1e6:	53                   	push   %ebx
  80e1e7:	83 ec 34             	sub    $0x34,%esp
  80e1ea:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80e1ed:	85 db                	test   %ebx,%ebx
  80e1ef:	75 1c                	jne    80e20d <netconn_listen_with_backlog+0x2a>
  80e1f1:	c7 44 24 08 56 45 81 	movl   $0x814556,0x8(%esp)
  80e1f8:	00 
  80e1f9:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80e200:	00 
  80e201:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e208:	e8 07 27 ff ff       	call   800914 <_panic>

  msg.function = do_listen;
  80e20d:	c7 45 e4 7f ef 80 00 	movl   $0x80ef7f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e214:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80e217:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e21a:	89 04 24             	mov    %eax,(%esp)
  80e21d:	e8 65 6a ff ff       	call   804c87 <tcpip_apimsg>
  80e222:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e226:	83 c4 34             	add    $0x34,%esp
  80e229:	5b                   	pop    %ebx
  80e22a:	5d                   	pop    %ebp
  80e22b:	c3                   	ret    

0080e22c <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80e22c:	55                   	push   %ebp
  80e22d:	89 e5                	mov    %esp,%ebp
  80e22f:	53                   	push   %ebx
  80e230:	83 ec 34             	sub    $0x34,%esp
  80e233:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e236:	85 db                	test   %ebx,%ebx
  80e238:	75 1c                	jne    80e256 <netconn_disconnect+0x2a>
  80e23a:	c7 44 24 08 90 46 81 	movl   $0x814690,0x8(%esp)
  80e241:	00 
  80e242:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80e249:	00 
  80e24a:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e251:	e8 be 26 ff ff       	call   800914 <_panic>

  msg.function = do_disconnect;
  80e256:	c7 45 e4 49 f1 80 00 	movl   $0x80f149,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e25d:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80e260:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e263:	89 04 24             	mov    %eax,(%esp)
  80e266:	e8 1c 6a ff ff       	call   804c87 <tcpip_apimsg>
  80e26b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e26f:	83 c4 34             	add    $0x34,%esp
  80e272:	5b                   	pop    %ebx
  80e273:	5d                   	pop    %ebp
  80e274:	c3                   	ret    

0080e275 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e275:	55                   	push   %ebp
  80e276:	89 e5                	mov    %esp,%ebp
  80e278:	53                   	push   %ebx
  80e279:	83 ec 34             	sub    $0x34,%esp
  80e27c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e27f:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e283:	85 db                	test   %ebx,%ebx
  80e285:	75 1c                	jne    80e2a3 <netconn_connect+0x2e>
  80e287:	c7 44 24 08 73 45 81 	movl   $0x814573,0x8(%esp)
  80e28e:	00 
  80e28f:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80e296:	00 
  80e297:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e29e:	e8 71 26 ff ff       	call   800914 <_panic>

  msg.function = do_connect;
  80e2a3:	c7 45 e4 80 f1 80 00 	movl   $0x80f180,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e2aa:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e2ad:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e2b0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80e2b3:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80e2b7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e2ba:	89 04 24             	mov    %eax,(%esp)
  80e2bd:	e8 c5 69 ff ff       	call   804c87 <tcpip_apimsg>
  80e2c2:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e2c6:	83 c4 34             	add    $0x34,%esp
  80e2c9:	5b                   	pop    %ebx
  80e2ca:	5d                   	pop    %ebp
  80e2cb:	c3                   	ret    

0080e2cc <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e2cc:	55                   	push   %ebp
  80e2cd:	89 e5                	mov    %esp,%ebp
  80e2cf:	53                   	push   %ebx
  80e2d0:	83 ec 34             	sub    $0x34,%esp
  80e2d3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e2d6:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80e2da:	85 db                	test   %ebx,%ebx
  80e2dc:	75 1c                	jne    80e2fa <netconn_bind+0x2e>
  80e2de:	c7 44 24 08 91 45 81 	movl   $0x814591,0x8(%esp)
  80e2e5:	00 
  80e2e6:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80e2ed:	00 
  80e2ee:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e2f5:	e8 1a 26 ff ff       	call   800914 <_panic>

  msg.function = do_bind;
  80e2fa:	c7 45 e4 48 f2 80 00 	movl   $0x80f248,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e301:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e304:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e307:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80e30a:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80e30e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e311:	89 04 24             	mov    %eax,(%esp)
  80e314:	e8 6e 69 ff ff       	call   804c87 <tcpip_apimsg>
  80e319:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e31d:	83 c4 34             	add    $0x34,%esp
  80e320:	5b                   	pop    %ebx
  80e321:	5d                   	pop    %ebp
  80e322:	c3                   	ret    

0080e323 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80e323:	55                   	push   %ebp
  80e324:	89 e5                	mov    %esp,%ebp
  80e326:	53                   	push   %ebx
  80e327:	83 ec 34             	sub    $0x34,%esp
  80e32a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e32d:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e330:	8b 45 10             	mov    0x10(%ebp),%eax
  80e333:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80e337:	85 db                	test   %ebx,%ebx
  80e339:	75 1c                	jne    80e357 <netconn_getaddr+0x34>
  80e33b:	c7 44 24 08 ac 45 81 	movl   $0x8145ac,0x8(%esp)
  80e342:	00 
  80e343:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80e34a:	00 
  80e34b:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e352:	e8 bd 25 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80e357:	85 d2                	test   %edx,%edx
  80e359:	75 1c                	jne    80e377 <netconn_getaddr+0x54>
  80e35b:	c7 44 24 08 ca 45 81 	movl   $0x8145ca,0x8(%esp)
  80e362:	00 
  80e363:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80e36a:	00 
  80e36b:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e372:	e8 9d 25 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80e377:	85 c0                	test   %eax,%eax
  80e379:	75 1c                	jne    80e397 <netconn_getaddr+0x74>
  80e37b:	c7 44 24 08 e8 45 81 	movl   $0x8145e8,0x8(%esp)
  80e382:	00 
  80e383:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80e38a:	00 
  80e38b:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e392:	e8 7d 25 ff ff       	call   800914 <_panic>

  msg.function = do_getaddr;
  80e397:	c7 45 e4 40 e7 80 00 	movl   $0x80e740,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e39e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80e3a1:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80e3a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80e3a7:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80e3aa:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e3ad:	89 04 24             	mov    %eax,(%esp)
  80e3b0:	e8 d2 68 ff ff       	call   804c87 <tcpip_apimsg>
  80e3b5:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax

  return conn->err;
}
  80e3b9:	83 c4 34             	add    $0x34,%esp
  80e3bc:	5b                   	pop    %ebx
  80e3bd:	5d                   	pop    %ebp
  80e3be:	c3                   	ret    

0080e3bf <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80e3bf:	55                   	push   %ebp
  80e3c0:	89 e5                	mov    %esp,%ebp
  80e3c2:	53                   	push   %ebx
  80e3c3:	83 ec 24             	sub    $0x24,%esp
  80e3c6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80e3c9:	85 db                	test   %ebx,%ebx
  80e3cb:	75 1c                	jne    80e3e9 <netconn_accept+0x2a>
  80e3cd:	c7 44 24 08 06 46 81 	movl   $0x814606,0x8(%esp)
  80e3d4:	00 
  80e3d5:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80e3dc:	00 
  80e3dd:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e3e4:	e8 2b 25 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80e3e9:	8b 43 18             	mov    0x18(%ebx),%eax
  80e3ec:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e3ef:	75 1c                	jne    80e40d <netconn_accept+0x4e>
  80e3f1:	c7 44 24 08 b4 46 81 	movl   $0x8146b4,0x8(%esp)
  80e3f8:	00 
  80e3f9:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80e400:	00 
  80e401:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e408:	e8 07 25 ff ff       	call   800914 <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80e40d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e414:	00 
  80e415:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80e418:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e41c:	89 04 24             	mov    %eax,(%esp)
  80e41f:	e8 cf f2 ff ff       	call   80d6f3 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80e424:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80e427:	85 c0                	test   %eax,%eax
  80e429:	74 15                	je     80e440 <netconn_accept+0x81>
  80e42b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e432:	00 
  80e433:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e43a:	00 
  80e43b:	89 1c 24             	mov    %ebx,(%esp)
  80e43e:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80e440:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80e443:	83 c4 24             	add    $0x24,%esp
  80e446:	5b                   	pop    %ebx
  80e447:	5d                   	pop    %ebp
  80e448:	c3                   	ret    

0080e449 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80e449:	55                   	push   %ebp
  80e44a:	89 e5                	mov    %esp,%ebp
  80e44c:	53                   	push   %ebx
  80e44d:	83 ec 34             	sub    $0x34,%esp
  80e450:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80e453:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80e45a:	85 db                	test   %ebx,%ebx
  80e45c:	75 1c                	jne    80e47a <netconn_recv+0x31>
  80e45e:	c7 44 24 08 23 46 81 	movl   $0x814623,0x8(%esp)
  80e465:	00 
  80e466:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80e46d:	00 
  80e46e:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e475:	e8 9a 24 ff ff       	call   800914 <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80e47a:	8b 43 14             	mov    0x14(%ebx),%eax
  80e47d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e480:	75 0e                	jne    80e490 <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80e482:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80e486:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  80e48b:	e9 65 01 00 00       	jmp    80e5f5 <netconn_recv+0x1ac>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80e490:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80e494:	0f 8c 56 01 00 00    	jl     80e5f0 <netconn_recv+0x1a7>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80e49a:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e49d:	8d 76 00             	lea    0x0(%esi),%esi
  80e4a0:	0f 85 fc 00 00 00    	jne    80e5a2 <netconn_recv+0x159>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80e4a6:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80e4aa:	75 0e                	jne    80e4ba <netconn_recv+0x71>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80e4ac:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80e4b0:	b8 00 00 00 00       	mov    $0x0,%eax
      return NULL;
  80e4b5:	e9 3b 01 00 00       	jmp    80e5f5 <netconn_recv+0x1ac>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80e4ba:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80e4c1:	e8 72 8d ff ff       	call   807238 <memp_malloc>
  80e4c6:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80e4c9:	85 c0                	test   %eax,%eax
  80e4cb:	75 09                	jne    80e4d6 <netconn_recv+0x8d>
      conn->err = ERR_MEM;
  80e4cd:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80e4d1:	e9 1f 01 00 00       	jmp    80e5f5 <netconn_recv+0x1ac>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80e4d6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e4dd:	00 
  80e4de:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80e4e1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e4e5:	8b 43 14             	mov    0x14(%ebx),%eax
  80e4e8:	89 04 24             	mov    %eax,(%esp)
  80e4eb:	e8 03 f2 ff ff       	call   80d6f3 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80e4f0:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e4f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80e4f8:	85 d2                	test   %edx,%edx
  80e4fa:	74 08                	je     80e504 <netconn_recv+0xbb>
      len = p->tot_len;
  80e4fc:	0f b7 42 08          	movzwl 0x8(%edx),%eax
      SYS_ARCH_DEC(conn->recv_avail, len);
  80e500:	66 29 43 20          	sub    %ax,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80e504:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80e507:	85 d2                	test   %edx,%edx
  80e509:	74 14                	je     80e51f <netconn_recv+0xd6>
  80e50b:	0f b7 c0             	movzwl %ax,%eax
  80e50e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e512:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e519:	00 
  80e51a:	89 1c 24             	mov    %ebx,(%esp)
  80e51d:	ff d2                	call   *%edx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80e51f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80e522:	85 c0                	test   %eax,%eax
  80e524:	75 2b                	jne    80e551 <netconn_recv+0x108>
      memp_free(MEMP_NETBUF, buf);
  80e526:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e529:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e52d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80e534:	e8 bb 8c ff ff       	call   8071f4 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80e539:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80e53d:	0f 85 ad 00 00 00    	jne    80e5f0 <netconn_recv+0x1a7>
        conn->err = ERR_CLSD;
  80e543:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80e547:	b8 00 00 00 00       	mov    $0x0,%eax
  80e54c:	e9 a4 00 00 00       	jmp    80e5f5 <netconn_recv+0x1ac>
      }
      return NULL;
    }

    buf->p = p;
  80e551:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e554:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80e556:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e559:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e55c:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80e55f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e562:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80e568:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e56b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80e572:	c7 45 e4 7b ee 80 00 	movl   $0x80ee7b,-0x1c(%ebp)
    msg.msg.conn = conn;
  80e579:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80e57c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e57f:	85 c0                	test   %eax,%eax
  80e581:	74 0c                	je     80e58f <netconn_recv+0x146>
      msg.msg.msg.r.len = buf->p->tot_len;
  80e583:	8b 00                	mov    (%eax),%eax
  80e585:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e589:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80e58d:	eb 06                	jmp    80e595 <netconn_recv+0x14c>
    } else {
      msg.msg.msg.r.len = 1;
  80e58f:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80e595:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e598:	89 04 24             	mov    %eax,(%esp)
  80e59b:	e8 e7 66 ff ff       	call   804c87 <tcpip_apimsg>
  80e5a0:	eb 49                	jmp    80e5eb <netconn_recv+0x1a2>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80e5a2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e5a9:	00 
  80e5aa:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80e5ad:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e5b1:	89 04 24             	mov    %eax,(%esp)
  80e5b4:	e8 3a f1 ff ff       	call   80d6f3 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80e5b9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e5bc:	85 c0                	test   %eax,%eax
  80e5be:	74 2b                	je     80e5eb <netconn_recv+0x1a2>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80e5c0:	8b 00                	mov    (%eax),%eax
  80e5c2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e5c6:	66 29 43 20          	sub    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80e5ca:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80e5cd:	85 c0                	test   %eax,%eax
  80e5cf:	74 1a                	je     80e5eb <netconn_recv+0x1a2>
  80e5d1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e5d4:	8b 12                	mov    (%edx),%edx
  80e5d6:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80e5da:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e5de:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e5e5:	00 
  80e5e6:	89 1c 24             	mov    %ebx,(%esp)
  80e5e9:	ff d0                	call   *%eax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80e5eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e5ee:	eb 05                	jmp    80e5f5 <netconn_recv+0x1ac>
  80e5f0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e5f5:	83 c4 34             	add    $0x34,%esp
  80e5f8:	5b                   	pop    %ebx
  80e5f9:	5d                   	pop    %ebp
  80e5fa:	c3                   	ret    

0080e5fb <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80e5fb:	55                   	push   %ebp
  80e5fc:	89 e5                	mov    %esp,%ebp
  80e5fe:	53                   	push   %ebx
  80e5ff:	83 ec 34             	sub    $0x34,%esp
  80e602:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80e605:	85 db                	test   %ebx,%ebx
  80e607:	74 24                	je     80e62d <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80e609:	c7 45 e4 e9 f2 80 00 	movl   $0x80f2e9,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e610:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80e613:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e616:	89 04 24             	mov    %eax,(%esp)
  80e619:	e8 69 66 ff ff       	call   804c87 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80e61e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80e625:	89 1c 24             	mov    %ebx,(%esp)
  80e628:	e8 74 0d 00 00       	call   80f3a1 <netconn_free>

  return ERR_OK;
}
  80e62d:	b8 00 00 00 00       	mov    $0x0,%eax
  80e632:	83 c4 34             	add    $0x34,%esp
  80e635:	5b                   	pop    %ebx
  80e636:	5d                   	pop    %ebp
  80e637:	c3                   	ret    

0080e638 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80e638:	55                   	push   %ebp
  80e639:	89 e5                	mov    %esp,%ebp
  80e63b:	56                   	push   %esi
  80e63c:	53                   	push   %ebx
  80e63d:	83 ec 30             	sub    $0x30,%esp
  80e640:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80e644:	8b 45 10             	mov    0x10(%ebp),%eax
  80e647:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e64b:	8b 45 08             	mov    0x8(%ebp),%eax
  80e64e:	89 04 24             	mov    %eax,(%esp)
  80e651:	e8 47 0f 00 00       	call   80f59d <netconn_alloc>
  80e656:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80e658:	85 c0                	test   %eax,%eax
  80e65a:	0f 84 d6 00 00 00    	je     80e736 <netconn_new_with_proto_and_callback+0xfe>
    msg.function = do_newconn;
  80e660:	c7 45 e4 0a f7 80 00 	movl   $0x80f70a,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80e667:	89 f0                	mov    %esi,%eax
  80e669:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80e66c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80e66f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e672:	89 04 24             	mov    %eax,(%esp)
  80e675:	e8 0d 66 ff ff       	call   804c87 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80e67a:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80e67e:	0f 84 b2 00 00 00    	je     80e736 <netconn_new_with_proto_and_callback+0xfe>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80e684:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80e688:	74 1c                	je     80e6a6 <netconn_new_with_proto_and_callback+0x6e>
  80e68a:	c7 44 24 08 d8 46 81 	movl   $0x8146d8,0x8(%esp)
  80e691:	00 
  80e692:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80e699:	00 
  80e69a:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e6a1:	e8 6e 22 ff ff       	call   800914 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80e6a6:	8b 43 10             	mov    0x10(%ebx),%eax
  80e6a9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e6ac:	75 1c                	jne    80e6ca <netconn_new_with_proto_and_callback+0x92>
  80e6ae:	c7 44 24 08 3e 46 81 	movl   $0x81463e,0x8(%esp)
  80e6b5:	00 
  80e6b6:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80e6bd:	00 
  80e6be:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e6c5:	e8 4a 22 ff ff       	call   800914 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80e6ca:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80e6ce:	75 1c                	jne    80e6ec <netconn_new_with_proto_and_callback+0xb4>
  80e6d0:	c7 44 24 08 57 46 81 	movl   $0x814657,0x8(%esp)
  80e6d7:	00 
  80e6d8:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80e6df:	00 
  80e6e0:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e6e7:	e8 28 22 ff ff       	call   800914 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80e6ec:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80e6f0:	74 1c                	je     80e70e <netconn_new_with_proto_and_callback+0xd6>
  80e6f2:	c7 44 24 08 fc 46 81 	movl   $0x8146fc,0x8(%esp)
  80e6f9:	00 
  80e6fa:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80e701:	00 
  80e702:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e709:	e8 06 22 ff ff       	call   800914 <_panic>
      sys_sem_free(conn->op_completed);
  80e70e:	89 04 24             	mov    %eax,(%esp)
  80e711:	e8 ed e8 ff ff       	call   80d003 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80e716:	8b 43 14             	mov    0x14(%ebx),%eax
  80e719:	89 04 24             	mov    %eax,(%esp)
  80e71c:	e8 72 e9 ff ff       	call   80d093 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80e721:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e725:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80e72c:	e8 c3 8a ff ff       	call   8071f4 <memp_free>
  80e731:	bb 00 00 00 00       	mov    $0x0,%ebx
      return NULL;
    }
  }
  return conn;
}
  80e736:	89 d8                	mov    %ebx,%eax
  80e738:	83 c4 30             	add    $0x30,%esp
  80e73b:	5b                   	pop    %ebx
  80e73c:	5e                   	pop    %esi
  80e73d:	5d                   	pop    %ebp
  80e73e:	c3                   	ret    
	...

0080e740 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80e740:	55                   	push   %ebp
  80e741:	89 e5                	mov    %esp,%ebp
  80e743:	83 ec 18             	sub    $0x18,%esp
  80e746:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80e749:	8b 08                	mov    (%eax),%ecx
  80e74b:	8b 51 08             	mov    0x8(%ecx),%edx
  80e74e:	85 d2                	test   %edx,%edx
  80e750:	0f 84 9f 00 00 00    	je     80e7f5 <do_getaddr+0xb5>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80e756:	8b 48 04             	mov    0x4(%eax),%ecx
  80e759:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80e75d:	74 06                	je     80e765 <do_getaddr+0x25>
  80e75f:	8b 12                	mov    (%edx),%edx
  80e761:	89 11                	mov    %edx,(%ecx)
  80e763:	eb 05                	jmp    80e76a <do_getaddr+0x2a>
  80e765:	8b 52 04             	mov    0x4(%edx),%edx
  80e768:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80e76a:	8b 08                	mov    (%eax),%ecx
  80e76c:	8b 11                	mov    (%ecx),%edx
  80e76e:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80e774:	83 fa 20             	cmp    $0x20,%edx
  80e777:	74 2e                	je     80e7a7 <do_getaddr+0x67>
  80e779:	83 fa 40             	cmp    $0x40,%edx
  80e77c:	74 0c                	je     80e78a <do_getaddr+0x4a>
  80e77e:	83 fa 10             	cmp    $0x10,%edx
  80e781:	75 76                	jne    80e7f9 <do_getaddr+0xb9>
  80e783:	90                   	nop
  80e784:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80e788:	eb 4d                	jmp    80e7d7 <do_getaddr+0x97>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80e78a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80e78e:	66 90                	xchg   %ax,%ax
  80e790:	74 0f                	je     80e7a1 <do_getaddr+0x61>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80e792:	8b 50 08             	mov    0x8(%eax),%edx
  80e795:	8b 49 08             	mov    0x8(%ecx),%ecx
  80e798:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80e79c:	66 89 0a             	mov    %cx,(%edx)
  80e79f:	eb 58                	jmp    80e7f9 <do_getaddr+0xb9>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80e7a1:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80e7a5:	eb 52                	jmp    80e7f9 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80e7a7:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80e7ab:	74 0f                	je     80e7bc <do_getaddr+0x7c>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80e7ad:	8b 50 08             	mov    0x8(%eax),%edx
  80e7b0:	8b 49 08             	mov    0x8(%ecx),%ecx
  80e7b3:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80e7b7:	66 89 0a             	mov    %cx,(%edx)
  80e7ba:	eb 3d                	jmp    80e7f9 <do_getaddr+0xb9>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80e7bc:	8b 51 08             	mov    0x8(%ecx),%edx
  80e7bf:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80e7c3:	75 06                	jne    80e7cb <do_getaddr+0x8b>
          msg->conn->err = ERR_CONN;
  80e7c5:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80e7c9:	eb 2e                	jmp    80e7f9 <do_getaddr+0xb9>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80e7cb:	8b 48 08             	mov    0x8(%eax),%ecx
  80e7ce:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80e7d2:	66 89 11             	mov    %dx,(%ecx)
  80e7d5:	eb 22                	jmp    80e7f9 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80e7d7:	8b 50 08             	mov    0x8(%eax),%edx
  80e7da:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80e7de:	74 09                	je     80e7e9 <do_getaddr+0xa9>
  80e7e0:	8b 49 08             	mov    0x8(%ecx),%ecx
  80e7e3:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80e7e7:	eb 07                	jmp    80e7f0 <do_getaddr+0xb0>
  80e7e9:	8b 49 08             	mov    0x8(%ecx),%ecx
  80e7ec:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80e7f0:	66 89 0a             	mov    %cx,(%edx)
  80e7f3:	eb 04                	jmp    80e7f9 <do_getaddr+0xb9>
      break;
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80e7f5:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80e7f9:	8b 00                	mov    (%eax),%eax
  80e7fb:	8b 40 10             	mov    0x10(%eax),%eax
  80e7fe:	89 04 24             	mov    %eax,(%esp)
  80e801:	e8 61 ee ff ff       	call   80d667 <sys_sem_signal>
}
  80e806:	c9                   	leave  
  80e807:	c3                   	ret    

0080e808 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80e808:	55                   	push   %ebp
  80e809:	89 e5                	mov    %esp,%ebp
  80e80b:	53                   	push   %ebx
  80e80c:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80e80f:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80e812:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e816:	89 1c 24             	mov    %ebx,(%esp)
  80e819:	e8 ca 9a ff ff       	call   8082e8 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80e81e:	c7 44 24 04 70 f0 80 	movl   $0x80f070,0x4(%esp)
  80e825:	00 
  80e826:	89 1c 24             	mov    %ebx,(%esp)
  80e829:	e8 c8 9a ff ff       	call   8082f6 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80e82e:	c7 44 24 04 7c ed 80 	movl   $0x80ed7c,0x4(%esp)
  80e835:	00 
  80e836:	89 1c 24             	mov    %ebx,(%esp)
  80e839:	e8 c9 9a ff ff       	call   808307 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80e83e:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80e845:	00 
  80e846:	c7 44 24 04 2a ed 80 	movl   $0x80ed2a,0x4(%esp)
  80e84d:	00 
  80e84e:	89 1c 24             	mov    %ebx,(%esp)
  80e851:	e8 e1 9a ff ff       	call   808337 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80e856:	c7 44 24 04 e8 ea 80 	movl   $0x80eae8,0x4(%esp)
  80e85d:	00 
  80e85e:	89 1c 24             	mov    %ebx,(%esp)
  80e861:	e8 b2 9a ff ff       	call   808318 <tcp_err>
}
  80e866:	83 c4 14             	add    $0x14,%esp
  80e869:	5b                   	pop    %ebx
  80e86a:	5d                   	pop    %ebp
  80e86b:	c3                   	ret    

0080e86c <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80e86c:	55                   	push   %ebp
  80e86d:	89 e5                	mov    %esp,%ebp
  80e86f:	53                   	push   %ebx
  80e870:	83 ec 14             	sub    $0x14,%esp
  80e873:	0f b6 55 10          	movzbl 0x10(%ebp),%edx
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  80e877:	8b 5d 08             	mov    0x8(%ebp),%ebx

  if (conn == NULL) {
  80e87a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80e87f:	85 db                	test   %ebx,%ebx
  80e881:	74 2a                	je     80e8ad <do_connected+0x41>
    return ERR_VAL;
  }

  conn->err = err;
  80e883:	88 53 0c             	mov    %dl,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80e886:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e889:	75 0b                	jne    80e896 <do_connected+0x2a>
  80e88b:	84 d2                	test   %dl,%dl
  80e88d:	75 07                	jne    80e896 <do_connected+0x2a>
    setup_tcp(conn);
  80e88f:	89 d8                	mov    %ebx,%eax
  80e891:	e8 72 ff ff ff       	call   80e808 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80e896:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80e89d:	8b 43 10             	mov    0x10(%ebx),%eax
  80e8a0:	89 04 24             	mov    %eax,(%esp)
  80e8a3:	e8 bf ed ff ff       	call   80d667 <sys_sem_signal>
  80e8a8:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80e8ad:	83 c4 14             	add    $0x14,%esp
  80e8b0:	5b                   	pop    %ebx
  80e8b1:	5d                   	pop    %ebp
  80e8b2:	c3                   	ret    

0080e8b3 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80e8b3:	55                   	push   %ebp
  80e8b4:	89 e5                	mov    %esp,%ebp
  80e8b6:	53                   	push   %ebx
  80e8b7:	83 ec 14             	sub    $0x14,%esp
  80e8ba:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80e8bc:	85 c0                	test   %eax,%eax
  80e8be:	75 1c                	jne    80e8dc <do_close_internal+0x29>
  80e8c0:	c7 44 24 08 49 45 81 	movl   $0x814549,0x8(%esp)
  80e8c7:	00 
  80e8c8:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80e8cf:	00 
  80e8d0:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80e8d7:	e8 38 20 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80e8dc:	83 38 10             	cmpl   $0x10,(%eax)
  80e8df:	74 1c                	je     80e8fd <do_close_internal+0x4a>
  80e8e1:	c7 44 24 08 34 47 81 	movl   $0x814734,0x8(%esp)
  80e8e8:	00 
  80e8e9:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80e8f0:	00 
  80e8f1:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80e8f8:	e8 17 20 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80e8fd:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80e901:	74 1c                	je     80e91f <do_close_internal+0x6c>
  80e903:	c7 44 24 08 00 48 81 	movl   $0x814800,0x8(%esp)
  80e90a:	00 
  80e90b:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80e912:	00 
  80e913:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80e91a:	e8 f5 1f ff ff       	call   800914 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80e91f:	8b 40 08             	mov    0x8(%eax),%eax
  80e922:	85 c0                	test   %eax,%eax
  80e924:	75 1c                	jne    80e942 <do_close_internal+0x8f>
  80e926:	c7 44 24 08 52 47 81 	movl   $0x814752,0x8(%esp)
  80e92d:	00 
  80e92e:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80e935:	00 
  80e936:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80e93d:	e8 d2 1f ff ff       	call   800914 <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80e942:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e949:	00 
  80e94a:	89 04 24             	mov    %eax,(%esp)
  80e94d:	e8 96 99 ff ff       	call   8082e8 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80e952:	8b 43 08             	mov    0x8(%ebx),%eax
  80e955:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80e959:	75 12                	jne    80e96d <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80e95b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e962:	00 
  80e963:	89 04 24             	mov    %eax,(%esp)
  80e966:	e8 be 99 ff ff       	call   808329 <tcp_accept>
  80e96b:	eb 64                	jmp    80e9d1 <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80e96d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e974:	00 
  80e975:	89 04 24             	mov    %eax,(%esp)
  80e978:	e8 79 99 ff ff       	call   8082f6 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80e97d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e984:	00 
  80e985:	8b 43 08             	mov    0x8(%ebx),%eax
  80e988:	89 04 24             	mov    %eax,(%esp)
  80e98b:	e8 99 99 ff ff       	call   808329 <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80e990:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e997:	00 
  80e998:	8b 43 08             	mov    0x8(%ebx),%eax
  80e99b:	89 04 24             	mov    %eax,(%esp)
  80e99e:	e8 64 99 ff ff       	call   808307 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80e9a3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80e9aa:	00 
  80e9ab:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e9b2:	00 
  80e9b3:	8b 43 08             	mov    0x8(%ebx),%eax
  80e9b6:	89 04 24             	mov    %eax,(%esp)
  80e9b9:	e8 79 99 ff ff       	call   808337 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80e9be:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e9c5:	00 
  80e9c6:	8b 43 08             	mov    0x8(%ebx),%eax
  80e9c9:	89 04 24             	mov    %eax,(%esp)
  80e9cc:	e8 47 99 ff ff       	call   808318 <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80e9d1:	8b 43 08             	mov    0x8(%ebx),%eax
  80e9d4:	89 04 24             	mov    %eax,(%esp)
  80e9d7:	e8 ff a7 ff ff       	call   8091db <tcp_close>
  if (err == ERR_OK) {
  80e9dc:	84 c0                	test   %al,%al
  80e9de:	75 57                	jne    80ea37 <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80e9e0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80e9e7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80e9ee:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80e9f2:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80e9f5:	85 c0                	test   %eax,%eax
  80e9f7:	74 31                	je     80ea2a <do_close_internal+0x177>
  80e9f9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ea00:	00 
  80ea01:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ea08:	00 
  80ea09:	89 1c 24             	mov    %ebx,(%esp)
  80ea0c:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80ea0e:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ea11:	85 c0                	test   %eax,%eax
  80ea13:	74 15                	je     80ea2a <do_close_internal+0x177>
  80ea15:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ea1c:	00 
  80ea1d:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80ea24:	00 
  80ea25:	89 1c 24             	mov    %ebx,(%esp)
  80ea28:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80ea2a:	8b 43 10             	mov    0x10(%ebx),%eax
  80ea2d:	89 04 24             	mov    %eax,(%esp)
  80ea30:	e8 32 ec ff ff       	call   80d667 <sys_sem_signal>
  80ea35:	eb 72                	jmp    80eaa9 <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80ea37:	8b 43 08             	mov    0x8(%ebx),%eax
  80ea3a:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80ea3e:	75 1c                	jne    80ea5c <do_close_internal+0x1a9>
  80ea40:	c7 44 24 08 24 48 81 	movl   $0x814824,0x8(%esp)
  80ea47:	00 
  80ea48:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80ea4f:	00 
  80ea50:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80ea57:	e8 b8 1e ff ff       	call   800914 <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80ea5c:	c7 44 24 04 7c ed 80 	movl   $0x80ed7c,0x4(%esp)
  80ea63:	00 
  80ea64:	89 04 24             	mov    %eax,(%esp)
  80ea67:	e8 9b 98 ff ff       	call   808307 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80ea6c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ea73:	00 
  80ea74:	c7 44 24 04 2a ed 80 	movl   $0x80ed2a,0x4(%esp)
  80ea7b:	00 
  80ea7c:	8b 43 08             	mov    0x8(%ebx),%eax
  80ea7f:	89 04 24             	mov    %eax,(%esp)
  80ea82:	e8 b0 98 ff ff       	call   808337 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80ea87:	c7 44 24 04 e8 ea 80 	movl   $0x80eae8,0x4(%esp)
  80ea8e:	00 
  80ea8f:	8b 43 08             	mov    0x8(%ebx),%eax
  80ea92:	89 04 24             	mov    %eax,(%esp)
  80ea95:	e8 7e 98 ff ff       	call   808318 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80ea9a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ea9e:	8b 43 08             	mov    0x8(%ebx),%eax
  80eaa1:	89 04 24             	mov    %eax,(%esp)
  80eaa4:	e8 3f 98 ff ff       	call   8082e8 <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80eaa9:	83 c4 14             	add    $0x14,%esp
  80eaac:	5b                   	pop    %ebx
  80eaad:	5d                   	pop    %ebp
  80eaae:	c3                   	ret    

0080eaaf <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80eaaf:	55                   	push   %ebp
  80eab0:	89 e5                	mov    %esp,%ebp
  80eab2:	83 ec 18             	sub    $0x18,%esp
  80eab5:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80eab8:	8b 02                	mov    (%edx),%eax
  80eaba:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80eabe:	74 15                	je     80ead5 <do_close+0x26>
  80eac0:	83 38 10             	cmpl   $0x10,(%eax)
  80eac3:	75 10                	jne    80ead5 <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80eac5:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80eacc:	8b 02                	mov    (%edx),%eax
  80eace:	e8 e0 fd ff ff       	call   80e8b3 <do_close_internal>
 */
void
do_close(struct api_msg_msg *msg)
{
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80ead3:	eb 11                	jmp    80eae6 <do_close+0x37>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80ead5:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80ead9:	8b 02                	mov    (%edx),%eax
  80eadb:	8b 40 10             	mov    0x10(%eax),%eax
  80eade:	89 04 24             	mov    %eax,(%esp)
  80eae1:	e8 81 eb ff ff       	call   80d667 <sys_sem_signal>
  }
}
  80eae6:	c9                   	leave  
  80eae7:	c3                   	ret    

0080eae8 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80eae8:	55                   	push   %ebp
  80eae9:	89 e5                	mov    %esp,%ebp
  80eaeb:	53                   	push   %ebx
  80eaec:	83 ec 14             	sub    $0x14,%esp
  80eaef:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  80eaf3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80eaf6:	85 db                	test   %ebx,%ebx
  80eaf8:	75 1c                	jne    80eb16 <err_tcp+0x2e>
  80eafa:	c7 44 24 08 65 47 81 	movl   $0x814765,0x8(%esp)
  80eb01:	00 
  80eb02:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80eb09:	00 
  80eb0a:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80eb11:	e8 fe 1d ff ff       	call   800914 <_panic>

  conn->pcb.tcp = NULL;
  80eb16:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80eb1d:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80eb20:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80eb24:	74 2f                	je     80eb55 <err_tcp+0x6d>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80eb26:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eb29:	85 c0                	test   %eax,%eax
  80eb2b:	74 15                	je     80eb42 <err_tcp+0x5a>
  80eb2d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eb34:	00 
  80eb35:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eb3c:	00 
  80eb3d:	89 1c 24             	mov    %ebx,(%esp)
  80eb40:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80eb42:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eb49:	00 
  80eb4a:	8b 43 14             	mov    0x14(%ebx),%eax
  80eb4d:	89 04 24             	mov    %eax,(%esp)
  80eb50:	e8 90 ed ff ff       	call   80d8e5 <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80eb55:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  80eb59:	74 18                	je     80eb73 <err_tcp+0x8b>
  80eb5b:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80eb5f:	75 12                	jne    80eb73 <err_tcp+0x8b>
    conn->state = NETCONN_NONE;
  80eb61:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80eb68:	8b 43 10             	mov    0x10(%ebx),%eax
  80eb6b:	89 04 24             	mov    %eax,(%esp)
  80eb6e:	e8 f4 ea ff ff       	call   80d667 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80eb73:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80eb77:	74 2f                	je     80eba8 <err_tcp+0xc0>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80eb79:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eb7c:	85 c0                	test   %eax,%eax
  80eb7e:	74 15                	je     80eb95 <err_tcp+0xad>
  80eb80:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eb87:	00 
  80eb88:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eb8f:	00 
  80eb90:	89 1c 24             	mov    %ebx,(%esp)
  80eb93:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80eb95:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eb9c:	00 
  80eb9d:	8b 43 18             	mov    0x18(%ebx),%eax
  80eba0:	89 04 24             	mov    %eax,(%esp)
  80eba3:	e8 3d ed ff ff       	call   80d8e5 <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80eba8:	8b 43 04             	mov    0x4(%ebx),%eax
  80ebab:	83 f8 01             	cmp    $0x1,%eax
  80ebae:	74 05                	je     80ebb5 <err_tcp+0xcd>
  80ebb0:	83 f8 04             	cmp    $0x4,%eax
  80ebb3:	75 12                	jne    80ebc7 <err_tcp+0xdf>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80ebb5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80ebbc:	8b 43 10             	mov    0x10(%ebx),%eax
  80ebbf:	89 04 24             	mov    %eax,(%esp)
  80ebc2:	e8 a0 ea ff ff       	call   80d667 <sys_sem_signal>
  }
}
  80ebc7:	83 c4 14             	add    $0x14,%esp
  80ebca:	5b                   	pop    %ebx
  80ebcb:	5d                   	pop    %ebp
  80ebcc:	c3                   	ret    

0080ebcd <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80ebcd:	55                   	push   %ebp
  80ebce:	89 e5                	mov    %esp,%ebp
  80ebd0:	57                   	push   %edi
  80ebd1:	56                   	push   %esi
  80ebd2:	53                   	push   %ebx
  80ebd3:	83 ec 2c             	sub    $0x2c,%esp
  80ebd6:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80ebd8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80ebdc:	74 1c                	je     80ebfa <do_writemore+0x2d>
  80ebde:	c7 44 24 08 72 47 81 	movl   $0x814772,0x8(%esp)
  80ebe5:	00 
  80ebe6:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80ebed:	00 
  80ebee:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80ebf5:	e8 1a 1d ff ff       	call   800914 <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80ebfa:	8b 50 24             	mov    0x24(%eax),%edx
  80ebfd:	8b 42 04             	mov    0x4(%edx),%eax
  80ec00:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ec03:	8b 43 28             	mov    0x28(%ebx),%eax
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80ec06:	8b 72 08             	mov    0x8(%edx),%esi
  80ec09:	89 f1                	mov    %esi,%ecx
  80ec0b:	29 c1                	sub    %eax,%ecx
  80ec0d:	66 29 c6             	sub    %ax,%si
  80ec10:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80ec16:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80ec1b:	0f 4d f1             	cmovge %ecx,%esi
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80ec1e:	8b 4b 08             	mov    0x8(%ebx),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80ec21:	66 3b 71 6e          	cmp    0x6e(%ecx),%si
  80ec25:	0f b7 79 6e          	movzwl 0x6e(%ecx),%edi
  80ec29:	0f 47 f7             	cmova  %edi,%esi
  80ec2c:	0f b7 f6             	movzwl %si,%esi
  80ec2f:	0f b6 52 0c          	movzbl 0xc(%edx),%edx
  80ec33:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80ec37:	89 74 24 08          	mov    %esi,0x8(%esp)
  80ec3b:	03 45 e4             	add    -0x1c(%ebp),%eax
  80ec3e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ec42:	89 0c 24             	mov    %ecx,(%esp)
  80ec45:	e8 ef cd ff ff       	call   80ba39 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80ec4a:	89 f2                	mov    %esi,%edx
  80ec4c:	03 53 28             	add    0x28(%ebx),%edx
  80ec4f:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80ec52:	3b 51 08             	cmp    0x8(%ecx),%edx
  80ec55:	7e 1c                	jle    80ec73 <do_writemore+0xa6>
  80ec57:	c7 44 24 08 8f 47 81 	movl   $0x81478f,0x8(%esp)
  80ec5e:	00 
  80ec5f:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80ec66:	00 
  80ec67:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80ec6e:	e8 a1 1c ff ff       	call   800914 <_panic>
  if (err == ERR_OK) {
  80ec73:	84 c0                	test   %al,%al
  80ec75:	75 72                	jne    80ece9 <do_writemore+0x11c>
    conn->write_offset += len;
  80ec77:	89 53 28             	mov    %edx,0x28(%ebx)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80ec7a:	8b 43 24             	mov    0x24(%ebx),%eax
  80ec7d:	bf 00 00 00 00       	mov    $0x0,%edi
  80ec82:	3b 50 08             	cmp    0x8(%eax),%edx
  80ec85:	75 13                	jne    80ec9a <do_writemore+0xcd>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80ec87:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80ec8e:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  80ec95:	bf 01 00 00 00       	mov    $0x1,%edi
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80ec9a:	8b 43 08             	mov    0x8(%ebx),%eax
  80ec9d:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80eca1:	74 12                	je     80ecb5 <do_writemore+0xe8>
  80eca3:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80eca7:	75 0c                	jne    80ecb5 <do_writemore+0xe8>
  80eca9:	8b 50 74             	mov    0x74(%eax),%edx
  80ecac:	85 d2                	test   %edx,%edx
  80ecae:	74 74                	je     80ed24 <do_writemore+0x157>
  80ecb0:	83 3a 00             	cmpl   $0x0,(%edx)
  80ecb3:	74 6f                	je     80ed24 <do_writemore+0x157>
  80ecb5:	89 04 24             	mov    %eax,(%esp)
  80ecb8:	e8 3e c1 ff ff       	call   80adfb <tcp_output>
    conn->err = err;
  80ecbd:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80ecc0:	84 c0                	test   %al,%al
  80ecc2:	75 3b                	jne    80ecff <do_writemore+0x132>
  80ecc4:	8b 43 08             	mov    0x8(%ebx),%eax
  80ecc7:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80eccd:	77 30                	ja     80ecff <do_writemore+0x132>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80eccf:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ecd2:	85 c0                	test   %eax,%eax
  80ecd4:	74 29                	je     80ecff <do_writemore+0x132>
  80ecd6:	89 74 24 08          	mov    %esi,0x8(%esp)
  80ecda:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80ece1:	00 
  80ece2:	89 1c 24             	mov    %ebx,(%esp)
  80ece5:	ff d0                	call   *%eax
  80ece7:	eb 16                	jmp    80ecff <do_writemore+0x132>
    }
  } else if (err == ERR_MEM) {
  80ece9:	3c ff                	cmp    $0xff,%al
  80eceb:	75 0d                	jne    80ecfa <do_writemore+0x12d>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80eced:	8b 43 08             	mov    0x8(%ebx),%eax
  80ecf0:	89 04 24             	mov    %eax,(%esp)
  80ecf3:	e8 03 c1 ff ff       	call   80adfb <tcp_output>
  80ecf8:	eb 1d                	jmp    80ed17 <do_writemore+0x14a>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80ecfa:	88 43 0c             	mov    %al,0xc(%ebx)
  80ecfd:	eb 06                	jmp    80ed05 <do_writemore+0x138>
    write_finished = 1;
  }

  if (write_finished) {
  80ecff:	89 f8                	mov    %edi,%eax
  80ed01:	84 c0                	test   %al,%al
  80ed03:	74 12                	je     80ed17 <do_writemore+0x14a>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80ed05:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80ed0c:	8b 43 10             	mov    0x10(%ebx),%eax
  80ed0f:	89 04 24             	mov    %eax,(%esp)
  80ed12:	e8 50 e9 ff ff       	call   80d667 <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80ed17:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed1c:	83 c4 2c             	add    $0x2c,%esp
  80ed1f:	5b                   	pop    %ebx
  80ed20:	5e                   	pop    %esi
  80ed21:	5f                   	pop    %edi
  80ed22:	5d                   	pop    %ebp
  80ed23:	c3                   	ret    
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80ed24:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80ed28:	eb 9a                	jmp    80ecc4 <do_writemore+0xf7>

0080ed2a <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80ed2a:	55                   	push   %ebp
  80ed2b:	89 e5                	mov    %esp,%ebp
  80ed2d:	83 ec 18             	sub    $0x18,%esp
  struct netconn *conn = arg;
  80ed30:	8b 45 08             	mov    0x8(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ed33:	85 c0                	test   %eax,%eax
  80ed35:	75 1c                	jne    80ed53 <poll_tcp+0x29>
  80ed37:	c7 44 24 08 65 47 81 	movl   $0x814765,0x8(%esp)
  80ed3e:	00 
  80ed3f:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80ed46:	00 
  80ed47:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80ed4e:	e8 c1 1b ff ff       	call   800914 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80ed53:	8b 50 04             	mov    0x4(%eax),%edx
  80ed56:	83 fa 01             	cmp    $0x1,%edx
  80ed59:	75 07                	jne    80ed62 <poll_tcp+0x38>
    do_writemore(conn);
  80ed5b:	e8 6d fe ff ff       	call   80ebcd <do_writemore>
  80ed60:	eb 13                	jmp    80ed75 <poll_tcp+0x4b>
  } else if (conn->state == NETCONN_CLOSE) {
  80ed62:	83 fa 04             	cmp    $0x4,%edx
  80ed65:	75 0e                	jne    80ed75 <poll_tcp+0x4b>
    do_close_internal(conn);
  80ed67:	89 f6                	mov    %esi,%esi
  80ed69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  80ed70:	e8 3e fb ff ff       	call   80e8b3 <do_close_internal>
  }

  return ERR_OK;
}
  80ed75:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed7a:	c9                   	leave  
  80ed7b:	c3                   	ret    

0080ed7c <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80ed7c:	55                   	push   %ebp
  80ed7d:	89 e5                	mov    %esp,%ebp
  80ed7f:	83 ec 18             	sub    $0x18,%esp
  80ed82:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80ed85:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80ed88:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct netconn *conn = arg;
  80ed8c:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ed8f:	85 db                	test   %ebx,%ebx
  80ed91:	75 1c                	jne    80edaf <sent_tcp+0x33>
  80ed93:	c7 44 24 08 65 47 81 	movl   $0x814765,0x8(%esp)
  80ed9a:	00 
  80ed9b:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80eda2:	00 
  80eda3:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80edaa:	e8 65 1b ff ff       	call   800914 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80edaf:	8b 43 04             	mov    0x4(%ebx),%eax
  80edb2:	83 f8 01             	cmp    $0x1,%eax
  80edb5:	75 2b                	jne    80ede2 <sent_tcp+0x66>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80edb7:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80edbb:	75 1c                	jne    80edd9 <sent_tcp+0x5d>
  80edbd:	c7 44 24 08 ad 47 81 	movl   $0x8147ad,0x8(%esp)
  80edc4:	00 
  80edc5:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80edcc:	00 
  80edcd:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80edd4:	e8 3b 1b ff ff       	call   800914 <_panic>
    do_writemore(conn);
  80edd9:	89 d8                	mov    %ebx,%eax
  80eddb:	e8 ed fd ff ff       	call   80ebcd <do_writemore>
  80ede0:	eb 13                	jmp    80edf5 <sent_tcp+0x79>
  } else if (conn->state == NETCONN_CLOSE) {
  80ede2:	83 f8 04             	cmp    $0x4,%eax
  80ede5:	75 0e                	jne    80edf5 <sent_tcp+0x79>
    do_close_internal(conn);
  80ede7:	89 d8                	mov    %ebx,%eax
  80ede9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80edf0:	e8 be fa ff ff       	call   80e8b3 <do_close_internal>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80edf5:	8b 43 08             	mov    0x8(%ebx),%eax
  80edf8:	85 c0                	test   %eax,%eax
  80edfa:	74 23                	je     80ee1f <sent_tcp+0xa3>
  80edfc:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80ee02:	76 1b                	jbe    80ee1f <sent_tcp+0xa3>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80ee04:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ee07:	85 c0                	test   %eax,%eax
  80ee09:	74 14                	je     80ee1f <sent_tcp+0xa3>
  80ee0b:	0f b7 f6             	movzwl %si,%esi
  80ee0e:	89 74 24 08          	mov    %esi,0x8(%esp)
  80ee12:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80ee19:	00 
  80ee1a:	89 1c 24             	mov    %ebx,(%esp)
  80ee1d:	ff d0                	call   *%eax
    }
  }
  
  return ERR_OK;
}
  80ee1f:	b8 00 00 00 00       	mov    $0x0,%eax
  80ee24:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80ee27:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80ee2a:	89 ec                	mov    %ebp,%esp
  80ee2c:	5d                   	pop    %ebp
  80ee2d:	c3                   	ret    

0080ee2e <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80ee2e:	55                   	push   %ebp
  80ee2f:	89 e5                	mov    %esp,%ebp
  80ee31:	83 ec 18             	sub    $0x18,%esp
  80ee34:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ee37:	8b 02                	mov    (%edx),%eax
  80ee39:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80ee3d:	7c 2d                	jl     80ee6c <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80ee3f:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80ee43:	74 23                	je     80ee68 <do_write+0x3a>
  80ee45:	83 38 10             	cmpl   $0x10,(%eax)
  80ee48:	75 1e                	jne    80ee68 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80ee4a:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80ee51:	8b 02                	mov    (%edx),%eax
  80ee53:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80ee56:	8b 02                	mov    (%edx),%eax
  80ee58:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80ee5f:	8b 02                	mov    (%edx),%eax
  80ee61:	e8 67 fd ff ff       	call   80ebcd <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80ee66:	eb 11                	jmp    80ee79 <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80ee68:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80ee6c:	8b 02                	mov    (%edx),%eax
  80ee6e:	8b 40 10             	mov    0x10(%eax),%eax
  80ee71:	89 04 24             	mov    %eax,(%esp)
  80ee74:	e8 ee e7 ff ff       	call   80d667 <sys_sem_signal>
}
  80ee79:	c9                   	leave  
  80ee7a:	c3                   	ret    

0080ee7b <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80ee7b:	55                   	push   %ebp
  80ee7c:	89 e5                	mov    %esp,%ebp
  80ee7e:	53                   	push   %ebx
  80ee7f:	83 ec 14             	sub    $0x14,%esp
  80ee82:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ee85:	8b 03                	mov    (%ebx),%eax
  80ee87:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80ee8b:	7c 1c                	jl     80eea9 <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80ee8d:	8b 50 08             	mov    0x8(%eax),%edx
  80ee90:	85 d2                	test   %edx,%edx
  80ee92:	74 15                	je     80eea9 <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80ee94:	83 38 10             	cmpl   $0x10,(%eax)
  80ee97:	75 10                	jne    80eea9 <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80ee99:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80ee9d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eea1:	89 14 24             	mov    %edx,(%esp)
  80eea4:	e8 ee 94 ff ff       	call   808397 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80eea9:	8b 03                	mov    (%ebx),%eax
  80eeab:	8b 40 10             	mov    0x10(%eax),%eax
  80eeae:	89 04 24             	mov    %eax,(%esp)
  80eeb1:	e8 b1 e7 ff ff       	call   80d667 <sys_sem_signal>
}
  80eeb6:	83 c4 14             	add    $0x14,%esp
  80eeb9:	5b                   	pop    %ebx
  80eeba:	5d                   	pop    %ebp
  80eebb:	c3                   	ret    

0080eebc <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80eebc:	55                   	push   %ebp
  80eebd:	89 e5                	mov    %esp,%ebp
  80eebf:	83 ec 28             	sub    $0x28,%esp
  80eec2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80eec5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80eec8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80eecb:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80eece:	8b 1e                	mov    (%esi),%ebx
  80eed0:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80eed4:	0f 8c 8b 00 00 00    	jl     80ef65 <do_send+0xa9>
    if (msg->conn->pcb.tcp != NULL) {
  80eeda:	8b 43 08             	mov    0x8(%ebx),%eax
  80eedd:	85 c0                	test   %eax,%eax
  80eedf:	0f 84 80 00 00 00    	je     80ef65 <do_send+0xa9>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80eee5:	8b 13                	mov    (%ebx),%edx
  80eee7:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80eeed:	83 fa 20             	cmp    $0x20,%edx
  80eef0:	74 39                	je     80ef2b <do_send+0x6f>
  80eef2:	83 fa 40             	cmp    $0x40,%edx
  80eef5:	75 6e                	jne    80ef65 <do_send+0xa9>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80eef7:	8b 56 04             	mov    0x4(%esi),%edx
  80eefa:	8b 4a 08             	mov    0x8(%edx),%ecx
  80eefd:	85 c9                	test   %ecx,%ecx
  80eeff:	75 13                	jne    80ef14 <do_send+0x58>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80ef01:	8b 12                	mov    (%edx),%edx
  80ef03:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ef07:	89 04 24             	mov    %eax,(%esp)
  80ef0a:	e8 43 27 00 00       	call   811652 <raw_send>
  80ef0f:	88 43 0c             	mov    %al,0xc(%ebx)
  80ef12:	eb 51                	jmp    80ef65 <do_send+0xa9>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80ef14:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80ef18:	8b 12                	mov    (%edx),%edx
  80ef1a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ef1e:	89 04 24             	mov    %eax,(%esp)
  80ef21:	e8 22 26 00 00       	call   811548 <raw_sendto>
  80ef26:	88 43 0c             	mov    %al,0xc(%ebx)
  80ef29:	eb 3a                	jmp    80ef65 <do_send+0xa9>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80ef2b:	8b 56 04             	mov    0x4(%esi),%edx
  80ef2e:	8b 4a 08             	mov    0x8(%edx),%ecx
  80ef31:	85 c9                	test   %ecx,%ecx
  80ef33:	75 13                	jne    80ef48 <do_send+0x8c>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80ef35:	8b 12                	mov    (%edx),%edx
  80ef37:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ef3b:	89 04 24             	mov    %eax,(%esp)
  80ef3e:	e8 bc cf ff ff       	call   80beff <udp_send>
  80ef43:	88 43 0c             	mov    %al,0xc(%ebx)
  80ef46:	eb 1d                	jmp    80ef65 <do_send+0xa9>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80ef48:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  80ef4c:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80ef50:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80ef54:	8b 12                	mov    (%edx),%edx
  80ef56:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ef5a:	89 04 24             	mov    %eax,(%esp)
  80ef5d:	e8 4c cf ff ff       	call   80beae <udp_sendto>
  80ef62:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80ef65:	8b 06                	mov    (%esi),%eax
  80ef67:	8b 40 10             	mov    0x10(%eax),%eax
  80ef6a:	89 04 24             	mov    %eax,(%esp)
  80ef6d:	e8 f5 e6 ff ff       	call   80d667 <sys_sem_signal>
}
  80ef72:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ef75:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ef78:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ef7b:	89 ec                	mov    %ebp,%esp
  80ef7d:	5d                   	pop    %ebp
  80ef7e:	c3                   	ret    

0080ef7f <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80ef7f:	55                   	push   %ebp
  80ef80:	89 e5                	mov    %esp,%ebp
  80ef82:	83 ec 28             	sub    $0x28,%esp
  80ef85:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ef88:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ef8b:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80ef8e:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ef91:	8b 03                	mov    (%ebx),%eax
  80ef93:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80ef97:	0f 8c b9 00 00 00    	jl     80f056 <do_listen+0xd7>
    if (msg->conn->pcb.tcp != NULL) {
  80ef9d:	8b 50 08             	mov    0x8(%eax),%edx
  80efa0:	85 d2                	test   %edx,%edx
  80efa2:	0f 84 ae 00 00 00    	je     80f056 <do_listen+0xd7>
      if (msg->conn->type == NETCONN_TCP) {
  80efa8:	83 38 10             	cmpl   $0x10,(%eax)
  80efab:	0f 85 a5 00 00 00    	jne    80f056 <do_listen+0xd7>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80efb1:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80efb5:	0f 85 97 00 00 00    	jne    80f052 <do_listen+0xd3>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80efbb:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80efc2:	00 
  80efc3:	89 14 24             	mov    %edx,(%esp)
  80efc6:	e8 0e 97 ff ff       	call   8086d9 <tcp_listen_with_backlog>
  80efcb:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80efcd:	85 c0                	test   %eax,%eax
  80efcf:	75 08                	jne    80efd9 <do_listen+0x5a>
            msg->conn->err = ERR_MEM;
  80efd1:	8b 03                	mov    (%ebx),%eax
  80efd3:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80efd7:	eb 7d                	jmp    80f056 <do_listen+0xd7>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80efd9:	8b 03                	mov    (%ebx),%eax
  80efdb:	8b 40 14             	mov    0x14(%eax),%eax
  80efde:	83 f8 ff             	cmp    $0xffffffff,%eax
  80efe1:	74 11                	je     80eff4 <do_listen+0x75>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80efe3:	89 04 24             	mov    %eax,(%esp)
  80efe6:	e8 a8 e0 ff ff       	call   80d093 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80efeb:	8b 03                	mov    (%ebx),%eax
  80efed:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80eff4:	8b 3b                	mov    (%ebx),%edi
  80eff6:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80effa:	75 1a                	jne    80f016 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80effc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f003:	e8 47 e5 ff ff       	call   80d54f <sys_mbox_new>
  80f008:	89 47 18             	mov    %eax,0x18(%edi)
  80f00b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f00e:	75 06                	jne    80f016 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  80f010:	8b 03                	mov    (%ebx),%eax
  80f012:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80f016:	8b 03                	mov    (%ebx),%eax
  80f018:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80f01c:	75 38                	jne    80f056 <do_listen+0xd7>
              msg->conn->state = NETCONN_LISTEN;
  80f01e:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80f025:	8b 03                	mov    (%ebx),%eax
  80f027:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80f02a:	8b 03                	mov    (%ebx),%eax
  80f02c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f030:	8b 40 08             	mov    0x8(%eax),%eax
  80f033:	89 04 24             	mov    %eax,(%esp)
  80f036:	e8 ad 92 ff ff       	call   8082e8 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80f03b:	c7 44 24 04 54 f6 80 	movl   $0x80f654,0x4(%esp)
  80f042:	00 
  80f043:	8b 03                	mov    (%ebx),%eax
  80f045:	8b 40 08             	mov    0x8(%eax),%eax
  80f048:	89 04 24             	mov    %eax,(%esp)
  80f04b:	e8 d9 92 ff ff       	call   808329 <tcp_accept>
  80f050:	eb 04                	jmp    80f056 <do_listen+0xd7>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80f052:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80f056:	8b 03                	mov    (%ebx),%eax
  80f058:	8b 40 10             	mov    0x10(%eax),%eax
  80f05b:	89 04 24             	mov    %eax,(%esp)
  80f05e:	e8 04 e6 ff ff       	call   80d667 <sys_sem_signal>
}
  80f063:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f066:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f069:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f06c:	89 ec                	mov    %ebp,%esp
  80f06e:	5d                   	pop    %ebp
  80f06f:	c3                   	ret    

0080f070 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80f070:	55                   	push   %ebp
  80f071:	89 e5                	mov    %esp,%ebp
  80f073:	83 ec 18             	sub    $0x18,%esp
  80f076:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f079:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f07c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f07f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f082:	8b 75 10             	mov    0x10(%ebp),%esi
  80f085:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80f089:	85 c0                	test   %eax,%eax
  80f08b:	75 1c                	jne    80f0a9 <recv_tcp+0x39>
  80f08d:	c7 44 24 08 48 48 81 	movl   $0x814848,0x8(%esp)
  80f094:	00 
  80f095:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80f09c:	00 
  80f09d:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f0a4:	e8 6b 18 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80f0a9:	85 db                	test   %ebx,%ebx
  80f0ab:	75 1c                	jne    80f0c9 <recv_tcp+0x59>
  80f0ad:	c7 44 24 08 6c 48 81 	movl   $0x81486c,0x8(%esp)
  80f0b4:	00 
  80f0b5:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80f0bc:	00 
  80f0bd:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f0c4:	e8 4b 18 ff ff       	call   800914 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80f0c9:	39 43 08             	cmp    %eax,0x8(%ebx)
  80f0cc:	74 1c                	je     80f0ea <recv_tcp+0x7a>
  80f0ce:	c7 44 24 08 c3 47 81 	movl   $0x8147c3,0x8(%esp)
  80f0d5:	00 
  80f0d6:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80f0dd:	00 
  80f0de:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f0e5:	e8 2a 18 ff ff       	call   800914 <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80f0ea:	85 db                	test   %ebx,%ebx
  80f0ec:	74 4c                	je     80f13a <recv_tcp+0xca>
  80f0ee:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f0f2:	74 46                	je     80f13a <recv_tcp+0xca>
    return ERR_VAL;
  }

  conn->err = err;
  80f0f4:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80f0f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80f0fc:	85 f6                	test   %esi,%esi
  80f0fe:	74 08                	je     80f108 <recv_tcp+0x98>
    len = p->tot_len;
  80f100:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80f104:	66 01 43 20          	add    %ax,0x20(%ebx)
  } else {
    len = 0;
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80f108:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80f10b:	85 d2                	test   %edx,%edx
  80f10d:	74 14                	je     80f123 <recv_tcp+0xb3>
  80f10f:	0f b7 c0             	movzwl %ax,%eax
  80f112:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f116:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f11d:	00 
  80f11e:	89 1c 24             	mov    %ebx,(%esp)
  80f121:	ff d2                	call   *%edx
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80f123:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f127:	8b 43 14             	mov    0x14(%ebx),%eax
  80f12a:	89 04 24             	mov    %eax,(%esp)
  80f12d:	e8 e5 e6 ff ff       	call   80d817 <sys_mbox_trypost>
  80f132:	3c 01                	cmp    $0x1,%al
  80f134:	19 c0                	sbb    %eax,%eax
  80f136:	f7 d0                	not    %eax
  80f138:	eb 05                	jmp    80f13f <recv_tcp+0xcf>
  80f13a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80f13f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f142:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f145:	89 ec                	mov    %ebp,%esp
  80f147:	5d                   	pop    %ebp
  80f148:	c3                   	ret    

0080f149 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80f149:	55                   	push   %ebp
  80f14a:	89 e5                	mov    %esp,%ebp
  80f14c:	53                   	push   %ebx
  80f14d:	83 ec 14             	sub    $0x14,%esp
  80f150:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80f153:	8b 03                	mov    (%ebx),%eax
  80f155:	8b 10                	mov    (%eax),%edx
  80f157:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f15d:	83 fa 20             	cmp    $0x20,%edx
  80f160:	75 0b                	jne    80f16d <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  80f162:	8b 40 08             	mov    0x8(%eax),%eax
  80f165:	89 04 24             	mov    %eax,(%esp)
  80f168:	e8 93 c9 ff ff       	call   80bb00 <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80f16d:	8b 03                	mov    (%ebx),%eax
  80f16f:	8b 40 10             	mov    0x10(%eax),%eax
  80f172:	89 04 24             	mov    %eax,(%esp)
  80f175:	e8 ed e4 ff ff       	call   80d667 <sys_sem_signal>
}
  80f17a:	83 c4 14             	add    $0x14,%esp
  80f17d:	5b                   	pop    %ebx
  80f17e:	5d                   	pop    %ebp
  80f17f:	c3                   	ret    

0080f180 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80f180:	55                   	push   %ebp
  80f181:	89 e5                	mov    %esp,%ebp
  80f183:	56                   	push   %esi
  80f184:	53                   	push   %ebx
  80f185:	83 ec 10             	sub    $0x10,%esp
  80f188:	8b 75 08             	mov    0x8(%ebp),%esi
  if (msg->conn->pcb.tcp == NULL) {
  80f18b:	8b 1e                	mov    (%esi),%ebx
  80f18d:	8b 53 08             	mov    0x8(%ebx),%edx
  80f190:	85 d2                	test   %edx,%edx
  80f192:	75 10                	jne    80f1a4 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80f194:	8b 43 10             	mov    0x10(%ebx),%eax
  80f197:	89 04 24             	mov    %eax,(%esp)
  80f19a:	e8 c8 e4 ff ff       	call   80d667 <sys_sem_signal>
    return;
  80f19f:	e9 9d 00 00 00       	jmp    80f241 <do_connect+0xc1>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f1a4:	8b 03                	mov    (%ebx),%eax
  80f1a6:	25 f0 00 00 00       	and    $0xf0,%eax
  80f1ab:	83 f8 20             	cmp    $0x20,%eax
  80f1ae:	74 33                	je     80f1e3 <do_connect+0x63>
  80f1b0:	83 f8 40             	cmp    $0x40,%eax
  80f1b3:	74 0d                	je     80f1c2 <do_connect+0x42>
  80f1b5:	83 f8 10             	cmp    $0x10,%eax
  80f1b8:	0f 85 83 00 00 00    	jne    80f241 <do_connect+0xc1>
  80f1be:	66 90                	xchg   %ax,%ax
  80f1c0:	eb 4a                	jmp    80f20c <do_connect+0x8c>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f1c2:	8b 46 04             	mov    0x4(%esi),%eax
  80f1c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f1c9:	89 14 24             	mov    %edx,(%esp)
  80f1cc:	e8 9c 22 00 00       	call   81146d <raw_connect>
  80f1d1:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f1d4:	8b 06                	mov    (%esi),%eax
  80f1d6:	8b 40 10             	mov    0x10(%eax),%eax
  80f1d9:	89 04 24             	mov    %eax,(%esp)
  80f1dc:	e8 86 e4 ff ff       	call   80d667 <sys_sem_signal>
    break;
  80f1e1:	eb 5e                	jmp    80f241 <do_connect+0xc1>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f1e3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f1e7:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f1eb:	8b 46 04             	mov    0x4(%esi),%eax
  80f1ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f1f2:	89 14 24             	mov    %edx,(%esp)
  80f1f5:	e8 84 ca ff ff       	call   80bc7e <udp_connect>
  80f1fa:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f1fd:	8b 06                	mov    (%esi),%eax
  80f1ff:	8b 40 10             	mov    0x10(%eax),%eax
  80f202:	89 04 24             	mov    %eax,(%esp)
  80f205:	e8 5d e4 ff ff       	call   80d667 <sys_sem_signal>
    break;
  80f20a:	eb 35                	jmp    80f241 <do_connect+0xc1>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80f20c:	c7 43 04 03 00 00 00 	movl   $0x3,0x4(%ebx)
    setup_tcp(msg->conn);
  80f213:	8b 06                	mov    (%esi),%eax
  80f215:	e8 ee f5 ff ff       	call   80e808 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80f21a:	8b 1e                	mov    (%esi),%ebx
  80f21c:	c7 44 24 0c 6c e8 80 	movl   $0x80e86c,0xc(%esp)
  80f223:	00 
  80f224:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f228:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f22c:	8b 46 04             	mov    0x4(%esi),%eax
  80f22f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f233:	8b 43 08             	mov    0x8(%ebx),%eax
  80f236:	89 04 24             	mov    %eax,(%esp)
  80f239:	e8 e5 96 ff ff       	call   808923 <tcp_connect>
  80f23e:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80f241:	83 c4 10             	add    $0x10,%esp
  80f244:	5b                   	pop    %ebx
  80f245:	5e                   	pop    %esi
  80f246:	5d                   	pop    %ebp
  80f247:	c3                   	ret    

0080f248 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80f248:	55                   	push   %ebp
  80f249:	89 e5                	mov    %esp,%ebp
  80f24b:	83 ec 18             	sub    $0x18,%esp
  80f24e:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f251:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f254:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f257:	8b 1e                	mov    (%esi),%ebx
  80f259:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80f25d:	7c 73                	jl     80f2d2 <do_bind+0x8a>
    if (msg->conn->pcb.tcp != NULL) {
  80f25f:	8b 53 08             	mov    0x8(%ebx),%edx
  80f262:	85 d2                	test   %edx,%edx
  80f264:	74 68                	je     80f2ce <do_bind+0x86>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f266:	8b 03                	mov    (%ebx),%eax
  80f268:	25 f0 00 00 00       	and    $0xf0,%eax
  80f26d:	83 f8 20             	cmp    $0x20,%eax
  80f270:	74 24                	je     80f296 <do_bind+0x4e>
  80f272:	83 f8 40             	cmp    $0x40,%eax
  80f275:	74 0b                	je     80f282 <do_bind+0x3a>
  80f277:	83 f8 10             	cmp    $0x10,%eax
  80f27a:	75 56                	jne    80f2d2 <do_bind+0x8a>
  80f27c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f280:	eb 30                	jmp    80f2b2 <do_bind+0x6a>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f282:	8b 46 04             	mov    0x4(%esi),%eax
  80f285:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f289:	89 14 24             	mov    %edx,(%esp)
  80f28c:	e8 bf 21 00 00       	call   811450 <raw_bind>
  80f291:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80f294:	eb 3c                	jmp    80f2d2 <do_bind+0x8a>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f296:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f29a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f29e:	8b 46 04             	mov    0x4(%esi),%eax
  80f2a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f2a5:	89 14 24             	mov    %edx,(%esp)
  80f2a8:	e8 0b c9 ff ff       	call   80bbb8 <udp_bind>
  80f2ad:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80f2b0:	eb 20                	jmp    80f2d2 <do_bind+0x8a>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f2b2:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f2b6:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f2ba:	8b 46 04             	mov    0x4(%esi),%eax
  80f2bd:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f2c1:	89 14 24             	mov    %edx,(%esp)
  80f2c4:	e8 15 95 ff ff       	call   8087de <tcp_bind>
  80f2c9:	88 43 0c             	mov    %al,0xc(%ebx)
  80f2cc:	eb 04                	jmp    80f2d2 <do_bind+0x8a>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80f2ce:	c6 43 0c f7          	movb   $0xf7,0xc(%ebx)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f2d2:	8b 06                	mov    (%esi),%eax
  80f2d4:	8b 40 10             	mov    0x10(%eax),%eax
  80f2d7:	89 04 24             	mov    %eax,(%esp)
  80f2da:	e8 88 e3 ff ff       	call   80d667 <sys_sem_signal>
}
  80f2df:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f2e2:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f2e5:	89 ec                	mov    %ebp,%esp
  80f2e7:	5d                   	pop    %ebp
  80f2e8:	c3                   	ret    

0080f2e9 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80f2e9:	55                   	push   %ebp
  80f2ea:	89 e5                	mov    %esp,%ebp
  80f2ec:	53                   	push   %ebx
  80f2ed:	83 ec 14             	sub    $0x14,%esp
  80f2f0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80f2f3:	8b 03                	mov    (%ebx),%eax
  80f2f5:	8b 48 08             	mov    0x8(%eax),%ecx
  80f2f8:	85 c9                	test   %ecx,%ecx
  80f2fa:	74 51                	je     80f34d <do_delconn+0x64>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f2fc:	8b 10                	mov    (%eax),%edx
  80f2fe:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f304:	83 fa 20             	cmp    $0x20,%edx
  80f307:	74 1e                	je     80f327 <do_delconn+0x3e>
  80f309:	83 fa 40             	cmp    $0x40,%edx
  80f30c:	74 0c                	je     80f31a <do_delconn+0x31>
  80f30e:	83 fa 10             	cmp    $0x10,%edx
  80f311:	75 3a                	jne    80f34d <do_delconn+0x64>
  80f313:	90                   	nop
  80f314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f318:	eb 23                	jmp    80f33d <do_delconn+0x54>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80f31a:	89 0c 24             	mov    %ecx,(%esp)
  80f31d:	8d 76 00             	lea    0x0(%esi),%esi
  80f320:	e8 d7 21 00 00       	call   8114fc <raw_remove>
      break;
  80f325:	eb 26                	jmp    80f34d <do_delconn+0x64>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80f327:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80f32e:	8b 03                	mov    (%ebx),%eax
  80f330:	8b 40 08             	mov    0x8(%eax),%eax
  80f333:	89 04 24             	mov    %eax,(%esp)
  80f336:	e8 31 c8 ff ff       	call   80bb6c <udp_remove>
      break;
  80f33b:	eb 10                	jmp    80f34d <do_delconn+0x64>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80f33d:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80f344:	8b 03                	mov    (%ebx),%eax
  80f346:	e8 68 f5 ff ff       	call   80e8b3 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80f34b:	eb 4e                	jmp    80f39b <do_delconn+0xb2>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80f34d:	8b 13                	mov    (%ebx),%edx
  80f34f:	8b 42 2c             	mov    0x2c(%edx),%eax
  80f352:	85 c0                	test   %eax,%eax
  80f354:	74 33                	je     80f389 <do_delconn+0xa0>
  80f356:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f35d:	00 
  80f35e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f365:	00 
  80f366:	89 14 24             	mov    %edx,(%esp)
  80f369:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80f36b:	8b 13                	mov    (%ebx),%edx
  80f36d:	8b 42 2c             	mov    0x2c(%edx),%eax
  80f370:	85 c0                	test   %eax,%eax
  80f372:	74 15                	je     80f389 <do_delconn+0xa0>
  80f374:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f37b:	00 
  80f37c:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80f383:	00 
  80f384:	89 14 24             	mov    %edx,(%esp)
  80f387:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80f389:	8b 03                	mov    (%ebx),%eax
  80f38b:	8b 40 10             	mov    0x10(%eax),%eax
  80f38e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f391:	74 08                	je     80f39b <do_delconn+0xb2>
    sys_sem_signal(msg->conn->op_completed);
  80f393:	89 04 24             	mov    %eax,(%esp)
  80f396:	e8 cc e2 ff ff       	call   80d667 <sys_sem_signal>
  }
}
  80f39b:	83 c4 14             	add    $0x14,%esp
  80f39e:	5b                   	pop    %ebx
  80f39f:	5d                   	pop    %ebp
  80f3a0:	c3                   	ret    

0080f3a1 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80f3a1:	55                   	push   %ebp
  80f3a2:	89 e5                	mov    %esp,%ebp
  80f3a4:	56                   	push   %esi
  80f3a5:	53                   	push   %ebx
  80f3a6:	83 ec 20             	sub    $0x20,%esp
  80f3a9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80f3ac:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f3b0:	74 1c                	je     80f3ce <netconn_free+0x2d>
  80f3b2:	c7 44 24 08 8c 48 81 	movl   $0x81488c,0x8(%esp)
  80f3b9:	00 
  80f3ba:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80f3c1:	00 
  80f3c2:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f3c9:	e8 46 15 ff ff       	call   800914 <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f3ce:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80f3d1:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f3d5:	75 27                	jne    80f3fe <netconn_free+0x5d>
  80f3d7:	eb 4b                	jmp    80f424 <netconn_free+0x83>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80f3d9:	83 3b 10             	cmpl   $0x10,(%ebx)
  80f3dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f3e0:	75 11                	jne    80f3f3 <netconn_free+0x52>
        if(mem != NULL) {
  80f3e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f3e5:	85 c0                	test   %eax,%eax
  80f3e7:	74 15                	je     80f3fe <netconn_free+0x5d>
          pbuf_free((struct pbuf *)mem);
  80f3e9:	89 04 24             	mov    %eax,(%esp)
  80f3ec:	e8 8c 85 ff ff       	call   80797d <pbuf_free>
  80f3f1:	eb 0b                	jmp    80f3fe <netconn_free+0x5d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80f3f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f3f6:	89 04 24             	mov    %eax,(%esp)
  80f3f9:	e8 a0 5c ff ff       	call   80509e <netbuf_delete>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f3fe:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f402:	8b 43 14             	mov    0x14(%ebx),%eax
  80f405:	89 04 24             	mov    %eax,(%esp)
  80f408:	e8 e8 e3 ff ff       	call   80d7f5 <sys_arch_mbox_tryfetch>
  80f40d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f410:	75 c7                	jne    80f3d9 <netconn_free+0x38>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80f412:	8b 43 14             	mov    0x14(%ebx),%eax
  80f415:	89 04 24             	mov    %eax,(%esp)
  80f418:	e8 76 dc ff ff       	call   80d093 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80f41d:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f424:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80f427:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80f42b:	75 0d                	jne    80f43a <netconn_free+0x99>
  80f42d:	eb 31                	jmp    80f460 <netconn_free+0xbf>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80f42f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f432:	89 04 24             	mov    %eax,(%esp)
  80f435:	e8 c1 f1 ff ff       	call   80e5fb <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f43a:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f43e:	8b 43 18             	mov    0x18(%ebx),%eax
  80f441:	89 04 24             	mov    %eax,(%esp)
  80f444:	e8 ac e3 ff ff       	call   80d7f5 <sys_arch_mbox_tryfetch>
  80f449:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f44c:	75 e1                	jne    80f42f <netconn_free+0x8e>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80f44e:	8b 43 18             	mov    0x18(%ebx),%eax
  80f451:	89 04 24             	mov    %eax,(%esp)
  80f454:	e8 3a dc ff ff       	call   80d093 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80f459:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80f460:	8b 43 10             	mov    0x10(%ebx),%eax
  80f463:	89 04 24             	mov    %eax,(%esp)
  80f466:	e8 98 db ff ff       	call   80d003 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80f46b:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80f472:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f476:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f47d:	e8 72 7d ff ff       	call   8071f4 <memp_free>
}
  80f482:	83 c4 20             	add    $0x20,%esp
  80f485:	5b                   	pop    %ebx
  80f486:	5e                   	pop    %esi
  80f487:	5d                   	pop    %ebp
  80f488:	c3                   	ret    

0080f489 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80f489:	55                   	push   %ebp
  80f48a:	89 e5                	mov    %esp,%ebp
  80f48c:	83 ec 38             	sub    $0x38,%esp
  80f48f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f492:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f495:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f498:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f49b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f49e:	8b 7d 10             	mov    0x10(%ebp),%edi
  80f4a1:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80f4a5:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80f4a9:	85 c0                	test   %eax,%eax
  80f4ab:	75 1c                	jne    80f4c9 <recv_udp+0x40>
  80f4ad:	c7 44 24 08 bc 48 81 	movl   $0x8148bc,0x8(%esp)
  80f4b4:	00 
  80f4b5:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80f4bc:	00 
  80f4bd:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f4c4:	e8 4b 14 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80f4c9:	85 db                	test   %ebx,%ebx
  80f4cb:	75 1c                	jne    80f4e9 <recv_udp+0x60>
  80f4cd:	c7 44 24 08 e0 48 81 	movl   $0x8148e0,0x8(%esp)
  80f4d4:	00 
  80f4d5:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80f4dc:	00 
  80f4dd:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f4e4:	e8 2b 14 ff ff       	call   800914 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80f4e9:	39 43 08             	cmp    %eax,0x8(%ebx)
  80f4ec:	74 1c                	je     80f50a <recv_udp+0x81>
  80f4ee:	c7 44 24 08 e1 47 81 	movl   $0x8147e1,0x8(%esp)
  80f4f5:	00 
  80f4f6:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80f4fd:	00 
  80f4fe:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f505:	e8 0a 14 ff ff       	call   800914 <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80f50a:	85 db                	test   %ebx,%ebx
  80f50c:	74 06                	je     80f514 <recv_udp+0x8b>
  80f50e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f512:	75 0e                	jne    80f522 <recv_udp+0x99>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80f514:	89 3c 24             	mov    %edi,(%esp)
  80f517:	e8 61 84 ff ff       	call   80797d <pbuf_free>
    return;
  80f51c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f520:	eb 6e                	jmp    80f590 <recv_udp+0x107>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80f522:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80f529:	e8 0a 7d ff ff       	call   807238 <memp_malloc>
  80f52e:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80f530:	85 c0                	test   %eax,%eax
  80f532:	75 0a                	jne    80f53e <recv_udp+0xb5>
    pbuf_free(p);
  80f534:	89 3c 24             	mov    %edi,(%esp)
  80f537:	e8 41 84 ff ff       	call   80797d <pbuf_free>
    return;
  80f53c:	eb 52                	jmp    80f590 <recv_udp+0x107>
  } else {
    buf->p = p;
  80f53e:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80f540:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80f543:	8b 45 14             	mov    0x14(%ebp),%eax
  80f546:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80f549:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80f54d:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80f551:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80f555:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80f559:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f55c:	85 c0                	test   %eax,%eax
  80f55e:	74 15                	je     80f575 <recv_udp+0xec>
  80f560:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80f564:	89 54 24 08          	mov    %edx,0x8(%esp)
  80f568:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f56f:	00 
  80f570:	89 1c 24             	mov    %ebx,(%esp)
  80f573:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80f575:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f579:	8b 43 14             	mov    0x14(%ebx),%eax
  80f57c:	89 04 24             	mov    %eax,(%esp)
  80f57f:	e8 93 e2 ff ff       	call   80d817 <sys_mbox_trypost>
  80f584:	84 c0                	test   %al,%al
  80f586:	74 08                	je     80f590 <recv_udp+0x107>
    netbuf_delete(buf);
  80f588:	89 34 24             	mov    %esi,(%esp)
  80f58b:	e8 0e 5b ff ff       	call   80509e <netbuf_delete>
    return;
  }
}
  80f590:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f593:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f596:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f599:	89 ec                	mov    %ebp,%esp
  80f59b:	5d                   	pop    %ebp
  80f59c:	c3                   	ret    

0080f59d <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80f59d:	55                   	push   %ebp
  80f59e:	89 e5                	mov    %esp,%ebp
  80f5a0:	53                   	push   %ebx
  80f5a1:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80f5a4:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f5ab:	e8 88 7c ff ff       	call   807238 <memp_malloc>
  80f5b0:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80f5b2:	85 c0                	test   %eax,%eax
  80f5b4:	0f 84 92 00 00 00    	je     80f64c <netconn_alloc+0xaf>
    return NULL;
  }

  conn->err = ERR_OK;
  80f5ba:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80f5be:	8b 45 08             	mov    0x8(%ebp),%eax
  80f5c1:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80f5c3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80f5ca:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f5d1:	e8 ef de ff ff       	call   80d4c5 <sys_sem_new>
  80f5d6:	89 43 10             	mov    %eax,0x10(%ebx)
  80f5d9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f5dc:	75 17                	jne    80f5f5 <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  80f5de:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f5e2:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f5e9:	e8 06 7c ff ff       	call   8071f4 <memp_free>
  80f5ee:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80f5f3:	eb 57                	jmp    80f64c <netconn_alloc+0xaf>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80f5f5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f5fc:	e8 4e df ff ff       	call   80d54f <sys_mbox_new>
  80f601:	89 43 14             	mov    %eax,0x14(%ebx)
  80f604:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f607:	75 22                	jne    80f62b <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  80f609:	8b 43 10             	mov    0x10(%ebx),%eax
  80f60c:	89 04 24             	mov    %eax,(%esp)
  80f60f:	e8 ef d9 ff ff       	call   80d003 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80f614:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f618:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f61f:	e8 d0 7b ff ff       	call   8071f4 <memp_free>
  80f624:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80f629:	eb 21                	jmp    80f64c <netconn_alloc+0xaf>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80f62b:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80f632:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80f639:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80f640:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f643:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80f646:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80f64c:	89 d8                	mov    %ebx,%eax
  80f64e:	83 c4 14             	add    $0x14,%esp
  80f651:	5b                   	pop    %ebx
  80f652:	5d                   	pop    %ebp
  80f653:	c3                   	ret    

0080f654 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80f654:	55                   	push   %ebp
  80f655:	89 e5                	mov    %esp,%ebp
  80f657:	83 ec 28             	sub    $0x28,%esp
  80f65a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f65d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f660:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f663:	0f b6 7d 10          	movzbl 0x10(%ebp),%edi
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  80f667:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80f66a:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80f66e:	75 1c                	jne    80f68c <accept_function+0x38>
  80f670:	c7 44 24 08 00 49 81 	movl   $0x814900,0x8(%esp)
  80f677:	00 
  80f678:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80f67f:	00 
  80f680:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f687:	e8 88 12 ff ff       	call   800914 <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80f68c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f68f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f693:	8b 03                	mov    (%ebx),%eax
  80f695:	89 04 24             	mov    %eax,(%esp)
  80f698:	e8 00 ff ff ff       	call   80f59d <netconn_alloc>
  80f69d:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80f69f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80f6a4:	85 f6                	test   %esi,%esi
  80f6a6:	74 55                	je     80f6fd <accept_function+0xa9>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80f6a8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f6ab:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80f6ae:	89 f0                	mov    %esi,%eax
  80f6b0:	e8 53 f1 ff ff       	call   80e808 <setup_tcp>
  newconn->err = err;
  80f6b5:	89 f8                	mov    %edi,%eax
  80f6b7:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80f6ba:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f6bd:	85 c0                	test   %eax,%eax
  80f6bf:	74 15                	je     80f6d6 <accept_function+0x82>
  80f6c1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f6c8:	00 
  80f6c9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f6d0:	00 
  80f6d1:	89 1c 24             	mov    %ebx,(%esp)
  80f6d4:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80f6d6:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f6da:	8b 43 18             	mov    0x18(%ebx),%eax
  80f6dd:	89 04 24             	mov    %eax,(%esp)
  80f6e0:	e8 32 e1 ff ff       	call   80d817 <sys_mbox_trypost>
  80f6e5:	84 c0                	test   %al,%al
  80f6e7:	74 14                	je     80f6fd <accept_function+0xa9>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80f6e9:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80f6f0:	89 34 24             	mov    %esi,(%esp)
  80f6f3:	e8 a9 fc ff ff       	call   80f3a1 <netconn_free>
  80f6f8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  return ERR_OK;
}
  80f6fd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f700:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f703:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f706:	89 ec                	mov    %ebp,%esp
  80f708:	5d                   	pop    %ebp
  80f709:	c3                   	ret    

0080f70a <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80f70a:	55                   	push   %ebp
  80f70b:	89 e5                	mov    %esp,%ebp
  80f70d:	83 ec 18             	sub    $0x18,%esp
  80f710:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f713:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f716:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80f719:	8b 03                	mov    (%ebx),%eax
  80f71b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f71f:	0f 85 d5 00 00 00    	jne    80f7fa <do_newconn+0xf0>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80f725:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80f729:	8b 33                	mov    (%ebx),%esi
  80f72b:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80f72f:	74 1c                	je     80f74d <do_newconn+0x43>
  80f731:	c7 44 24 08 2c 49 81 	movl   $0x81492c,0x8(%esp)
  80f738:	00 
  80f739:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80f740:	00 
  80f741:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f748:	e8 c7 11 ff ff       	call   800914 <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80f74d:	8b 06                	mov    (%esi),%eax
  80f74f:	25 f0 00 00 00       	and    $0xf0,%eax
  80f754:	83 f8 20             	cmp    $0x20,%eax
  80f757:	74 45                	je     80f79e <do_newconn+0x94>
  80f759:	83 f8 40             	cmp    $0x40,%eax
  80f75c:	74 0c                	je     80f76a <do_newconn+0x60>
  80f75e:	83 f8 10             	cmp    $0x10,%eax
  80f761:	0f 85 8f 00 00 00    	jne    80f7f6 <do_newconn+0xec>
  80f767:	90                   	nop
  80f768:	eb 6f                	jmp    80f7d9 <do_newconn+0xcf>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80f76a:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80f76e:	89 04 24             	mov    %eax,(%esp)
  80f771:	e8 29 1d 00 00       	call   81149f <raw_new>
  80f776:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80f779:	8b 03                	mov    (%ebx),%eax
  80f77b:	8b 50 08             	mov    0x8(%eax),%edx
  80f77e:	85 d2                	test   %edx,%edx
  80f780:	75 06                	jne    80f788 <do_newconn+0x7e>
       msg->conn->err = ERR_MEM;
  80f782:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f786:	eb 72                	jmp    80f7fa <do_newconn+0xf0>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80f788:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f78c:	c7 44 24 04 11 f8 80 	movl   $0x80f811,0x4(%esp)
  80f793:	00 
  80f794:	89 14 24             	mov    %edx,(%esp)
  80f797:	e8 ef 1c 00 00       	call   81148b <raw_recv>
  80f79c:	eb 5c                	jmp    80f7fa <do_newconn+0xf0>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80f79e:	e8 8c c3 ff ff       	call   80bb2f <udp_new>
  80f7a3:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80f7a6:	8b 03                	mov    (%ebx),%eax
  80f7a8:	8b 50 08             	mov    0x8(%eax),%edx
  80f7ab:	85 d2                	test   %edx,%edx
  80f7ad:	75 06                	jne    80f7b5 <do_newconn+0xab>
       msg->conn->err = ERR_MEM;
  80f7af:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f7b3:	eb 45                	jmp    80f7fa <do_newconn+0xf0>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80f7b5:	83 38 22             	cmpl   $0x22,(%eax)
  80f7b8:	75 04                	jne    80f7be <do_newconn+0xb4>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80f7ba:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80f7be:	8b 03                	mov    (%ebx),%eax
  80f7c0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f7c4:	c7 44 24 04 89 f4 80 	movl   $0x80f489,0x4(%esp)
  80f7cb:	00 
  80f7cc:	8b 40 08             	mov    0x8(%eax),%eax
  80f7cf:	89 04 24             	mov    %eax,(%esp)
  80f7d2:	e8 44 c3 ff ff       	call   80bb1b <udp_recv>
  80f7d7:	eb 21                	jmp    80f7fa <do_newconn+0xf0>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80f7d9:	e8 6c 95 ff ff       	call   808d4a <tcp_new>
  80f7de:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80f7e1:	8b 03                	mov    (%ebx),%eax
  80f7e3:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f7e7:	75 06                	jne    80f7ef <do_newconn+0xe5>
       msg->conn->err = ERR_MEM;
  80f7e9:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f7ed:	eb 0b                	jmp    80f7fa <do_newconn+0xf0>
       break;
     }
     setup_tcp(msg->conn);
  80f7ef:	e8 14 f0 ff ff       	call   80e808 <setup_tcp>
  80f7f4:	eb 04                	jmp    80f7fa <do_newconn+0xf0>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80f7f6:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80f7fa:	8b 03                	mov    (%ebx),%eax
  80f7fc:	8b 40 10             	mov    0x10(%eax),%eax
  80f7ff:	89 04 24             	mov    %eax,(%esp)
  80f802:	e8 60 de ff ff       	call   80d667 <sys_sem_signal>
}
  80f807:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f80a:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f80d:	89 ec                	mov    %ebp,%esp
  80f80f:	5d                   	pop    %ebp
  80f810:	c3                   	ret    

0080f811 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80f811:	55                   	push   %ebp
  80f812:	89 e5                	mov    %esp,%ebp
  80f814:	83 ec 28             	sub    $0x28,%esp
  80f817:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f81a:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f81d:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f820:	8b 7d 10             	mov    0x10(%ebp),%edi
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  80f823:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80f826:	85 db                	test   %ebx,%ebx
  80f828:	0f 84 b0 00 00 00    	je     80f8de <recv_raw+0xcd>
  80f82e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f832:	0f 84 a6 00 00 00    	je     80f8de <recv_raw+0xcd>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80f838:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f83f:	00 
  80f840:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80f844:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f848:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80f84f:	e8 e5 83 ff ff       	call   807c39 <pbuf_alloc>
  80f854:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80f856:	85 c0                	test   %eax,%eax
  80f858:	0f 84 80 00 00 00    	je     80f8de <recv_raw+0xcd>
      if (pbuf_copy(q, p) != ERR_OK) {
  80f85e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f862:	89 04 24             	mov    %eax,(%esp)
  80f865:	e8 6a 7f ff ff       	call   8077d4 <pbuf_copy>
  80f86a:	84 c0                	test   %al,%al
  80f86c:	0f 84 7e 00 00 00    	je     80f8f0 <recv_raw+0xdf>
        pbuf_free(q);
  80f872:	89 34 24             	mov    %esi,(%esp)
  80f875:	e8 03 81 ff ff       	call   80797d <pbuf_free>
  80f87a:	eb 62                	jmp    80f8de <recv_raw+0xcd>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80f87c:	89 34 24             	mov    %esi,(%esp)
  80f87f:	e8 f9 80 ff ff       	call   80797d <pbuf_free>
        return 0;
  80f884:	eb 58                	jmp    80f8de <recv_raw+0xcd>
      }

      buf->p = q;
  80f886:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80f888:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80f88b:	8b 46 04             	mov    0x4(%esi),%eax
  80f88e:	83 c0 0c             	add    $0xc,%eax
  80f891:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80f894:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f897:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80f89b:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80f89f:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f8a3:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80f8a7:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f8aa:	85 c0                	test   %eax,%eax
  80f8ac:	74 15                	je     80f8c3 <recv_raw+0xb2>
  80f8ae:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80f8b2:	89 54 24 08          	mov    %edx,0x8(%esp)
  80f8b6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f8bd:	00 
  80f8be:	89 1c 24             	mov    %ebx,(%esp)
  80f8c1:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80f8c3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f8c7:	8b 43 14             	mov    0x14(%ebx),%eax
  80f8ca:	89 04 24             	mov    %eax,(%esp)
  80f8cd:	e8 45 df ff ff       	call   80d817 <sys_mbox_trypost>
  80f8d2:	84 c0                	test   %al,%al
  80f8d4:	74 08                	je     80f8de <recv_raw+0xcd>
        netbuf_delete(buf);
  80f8d6:	89 3c 24             	mov    %edi,(%esp)
  80f8d9:	e8 c0 57 ff ff       	call   80509e <netbuf_delete>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80f8de:	b8 00 00 00 00       	mov    $0x0,%eax
  80f8e3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f8e6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f8e9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f8ec:	89 ec                	mov    %ebp,%esp
  80f8ee:	5d                   	pop    %ebp
  80f8ef:	c3                   	ret    
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80f8f0:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80f8f7:	e8 3c 79 ff ff       	call   807238 <memp_malloc>
  80f8fc:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80f8fe:	85 c0                	test   %eax,%eax
  80f900:	75 84                	jne    80f886 <recv_raw+0x75>
  80f902:	e9 75 ff ff ff       	jmp    80f87c <recv_raw+0x6b>
	...

0080f910 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80f910:	55                   	push   %ebp
  80f911:	89 e5                	mov    %esp,%ebp
  80f913:	57                   	push   %edi
  80f914:	56                   	push   %esi
  80f915:	53                   	push   %ebx
  80f916:	83 ec 1c             	sub    $0x1c,%esp
  80f919:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80f91b:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80f920:	8d 70 14             	lea    0x14(%eax),%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80f923:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80f927:	89 04 24             	mov    %eax,(%esp)
  80f92a:	e8 51 ae ff ff       	call   80a780 <ntohs>
  80f92f:	66 c1 e8 0c          	shr    $0xc,%ax
  80f933:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f938:	66 83 f8 05          	cmp    $0x5,%ax
  80f93c:	77 54                	ja     80f992 <tcp_parseopt+0x82>
  80f93e:	eb 78                	jmp    80f9b8 <tcp_parseopt+0xa8>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80f940:	0f b6 d3             	movzbl %bl,%edx
  80f943:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80f947:	84 c0                	test   %al,%al
  80f949:	74 6d                	je     80f9b8 <tcp_parseopt+0xa8>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80f94b:	3c 01                	cmp    $0x1,%al
  80f94d:	8d 76 00             	lea    0x0(%esi),%esi
  80f950:	75 05                	jne    80f957 <tcp_parseopt+0x47>
        ++c;
  80f952:	83 c3 01             	add    $0x1,%ebx
  80f955:	eb 3b                	jmp    80f992 <tcp_parseopt+0x82>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80f957:	3c 02                	cmp    $0x2,%al
  80f959:	75 2c                	jne    80f987 <tcp_parseopt+0x77>
        opts[c + 1] == 0x04) {
  80f95b:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80f960:	75 25                	jne    80f987 <tcp_parseopt+0x77>
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80f962:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80f967:	c1 e0 08             	shl    $0x8,%eax
  80f96a:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80f96f:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80f971:	8d 50 ff             	lea    -0x1(%eax),%edx
  80f974:	66 81 fa b4 05       	cmp    $0x5b4,%dx
  80f979:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80f97e:	0f 43 c2             	cmovae %edx,%eax
  80f981:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80f985:	eb 31                	jmp    80f9b8 <tcp_parseopt+0xa8>
      } else {
        if (opts[c + 1] == 0) {
  80f987:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80f98c:	84 c0                	test   %al,%al
  80f98e:	74 28                	je     80f9b8 <tcp_parseopt+0xa8>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80f990:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80f992:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80f997:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80f99b:	89 04 24             	mov    %eax,(%esp)
  80f99e:	e8 dd ad ff ff       	call   80a780 <ntohs>
  80f9a3:	0f b6 d3             	movzbl %bl,%edx
  80f9a6:	66 c1 e8 0c          	shr    $0xc,%ax
  80f9aa:	0f b7 c0             	movzwl %ax,%eax
  80f9ad:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80f9b4:	39 c2                	cmp    %eax,%edx
  80f9b6:	7c 88                	jl     80f940 <tcp_parseopt+0x30>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80f9b8:	83 c4 1c             	add    $0x1c,%esp
  80f9bb:	5b                   	pop    %ebx
  80f9bc:	5e                   	pop    %esi
  80f9bd:	5f                   	pop    %edi
  80f9be:	5d                   	pop    %ebp
  80f9bf:	c3                   	ret    

0080f9c0 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80f9c0:	55                   	push   %ebp
  80f9c1:	89 e5                	mov    %esp,%ebp
  80f9c3:	57                   	push   %edi
  80f9c4:	56                   	push   %esi
  80f9c5:	53                   	push   %ebx
  80f9c6:	83 ec 2c             	sub    $0x2c,%esp
  80f9c9:	89 c3                	mov    %eax,%ebx
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80f9cb:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  80f9d2:	0f 84 6c 04 00 00    	je     80fe44 <tcp_receive+0x484>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80f9d8:	0f b7 70 5c          	movzwl 0x5c(%eax),%esi
  80f9dc:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80f9df:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  80f9e4:	39 c2                	cmp    %eax,%edx
  80f9e6:	78 24                	js     80fa0c <tcp_receive+0x4c>
  80f9e8:	39 c2                	cmp    %eax,%edx
  80f9ea:	75 0a                	jne    80f9f6 <tcp_receive+0x36>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80f9ec:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80f9f1:	39 43 64             	cmp    %eax,0x64(%ebx)
  80f9f4:	78 16                	js     80fa0c <tcp_receive+0x4c>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80f9f6:	8b 43 64             	mov    0x64(%ebx),%eax
  80f9f9:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  80f9ff:	75 3f                	jne    80fa40 <tcp_receive+0x80>
  80fa01:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80fa06:	66 3b 70 0e          	cmp    0xe(%eax),%si
  80fa0a:	73 34                	jae    80fa40 <tcp_receive+0x80>
      pcb->snd_wnd = tcphdr->wnd;
  80fa0c:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80fa11:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  80fa15:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno;
  80fa19:	8b 0d f8 c1 b3 00    	mov    0xb3c1f8,%ecx
  80fa1f:	89 4b 60             	mov    %ecx,0x60(%ebx)
      pcb->snd_wl2 = ackno;
  80fa22:	8b 0d fc c1 b3 00    	mov    0xb3c1fc,%ecx
  80fa28:	89 4b 64             	mov    %ecx,0x64(%ebx)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80fa2b:	66 85 c0             	test   %ax,%ax
  80fa2e:	74 10                	je     80fa40 <tcp_receive+0x80>
  80fa30:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  80fa37:	74 07                	je     80fa40 <tcp_receive+0x80>
          pcb->persist_backoff = 0;
  80fa39:	c6 83 a4 00 00 00 00 	movb   $0x0,0xa4(%ebx)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80fa40:	8b 4b 48             	mov    0x48(%ebx),%ecx
  80fa43:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80fa48:	39 c1                	cmp    %eax,%ecx
  80fa4a:	0f 85 ab 00 00 00    	jne    80fafb <tcp_receive+0x13b>
      pcb->acked = 0;
  80fa50:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80fa56:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  80fa5a:	03 43 60             	add    0x60(%ebx),%eax
  80fa5d:	0f b7 f6             	movzwl %si,%esi
  80fa60:	8d 14 16             	lea    (%esi,%edx,1),%edx
  80fa63:	39 d0                	cmp    %edx,%eax
  80fa65:	0f 85 fe 02 00 00    	jne    80fd69 <tcp_receive+0x3a9>
        ++pcb->dupacks;
  80fa6b:	0f b6 43 4c          	movzbl 0x4c(%ebx),%eax
  80fa6f:	83 c0 01             	add    $0x1,%eax
  80fa72:	88 43 4c             	mov    %al,0x4c(%ebx)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80fa75:	3c 02                	cmp    $0x2,%al
  80fa77:	0f 86 ec 02 00 00    	jbe    80fd69 <tcp_receive+0x3a9>
  80fa7d:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80fa81:	0f 84 e2 02 00 00    	je     80fd69 <tcp_receive+0x3a9>
          if (!(pcb->flags & TF_INFR)) {
  80fa87:	f6 43 20 04          	testb  $0x4,0x20(%ebx)
  80fa8b:	75 52                	jne    80fadf <tcp_receive+0x11f>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80fa8d:	89 1c 24             	mov    %ebx,(%esp)
  80fa90:	e8 13 b8 ff ff       	call   80b2a8 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80fa95:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  80fa99:	0f b7 53 5c          	movzwl 0x5c(%ebx),%edx
  80fa9d:	66 39 d0             	cmp    %dx,%ax
  80faa0:	76 09                	jbe    80faab <tcp_receive+0xeb>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80faa2:	66 d1 ea             	shr    %dx
  80faa5:	66 89 53 50          	mov    %dx,0x50(%ebx)
  80faa9:	eb 07                	jmp    80fab2 <tcp_receive+0xf2>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80faab:	66 d1 e8             	shr    %ax
  80faae:	66 89 43 50          	mov    %ax,0x50(%ebx)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80fab2:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80fab6:	0f b7 4b 50          	movzwl 0x50(%ebx),%ecx
  80faba:	0f b7 d0             	movzwl %ax,%edx
  80fabd:	01 d2                	add    %edx,%edx
  80fabf:	39 d1                	cmp    %edx,%ecx
  80fac1:	7d 06                	jge    80fac9 <tcp_receive+0x109>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80fac3:	01 c0                	add    %eax,%eax
  80fac5:	66 89 43 50          	mov    %ax,0x50(%ebx)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80fac9:	66 6b 43 34 03       	imul   $0x3,0x34(%ebx),%ax
  80face:	66 03 43 50          	add    0x50(%ebx),%ax
  80fad2:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
            pcb->flags |= TF_INFR;
  80fad6:	80 4b 20 04          	orb    $0x4,0x20(%ebx)
  80fada:	e9 8a 02 00 00       	jmp    80fd69 <tcp_receive+0x3a9>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80fadf:	0f b7 53 4e          	movzwl 0x4e(%ebx),%edx
  80fae3:	89 d0                	mov    %edx,%eax
  80fae5:	66 03 43 34          	add    0x34(%ebx),%ax
  80fae9:	66 39 c2             	cmp    %ax,%dx
  80faec:	0f 83 77 02 00 00    	jae    80fd69 <tcp_receive+0x3a9>
              pcb->cwnd += pcb->mss;
  80faf2:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80faf6:	e9 6e 02 00 00       	jmp    80fd69 <tcp_receive+0x3a9>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80fafb:	f7 d1                	not    %ecx
  80fafd:	01 c1                	add    %eax,%ecx
  80faff:	0f 88 b2 01 00 00    	js     80fcb7 <tcp_receive+0x2f7>
  80fb05:	2b 43 58             	sub    0x58(%ebx),%eax
  80fb08:	85 c0                	test   %eax,%eax
  80fb0a:	0f 8f a7 01 00 00    	jg     80fcb7 <tcp_receive+0x2f7>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80fb10:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80fb14:	a8 04                	test   $0x4,%al
  80fb16:	74 0e                	je     80fb26 <tcp_receive+0x166>
        pcb->flags &= ~TF_INFR;
  80fb18:	83 e0 fb             	and    $0xfffffffb,%eax
  80fb1b:	88 43 20             	mov    %al,0x20(%ebx)
        pcb->cwnd = pcb->ssthresh;
  80fb1e:	0f b7 43 50          	movzwl 0x50(%ebx),%eax
  80fb22:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80fb26:	c6 43 46 00          	movb   $0x0,0x46(%ebx)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80fb2a:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  80fb2e:	66 c1 f8 03          	sar    $0x3,%ax
  80fb32:	66 03 43 42          	add    0x42(%ebx),%ax
  80fb36:	66 89 43 44          	mov    %ax,0x44(%ebx)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80fb3a:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80fb3f:	66 2b 43 48          	sub    0x48(%ebx),%ax
  80fb43:	66 89 43 6c          	mov    %ax,0x6c(%ebx)

      pcb->snd_buf += pcb->acked;
  80fb47:	66 01 43 6e          	add    %ax,0x6e(%ebx)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80fb4b:	c6 43 4c 00          	movb   $0x0,0x4c(%ebx)
      pcb->lastack = ackno;
  80fb4f:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80fb54:	89 43 48             	mov    %eax,0x48(%ebx)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80fb57:	83 7b 10 03          	cmpl   $0x3,0x10(%ebx)
  80fb5b:	0f 86 d3 00 00 00    	jbe    80fc34 <tcp_receive+0x274>
        if (pcb->cwnd < pcb->ssthresh) {
  80fb61:	0f b7 4b 4e          	movzwl 0x4e(%ebx),%ecx
  80fb65:	66 3b 4b 50          	cmp    0x50(%ebx),%cx
  80fb69:	73 18                	jae    80fb83 <tcp_receive+0x1c3>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80fb6b:	89 c8                	mov    %ecx,%eax
  80fb6d:	66 03 43 34          	add    0x34(%ebx),%ax
  80fb71:	66 39 c1             	cmp    %ax,%cx
  80fb74:	0f 83 ba 00 00 00    	jae    80fc34 <tcp_receive+0x274>
            pcb->cwnd += pcb->mss;
  80fb7a:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80fb7e:	e9 b1 00 00 00       	jmp    80fc34 <tcp_receive+0x274>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80fb83:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80fb87:	0f af d2             	imul   %edx,%edx
  80fb8a:	0f b7 f1             	movzwl %cx,%esi
  80fb8d:	89 d0                	mov    %edx,%eax
  80fb8f:	c1 fa 1f             	sar    $0x1f,%edx
  80fb92:	f7 fe                	idiv   %esi
  80fb94:	8d 04 01             	lea    (%ecx,%eax,1),%eax
          if (new_cwnd > pcb->cwnd) {
  80fb97:	66 39 c1             	cmp    %ax,%cx
  80fb9a:	0f 83 94 00 00 00    	jae    80fc34 <tcp_receive+0x274>
            pcb->cwnd = new_cwnd;
  80fba0:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80fba4:	e9 8b 00 00 00       	jmp    80fc34 <tcp_receive+0x274>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80fba9:	8b 73 78             	mov    0x78(%ebx),%esi
        pcb->unacked = pcb->unacked->next;
  80fbac:	8b 06                	mov    (%esi),%eax
  80fbae:	89 43 78             	mov    %eax,0x78(%ebx)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80fbb1:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80fbb5:	8b 46 04             	mov    0x4(%esi),%eax
  80fbb8:	89 04 24             	mov    %eax,(%esp)
  80fbbb:	e8 60 79 ff ff       	call   807520 <pbuf_clen>
  80fbc0:	0f b6 c0             	movzbl %al,%eax
  80fbc3:	66 39 c7             	cmp    %ax,%di
  80fbc6:	73 1c                	jae    80fbe4 <tcp_receive+0x224>
  80fbc8:	c7 44 24 08 4c 49 81 	movl   $0x81494c,0x8(%esp)
  80fbcf:	00 
  80fbd0:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  80fbd7:	00 
  80fbd8:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fbdf:	e8 30 0d ff ff       	call   800914 <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80fbe4:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80fbe8:	8b 46 04             	mov    0x4(%esi),%eax
  80fbeb:	89 04 24             	mov    %eax,(%esp)
  80fbee:	e8 2d 79 ff ff       	call   807520 <pbuf_clen>
  80fbf3:	0f b6 c0             	movzbl %al,%eax
  80fbf6:	66 29 c7             	sub    %ax,%di
  80fbf9:	66 89 7b 70          	mov    %di,0x70(%ebx)
        tcp_seg_free(next);
  80fbfd:	89 34 24             	mov    %esi,(%esp)
  80fc00:	e8 ec 88 ff ff       	call   8084f1 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80fc05:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  80fc0a:	74 28                	je     80fc34 <tcp_receive+0x274>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80fc0c:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80fc10:	75 22                	jne    80fc34 <tcp_receive+0x274>
  80fc12:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  80fc16:	75 1c                	jne    80fc34 <tcp_receive+0x274>
  80fc18:	c7 44 24 08 74 49 81 	movl   $0x814974,0x8(%esp)
  80fc1f:	00 
  80fc20:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  80fc27:	00 
  80fc28:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fc2f:	e8 e0 0c ff ff       	call   800914 <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80fc34:	8b 43 78             	mov    0x78(%ebx),%eax
  80fc37:	85 c0                	test   %eax,%eax
  80fc39:	74 65                	je     80fca0 <tcp_receive+0x2e0>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80fc3b:	8b 40 10             	mov    0x10(%eax),%eax
  80fc3e:	8b 40 04             	mov    0x4(%eax),%eax
  80fc41:	89 04 24             	mov    %eax,(%esp)
  80fc44:	e8 6c ad ff ff       	call   80a9b5 <ntohl>
  80fc49:	89 c6                	mov    %eax,%esi
  80fc4b:	8b 43 78             	mov    0x78(%ebx),%eax
  80fc4e:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80fc52:	8b 40 10             	mov    0x10(%eax),%eax
  80fc55:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fc59:	89 04 24             	mov    %eax,(%esp)
  80fc5c:	e8 1f ab ff ff       	call   80a780 <ntohs>
  80fc61:	a8 01                	test   $0x1,%al
  80fc63:	75 1b                	jne    80fc80 <tcp_receive+0x2c0>
  80fc65:	8b 43 78             	mov    0x78(%ebx),%eax
  80fc68:	8b 40 10             	mov    0x10(%eax),%eax
  80fc6b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fc6f:	89 04 24             	mov    %eax,(%esp)
  80fc72:	e8 09 ab ff ff       	call   80a780 <ntohs>
  80fc77:	ba 00 00 00 00       	mov    $0x0,%edx
  80fc7c:	a8 02                	test   $0x2,%al
  80fc7e:	74 05                	je     80fc85 <tcp_receive+0x2c5>
  80fc80:	ba 01 00 00 00       	mov    $0x1,%edx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80fc85:	2b 35 fc c1 b3 00    	sub    0xb3c1fc,%esi
  80fc8b:	0f b7 ff             	movzwl %di,%edi
  80fc8e:	01 fa                	add    %edi,%edx
  80fc90:	01 d6                	add    %edx,%esi
  80fc92:	85 f6                	test   %esi,%esi
  80fc94:	0f 8e 0f ff ff ff    	jle    80fba9 <tcp_receive+0x1e9>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80fc9a:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80fc9e:	75 08                	jne    80fca8 <tcp_receive+0x2e8>
        pcb->rtime = -1;
  80fca0:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80fca6:	eb 06                	jmp    80fcae <tcp_receive+0x2ee>
      else
        pcb->rtime = 0;
  80fca8:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

      pcb->polltmr = 0;
  80fcae:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80fcb2:	e9 b2 00 00 00       	jmp    80fd69 <tcp_receive+0x3a9>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80fcb7:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)
  80fcbd:	8d 76 00             	lea    0x0(%esi),%esi
  80fcc0:	e9 a4 00 00 00       	jmp    80fd69 <tcp_receive+0x3a9>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80fcc5:	8b 73 74             	mov    0x74(%ebx),%esi
      pcb->unsent = pcb->unsent->next;
  80fcc8:	8b 06                	mov    (%esi),%eax
  80fcca:	89 43 74             	mov    %eax,0x74(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80fccd:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80fcd1:	8b 46 04             	mov    0x4(%esi),%eax
  80fcd4:	89 04 24             	mov    %eax,(%esp)
  80fcd7:	e8 44 78 ff ff       	call   807520 <pbuf_clen>
  80fcdc:	0f b6 c0             	movzbl %al,%eax
  80fcdf:	66 39 c7             	cmp    %ax,%di
  80fce2:	73 1c                	jae    80fd00 <tcp_receive+0x340>
  80fce4:	c7 44 24 08 4c 49 81 	movl   $0x81494c,0x8(%esp)
  80fceb:	00 
  80fcec:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  80fcf3:	00 
  80fcf4:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fcfb:	e8 14 0c ff ff       	call   800914 <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80fd00:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80fd04:	8b 46 04             	mov    0x4(%esi),%eax
  80fd07:	89 04 24             	mov    %eax,(%esp)
  80fd0a:	e8 11 78 ff ff       	call   807520 <pbuf_clen>
  80fd0f:	0f b6 c0             	movzbl %al,%eax
  80fd12:	66 29 c7             	sub    %ax,%di
  80fd15:	66 89 7b 70          	mov    %di,0x70(%ebx)
      tcp_seg_free(next);
  80fd19:	89 34 24             	mov    %esi,(%esp)
  80fd1c:	e8 d0 87 ff ff       	call   8084f1 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80fd21:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  80fd26:	74 29                	je     80fd51 <tcp_receive+0x391>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80fd28:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80fd2c:	75 23                	jne    80fd51 <tcp_receive+0x391>
  80fd2e:	8b 43 74             	mov    0x74(%ebx),%eax
  80fd31:	85 c0                	test   %eax,%eax
  80fd33:	75 23                	jne    80fd58 <tcp_receive+0x398>
  80fd35:	c7 44 24 08 74 49 81 	movl   $0x814974,0x8(%esp)
  80fd3c:	00 
  80fd3d:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  80fd44:	00 
  80fd45:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fd4c:	e8 c3 0b ff ff       	call   800914 <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80fd51:	8b 43 74             	mov    0x74(%ebx),%eax
  80fd54:	85 c0                	test   %eax,%eax
  80fd56:	74 11                	je     80fd69 <tcp_receive+0x3a9>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80fd58:	8b 40 10             	mov    0x10(%eax),%eax
  80fd5b:	8b 40 04             	mov    0x4(%eax),%eax
  80fd5e:	89 04 24             	mov    %eax,(%esp)
  80fd61:	e8 2e aa ff ff       	call   80a794 <htonl>
  80fd66:	89 43 54             	mov    %eax,0x54(%ebx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80fd69:	8b 43 74             	mov    0x74(%ebx),%eax
  80fd6c:	85 c0                	test   %eax,%eax
  80fd6e:	74 70                	je     80fde0 <tcp_receive+0x420>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80fd70:	8b 35 fc c1 b3 00    	mov    0xb3c1fc,%esi
  80fd76:	8b 40 10             	mov    0x10(%eax),%eax
  80fd79:	8b 40 04             	mov    0x4(%eax),%eax
  80fd7c:	89 04 24             	mov    %eax,(%esp)
  80fd7f:	e8 31 ac ff ff       	call   80a9b5 <ntohl>
  80fd84:	89 c7                	mov    %eax,%edi
  80fd86:	8b 43 74             	mov    0x74(%ebx),%eax
  80fd89:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  80fd8d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  80fd91:	8b 40 10             	mov    0x10(%eax),%eax
  80fd94:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fd98:	89 04 24             	mov    %eax,(%esp)
  80fd9b:	e8 e0 a9 ff ff       	call   80a780 <ntohs>
  80fda0:	a8 01                	test   $0x1,%al
  80fda2:	75 1b                	jne    80fdbf <tcp_receive+0x3ff>
  80fda4:	8b 43 74             	mov    0x74(%ebx),%eax
  80fda7:	8b 40 10             	mov    0x10(%eax),%eax
  80fdaa:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fdae:	89 04 24             	mov    %eax,(%esp)
  80fdb1:	e8 ca a9 ff ff       	call   80a780 <ntohs>
  80fdb6:	ba 00 00 00 00       	mov    $0x0,%edx
  80fdbb:	a8 02                	test   $0x2,%al
  80fdbd:	74 05                	je     80fdc4 <tcp_receive+0x404>
  80fdbf:	ba 01 00 00 00       	mov    $0x1,%edx
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80fdc4:	29 fe                	sub    %edi,%esi
  80fdc6:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80fdca:	01 c2                	add    %eax,%edx
  80fdcc:	39 d6                	cmp    %edx,%esi
  80fdce:	78 10                	js     80fde0 <tcp_receive+0x420>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80fdd0:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80fdd5:	2b 43 58             	sub    0x58(%ebx),%eax
  80fdd8:	85 c0                	test   %eax,%eax
  80fdda:	0f 8e e5 fe ff ff    	jle    80fcc5 <tcp_receive+0x305>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80fde0:	8b 43 38             	mov    0x38(%ebx),%eax
  80fde3:	85 c0                	test   %eax,%eax
  80fde5:	74 5d                	je     80fe44 <tcp_receive+0x484>
  80fde7:	8b 35 fc c1 b3 00    	mov    0xb3c1fc,%esi
  80fded:	39 73 3c             	cmp    %esi,0x3c(%ebx)
  80fdf0:	79 52                	jns    80fe44 <tcp_receive+0x484>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80fdf2:	0f b7 53 40          	movzwl 0x40(%ebx),%edx
  80fdf6:	8b 0d 10 f0 b3 00    	mov    0xb3f010,%ecx
  80fdfc:	66 29 c1             	sub    %ax,%cx
  80fdff:	89 c8                	mov    %ecx,%eax
  80fe01:	89 d1                	mov    %edx,%ecx
  80fe03:	66 c1 f9 03          	sar    $0x3,%cx
  80fe07:	66 29 c8             	sub    %cx,%ax
      pcb->sa += m;
  80fe0a:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80fe0d:	66 89 53 40          	mov    %dx,0x40(%ebx)
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
  80fe11:	0f b7 4b 42          	movzwl 0x42(%ebx),%ecx
      pcb->sv += m;
  80fe15:	89 ce                	mov    %ecx,%esi
  80fe17:	66 c1 fe 02          	sar    $0x2,%si
  80fe1b:	66 29 f1             	sub    %si,%cx
  80fe1e:	89 ce                	mov    %ecx,%esi
  80fe20:	89 c1                	mov    %eax,%ecx
  80fe22:	66 c1 f9 0f          	sar    $0xf,%cx
  80fe26:	31 c8                	xor    %ecx,%eax
  80fe28:	66 29 c8             	sub    %cx,%ax
  80fe2b:	8d 04 06             	lea    (%esi,%eax,1),%eax
  80fe2e:	66 89 43 42          	mov    %ax,0x42(%ebx)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80fe32:	66 c1 fa 03          	sar    $0x3,%dx
  80fe36:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80fe39:	66 89 43 44          	mov    %ax,0x44(%ebx)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80fe3d:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80fe44:	0f b7 0d 02 c2 b3 00 	movzwl 0xb3c202,%ecx
  80fe4b:	66 85 c9             	test   %cx,%cx
  80fe4e:	0f 84 a5 07 00 00    	je     8105f9 <tcp_receive+0xc39>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80fe54:	8b 53 24             	mov    0x24(%ebx),%edx
  80fe57:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  80fe5c:	89 c6                	mov    %eax,%esi
  80fe5e:	f7 d6                	not    %esi
  80fe60:	01 d6                	add    %edx,%esi
  80fe62:	0f 88 3a 01 00 00    	js     80ffa2 <tcp_receive+0x5e2>
  80fe68:	8d 7a 01             	lea    0x1(%edx),%edi
  80fe6b:	29 c7                	sub    %eax,%edi
  80fe6d:	0f b7 f1             	movzwl %cx,%esi
  80fe70:	89 f9                	mov    %edi,%ecx
  80fe72:	29 f1                	sub    %esi,%ecx
  80fe74:	85 c9                	test   %ecx,%ecx
  80fe76:	0f 8f 26 01 00 00    	jg     80ffa2 <tcp_receive+0x5e2>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
  80fe7c:	8b 35 e0 c1 b3 00    	mov    0xb3c1e0,%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80fe82:	85 f6                	test   %esi,%esi
  80fe84:	75 1c                	jne    80fea2 <tcp_receive+0x4e2>
  80fe86:	c7 44 24 08 cf 4a 81 	movl   $0x814acf,0x8(%esp)
  80fe8d:	00 
  80fe8e:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  80fe95:	00 
  80fe96:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fe9d:	e8 72 0a ff ff       	call   800914 <_panic>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80fea2:	29 c2                	sub    %eax,%edx
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80fea4:	81 fa fe 7f 00 00    	cmp    $0x7ffe,%edx
  80feaa:	7e 1c                	jle    80fec8 <tcp_receive+0x508>
  80feac:	c7 44 24 08 df 4a 81 	movl   $0x814adf,0x8(%esp)
  80feb3:	00 
  80feb4:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  80febb:	00 
  80febc:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fec3:	e8 4c 0a ff ff       	call   800914 <_panic>
      if (inseg.p->len < off) {
  80fec8:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80fecc:	39 c2                	cmp    %eax,%edx
  80fece:	7e 71                	jle    80ff41 <tcp_receive+0x581>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80fed0:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  80fed4:	0f b7 f9             	movzwl %cx,%edi
  80fed7:	39 fa                	cmp    %edi,%edx
  80fed9:	7e 1c                	jle    80fef7 <tcp_receive+0x537>
  80fedb:	c7 44 24 08 ee 4a 81 	movl   $0x814aee,0x8(%esp)
  80fee2:	00 
  80fee3:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  80feea:	00 
  80feeb:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fef2:	e8 1d 0a ff ff       	call   800914 <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80fef7:	66 29 d1             	sub    %dx,%cx
        while (p->len < off) {
          off -= p->len;
  80fefa:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80fefc:	66 89 4e 08          	mov    %cx,0x8(%esi)
          p->len = 0;
  80ff00:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
          p = p->next;
  80ff06:	8b 36                	mov    (%esi),%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80ff08:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80ff0c:	39 d0                	cmp    %edx,%eax
  80ff0e:	7c ea                	jl     80fefa <tcp_receive+0x53a>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80ff10:	f7 da                	neg    %edx
  80ff12:	0f bf c2             	movswl %dx,%eax
  80ff15:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ff19:	89 34 24             	mov    %esi,(%esp)
  80ff1c:	e8 f2 76 ff ff       	call   807613 <pbuf_header>
  80ff21:	84 c0                	test   %al,%al
  80ff23:	74 4d                	je     80ff72 <tcp_receive+0x5b2>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80ff25:	c7 44 24 08 fe 4a 81 	movl   $0x814afe,0x8(%esp)
  80ff2c:	00 
  80ff2d:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  80ff34:	00 
  80ff35:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80ff3c:	e8 d3 09 ff ff       	call   800914 <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80ff41:	f7 da                	neg    %edx
  80ff43:	0f bf c2             	movswl %dx,%eax
  80ff46:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ff4a:	89 34 24             	mov    %esi,(%esp)
  80ff4d:	e8 c1 76 ff ff       	call   807613 <pbuf_header>
  80ff52:	84 c0                	test   %al,%al
  80ff54:	74 1c                	je     80ff72 <tcp_receive+0x5b2>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80ff56:	c7 44 24 08 fe 4a 81 	movl   $0x814afe,0x8(%esp)
  80ff5d:	00 
  80ff5e:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  80ff65:	00 
  80ff66:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80ff6d:	e8 a2 09 ff ff       	call   800914 <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80ff72:	8b 46 04             	mov    0x4(%esi),%eax
  80ff75:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80ff7a:	b8 e8 c1 b3 00       	mov    $0xb3c1e8,%eax
  80ff7f:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  80ff85:	66 03 10             	add    (%eax),%dx
  80ff88:	66 2b 53 24          	sub    0x24(%ebx),%dx
  80ff8c:	66 89 10             	mov    %dx,(%eax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80ff8f:	8b 43 24             	mov    0x24(%ebx),%eax
  80ff92:	a3 f8 c1 b3 00       	mov    %eax,0xb3c1f8
  80ff97:	8b 15 ec c1 b3 00    	mov    0xb3c1ec,%edx
  80ff9d:	89 42 04             	mov    %eax,0x4(%edx)
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80ffa0:	eb 10                	jmp    80ffb2 <tcp_receive+0x5f2>
      inseg.dataptr = p->payload;
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80ffa2:	39 d0                	cmp    %edx,%eax
  80ffa4:	79 1c                	jns    80ffc2 <tcp_receive+0x602>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80ffa6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80ffaa:	89 1c 24             	mov    %ebx,(%esp)
  80ffad:	e8 49 ae ff ff       	call   80adfb <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80ffb2:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  80ffb7:	8b 53 24             	mov    0x24(%ebx),%edx
  80ffba:	39 d0                	cmp    %edx,%eax
  80ffbc:	0f 88 24 06 00 00    	js     8105e6 <tcp_receive+0xc26>
  80ffc2:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80ffc6:	89 c7                	mov    %eax,%edi
  80ffc8:	29 cf                	sub    %ecx,%edi
  80ffca:	8d 4f 01             	lea    0x1(%edi),%ecx
  80ffcd:	29 d1                	sub    %edx,%ecx
  80ffcf:	85 c9                	test   %ecx,%ecx
  80ffd1:	0f 8f 0f 06 00 00    	jg     8105e6 <tcp_receive+0xc26>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80ffd7:	39 d0                	cmp    %edx,%eax
  80ffd9:	0f 85 95 03 00 00    	jne    810374 <tcp_receive+0x9b4>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80ffdf:	8b 53 7c             	mov    0x7c(%ebx),%edx
  80ffe2:	85 d2                	test   %edx,%edx
  80ffe4:	0f 84 86 00 00 00    	je     810070 <tcp_receive+0x6b0>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80ffea:	8b 4a 10             	mov    0x10(%edx),%ecx
  80ffed:	8b 49 04             	mov    0x4(%ecx),%ecx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80fff0:	0f b7 35 e8 c1 b3 00 	movzwl 0xb3c1e8,%esi
  80fff7:	89 cf                	mov    %ecx,%edi
  80fff9:	29 f7                	sub    %esi,%edi
  80fffb:	89 fe                	mov    %edi,%esi
  80fffd:	29 c6                	sub    %eax,%esi
  80ffff:	85 f6                	test   %esi,%esi
  810001:	7f 6d                	jg     810070 <tcp_receive+0x6b0>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  810003:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  810008:	74 20                	je     81002a <tcp_receive+0x66a>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81000a:	66 29 c1             	sub    %ax,%cx
  81000d:	66 89 0d e8 c1 b3 00 	mov    %cx,0xb3c1e8
            pbuf_realloc(inseg.p, inseg.len);
  810014:	0f b7 c1             	movzwl %cx,%eax
  810017:	89 44 24 04          	mov    %eax,0x4(%esp)
  81001b:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  810020:	89 04 24             	mov    %eax,(%esp)
  810023:	e8 e1 7a ff ff       	call   807b09 <pbuf_realloc>
  810028:	eb 46                	jmp    810070 <tcp_receive+0x6b0>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81002a:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  81002f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810033:	89 04 24             	mov    %eax,(%esp)
  810036:	e8 45 a7 ff ff       	call   80a780 <ntohs>
  81003b:	89 c6                	mov    %eax,%esi
  81003d:	8b 43 7c             	mov    0x7c(%ebx),%eax
  810040:	8b 40 10             	mov    0x10(%eax),%eax
  810043:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810047:	89 04 24             	mov    %eax,(%esp)
  81004a:	e8 31 a7 ff ff       	call   80a780 <ntohs>
  81004f:	31 c6                	xor    %eax,%esi
  810051:	66 f7 c6 03 00       	test   $0x3,%si
  810056:	75 18                	jne    810070 <tcp_receive+0x6b0>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  810058:	8b 43 7c             	mov    0x7c(%ebx),%eax
              pcb->ooseq = pcb->ooseq->next;
  81005b:	8b 10                	mov    (%eax),%edx
  81005d:	89 53 7c             	mov    %edx,0x7c(%ebx)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  810060:	89 44 24 04          	mov    %eax,0x4(%esp)
  810064:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  81006b:	e8 84 71 ff ff       	call   8071f4 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  810070:	0f b7 35 e8 c1 b3 00 	movzwl 0xb3c1e8,%esi
  810077:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  81007c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810080:	89 04 24             	mov    %eax,(%esp)
  810083:	e8 f8 a6 ff ff       	call   80a780 <ntohs>
  810088:	a8 01                	test   $0x1,%al
  81008a:	75 1a                	jne    8100a6 <tcp_receive+0x6e6>
  81008c:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  810091:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810095:	89 04 24             	mov    %eax,(%esp)
  810098:	e8 e3 a6 ff ff       	call   80a780 <ntohs>
  81009d:	ba 00 00 00 00       	mov    $0x0,%edx
  8100a2:	a8 02                	test   $0x2,%al
  8100a4:	74 05                	je     8100ab <tcp_receive+0x6eb>
  8100a6:	ba 01 00 00 00       	mov    $0x1,%edx
  8100ab:	01 d6                	add    %edx,%esi
  8100ad:	66 89 35 02 c2 b3 00 	mov    %si,0xb3c202

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  8100b4:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8100b8:	74 06                	je     8100c0 <tcp_receive+0x700>
          pcb->rcv_nxt += tcplen;
  8100ba:	0f b7 f6             	movzwl %si,%esi
  8100bd:	01 73 24             	add    %esi,0x24(%ebx)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  8100c0:	0f b7 53 28          	movzwl 0x28(%ebx),%edx
  8100c4:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  8100cb:	66 39 c2             	cmp    %ax,%dx
  8100ce:	73 08                	jae    8100d8 <tcp_receive+0x718>
          pcb->rcv_wnd = 0;
  8100d0:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  8100d6:	eb 07                	jmp    8100df <tcp_receive+0x71f>
        } else {
          pcb->rcv_wnd -= tcplen;
  8100d8:	66 29 c2             	sub    %ax,%dx
  8100db:	66 89 53 28          	mov    %dx,0x28(%ebx)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  8100df:	0f b7 53 2a          	movzwl 0x2a(%ebx),%edx
  8100e3:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  8100ea:	66 39 c2             	cmp    %ax,%dx
  8100ed:	73 08                	jae    8100f7 <tcp_receive+0x737>
          pcb->rcv_ann_wnd = 0;
  8100ef:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  8100f5:	eb 07                	jmp    8100fe <tcp_receive+0x73e>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  8100f7:	66 29 c2             	sub    %ax,%dx
  8100fa:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  8100fe:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  810103:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  810108:	74 0f                	je     810119 <tcp_receive+0x759>
          recv_data = inseg.p;
  81010a:	a3 08 c2 b3 00       	mov    %eax,0xb3c208
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81010f:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  810116:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  810119:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  81011e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810122:	89 04 24             	mov    %eax,(%esp)
  810125:	e8 56 a6 ff ff       	call   80a780 <ntohs>
  81012a:	a8 01                	test   $0x1,%al
  81012c:	74 07                	je     810135 <tcp_receive+0x775>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81012e:	c6 05 04 c2 b3 00 20 	movb   $0x20,0xb3c204
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  810135:	8b 73 7c             	mov    0x7c(%ebx),%esi
  810138:	85 f6                	test   %esi,%esi
  81013a:	0f 84 01 02 00 00    	je     810341 <tcp_receive+0x981>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  810140:	8b 46 10             	mov    0x10(%esi),%eax
  810143:	8b 40 04             	mov    0x4(%eax),%eax
  810146:	3b 43 24             	cmp    0x24(%ebx),%eax
  810149:	0f 85 f2 01 00 00    	jne    810341 <tcp_receive+0x981>

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  81014f:	a3 f8 c1 b3 00       	mov    %eax,0xb3c1f8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  810154:	8b 43 24             	mov    0x24(%ebx),%eax
  810157:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  81015a:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  81015e:	8b 46 10             	mov    0x10(%esi),%eax
  810161:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810165:	89 04 24             	mov    %eax,(%esp)
  810168:	e8 13 a6 ff ff       	call   80a780 <ntohs>
  81016d:	a8 01                	test   $0x1,%al
  81016f:	75 18                	jne    810189 <tcp_receive+0x7c9>
  810171:	8b 46 10             	mov    0x10(%esi),%eax
  810174:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810178:	89 04 24             	mov    %eax,(%esp)
  81017b:	e8 00 a6 ff ff       	call   80a780 <ntohs>
  810180:	ba 00 00 00 00       	mov    $0x0,%edx
  810185:	a8 02                	test   $0x2,%al
  810187:	74 05                	je     81018e <tcp_receive+0x7ce>
  810189:	ba 01 00 00 00       	mov    $0x1,%edx
  81018e:	0f b7 ff             	movzwl %di,%edi
  810191:	01 fa                	add    %edi,%edx
  810193:	03 55 e4             	add    -0x1c(%ebp),%edx
  810196:	89 53 24             	mov    %edx,0x24(%ebx)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  810199:	0f b7 7b 28          	movzwl 0x28(%ebx),%edi
  81019d:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  8101a1:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  8101a5:	8b 46 10             	mov    0x10(%esi),%eax
  8101a8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8101ac:	89 04 24             	mov    %eax,(%esp)
  8101af:	e8 cc a5 ff ff       	call   80a780 <ntohs>
  8101b4:	a8 01                	test   $0x1,%al
  8101b6:	75 18                	jne    8101d0 <tcp_receive+0x810>
  8101b8:	8b 46 10             	mov    0x10(%esi),%eax
  8101bb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8101bf:	89 04 24             	mov    %eax,(%esp)
  8101c2:	e8 b9 a5 ff ff       	call   80a780 <ntohs>
  8101c7:	ba 00 00 00 00       	mov    $0x0,%edx
  8101cc:	a8 02                	test   $0x2,%al
  8101ce:	74 05                	je     8101d5 <tcp_receive+0x815>
  8101d0:	ba 01 00 00 00       	mov    $0x1,%edx
  8101d5:	0f b7 ff             	movzwl %di,%edi
  8101d8:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8101dc:	01 c2                	add    %eax,%edx
  8101de:	39 d7                	cmp    %edx,%edi
  8101e0:	7d 08                	jge    8101ea <tcp_receive+0x82a>
            pcb->rcv_wnd = 0;
  8101e2:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  8101e8:	eb 47                	jmp    810231 <tcp_receive+0x871>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  8101ea:	0f b7 7b 28          	movzwl 0x28(%ebx),%edi
  8101ee:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8101f2:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  8101f6:	8b 46 10             	mov    0x10(%esi),%eax
  8101f9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8101fd:	89 04 24             	mov    %eax,(%esp)
  810200:	e8 7b a5 ff ff       	call   80a780 <ntohs>
  810205:	a8 01                	test   $0x1,%al
  810207:	75 18                	jne    810221 <tcp_receive+0x861>
  810209:	8b 46 10             	mov    0x10(%esi),%eax
  81020c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810210:	89 04 24             	mov    %eax,(%esp)
  810213:	e8 68 a5 ff ff       	call   80a780 <ntohs>
  810218:	ba 00 00 00 00       	mov    $0x0,%edx
  81021d:	a8 02                	test   $0x2,%al
  81021f:	74 05                	je     810226 <tcp_receive+0x866>
  810221:	ba 01 00 00 00       	mov    $0x1,%edx
  810226:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  81022a:	66 29 d7             	sub    %dx,%di
  81022d:	66 89 7b 28          	mov    %di,0x28(%ebx)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  810231:	0f b7 7b 2a          	movzwl 0x2a(%ebx),%edi
  810235:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  810239:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  81023d:	8b 46 10             	mov    0x10(%esi),%eax
  810240:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810244:	89 04 24             	mov    %eax,(%esp)
  810247:	e8 34 a5 ff ff       	call   80a780 <ntohs>
  81024c:	a8 01                	test   $0x1,%al
  81024e:	75 18                	jne    810268 <tcp_receive+0x8a8>
  810250:	8b 46 10             	mov    0x10(%esi),%eax
  810253:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810257:	89 04 24             	mov    %eax,(%esp)
  81025a:	e8 21 a5 ff ff       	call   80a780 <ntohs>
  81025f:	ba 00 00 00 00       	mov    $0x0,%edx
  810264:	a8 02                	test   $0x2,%al
  810266:	74 05                	je     81026d <tcp_receive+0x8ad>
  810268:	ba 01 00 00 00       	mov    $0x1,%edx
  81026d:	0f b7 ff             	movzwl %di,%edi
  810270:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  810274:	01 c2                	add    %eax,%edx
  810276:	39 d7                	cmp    %edx,%edi
  810278:	7d 08                	jge    810282 <tcp_receive+0x8c2>
            pcb->rcv_ann_wnd = 0;
  81027a:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  810280:	eb 47                	jmp    8102c9 <tcp_receive+0x909>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  810282:	0f b7 7b 2a          	movzwl 0x2a(%ebx),%edi
  810286:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  81028a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  81028e:	8b 46 10             	mov    0x10(%esi),%eax
  810291:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810295:	89 04 24             	mov    %eax,(%esp)
  810298:	e8 e3 a4 ff ff       	call   80a780 <ntohs>
  81029d:	a8 01                	test   $0x1,%al
  81029f:	75 18                	jne    8102b9 <tcp_receive+0x8f9>
  8102a1:	8b 46 10             	mov    0x10(%esi),%eax
  8102a4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8102a8:	89 04 24             	mov    %eax,(%esp)
  8102ab:	e8 d0 a4 ff ff       	call   80a780 <ntohs>
  8102b0:	ba 00 00 00 00       	mov    $0x0,%edx
  8102b5:	a8 02                	test   $0x2,%al
  8102b7:	74 05                	je     8102be <tcp_receive+0x8fe>
  8102b9:	ba 01 00 00 00       	mov    $0x1,%edx
  8102be:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  8102c2:	66 29 d7             	sub    %dx,%di
  8102c5:	66 89 7b 2a          	mov    %di,0x2a(%ebx)
          }

          if (cseg->p->tot_len > 0) {
  8102c9:	8b 46 04             	mov    0x4(%esi),%eax
  8102cc:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  8102d1:	74 24                	je     8102f7 <tcp_receive+0x937>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  8102d3:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  8102d9:	85 d2                	test   %edx,%edx
  8102db:	74 0e                	je     8102eb <tcp_receive+0x92b>
              pbuf_cat(recv_data, cseg->p);
  8102dd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8102e1:	89 14 24             	mov    %edx,(%esp)
  8102e4:	e8 62 72 ff ff       	call   80754b <pbuf_cat>
  8102e9:	eb 05                	jmp    8102f0 <tcp_receive+0x930>
            } else {
              recv_data = cseg->p;
  8102eb:	a3 08 c2 b3 00       	mov    %eax,0xb3c208
            }
            cseg->p = NULL;
  8102f0:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  8102f7:	8b 46 10             	mov    0x10(%esi),%eax
  8102fa:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8102fe:	89 04 24             	mov    %eax,(%esp)
  810301:	e8 7a a4 ff ff       	call   80a780 <ntohs>
  810306:	a8 01                	test   $0x1,%al
  810308:	74 14                	je     81031e <tcp_receive+0x95e>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81030a:	c6 05 04 c2 b3 00 20 	movb   $0x20,0xb3c204
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  810311:	83 7b 10 04          	cmpl   $0x4,0x10(%ebx)
  810315:	75 07                	jne    81031e <tcp_receive+0x95e>
              pcb->state = CLOSE_WAIT;
  810317:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
            } 
          }


          pcb->ooseq = cseg->next;
  81031e:	8b 06                	mov    (%esi),%eax
  810320:	89 43 7c             	mov    %eax,0x7c(%ebx)
          tcp_seg_free(cseg);
  810323:	89 34 24             	mov    %esi,(%esp)
  810326:	e8 c6 81 ff ff       	call   8084f1 <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81032b:	8b 73 7c             	mov    0x7c(%ebx),%esi
  81032e:	85 f6                	test   %esi,%esi
  810330:	74 0f                	je     810341 <tcp_receive+0x981>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  810332:	8b 46 10             	mov    0x10(%esi),%eax
  810335:	8b 40 04             	mov    0x4(%eax),%eax
  810338:	3b 43 24             	cmp    0x24(%ebx),%eax
  81033b:	0f 84 0e fe ff ff    	je     81014f <tcp_receive+0x78f>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  810341:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  810345:	a8 01                	test   $0x1,%al
  810347:	74 1b                	je     810364 <tcp_receive+0x9a4>
  810349:	83 e0 fe             	and    $0xfffffffe,%eax
  81034c:	83 c8 02             	or     $0x2,%eax
  81034f:	88 43 20             	mov    %al,0x20(%ebx)
  810352:	89 1c 24             	mov    %ebx,(%esp)
  810355:	e8 a1 aa ff ff       	call   80adfb <tcp_output>
  81035a:	b8 01 00 00 00       	mov    $0x1,%eax
  81035f:	e9 cb 02 00 00       	jmp    81062f <tcp_receive+0xc6f>
  810364:	83 c8 01             	or     $0x1,%eax
  810367:	88 43 20             	mov    %al,0x20(%ebx)
  81036a:	b8 01 00 00 00       	mov    $0x1,%eax
  81036f:	e9 bb 02 00 00       	jmp    81062f <tcp_receive+0xc6f>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  810374:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810378:	89 1c 24             	mov    %ebx,(%esp)
  81037b:	e8 7b aa ff ff       	call   80adfb <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  810380:	8b 73 7c             	mov    0x7c(%ebx),%esi
  810383:	85 f6                	test   %esi,%esi
  810385:	74 31                	je     8103b8 <tcp_receive+0x9f8>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  810387:	8b 46 10             	mov    0x10(%esi),%eax
  81038a:	8b 40 04             	mov    0x4(%eax),%eax
  81038d:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  810393:	39 d0                	cmp    %edx,%eax
  810395:	74 18                	je     8103af <tcp_receive+0x9ef>
  810397:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  81039a:	bf 00 00 00 00       	mov    $0x0,%edi
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81039f:	8d 72 01             	lea    0x1(%edx),%esi
  8103a2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8103a5:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  8103a8:	89 f3                	mov    %esi,%ebx
  8103aa:	e9 b7 00 00 00       	jmp    810466 <tcp_receive+0xaa6>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  8103af:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8103b6:	eb 1f                	jmp    8103d7 <tcp_receive+0xa17>
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
          pcb->ooseq = tcp_seg_copy(&inseg);
  8103b8:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  8103bf:	e8 ea 80 ff ff       	call   8084ae <tcp_seg_copy>
  8103c4:	89 43 7c             	mov    %eax,0x7c(%ebx)
  8103c7:	b8 00 00 00 00       	mov    $0x0,%eax
  8103cc:	e9 5e 02 00 00       	jmp    81062f <tcp_receive+0xc6f>
  8103d1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8103d4:	8b 5d e0             	mov    -0x20(%ebp),%ebx
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  8103d7:	0f b7 05 e8 c1 b3 00 	movzwl 0xb3c1e8,%eax
  8103de:	66 3b 46 0c          	cmp    0xc(%esi),%ax
  8103e2:	0f 86 42 02 00 00    	jbe    81062a <tcp_receive+0xc6a>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  8103e8:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  8103ef:	e8 ba 80 ff ff       	call   8084ae <tcp_seg_copy>
  8103f4:	89 c7                	mov    %eax,%edi
                if (cseg != NULL) {
  8103f6:	85 c0                	test   %eax,%eax
  8103f8:	0f 84 2c 02 00 00    	je     81062a <tcp_receive+0xc6a>
                  cseg->next = next->next;
  8103fe:	8b 06                	mov    (%esi),%eax
  810400:	89 07                	mov    %eax,(%edi)
                  if (prev != NULL) {
  810402:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  810406:	74 07                	je     81040f <tcp_receive+0xa4f>
                    prev->next = cseg;
  810408:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  81040b:	89 3b                	mov    %edi,(%ebx)
  81040d:	eb 03                	jmp    810412 <tcp_receive+0xa52>
                  } else {
                    pcb->ooseq = cseg;
  81040f:	89 7b 7c             	mov    %edi,0x7c(%ebx)
                  }
                  tcp_seg_free(next);
  810412:	89 34 24             	mov    %esi,(%esp)
  810415:	e8 d7 80 ff ff       	call   8084f1 <tcp_seg_free>
                  if (cseg->next != NULL) {
  81041a:	8b 17                	mov    (%edi),%edx
  81041c:	85 d2                	test   %edx,%edx
  81041e:	0f 84 06 02 00 00    	je     81062a <tcp_receive+0xc6a>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  810424:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810429:	8b 52 10             	mov    0x10(%edx),%edx
  81042c:	8b 52 04             	mov    0x4(%edx),%edx
  81042f:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  810433:	29 d1                	sub    %edx,%ecx
  810435:	01 c1                	add    %eax,%ecx
  810437:	85 c9                	test   %ecx,%ecx
  810439:	0f 8e eb 01 00 00    	jle    81062a <tcp_receive+0xc6a>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81043f:	66 29 c2             	sub    %ax,%dx
  810442:	66 89 57 0c          	mov    %dx,0xc(%edi)
                      pbuf_realloc(cseg->p, cseg->len);
  810446:	0f b7 c2             	movzwl %dx,%eax
  810449:	89 44 24 04          	mov    %eax,0x4(%esp)
  81044d:	8b 47 04             	mov    0x4(%edi),%eax
  810450:	89 04 24             	mov    %eax,(%esp)
  810453:	e8 b1 76 ff ff       	call   807b09 <pbuf_realloc>
  810458:	b8 00 00 00 00       	mov    $0x0,%eax
  81045d:	e9 cd 01 00 00       	jmp    81062f <tcp_receive+0xc6f>
  810462:	89 cf                	mov    %ecx,%edi
  810464:	89 f1                	mov    %esi,%ecx
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  810466:	85 ff                	test   %edi,%edi
  810468:	75 60                	jne    8104ca <tcp_receive+0xb0a>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81046a:	39 c2                	cmp    %eax,%edx
  81046c:	0f 89 fd 00 00 00    	jns    81056f <tcp_receive+0xbaf>
  810472:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  810475:	8b 5d e0             	mov    -0x20(%ebp),%ebx
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  810478:	0f b7 0d e8 c1 b3 00 	movzwl 0xb3c1e8,%ecx
  81047f:	01 d1                	add    %edx,%ecx
  810481:	29 c1                	sub    %eax,%ecx
  810483:	85 c9                	test   %ecx,%ecx
  810485:	7e 1d                	jle    8104a4 <tcp_receive+0xae4>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  810487:	66 29 d0             	sub    %dx,%ax
  81048a:	66 a3 e8 c1 b3 00    	mov    %ax,0xb3c1e8
                    pbuf_realloc(inseg.p, inseg.len);
  810490:	0f b7 c0             	movzwl %ax,%eax
  810493:	89 44 24 04          	mov    %eax,0x4(%esp)
  810497:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  81049c:	89 04 24             	mov    %eax,(%esp)
  81049f:	e8 65 76 ff ff       	call   807b09 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  8104a4:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  8104ab:	e8 fe 7f ff ff       	call   8084ae <tcp_seg_copy>
                  if (cseg != NULL) {
  8104b0:	85 c0                	test   %eax,%eax
  8104b2:	0f 84 72 01 00 00    	je     81062a <tcp_receive+0xc6a>
                    cseg->next = next;
  8104b8:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8104bb:	89 30                	mov    %esi,(%eax)
                    pcb->ooseq = cseg;
  8104bd:	89 43 7c             	mov    %eax,0x7c(%ebx)
  8104c0:	b8 00 00 00 00       	mov    $0x0,%eax
  8104c5:	e9 65 01 00 00       	jmp    81062f <tcp_receive+0xc6f>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  8104ca:	8b 77 10             	mov    0x10(%edi),%esi
  8104cd:	8b 76 04             	mov    0x4(%esi),%esi
  8104d0:	f7 d6                	not    %esi
  8104d2:	01 d6                	add    %edx,%esi
  8104d4:	0f 88 95 00 00 00    	js     81056f <tcp_receive+0xbaf>
  8104da:	89 de                	mov    %ebx,%esi
  8104dc:	29 c6                	sub    %eax,%esi
  8104de:	85 f6                	test   %esi,%esi
  8104e0:	0f 8f 89 00 00 00    	jg     81056f <tcp_receive+0xbaf>
  8104e6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  8104e9:	0f b7 0d e8 c1 b3 00 	movzwl 0xb3c1e8,%ecx
  8104f0:	01 d1                	add    %edx,%ecx
  8104f2:	29 c1                	sub    %eax,%ecx
  8104f4:	85 c9                	test   %ecx,%ecx
  8104f6:	7e 1d                	jle    810515 <tcp_receive+0xb55>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  8104f8:	66 29 d0             	sub    %dx,%ax
  8104fb:	66 a3 e8 c1 b3 00    	mov    %ax,0xb3c1e8
                  pbuf_realloc(inseg.p, inseg.len);
  810501:	0f b7 c0             	movzwl %ax,%eax
  810504:	89 44 24 04          	mov    %eax,0x4(%esp)
  810508:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  81050d:	89 04 24             	mov    %eax,(%esp)
  810510:	e8 f4 75 ff ff       	call   807b09 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  810515:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  81051c:	e8 8d 7f ff ff       	call   8084ae <tcp_seg_copy>
                if (cseg != NULL) {
  810521:	85 c0                	test   %eax,%eax
  810523:	0f 84 01 01 00 00    	je     81062a <tcp_receive+0xc6a>
                  cseg->next = next;
  810529:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  81052c:	89 10                	mov    %edx,(%eax)
                  prev->next = cseg;
  81052e:	89 07                	mov    %eax,(%edi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  810530:	8b 47 10             	mov    0x10(%edi),%eax
  810533:	8b 40 04             	mov    0x4(%eax),%eax
  810536:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  81053c:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  810540:	29 d1                	sub    %edx,%ecx
  810542:	01 c1                	add    %eax,%ecx
  810544:	85 c9                	test   %ecx,%ecx
  810546:	0f 8e de 00 00 00    	jle    81062a <tcp_receive+0xc6a>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  81054c:	66 29 c2             	sub    %ax,%dx
  81054f:	66 89 57 0c          	mov    %dx,0xc(%edi)
                    pbuf_realloc(prev->p, prev->len);
  810553:	0f b7 c2             	movzwl %dx,%eax
  810556:	89 44 24 04          	mov    %eax,0x4(%esp)
  81055a:	8b 47 04             	mov    0x4(%edi),%eax
  81055d:	89 04 24             	mov    %eax,(%esp)
  810560:	e8 a4 75 ff ff       	call   807b09 <pbuf_realloc>
  810565:	b8 00 00 00 00       	mov    $0x0,%eax
  81056a:	e9 c0 00 00 00       	jmp    81062f <tcp_receive+0xc6f>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81056f:	8b 31                	mov    (%ecx),%esi
  810571:	85 f6                	test   %esi,%esi
  810573:	75 5e                	jne    8105d3 <tcp_receive+0xc13>
  810575:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  810578:	29 c2                	sub    %eax,%edx
  81057a:	85 d2                	test   %edx,%edx
  81057c:	0f 8e a8 00 00 00    	jle    81062a <tcp_receive+0xc6a>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  810582:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  810589:	e8 20 7f ff ff       	call   8084ae <tcp_seg_copy>
  81058e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  810591:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  810593:	85 c0                	test   %eax,%eax
  810595:	0f 84 8f 00 00 00    	je     81062a <tcp_receive+0xc6a>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  81059b:	8b 43 10             	mov    0x10(%ebx),%eax
  81059e:	8b 40 04             	mov    0x4(%eax),%eax
  8105a1:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  8105a7:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  8105ab:	29 d1                	sub    %edx,%ecx
  8105ad:	01 c1                	add    %eax,%ecx
  8105af:	85 c9                	test   %ecx,%ecx
  8105b1:	7e 77                	jle    81062a <tcp_receive+0xc6a>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  8105b3:	66 29 c2             	sub    %ax,%dx
  8105b6:	66 89 53 0c          	mov    %dx,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  8105ba:	0f b7 c2             	movzwl %dx,%eax
  8105bd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8105c1:	8b 43 04             	mov    0x4(%ebx),%eax
  8105c4:	89 04 24             	mov    %eax,(%esp)
  8105c7:	e8 3d 75 ff ff       	call   807b09 <pbuf_realloc>
  8105cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8105d1:	eb 5c                	jmp    81062f <tcp_receive+0xc6f>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  8105d3:	8b 46 10             	mov    0x10(%esi),%eax
  8105d6:	8b 40 04             	mov    0x4(%eax),%eax
  8105d9:	39 d0                	cmp    %edx,%eax
  8105db:	0f 85 81 fe ff ff    	jne    810462 <tcp_receive+0xaa2>
  8105e1:	e9 eb fd ff ff       	jmp    8103d1 <tcp_receive+0xa11>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  8105e6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8105ea:	89 1c 24             	mov    %ebx,(%esp)
  8105ed:	e8 09 a8 ff ff       	call   80adfb <tcp_output>
  8105f2:	b8 00 00 00 00       	mov    $0x0,%eax
  8105f7:	eb 36                	jmp    81062f <tcp_receive+0xc6f>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  8105f9:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  8105ff:	8b 43 24             	mov    0x24(%ebx),%eax
  810602:	39 c2                	cmp    %eax,%edx
  810604:	78 11                	js     810617 <tcp_receive+0xc57>
  810606:	83 c2 01             	add    $0x1,%edx
  810609:	29 c2                	sub    %eax,%edx
  81060b:	89 d0                	mov    %edx,%eax
  81060d:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  810611:	29 c8                	sub    %ecx,%eax
  810613:	85 c0                	test   %eax,%eax
  810615:	7e 13                	jle    81062a <tcp_receive+0xc6a>
      tcp_ack_now(pcb);
  810617:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81061b:	89 1c 24             	mov    %ebx,(%esp)
  81061e:	e8 d8 a7 ff ff       	call   80adfb <tcp_output>
  810623:	b8 00 00 00 00       	mov    $0x0,%eax
  810628:	eb 05                	jmp    81062f <tcp_receive+0xc6f>
  81062a:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  return accepted_inseq;
}
  81062f:	83 c4 2c             	add    $0x2c,%esp
  810632:	5b                   	pop    %ebx
  810633:	5e                   	pop    %esi
  810634:	5f                   	pop    %edi
  810635:	5d                   	pop    %ebp
  810636:	c3                   	ret    

00810637 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  810637:	55                   	push   %ebp
  810638:	89 e5                	mov    %esp,%ebp
  81063a:	57                   	push   %edi
  81063b:	56                   	push   %esi
  81063c:	53                   	push   %ebx
  81063d:	83 ec 5c             	sub    $0x5c,%esp
  810640:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  810643:	8b 46 04             	mov    0x4(%esi),%eax
  810646:	a3 f4 c1 b3 00       	mov    %eax,0xb3c1f4
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  81064b:	8b 5e 04             	mov    0x4(%esi),%ebx
  81064e:	0f b7 00             	movzwl (%eax),%eax
  810651:	89 04 24             	mov    %eax,(%esp)
  810654:	e8 27 a1 ff ff       	call   80a780 <ntohs>
  810659:	c1 e8 06             	shr    $0x6,%eax
  81065c:	83 e0 3c             	and    $0x3c,%eax
  81065f:	01 c3                	add    %eax,%ebx
  810661:	89 1d f0 c1 b3 00    	mov    %ebx,0xb3c1f0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  810667:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  81066c:	0f b7 00             	movzwl (%eax),%eax
  81066f:	89 04 24             	mov    %eax,(%esp)
  810672:	e8 09 a1 ff ff       	call   80a780 <ntohs>
  810677:	66 c1 e8 06          	shr    $0x6,%ax
  81067b:	83 e0 3c             	and    $0x3c,%eax
  81067e:	f7 d8                	neg    %eax
  810680:	98                   	cwtl   
  810681:	89 44 24 04          	mov    %eax,0x4(%esp)
  810685:	89 34 24             	mov    %esi,(%esp)
  810688:	e8 86 6f ff ff       	call   807613 <pbuf_header>
  81068d:	84 c0                	test   %al,%al
  81068f:	75 07                	jne    810698 <tcp_input+0x61>
  810691:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  810696:	77 12                	ja     8106aa <tcp_input+0x73>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810698:	89 34 24             	mov    %esi,(%esp)
  81069b:	90                   	nop
  81069c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8106a0:	e8 d8 72 ff ff       	call   80797d <pbuf_free>
    return;
  8106a5:	e9 9a 0d 00 00       	jmp    811444 <tcp_input+0xe0d>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  8106aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106ad:	89 44 24 04          	mov    %eax,0x4(%esp)
  8106b1:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  8106b6:	83 c0 10             	add    $0x10,%eax
  8106b9:	89 04 24             	mov    %eax,(%esp)
  8106bc:	e8 a7 8c ff ff       	call   809368 <ip_addr_isbroadcast>
  8106c1:	84 c0                	test   %al,%al
  8106c3:	75 28                	jne    8106ed <tcp_input+0xb6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  8106c5:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  8106ca:	8b 78 10             	mov    0x10(%eax),%edi
  8106cd:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  8106d4:	e8 dc a2 ff ff       	call   80a9b5 <ntohl>
  8106d9:	89 c3                	mov    %eax,%ebx
  8106db:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8106e2:	e8 ce a2 ff ff       	call   80a9b5 <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  8106e7:	21 fb                	and    %edi,%ebx
  8106e9:	39 c3                	cmp    %eax,%ebx
  8106eb:	75 0d                	jne    8106fa <tcp_input+0xc3>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  8106ed:	89 34 24             	mov    %esi,(%esp)
  8106f0:	e8 88 72 ff ff       	call   80797d <pbuf_free>
    return;
  8106f5:	e9 4a 0d 00 00       	jmp    811444 <tcp_input+0xe0d>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  8106fa:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  8106ff:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  810703:	89 54 24 10          	mov    %edx,0x10(%esp)
  810707:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  81070e:	00 
  81070f:	8d 50 10             	lea    0x10(%eax),%edx
  810712:	89 54 24 08          	mov    %edx,0x8(%esp)
  810716:	83 c0 0c             	add    $0xc,%eax
  810719:	89 44 24 04          	mov    %eax,0x4(%esp)
  81071d:	89 34 24             	mov    %esi,(%esp)
  810720:	e8 4b 9d ff ff       	call   80a470 <inet_chksum_pseudo>
  810725:	66 85 c0             	test   %ax,%ax
  810728:	74 0d                	je     810737 <tcp_input+0x100>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81072a:	89 34 24             	mov    %esi,(%esp)
  81072d:	e8 4b 72 ff ff       	call   80797d <pbuf_free>
    return;
  810732:	e9 0d 0d 00 00       	jmp    811444 <tcp_input+0xe0d>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  810737:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  81073c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810740:	89 04 24             	mov    %eax,(%esp)
  810743:	e8 38 a0 ff ff       	call   80a780 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  810748:	66 c1 e8 0c          	shr    $0xc,%ax
  81074c:	f7 d8                	neg    %eax
  81074e:	c1 e0 02             	shl    $0x2,%eax
  810751:	98                   	cwtl   
  810752:	89 44 24 04          	mov    %eax,0x4(%esp)
  810756:	89 34 24             	mov    %esi,(%esp)
  810759:	e8 b5 6e ff ff       	call   807613 <pbuf_header>
  81075e:	84 c0                	test   %al,%al
  810760:	74 0d                	je     81076f <tcp_input+0x138>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810762:	89 34 24             	mov    %esi,(%esp)
  810765:	e8 13 72 ff ff       	call   80797d <pbuf_free>
    return;
  81076a:	e9 d5 0c 00 00       	jmp    811444 <tcp_input+0xe0d>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  81076f:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  810775:	0f b7 03             	movzwl (%ebx),%eax
  810778:	89 04 24             	mov    %eax,(%esp)
  81077b:	e8 00 a0 ff ff       	call   80a780 <ntohs>
  810780:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  810783:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  810789:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  81078d:	89 04 24             	mov    %eax,(%esp)
  810790:	e8 eb 9f ff ff       	call   80a780 <ntohs>
  810795:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  810799:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  81079f:	8b 43 04             	mov    0x4(%ebx),%eax
  8107a2:	89 04 24             	mov    %eax,(%esp)
  8107a5:	e8 0b a2 ff ff       	call   80a9b5 <ntohl>
  8107aa:	89 43 04             	mov    %eax,0x4(%ebx)
  8107ad:	a3 f8 c1 b3 00       	mov    %eax,0xb3c1f8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  8107b2:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  8107b8:	8b 43 08             	mov    0x8(%ebx),%eax
  8107bb:	89 04 24             	mov    %eax,(%esp)
  8107be:	e8 f2 a1 ff ff       	call   80a9b5 <ntohl>
  8107c3:	89 43 08             	mov    %eax,0x8(%ebx)
  8107c6:	a3 fc c1 b3 00       	mov    %eax,0xb3c1fc
  tcphdr->wnd = ntohs(tcphdr->wnd);
  8107cb:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  8107d1:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  8107d5:	89 04 24             	mov    %eax,(%esp)
  8107d8:	e8 a3 9f ff ff       	call   80a780 <ntohs>
  8107dd:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  8107e1:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  8107e6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8107ea:	89 04 24             	mov    %eax,(%esp)
  8107ed:	e8 8e 9f ff ff       	call   80a780 <ntohs>
  8107f2:	83 e0 3f             	and    $0x3f,%eax
  8107f5:	a2 00 c2 b3 00       	mov    %al,0xb3c200
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  8107fa:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  8107fe:	ba 01 00 00 00       	mov    $0x1,%edx
  810803:	a8 01                	test   $0x1,%al
  810805:	75 07                	jne    81080e <tcp_input+0x1d7>
  810807:	d1 e8                	shr    %eax
  810809:	89 c2                	mov    %eax,%edx
  81080b:	83 e2 01             	and    $0x1,%edx
  81080e:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  810811:	66 89 15 02 c2 b3 00 	mov    %dx,0xb3c202
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810818:	8b 1d 0c f0 b3 00    	mov    0xb3f00c,%ebx
  81081e:	85 db                	test   %ebx,%ebx
  810820:	0f 84 32 01 00 00    	je     810958 <tcp_input+0x321>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  810826:	8b 43 10             	mov    0x10(%ebx),%eax
  810829:	85 c0                	test   %eax,%eax
  81082b:	74 15                	je     810842 <tcp_input+0x20b>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81082d:	83 f8 0a             	cmp    $0xa,%eax
  810830:	74 31                	je     810863 <tcp_input+0x22c>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  810832:	83 f8 01             	cmp    $0x1,%eax
  810835:	75 6f                	jne    8108a6 <tcp_input+0x26f>
  810837:	90                   	nop
  810838:	eb 50                	jmp    81088a <tcp_input+0x253>
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  81083a:	8b 50 10             	mov    0x10(%eax),%edx
  81083d:	85 d2                	test   %edx,%edx
  81083f:	90                   	nop
  810840:	75 1c                	jne    81085e <tcp_input+0x227>
  810842:	c7 44 24 08 94 49 81 	movl   $0x814994,0x8(%esp)
  810849:	00 
  81084a:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  810851:	00 
  810852:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  810859:	e8 b6 00 ff ff       	call   800914 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81085e:	83 fa 0a             	cmp    $0xa,%edx
  810861:	75 1c                	jne    81087f <tcp_input+0x248>
  810863:	c7 44 24 08 bc 49 81 	movl   $0x8149bc,0x8(%esp)
  81086a:	00 
  81086b:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  810872:	00 
  810873:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  81087a:	e8 95 00 ff ff       	call   800914 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  81087f:	83 fa 01             	cmp    $0x1,%edx
  810882:	74 06                	je     81088a <tcp_input+0x253>
  810884:	89 da                	mov    %ebx,%edx
  810886:	89 c3                	mov    %eax,%ebx
  810888:	eb 35                	jmp    8108bf <tcp_input+0x288>
  81088a:	c7 44 24 08 e8 49 81 	movl   $0x8149e8,0x8(%esp)
  810891:	00 
  810892:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  810899:	00 
  81089a:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  8108a1:	e8 6e 00 ff ff       	call   800914 <_panic>
    if (pcb->remote_port == tcphdr->src &&
  8108a6:	8b 3d f0 c1 b3 00    	mov    0xb3c1f0,%edi
  8108ac:	0f b7 0f             	movzwl (%edi),%ecx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  8108af:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  8108b4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8108b7:	ba 00 00 00 00       	mov    $0x0,%edx
  8108bc:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  8108bf:	66 39 4b 1e          	cmp    %cx,0x1e(%ebx)
  8108c3:	75 7b                	jne    810940 <tcp_input+0x309>
       pcb->local_port == tcphdr->dest &&
  8108c5:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  8108c9:	66 3b 47 02          	cmp    0x2(%edi),%ax
  8108cd:	75 71                	jne    810940 <tcp_input+0x309>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  8108cf:	8b 43 04             	mov    0x4(%ebx),%eax
  8108d2:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  8108d5:	3b 46 0c             	cmp    0xc(%esi),%eax
  8108d8:	75 66                	jne    810940 <tcp_input+0x309>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  8108da:	8b 03                	mov    (%ebx),%eax
  8108dc:	3b 46 10             	cmp    0x10(%esi),%eax
  8108df:	75 5f                	jne    810940 <tcp_input+0x309>
  8108e1:	8b 75 c4             	mov    -0x3c(%ebp),%esi
  8108e4:	89 d8                	mov    %ebx,%eax

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  8108e6:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  8108e9:	39 d9                	cmp    %ebx,%ecx
  8108eb:	75 1c                	jne    810909 <tcp_input+0x2d2>
  8108ed:	c7 44 24 08 10 4a 81 	movl   $0x814a10,0x8(%esp)
  8108f4:	00 
  8108f5:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  8108fc:	00 
  8108fd:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  810904:	e8 0b 00 ff ff       	call   800914 <_panic>
      if (prev != NULL) {
  810909:	85 d2                	test   %edx,%edx
  81090b:	74 43                	je     810950 <tcp_input+0x319>
        prev->next = pcb->next;
  81090d:	89 4a 0c             	mov    %ecx,0xc(%edx)
        pcb->next = tcp_active_pcbs;
  810910:	8b 15 0c f0 b3 00    	mov    0xb3f00c,%edx
  810916:	89 53 0c             	mov    %edx,0xc(%ebx)
        tcp_active_pcbs = pcb;
  810919:	89 1d 0c f0 b3 00    	mov    %ebx,0xb3f00c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  81091f:	39 5b 0c             	cmp    %ebx,0xc(%ebx)
  810922:	75 2c                	jne    810950 <tcp_input+0x319>
  810924:	c7 44 24 08 3c 4a 81 	movl   $0x814a3c,0x8(%esp)
  81092b:	00 
  81092c:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  810933:	00 
  810934:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  81093b:	e8 d4 ff fe ff       	call   800914 <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810940:	8b 43 0c             	mov    0xc(%ebx),%eax
  810943:	85 c0                	test   %eax,%eax
  810945:	0f 85 ef fe ff ff    	jne    81083a <tcp_input+0x203>
  81094b:	8b 75 c4             	mov    -0x3c(%ebp),%esi
  81094e:	eb 08                	jmp    810958 <tcp_input+0x321>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  810950:	85 c0                	test   %eax,%eax
  810952:	0f 85 be 02 00 00    	jne    810c16 <tcp_input+0x5df>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810958:	8b 1d 20 f0 b3 00    	mov    0xb3f020,%ebx
  81095e:	85 db                	test   %ebx,%ebx
  810960:	0f 84 ad 00 00 00    	je     810a13 <tcp_input+0x3dc>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  810966:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  81096a:	74 2a                	je     810996 <tcp_input+0x35f>
  81096c:	eb 0c                	jmp    81097a <tcp_input+0x343>
  81096e:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  810972:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810978:	74 2b                	je     8109a5 <tcp_input+0x36e>
  81097a:	c7 44 24 08 68 4a 81 	movl   $0x814a68,0x8(%esp)
  810981:	00 
  810982:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  810989:	00 
  81098a:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  810991:	e8 7e ff fe ff       	call   800914 <_panic>
      if (pcb->remote_port == tcphdr->src &&
  810996:	8b 0d f0 c1 b3 00    	mov    0xb3c1f0,%ecx
  81099c:	0f b7 01             	movzwl (%ecx),%eax
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  81099f:	8b 3d f4 c1 b3 00    	mov    0xb3c1f4,%edi
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  8109a5:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  8109a9:	75 5d                	jne    810a08 <tcp_input+0x3d1>
         pcb->local_port == tcphdr->dest &&
  8109ab:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  8109af:	66 3b 51 02          	cmp    0x2(%ecx),%dx
  8109b3:	75 53                	jne    810a08 <tcp_input+0x3d1>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  8109b5:	8b 53 04             	mov    0x4(%ebx),%edx
  8109b8:	3b 57 0c             	cmp    0xc(%edi),%edx
  8109bb:	75 4b                	jne    810a08 <tcp_input+0x3d1>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  8109bd:	8b 13                	mov    (%ebx),%edx
  8109bf:	3b 57 10             	cmp    0x10(%edi),%edx
  8109c2:	75 44                	jne    810a08 <tcp_input+0x3d1>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  8109c4:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  8109cb:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  8109d1:	89 c2                	mov    %eax,%edx
  8109d3:	2b 53 24             	sub    0x24(%ebx),%edx
  8109d6:	85 d2                	test   %edx,%edx
  8109d8:	7e 03                	jle    8109dd <tcp_input+0x3a6>
    pcb->rcv_nxt = seqno + tcplen;
  8109da:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  8109dd:	66 83 3d 02 c2 b3 00 	cmpw   $0x0,0xb3c202
  8109e4:	00 
  8109e5:	74 0c                	je     8109f3 <tcp_input+0x3bc>
    tcp_ack_now(pcb);
  8109e7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8109eb:	89 1c 24             	mov    %ebx,(%esp)
  8109ee:	e8 08 a4 ff ff       	call   80adfb <tcp_output>
  }
  return tcp_output(pcb);
  8109f3:	89 1c 24             	mov    %ebx,(%esp)
  8109f6:	e8 00 a4 ff ff       	call   80adfb <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  8109fb:	89 34 24             	mov    %esi,(%esp)
  8109fe:	e8 7a 6f ff ff       	call   80797d <pbuf_free>
        return;
  810a03:	e9 3c 0a 00 00       	jmp    811444 <tcp_input+0xe0d>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810a08:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  810a0b:	85 db                	test   %ebx,%ebx
  810a0d:	0f 85 5b ff ff ff    	jne    81096e <tcp_input+0x337>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  810a13:	8b 3d 14 f0 b3 00    	mov    0xb3f014,%edi
  810a19:	85 ff                	test   %edi,%edi
  810a1b:	0f 84 ed 01 00 00    	je     810c0e <tcp_input+0x5d7>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  810a21:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
        lpcb->local_port == tcphdr->dest) {
  810a26:	8b 0d f0 c1 b3 00    	mov    0xb3c1f0,%ecx
  810a2c:	ba 00 00 00 00       	mov    $0x0,%edx
  810a31:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  810a34:	89 c3                	mov    %eax,%ebx

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  810a36:	85 ff                	test   %edi,%edi
  810a38:	74 0f                	je     810a49 <tcp_input+0x412>
  810a3a:	8b 07                	mov    (%edi),%eax
  810a3c:	85 c0                	test   %eax,%eax
  810a3e:	74 09                	je     810a49 <tcp_input+0x412>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  810a40:	3b 43 10             	cmp    0x10(%ebx),%eax
  810a43:	0f 85 b1 01 00 00    	jne    810bfa <tcp_input+0x5c3>
        lpcb->local_port == tcphdr->dest) {
  810a49:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  810a4d:	66 3b 41 02          	cmp    0x2(%ecx),%ax
  810a51:	0f 85 a3 01 00 00    	jne    810bfa <tcp_input+0x5c3>
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  810a57:	85 d2                	test   %edx,%edx
  810a59:	74 14                	je     810a6f <tcp_input+0x438>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  810a5b:	8b 47 0c             	mov    0xc(%edi),%eax
  810a5e:	89 42 0c             	mov    %eax,0xc(%edx)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  810a61:	a1 14 f0 b3 00       	mov    0xb3f014,%eax
  810a66:	89 47 0c             	mov    %eax,0xc(%edi)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  810a69:	89 3d 14 f0 b3 00    	mov    %edi,0xb3f014
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  810a6f:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  810a76:	a8 10                	test   $0x10,%al
  810a78:	74 4e                	je     810ac8 <tcp_input+0x491>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  810a7a:	8b 15 f0 c1 b3 00    	mov    0xb3c1f0,%edx
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  810a80:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  810a85:	0f b7 0a             	movzwl (%edx),%ecx
  810a88:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  810a8c:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  810a90:	89 54 24 10          	mov    %edx,0x10(%esp)
  810a94:	8d 50 0c             	lea    0xc(%eax),%edx
  810a97:	89 54 24 0c          	mov    %edx,0xc(%esp)
  810a9b:	83 c0 10             	add    $0x10,%eax
  810a9e:	89 44 24 08          	mov    %eax,0x8(%esp)
  810aa2:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  810aa9:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  810aaf:	89 44 24 04          	mov    %eax,0x4(%esp)
  810ab3:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  810ab8:	83 c0 01             	add    $0x1,%eax
  810abb:	89 04 24             	mov    %eax,(%esp)
  810abe:	e8 d9 a1 ff ff       	call   80ac9c <tcp_rst>
  810ac3:	e9 25 01 00 00       	jmp    810bed <tcp_input+0x5b6>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  810ac8:	a8 02                	test   $0x2,%al
  810aca:	0f 84 1d 01 00 00    	je     810bed <tcp_input+0x5b6>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  810ad0:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  810ad4:	89 04 24             	mov    %eax,(%esp)
  810ad7:	e8 d2 80 ff ff       	call   808bae <tcp_alloc>
  810adc:	89 c3                	mov    %eax,%ebx
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  810ade:	85 c0                	test   %eax,%eax
  810ae0:	0f 84 07 01 00 00    	je     810bed <tcp_input+0x5b6>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  810ae6:	8b 15 f4 c1 b3 00    	mov    0xb3c1f4,%edx
  810aec:	b8 00 00 00 00       	mov    $0x0,%eax
  810af1:	83 fa f0             	cmp    $0xfffffff0,%edx
  810af4:	74 03                	je     810af9 <tcp_input+0x4c2>
  810af6:	8b 42 10             	mov    0x10(%edx),%eax
  810af9:	89 03                	mov    %eax,(%ebx)
    npcb->local_port = pcb->local_port;
  810afb:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  810aff:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  810b03:	8b 15 f4 c1 b3 00    	mov    0xb3c1f4,%edx
  810b09:	b8 00 00 00 00       	mov    $0x0,%eax
  810b0e:	83 fa f4             	cmp    $0xfffffff4,%edx
  810b11:	74 03                	je     810b16 <tcp_input+0x4df>
  810b13:	8b 42 0c             	mov    0xc(%edx),%eax
  810b16:	89 43 04             	mov    %eax,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  810b19:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810b1e:	0f b7 00             	movzwl (%eax),%eax
  810b21:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  810b25:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  810b2c:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810b31:	83 c0 01             	add    $0x1,%eax
  810b34:	89 43 24             	mov    %eax,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  810b37:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810b3c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  810b40:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  810b44:	66 89 43 50          	mov    %ax,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  810b48:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810b4d:	83 e8 01             	sub    $0x1,%eax
  810b50:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  810b53:	8b 47 18             	mov    0x18(%edi),%eax
  810b56:	89 43 18             	mov    %eax,0x18(%ebx)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  810b59:	8b 47 20             	mov    0x20(%edi),%eax
  810b5c:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  810b62:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  810b66:	66 25 99 01          	and    $0x199,%ax
  810b6a:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  810b6e:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  810b73:	89 43 0c             	mov    %eax,0xc(%ebx)
  810b76:	89 1d 0c f0 b3 00    	mov    %ebx,0xb3f00c
  810b7c:	e8 9c 3e ff ff       	call   804a1d <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  810b81:	89 d8                	mov    %ebx,%eax
  810b83:	e8 88 ed ff ff       	call   80f910 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  810b88:	8d 43 04             	lea    0x4(%ebx),%eax
  810b8b:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b8f:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  810b93:	89 04 24             	mov    %eax,(%esp)
  810b96:	e8 c8 77 ff ff       	call   808363 <tcp_eff_send_mss>
  810b9b:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  810b9f:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  810ba6:	e8 e9 9b ff ff       	call   80a794 <htonl>
  810bab:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  810bae:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  810bb5:	00 
  810bb6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  810bb9:	89 44 24 14          	mov    %eax,0x14(%esp)
  810bbd:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  810bc4:	00 
  810bc5:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  810bcc:	00 
  810bcd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810bd4:	00 
  810bd5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810bdc:	00 
  810bdd:	89 1c 24             	mov    %ebx,(%esp)
  810be0:	e8 63 a7 ff ff       	call   80b348 <tcp_enqueue>
    return tcp_output(npcb);
  810be5:	89 1c 24             	mov    %ebx,(%esp)
  810be8:	e8 0e a2 ff ff       	call   80adfb <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  810bed:	89 34 24             	mov    %esi,(%esp)
  810bf0:	e8 88 6d ff ff       	call   80797d <pbuf_free>
        return;
  810bf5:	e9 4a 08 00 00       	jmp    811444 <tcp_input+0xe0d>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  810bfa:	8b 47 0c             	mov    0xc(%edi),%eax
  810bfd:	85 c0                	test   %eax,%eax
  810bff:	90                   	nop
  810c00:	74 09                	je     810c0b <tcp_input+0x5d4>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
        return;
      }
      prev = (struct tcp_pcb *)lpcb;
  810c02:	89 fa                	mov    %edi,%edx
  810c04:	89 c7                	mov    %eax,%edi
  810c06:	e9 2b fe ff ff       	jmp    810a36 <tcp_input+0x3ff>
  810c0b:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  810c0e:	85 db                	test   %ebx,%ebx
  810c10:	0f 84 9b 07 00 00    	je     8113b1 <tcp_input+0xd7a>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  810c16:	c7 05 dc c1 b3 00 00 	movl   $0x0,0xb3c1dc
  810c1d:	00 00 00 
    inseg.len = p->tot_len;
  810c20:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  810c24:	66 a3 e8 c1 b3 00    	mov    %ax,0xb3c1e8
    inseg.dataptr = p->payload;
  810c2a:	8b 46 04             	mov    0x4(%esi),%eax
  810c2d:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4
    inseg.p = p;
  810c32:	89 35 e0 c1 b3 00    	mov    %esi,0xb3c1e0
    inseg.tcphdr = tcphdr;
  810c38:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810c3d:	a3 ec c1 b3 00       	mov    %eax,0xb3c1ec

    recv_data = NULL;
  810c42:	c7 05 08 c2 b3 00 00 	movl   $0x0,0xb3c208
  810c49:	00 00 00 
    recv_flags = 0;
  810c4c:	c6 05 04 c2 b3 00 00 	movb   $0x0,0xb3c204

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  810c53:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  810c59:	85 c0                	test   %eax,%eax
  810c5b:	74 49                	je     810ca6 <tcp_input+0x66f>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  810c5d:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  810c63:	85 d2                	test   %edx,%edx
  810c65:	74 1e                	je     810c85 <tcp_input+0x64e>
  810c67:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  810c6e:	00 
  810c6f:	89 44 24 08          	mov    %eax,0x8(%esp)
  810c73:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810c77:	8b 43 18             	mov    0x18(%ebx),%eax
  810c7a:	89 04 24             	mov    %eax,(%esp)
  810c7d:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  810c7f:	84 c0                	test   %al,%al
  810c81:	74 0a                	je     810c8d <tcp_input+0x656>
  810c83:	eb 14                	jmp    810c99 <tcp_input+0x662>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  810c85:	89 04 24             	mov    %eax,(%esp)
  810c88:	e8 f0 6c ff ff       	call   80797d <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  810c8d:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  810c94:	00 00 00 
  810c97:	eb 0d                	jmp    810ca6 <tcp_input+0x66f>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  810c99:	89 34 24             	mov    %esi,(%esp)
  810c9c:	e8 dc 6c ff ff       	call   80797d <pbuf_free>
        return;
  810ca1:	e9 9e 07 00 00       	jmp    811444 <tcp_input+0xe0d>
      }
    }

    tcp_input_pcb = pcb;
  810ca6:	89 1d 28 f0 b3 00    	mov    %ebx,0xb3f028
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  810cac:	f6 05 00 c2 b3 00 04 	testb  $0x4,0xb3c200
  810cb3:	74 68                	je     810d1d <tcp_input+0x6e6>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  810cb5:	8b 43 10             	mov    0x10(%ebx),%eax
  810cb8:	83 f8 02             	cmp    $0x2,%eax
  810cbb:	75 0e                	jne    810ccb <tcp_input+0x694>
  810cbd:	8b 53 54             	mov    0x54(%ebx),%edx
  810cc0:	3b 15 fc c1 b3 00    	cmp    0xb3c1fc,%edx
  810cc6:	0f 94 c2             	sete   %dl
  810cc9:	eb 1a                	jmp    810ce5 <tcp_input+0x6ae>
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  810ccb:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  810cd1:	2b 53 24             	sub    0x24(%ebx),%edx
  810cd4:	0f 88 51 07 00 00    	js     81142b <tcp_input+0xdf4>
  810cda:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  810cde:	29 ca                	sub    %ecx,%edx
  810ce0:	85 d2                	test   %edx,%edx
  810ce2:	0f 9e c2             	setle  %dl
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  810ce5:	84 d2                	test   %dl,%dl
  810ce7:	0f 84 3e 07 00 00    	je     81142b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  810ced:	85 c0                	test   %eax,%eax
  810cef:	75 1c                	jne    810d0d <tcp_input+0x6d6>
  810cf1:	c7 44 24 08 98 4a 81 	movl   $0x814a98,0x8(%esp)
  810cf8:	00 
  810cf9:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  810d00:	00 
  810d01:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  810d08:	e8 07 fc fe ff       	call   800914 <_panic>
      recv_flags = TF_RESET;
  810d0d:	c6 05 04 c2 b3 00 08 	movb   $0x8,0xb3c204
      pcb->flags &= ~TF_ACK_DELAY;
  810d14:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  810d18:	e9 0e 07 00 00       	jmp    81142b <tcp_input+0xdf4>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  810d1d:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  810d22:	89 43 2c             	mov    %eax,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  810d25:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  810d2c:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  810d30:	0f 87 07 05 00 00    	ja     81123d <tcp_input+0xc06>
  810d36:	8b 43 10             	mov    0x10(%ebx),%eax
  810d39:	ff 24 85 3c 4b 81 00 	jmp    *0x814b3c(,%eax,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  810d40:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  810d47:	83 e0 12             	and    $0x12,%eax
  810d4a:	83 f8 12             	cmp    $0x12,%eax
  810d4d:	0f 85 0c 01 00 00    	jne    810e5f <tcp_input+0x828>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  810d53:	8b 43 78             	mov    0x78(%ebx),%eax
  810d56:	8b 40 10             	mov    0x10(%eax),%eax
  810d59:	8b 40 04             	mov    0x4(%eax),%eax
  810d5c:	89 04 24             	mov    %eax,(%esp)
  810d5f:	e8 51 9c ff ff       	call   80a9b5 <ntohl>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  810d64:	83 c0 01             	add    $0x1,%eax
  810d67:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  810d6d:	0f 85 ec 00 00 00    	jne    810e5f <tcp_input+0x828>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
  810d73:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  810d78:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810d7d:	83 c0 01             	add    $0x1,%eax
  810d80:	89 43 24             	mov    %eax,0x24(%ebx)
      pcb->lastack = ackno;
  810d83:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  810d88:	89 43 48             	mov    %eax,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  810d8b:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810d90:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  810d94:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  810d98:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810d9d:	83 e8 01             	sub    $0x1,%eax
  810da0:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  810da3:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  810daa:	89 d8                	mov    %ebx,%eax
  810dac:	e8 5f eb ff ff       	call   80f910 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  810db1:	8d 43 04             	lea    0x4(%ebx),%eax
  810db4:	89 44 24 04          	mov    %eax,0x4(%esp)
  810db8:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  810dbc:	89 04 24             	mov    %eax,(%esp)
  810dbf:	e8 9f 75 ff ff       	call   808363 <tcp_eff_send_mss>
  810dc4:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  810dc8:	6b d0 0a             	imul   $0xa,%eax,%edx
  810dcb:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  810dcf:	8d 14 00             	lea    (%eax,%eax,1),%edx
  810dd2:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  810dd7:	0f 44 c2             	cmove  %edx,%eax
  810dda:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  810dde:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  810de2:	66 85 c0             	test   %ax,%ax
  810de5:	75 1c                	jne    810e03 <tcp_input+0x7cc>
  810de7:	c7 44 24 08 11 4b 81 	movl   $0x814b11,0x8(%esp)
  810dee:	00 
  810def:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  810df6:	00 
  810df7:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  810dfe:	e8 11 fb fe ff       	call   800914 <_panic>
      --pcb->snd_queuelen;
  810e03:	83 e8 01             	sub    $0x1,%eax
  810e06:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  810e0a:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  810e0d:	8b 10                	mov    (%eax),%edx
  810e0f:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  810e12:	85 d2                	test   %edx,%edx
  810e14:	75 08                	jne    810e1e <tcp_input+0x7e7>
        pcb->rtime = -1;
  810e16:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  810e1c:	eb 0a                	jmp    810e28 <tcp_input+0x7f1>
      else {
        pcb->rtime = 0;
  810e1e:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  810e24:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  810e28:	89 04 24             	mov    %eax,(%esp)
  810e2b:	e8 c1 76 ff ff       	call   8084f1 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  810e30:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  810e36:	85 c0                	test   %eax,%eax
  810e38:	74 14                	je     810e4e <tcp_input+0x817>
  810e3a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810e41:	00 
  810e42:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810e46:	8b 53 18             	mov    0x18(%ebx),%edx
  810e49:	89 14 24             	mov    %edx,(%esp)
  810e4c:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  810e4e:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810e52:	89 1c 24             	mov    %ebx,(%esp)
  810e55:	e8 a1 9f ff ff       	call   80adfb <tcp_output>
  810e5a:	e9 cc 05 00 00       	jmp    81142b <tcp_input+0xdf4>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  810e5f:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  810e66:	0f 84 bf 05 00 00    	je     81142b <tcp_input+0xdf4>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  810e6c:	8b 15 f0 c1 b3 00    	mov    0xb3c1f0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  810e72:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  810e77:	0f b7 0a             	movzwl (%edx),%ecx
  810e7a:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  810e7e:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  810e82:	89 54 24 10          	mov    %edx,0x10(%esp)
  810e86:	8d 50 0c             	lea    0xc(%eax),%edx
  810e89:	89 54 24 0c          	mov    %edx,0xc(%esp)
  810e8d:	83 c0 10             	add    $0x10,%eax
  810e90:	89 44 24 08          	mov    %eax,0x8(%esp)
  810e94:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  810e9b:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  810ea1:	89 44 24 04          	mov    %eax,0x4(%esp)
  810ea5:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  810eaa:	89 04 24             	mov    %eax,(%esp)
  810ead:	e8 ea 9d ff ff       	call   80ac9c <tcp_rst>
  810eb2:	e9 74 05 00 00       	jmp    81142b <tcp_input+0xdf4>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  810eb7:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  810ebe:	83 e0 14             	and    $0x14,%eax
  810ec1:	83 f8 10             	cmp    $0x10,%eax
  810ec4:	0f 85 61 05 00 00    	jne    81142b <tcp_input+0xdf4>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  810eca:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  810ecf:	8b 53 48             	mov    0x48(%ebx),%edx
  810ed2:	f7 d2                	not    %edx
  810ed4:	01 c2                	add    %eax,%edx
  810ed6:	0f 88 b7 00 00 00    	js     810f93 <tcp_input+0x95c>
  810edc:	89 c2                	mov    %eax,%edx
  810ede:	2b 53 54             	sub    0x54(%ebx),%edx
  810ee1:	85 d2                	test   %edx,%edx
  810ee3:	0f 8f aa 00 00 00    	jg     810f93 <tcp_input+0x95c>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  810ee9:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  810ef0:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  810ef6:	85 c0                	test   %eax,%eax
  810ef8:	75 1c                	jne    810f16 <tcp_input+0x8df>
  810efa:	c7 44 24 08 27 4b 81 	movl   $0x814b27,0x8(%esp)
  810f01:	00 
  810f02:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  810f09:	00 
  810f0a:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  810f11:	e8 fe f9 fe ff       	call   800914 <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  810f16:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810f1d:	00 
  810f1e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810f22:	8b 53 18             	mov    0x18(%ebx),%edx
  810f25:	89 14 24             	mov    %edx,(%esp)
  810f28:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  810f2a:	84 c0                	test   %al,%al
  810f2c:	74 17                	je     810f45 <tcp_input+0x90e>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  810f2e:	89 1c 24             	mov    %ebx,(%esp)
  810f31:	e8 68 7b ff ff       	call   808a9e <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  810f36:	c7 05 28 f0 b3 00 00 	movl   $0x0,0xb3f028
  810f3d:	00 00 00 
  810f40:	e9 48 04 00 00       	jmp    81138d <tcp_input+0xd56>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  810f45:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  810f49:	89 d8                	mov    %ebx,%eax
  810f4b:	e8 70 ea ff ff       	call   80f9c0 <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  810f50:	66 83 fe 01          	cmp    $0x1,%si
  810f54:	75 08                	jne    810f5e <tcp_input+0x927>
  810f56:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  810f5a:	01 d2                	add    %edx,%edx
  810f5c:	eb 04                	jmp    810f62 <tcp_input+0x92b>
  810f5e:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  810f62:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  810f66:	f6 05 00 c2 b3 00 01 	testb  $0x1,0xb3c200
  810f6d:	0f 84 b8 04 00 00    	je     81142b <tcp_input+0xdf4>
  810f73:	84 c0                	test   %al,%al
  810f75:	0f 84 b0 04 00 00    	je     81142b <tcp_input+0xdf4>
          tcp_ack_now(pcb);
  810f7b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810f7f:	89 1c 24             	mov    %ebx,(%esp)
  810f82:	e8 74 9e ff ff       	call   80adfb <tcp_output>
          pcb->state = CLOSE_WAIT;
  810f87:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  810f8e:	e9 98 04 00 00       	jmp    81142b <tcp_input+0xdf4>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  810f93:	8b 0d f0 c1 b3 00    	mov    0xb3c1f0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  810f99:	8b 15 f4 c1 b3 00    	mov    0xb3c1f4,%edx
  810f9f:	0f b7 31             	movzwl (%ecx),%esi
  810fa2:	89 74 24 14          	mov    %esi,0x14(%esp)
  810fa6:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  810faa:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  810fae:	8d 4a 0c             	lea    0xc(%edx),%ecx
  810fb1:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  810fb5:	83 c2 10             	add    $0x10,%edx
  810fb8:	89 54 24 08          	mov    %edx,0x8(%esp)
  810fbc:	0f b7 15 02 c2 b3 00 	movzwl 0xb3c202,%edx
  810fc3:	03 15 f8 c1 b3 00    	add    0xb3c1f8,%edx
  810fc9:	89 54 24 04          	mov    %edx,0x4(%esp)
  810fcd:	89 04 24             	mov    %eax,(%esp)
  810fd0:	e8 c7 9c ff ff       	call   80ac9c <tcp_rst>
  810fd5:	e9 51 04 00 00       	jmp    81142b <tcp_input+0xdf4>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  810fda:	89 d8                	mov    %ebx,%eax
  810fdc:	e8 df e9 ff ff       	call   80f9c0 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  810fe1:	f6 05 00 c2 b3 00 01 	testb  $0x1,0xb3c200
  810fe8:	0f 84 3d 04 00 00    	je     81142b <tcp_input+0xdf4>
  810fee:	84 c0                	test   %al,%al
  810ff0:	0f 84 35 04 00 00    	je     81142b <tcp_input+0xdf4>
      tcp_ack_now(pcb);
  810ff6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810ffa:	89 1c 24             	mov    %ebx,(%esp)
  810ffd:	e8 f9 9d ff ff       	call   80adfb <tcp_output>
      pcb->state = CLOSE_WAIT;
  811002:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  811009:	e9 1d 04 00 00       	jmp    81142b <tcp_input+0xdf4>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81100e:	89 d8                	mov    %ebx,%eax
  811010:	e8 ab e9 ff ff       	call   80f9c0 <tcp_receive>
    if (flags & TCP_FIN) {
  811015:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  81101c:	a8 01                	test   $0x1,%al
  81101e:	0f 84 a1 00 00 00    	je     8110c5 <tcp_input+0xa8e>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  811024:	a8 10                	test   $0x10,%al
  811026:	0f 84 81 00 00 00    	je     8110ad <tcp_input+0xa76>
  81102c:	8b 43 54             	mov    0x54(%ebx),%eax
  81102f:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  811035:	75 76                	jne    8110ad <tcp_input+0xa76>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  811037:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81103b:	89 1c 24             	mov    %ebx,(%esp)
  81103e:	e8 b8 9d ff ff       	call   80adfb <tcp_output>
        tcp_pcb_purge(pcb);
  811043:	89 1c 24             	mov    %ebx,(%esp)
  811046:	e8 1c 75 ff ff       	call   808567 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  81104b:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  811050:	39 c3                	cmp    %eax,%ebx
  811052:	75 0a                	jne    81105e <tcp_input+0xa27>
  811054:	8b 43 0c             	mov    0xc(%ebx),%eax
  811057:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
  81105c:	eb 29                	jmp    811087 <tcp_input+0xa50>
  81105e:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  811063:	eb 19                	jmp    81107e <tcp_input+0xa47>
  811065:	8b 50 0c             	mov    0xc(%eax),%edx
  811068:	85 d2                	test   %edx,%edx
  81106a:	74 0c                	je     811078 <tcp_input+0xa41>
  81106c:	39 d3                	cmp    %edx,%ebx
  81106e:	75 08                	jne    811078 <tcp_input+0xa41>
  811070:	8b 53 0c             	mov    0xc(%ebx),%edx
  811073:	89 50 0c             	mov    %edx,0xc(%eax)
  811076:	eb 0f                	jmp    811087 <tcp_input+0xa50>
  811078:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  81107e:	a1 18 f0 b3 00       	mov    0xb3f018,%eax
  811083:	85 c0                	test   %eax,%eax
  811085:	75 de                	jne    811065 <tcp_input+0xa2e>
  811087:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
        pcb->state = TIME_WAIT;
  81108e:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  811095:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  81109a:	89 43 0c             	mov    %eax,0xc(%ebx)
  81109d:	89 1d 20 f0 b3 00    	mov    %ebx,0xb3f020
  8110a3:	e8 75 39 ff ff       	call   804a1d <tcp_timer_needed>
  8110a8:	e9 7e 03 00 00       	jmp    81142b <tcp_input+0xdf4>
      } else {
        tcp_ack_now(pcb);
  8110ad:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8110b1:	89 1c 24             	mov    %ebx,(%esp)
  8110b4:	e8 42 9d ff ff       	call   80adfb <tcp_output>
        pcb->state = CLOSING;
  8110b9:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  8110c0:	e9 66 03 00 00       	jmp    81142b <tcp_input+0xdf4>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  8110c5:	a8 10                	test   $0x10,%al
  8110c7:	0f 84 5e 03 00 00    	je     81142b <tcp_input+0xdf4>
  8110cd:	8b 43 54             	mov    0x54(%ebx),%eax
  8110d0:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  8110d6:	0f 85 4f 03 00 00    	jne    81142b <tcp_input+0xdf4>
      pcb->state = FIN_WAIT_2;
  8110dc:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  8110e3:	e9 43 03 00 00       	jmp    81142b <tcp_input+0xdf4>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  8110e8:	89 d8                	mov    %ebx,%eax
  8110ea:	e8 d1 e8 ff ff       	call   80f9c0 <tcp_receive>
    if (flags & TCP_FIN) {
  8110ef:	f6 05 00 c2 b3 00 01 	testb  $0x1,0xb3c200
  8110f6:	0f 84 2f 03 00 00    	je     81142b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  8110fc:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  811100:	89 1c 24             	mov    %ebx,(%esp)
  811103:	e8 f3 9c ff ff       	call   80adfb <tcp_output>
      tcp_pcb_purge(pcb);
  811108:	89 1c 24             	mov    %ebx,(%esp)
  81110b:	e8 57 74 ff ff       	call   808567 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  811110:	8b 15 0c f0 b3 00    	mov    0xb3f00c,%edx
  811116:	39 d3                	cmp    %edx,%ebx
  811118:	75 0a                	jne    811124 <tcp_input+0xaed>
  81111a:	8b 43 0c             	mov    0xc(%ebx),%eax
  81111d:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
  811122:	eb 2a                	jmp    81114e <tcp_input+0xb17>
  811124:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  81112a:	85 d2                	test   %edx,%edx
  81112c:	74 20                	je     81114e <tcp_input+0xb17>
  81112e:	8b 42 0c             	mov    0xc(%edx),%eax
  811131:	85 c0                	test   %eax,%eax
  811133:	0f 84 dd 02 00 00    	je     811416 <tcp_input+0xddf>
  811139:	39 c3                	cmp    %eax,%ebx
  81113b:	75 08                	jne    811145 <tcp_input+0xb0e>
  81113d:	8b 43 0c             	mov    0xc(%ebx),%eax
  811140:	89 42 0c             	mov    %eax,0xc(%edx)
  811143:	eb 09                	jmp    81114e <tcp_input+0xb17>
  811145:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  81114a:	89 c2                	mov    %eax,%edx
  81114c:	eb e0                	jmp    81112e <tcp_input+0xaf7>
  81114e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  811155:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81115c:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  811161:	89 43 0c             	mov    %eax,0xc(%ebx)
  811164:	89 1d 20 f0 b3 00    	mov    %ebx,0xb3f020
  81116a:	e8 ae 38 ff ff       	call   804a1d <tcp_timer_needed>
  81116f:	e9 b7 02 00 00       	jmp    81142b <tcp_input+0xdf4>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  811174:	89 d8                	mov    %ebx,%eax
  811176:	e8 45 e8 ff ff       	call   80f9c0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81117b:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  811182:	0f 84 a3 02 00 00    	je     81142b <tcp_input+0xdf4>
  811188:	8b 43 54             	mov    0x54(%ebx),%eax
  81118b:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  811191:	0f 85 94 02 00 00    	jne    81142b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  811197:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81119b:	89 1c 24             	mov    %ebx,(%esp)
  81119e:	e8 58 9c ff ff       	call   80adfb <tcp_output>
      tcp_pcb_purge(pcb);
  8111a3:	89 1c 24             	mov    %ebx,(%esp)
  8111a6:	e8 bc 73 ff ff       	call   808567 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  8111ab:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  8111b0:	39 c3                	cmp    %eax,%ebx
  8111b2:	75 0a                	jne    8111be <tcp_input+0xb87>
  8111b4:	8b 43 0c             	mov    0xc(%ebx),%eax
  8111b7:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
  8111bc:	eb 2a                	jmp    8111e8 <tcp_input+0xbb1>
  8111be:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  8111c3:	85 c0                	test   %eax,%eax
  8111c5:	74 21                	je     8111e8 <tcp_input+0xbb1>
  8111c7:	8b 50 0c             	mov    0xc(%eax),%edx
  8111ca:	85 d2                	test   %edx,%edx
  8111cc:	0f 84 4e 02 00 00    	je     811420 <tcp_input+0xde9>
  8111d2:	39 d3                	cmp    %edx,%ebx
  8111d4:	75 08                	jne    8111de <tcp_input+0xba7>
  8111d6:	8b 53 0c             	mov    0xc(%ebx),%edx
  8111d9:	89 50 0c             	mov    %edx,0xc(%eax)
  8111dc:	eb 0a                	jmp    8111e8 <tcp_input+0xbb1>
  8111de:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  8111e4:	89 d0                	mov    %edx,%eax
  8111e6:	eb df                	jmp    8111c7 <tcp_input+0xb90>
  8111e8:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  8111ef:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  8111f6:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  8111fb:	89 43 0c             	mov    %eax,0xc(%ebx)
  8111fe:	89 1d 20 f0 b3 00    	mov    %ebx,0xb3f020
  811204:	e8 14 38 ff ff       	call   804a1d <tcp_timer_needed>
  811209:	e9 1d 02 00 00       	jmp    81142b <tcp_input+0xdf4>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  81120e:	89 d8                	mov    %ebx,%eax
  811210:	e8 ab e7 ff ff       	call   80f9c0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  811215:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  81121c:	0f 84 09 02 00 00    	je     81142b <tcp_input+0xdf4>
  811222:	8b 43 54             	mov    0x54(%ebx),%eax
  811225:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  81122b:	0f 85 fa 01 00 00    	jne    81142b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  811231:	c6 05 04 c2 b3 00 10 	movb   $0x10,0xb3c204
  811238:	e9 ee 01 00 00       	jmp    81142b <tcp_input+0xdf4>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  81123d:	c7 05 28 f0 b3 00 00 	movl   $0x0,0xb3f028
  811244:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  811247:	0f b6 05 04 c2 b3 00 	movzbl 0xb3c204,%eax
  81124e:	a8 08                	test   $0x8,%al
  811250:	74 3f                	je     811291 <tcp_input+0xc5a>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  811252:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  811258:	85 c0                	test   %eax,%eax
  81125a:	74 10                	je     81126c <tcp_input+0xc35>
  81125c:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  811263:	ff 
  811264:	8b 53 18             	mov    0x18(%ebx),%edx
  811267:	89 14 24             	mov    %edx,(%esp)
  81126a:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81126c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811270:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  811277:	e8 64 73 ff ff       	call   8085e0 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  81127c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811280:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  811287:	e8 68 5f ff ff       	call   8071f4 <memp_free>
  81128c:	e9 fc 00 00 00       	jmp    81138d <tcp_input+0xd56>
      } else if (recv_flags & TF_CLOSED) {
  811291:	a8 10                	test   $0x10,%al
  811293:	74 25                	je     8112ba <tcp_input+0xc83>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  811295:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811299:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  8112a0:	e8 3b 73 ff ff       	call   8085e0 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  8112a5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8112a9:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8112b0:	e8 3f 5f ff ff       	call   8071f4 <memp_free>
  8112b5:	e9 d3 00 00 00       	jmp    81138d <tcp_input+0xd56>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  8112ba:	0f b7 43 6c          	movzwl 0x6c(%ebx),%eax
  8112be:	66 85 c0             	test   %ax,%ax
  8112c1:	74 1f                	je     8112e2 <tcp_input+0xcab>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  8112c3:	8b 93 84 00 00 00    	mov    0x84(%ebx),%edx
  8112c9:	85 d2                	test   %edx,%edx
  8112cb:	74 15                	je     8112e2 <tcp_input+0xcab>
  8112cd:	0f b7 c0             	movzwl %ax,%eax
  8112d0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8112d4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8112d8:	8b 43 18             	mov    0x18(%ebx),%eax
  8112db:	89 04 24             	mov    %eax,(%esp)
  8112de:	ff d2                	call   *%edx
  8112e0:	eb 05                	jmp    8112e7 <tcp_input+0xcb0>
  8112e2:	b8 00 00 00 00       	mov    $0x0,%eax
        }
      
        if (recv_data != NULL) {
  8112e7:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  8112ed:	85 d2                	test   %edx,%edx
  8112ef:	74 61                	je     811352 <tcp_input+0xd1b>
          if(flags & TCP_PSH) {
  8112f1:	f6 05 00 c2 b3 00 08 	testb  $0x8,0xb3c200
  8112f8:	74 04                	je     8112fe <tcp_input+0xcc7>
            recv_data->flags |= PBUF_FLAG_PUSH;
  8112fa:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  8112fe:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  811304:	85 c0                	test   %eax,%eax
  811306:	74 24                	je     81132c <tcp_input+0xcf5>
  811308:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  81130f:	00 
  811310:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  811316:	89 54 24 08          	mov    %edx,0x8(%esp)
  81131a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81131e:	8b 53 18             	mov    0x18(%ebx),%edx
  811321:	89 14 24             	mov    %edx,(%esp)
  811324:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  811326:	84 c0                	test   %al,%al
  811328:	75 1c                	jne    811346 <tcp_input+0xd0f>
  81132a:	eb 26                	jmp    811352 <tcp_input+0xd1b>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81132c:	a1 08 c2 b3 00       	mov    0xb3c208,%eax
  811331:	85 c0                	test   %eax,%eax
  811333:	0f 84 01 01 00 00    	je     81143a <tcp_input+0xe03>
  811339:	89 04 24             	mov    %eax,(%esp)
  81133c:	e8 3c 66 ff ff       	call   80797d <pbuf_free>
  811341:	e9 f4 00 00 00       	jmp    81143a <tcp_input+0xe03>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  811346:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  81134c:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  811352:	f6 05 04 c2 b3 00 20 	testb  $0x20,0xb3c204
  811359:	74 26                	je     811381 <tcp_input+0xd4a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81135b:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  811361:	85 c0                	test   %eax,%eax
  811363:	74 20                	je     811385 <tcp_input+0xd4e>
  811365:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  81136c:	00 
  81136d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811374:	00 
  811375:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811379:	8b 53 18             	mov    0x18(%ebx),%edx
  81137c:	89 14 24             	mov    %edx,(%esp)
  81137f:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  811381:	84 c0                	test   %al,%al
  811383:	75 08                	jne    81138d <tcp_input+0xd56>
          tcp_output(pcb);
  811385:	89 1c 24             	mov    %ebx,(%esp)
  811388:	e8 6e 9a ff ff       	call   80adfb <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81138d:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  811392:	85 c0                	test   %eax,%eax
  811394:	0f 84 aa 00 00 00    	je     811444 <tcp_input+0xe0d>
    {
      pbuf_free(inseg.p);
  81139a:	89 04 24             	mov    %eax,(%esp)
  81139d:	e8 db 65 ff ff       	call   80797d <pbuf_free>
      inseg.p = NULL;
  8113a2:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  8113a9:	00 00 00 
  8113ac:	e9 93 00 00 00       	jmp    811444 <tcp_input+0xe0d>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  8113b1:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  8113b6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8113ba:	89 04 24             	mov    %eax,(%esp)
  8113bd:	e8 be 93 ff ff       	call   80a780 <ntohs>
  8113c2:	a8 04                	test   $0x4,%al
  8113c4:	75 46                	jne    81140c <tcp_input+0xdd5>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  8113c6:	8b 15 f0 c1 b3 00    	mov    0xb3c1f0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  8113cc:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  8113d1:	0f b7 0a             	movzwl (%edx),%ecx
  8113d4:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  8113d8:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  8113dc:	89 54 24 10          	mov    %edx,0x10(%esp)
  8113e0:	8d 50 0c             	lea    0xc(%eax),%edx
  8113e3:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8113e7:	83 c0 10             	add    $0x10,%eax
  8113ea:	89 44 24 08          	mov    %eax,0x8(%esp)
  8113ee:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  8113f5:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  8113fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8113ff:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  811404:	89 04 24             	mov    %eax,(%esp)
  811407:	e8 90 98 ff ff       	call   80ac9c <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  81140c:	89 34 24             	mov    %esi,(%esp)
  81140f:	e8 69 65 ff ff       	call   80797d <pbuf_free>
  811414:	eb 2e                	jmp    811444 <tcp_input+0xe0d>
    tcp_receive(pcb);
    if (flags & TCP_FIN) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  811416:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  81141b:	e9 2e fd ff ff       	jmp    81114e <tcp_input+0xb17>
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  811420:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  811426:	e9 bd fd ff ff       	jmp    8111e8 <tcp_input+0xbb1>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  81142b:	c7 05 28 f0 b3 00 00 	movl   $0x0,0xb3f028
  811432:	00 00 00 
  811435:	e9 0d fe ff ff       	jmp    811247 <tcp_input+0xc10>
  81143a:	b8 00 00 00 00       	mov    $0x0,%eax
  81143f:	e9 0e ff ff ff       	jmp    811352 <tcp_input+0xd1b>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  811444:	83 c4 5c             	add    $0x5c,%esp
  811447:	5b                   	pop    %ebx
  811448:	5e                   	pop    %esi
  811449:	5f                   	pop    %edi
  81144a:	5d                   	pop    %ebp
  81144b:	c3                   	ret    
  81144c:	00 00                	add    %al,(%eax)
	...

00811450 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  811450:	55                   	push   %ebp
  811451:	89 e5                	mov    %esp,%ebp
  811453:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  811456:	b8 00 00 00 00       	mov    $0x0,%eax
  81145b:	85 d2                	test   %edx,%edx
  81145d:	74 02                	je     811461 <raw_bind+0x11>
  81145f:	8b 02                	mov    (%edx),%eax
  811461:	8b 55 08             	mov    0x8(%ebp),%edx
  811464:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  811466:	b8 00 00 00 00       	mov    $0x0,%eax
  81146b:	5d                   	pop    %ebp
  81146c:	c3                   	ret    

0081146d <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81146d:	55                   	push   %ebp
  81146e:	89 e5                	mov    %esp,%ebp
  811470:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  811473:	b8 00 00 00 00       	mov    $0x0,%eax
  811478:	85 d2                	test   %edx,%edx
  81147a:	74 02                	je     81147e <raw_connect+0x11>
  81147c:	8b 02                	mov    (%edx),%eax
  81147e:	8b 55 08             	mov    0x8(%ebp),%edx
  811481:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  811484:	b8 00 00 00 00       	mov    $0x0,%eax
  811489:	5d                   	pop    %ebp
  81148a:	c3                   	ret    

0081148b <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  81148b:	55                   	push   %ebp
  81148c:	89 e5                	mov    %esp,%ebp
  81148e:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  811491:	8b 55 0c             	mov    0xc(%ebp),%edx
  811494:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  811497:	8b 55 10             	mov    0x10(%ebp),%edx
  81149a:	89 50 18             	mov    %edx,0x18(%eax)
}
  81149d:	5d                   	pop    %ebp
  81149e:	c3                   	ret    

0081149f <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  81149f:	55                   	push   %ebp
  8114a0:	89 e5                	mov    %esp,%ebp
  8114a2:	83 ec 18             	sub    $0x18,%esp
  8114a5:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8114a8:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8114ab:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  8114af:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8114b6:	e8 7d 5d ff ff       	call   807238 <memp_malloc>
  8114bb:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  8114bd:	85 c0                	test   %eax,%eax
  8114bf:	74 2f                	je     8114f0 <raw_new+0x51>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  8114c1:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  8114c8:	00 
  8114c9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8114d0:	00 
  8114d1:	89 04 24             	mov    %eax,(%esp)
  8114d4:	e8 bd fd fe ff       	call   801296 <memset>
    pcb->protocol = proto;
  8114d9:	89 f0                	mov    %esi,%eax
  8114db:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  8114de:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  8114e2:	a1 0c c2 b3 00       	mov    0xb3c20c,%eax
  8114e7:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  8114ea:	89 1d 0c c2 b3 00    	mov    %ebx,0xb3c20c
  }
  return pcb;
}
  8114f0:	89 d8                	mov    %ebx,%eax
  8114f2:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8114f5:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8114f8:	89 ec                	mov    %ebp,%esp
  8114fa:	5d                   	pop    %ebp
  8114fb:	c3                   	ret    

008114fc <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  8114fc:	55                   	push   %ebp
  8114fd:	89 e5                	mov    %esp,%ebp
  8114ff:	83 ec 18             	sub    $0x18,%esp
  811502:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  811505:	8b 15 0c c2 b3 00    	mov    0xb3c20c,%edx
  81150b:	39 ca                	cmp    %ecx,%edx
  81150d:	74 06                	je     811515 <raw_remove+0x19>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81150f:	85 d2                	test   %edx,%edx
  811511:	75 0e                	jne    811521 <raw_remove+0x25>
  811513:	eb 21                	jmp    811536 <raw_remove+0x3a>
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  811515:	8b 42 0c             	mov    0xc(%edx),%eax
  811518:	a3 0c c2 b3 00       	mov    %eax,0xb3c20c
  81151d:	eb 17                	jmp    811536 <raw_remove+0x3a>
  81151f:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  811521:	8b 42 0c             	mov    0xc(%edx),%eax
  811524:	85 c0                	test   %eax,%eax
  811526:	74 0e                	je     811536 <raw_remove+0x3a>
  811528:	39 c1                	cmp    %eax,%ecx
  81152a:	75 f3                	jne    81151f <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  81152c:	8b 41 0c             	mov    0xc(%ecx),%eax
  81152f:	89 42 0c             	mov    %eax,0xc(%edx)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  811532:	85 c0                	test   %eax,%eax
  811534:	75 e9                	jne    81151f <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  811536:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  81153a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811541:	e8 ae 5c ff ff       	call   8071f4 <memp_free>
}
  811546:	c9                   	leave  
  811547:	c3                   	ret    

00811548 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  811548:	55                   	push   %ebp
  811549:	89 e5                	mov    %esp,%ebp
  81154b:	57                   	push   %edi
  81154c:	56                   	push   %esi
  81154d:	53                   	push   %ebx
  81154e:	83 ec 3c             	sub    $0x3c,%esp
  811551:	8b 5d 08             	mov    0x8(%ebp),%ebx
  811554:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  811557:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  81155e:	00 
  81155f:	89 3c 24             	mov    %edi,(%esp)
  811562:	e8 ac 60 ff ff       	call   807613 <pbuf_header>
  811567:	84 c0                	test   %al,%al
  811569:	74 38                	je     8115a3 <raw_sendto+0x5b>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  81156b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811572:	00 
  811573:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  81157a:	00 
  81157b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811582:	e8 b2 66 ff ff       	call   807c39 <pbuf_alloc>
  811587:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  811589:	c6 45 e7 ff          	movb   $0xff,-0x19(%ebp)
  81158d:	85 c0                	test   %eax,%eax
  81158f:	0f 84 b1 00 00 00    	je     811646 <raw_sendto+0xfe>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  811595:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811599:	89 04 24             	mov    %eax,(%esp)
  81159c:	e8 4b 60 ff ff       	call   8075ec <pbuf_chain>
  8115a1:	eb 32                	jmp    8115d5 <raw_sendto+0x8d>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  8115a3:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  8115aa:	ff 
  8115ab:	89 3c 24             	mov    %edi,(%esp)
  8115ae:	e8 60 60 ff ff       	call   807613 <pbuf_header>
  8115b3:	84 c0                	test   %al,%al
  8115b5:	74 1c                	je     8115d3 <raw_sendto+0x8b>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  8115b7:	c7 44 24 08 64 4b 81 	movl   $0x814b64,0x8(%esp)
  8115be:	00 
  8115bf:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  8115c6:	00 
  8115c7:	c7 04 24 8a 4b 81 00 	movl   $0x814b8a,(%esp)
  8115ce:	e8 41 f3 fe ff       	call   800914 <_panic>
  8115d3:	89 fe                	mov    %edi,%esi
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  8115d5:	8b 45 10             	mov    0x10(%ebp),%eax
  8115d8:	89 04 24             	mov    %eax,(%esp)
  8115db:	e8 81 7f ff ff       	call   809561 <ip_route>
  8115e0:	85 c0                	test   %eax,%eax
  8115e2:	75 16                	jne    8115fa <raw_sendto+0xb2>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  8115e4:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  8115e8:	39 fe                	cmp    %edi,%esi
  8115ea:	74 5a                	je     811646 <raw_sendto+0xfe>
      pbuf_free(q);
  8115ec:	89 34 24             	mov    %esi,(%esp)
  8115ef:	e8 89 63 ff ff       	call   80797d <pbuf_free>
  8115f4:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  8115f8:	eb 4c                	jmp    811646 <raw_sendto+0xfe>
    }
    return ERR_RTE;
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  8115fa:	89 da                	mov    %ebx,%edx
  8115fc:	85 db                	test   %ebx,%ebx
  8115fe:	74 05                	je     811605 <raw_sendto+0xbd>
  811600:	83 3b 00             	cmpl   $0x0,(%ebx)
  811603:	75 03                	jne    811608 <raw_sendto+0xc0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  811605:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  811608:	89 44 24 18          	mov    %eax,0x18(%esp)
  81160c:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  811610:	89 44 24 14          	mov    %eax,0x14(%esp)
  811614:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  811618:	89 44 24 10          	mov    %eax,0x10(%esp)
  81161c:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  811620:	89 44 24 0c          	mov    %eax,0xc(%esp)
  811624:	8b 45 10             	mov    0x10(%ebp),%eax
  811627:	89 44 24 08          	mov    %eax,0x8(%esp)
  81162b:	89 54 24 04          	mov    %edx,0x4(%esp)
  81162f:	89 34 24             	mov    %esi,(%esp)
  811632:	e8 79 7d ff ff       	call   8093b0 <ip_output_if>
  811637:	88 45 e7             	mov    %al,-0x19(%ebp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  81163a:	39 fe                	cmp    %edi,%esi
  81163c:	74 08                	je     811646 <raw_sendto+0xfe>
    /* free the header */
    pbuf_free(q);
  81163e:	89 34 24             	mov    %esi,(%esp)
  811641:	e8 37 63 ff ff       	call   80797d <pbuf_free>
  }
  return err;
}
  811646:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  81164a:	83 c4 3c             	add    $0x3c,%esp
  81164d:	5b                   	pop    %ebx
  81164e:	5e                   	pop    %esi
  81164f:	5f                   	pop    %edi
  811650:	5d                   	pop    %ebp
  811651:	c3                   	ret    

00811652 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  811652:	55                   	push   %ebp
  811653:	89 e5                	mov    %esp,%ebp
  811655:	83 ec 18             	sub    $0x18,%esp
  811658:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  81165b:	8d 50 04             	lea    0x4(%eax),%edx
  81165e:	89 54 24 08          	mov    %edx,0x8(%esp)
  811662:	8b 55 0c             	mov    0xc(%ebp),%edx
  811665:	89 54 24 04          	mov    %edx,0x4(%esp)
  811669:	89 04 24             	mov    %eax,(%esp)
  81166c:	e8 d7 fe ff ff       	call   811548 <raw_sendto>
}
  811671:	c9                   	leave  
  811672:	c3                   	ret    

00811673 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  811673:	55                   	push   %ebp
  811674:	89 e5                	mov    %esp,%ebp
  811676:	57                   	push   %edi
  811677:	56                   	push   %esi
  811678:	53                   	push   %ebx
  811679:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  81167c:	8b 45 08             	mov    0x8(%ebp),%eax
  81167f:	8b 70 04             	mov    0x4(%eax),%esi
  proto = IPH_PROTO(iphdr);
  811682:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811686:	89 04 24             	mov    %eax,(%esp)
  811689:	e8 f2 90 ff ff       	call   80a780 <ntohs>
  81168e:	66 25 ff 00          	and    $0xff,%ax

  prev = NULL;
  pcb = raw_pcbs;
  811692:	8b 1d 0c c2 b3 00    	mov    0xb3c20c,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  811698:	85 db                	test   %ebx,%ebx
  81169a:	74 6c                	je     811708 <raw_input+0x95>
    if (pcb->protocol == proto) {
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  81169c:	83 c6 0c             	add    $0xc,%esi
  81169f:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  8116a2:	be 00 00 00 00       	mov    $0x0,%esi
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  8116a7:	0f bf f8             	movswl %ax,%edi
  8116aa:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  8116ae:	39 f8                	cmp    %edi,%eax
  8116b0:	75 49                	jne    8116fb <raw_input+0x88>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  8116b2:	8b 43 14             	mov    0x14(%ebx),%eax
  8116b5:	85 c0                	test   %eax,%eax
  8116b7:	74 42                	je     8116fb <raw_input+0x88>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  8116b9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8116bc:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8116c0:	8b 55 08             	mov    0x8(%ebp),%edx
  8116c3:	89 54 24 08          	mov    %edx,0x8(%esp)
  8116c7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8116cb:	8b 53 18             	mov    0x18(%ebx),%edx
  8116ce:	89 14 24             	mov    %edx,(%esp)
  8116d1:	ff d0                	call   *%eax
  8116d3:	84 c0                	test   %al,%al
  8116d5:	74 24                	je     8116fb <raw_input+0x88>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  8116d7:	b8 01 00 00 00       	mov    $0x1,%eax
  8116dc:	85 f6                	test   %esi,%esi
  8116de:	74 2d                	je     81170d <raw_input+0x9a>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  8116e0:	8b 43 0c             	mov    0xc(%ebx),%eax
  8116e3:	89 46 0c             	mov    %eax,0xc(%esi)
            pcb->next = raw_pcbs;
  8116e6:	a1 0c c2 b3 00       	mov    0xb3c20c,%eax
  8116eb:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  8116ee:	89 1d 0c c2 b3 00    	mov    %ebx,0xb3c20c
  8116f4:	b8 01 00 00 00       	mov    $0x1,%eax
  8116f9:	eb 12                	jmp    81170d <raw_input+0x9a>
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  8116fb:	8b 43 0c             	mov    0xc(%ebx),%eax

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  8116fe:	85 c0                	test   %eax,%eax
  811700:	74 06                	je     811708 <raw_input+0x95>
  811702:	89 de                	mov    %ebx,%esi
  811704:	89 c3                	mov    %eax,%ebx
  811706:	eb a2                	jmp    8116aa <raw_input+0x37>
  811708:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  81170d:	83 c4 2c             	add    $0x2c,%esp
  811710:	5b                   	pop    %ebx
  811711:	5e                   	pop    %esi
  811712:	5f                   	pop    %edi
  811713:	5d                   	pop    %ebp
  811714:	c3                   	ret    
	...

00811720 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  811720:	55                   	push   %ebp
  811721:	89 e5                	mov    %esp,%ebp
  811723:	57                   	push   %edi
  811724:	56                   	push   %esi
  811725:	53                   	push   %ebx
  811726:	83 ec 3c             	sub    $0x3c,%esp
  811729:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  81172c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811733:	00 
  811734:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  81173b:	00 
  81173c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811743:	e8 f1 64 ff ff       	call   807c39 <pbuf_alloc>
  811748:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  81174a:	85 c0                	test   %eax,%eax
  81174c:	0f 84 d8 00 00 00    	je     81182a <icmp_time_exceeded+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  811752:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  811757:	77 1c                	ja     811775 <icmp_time_exceeded+0x55>
  811759:	c7 44 24 08 a0 4b 81 	movl   $0x814ba0,0x8(%esp)
  811760:	00 
  811761:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  811768:	00 
  811769:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811770:	e8 9f f1 fe ff       	call   800914 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  811775:	8b 47 04             	mov    0x4(%edi),%eax
  811778:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  81177b:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  81177e:	0f b7 06             	movzwl (%esi),%eax
  811781:	89 04 24             	mov    %eax,(%esp)
  811784:	e8 f7 8f ff ff       	call   80a780 <ntohs>
  811789:	0f b6 c0             	movzbl %al,%eax
  81178c:	80 cc 0b             	or     $0xb,%ah
  81178f:	89 04 24             	mov    %eax,(%esp)
  811792:	e8 dc 8f ff ff       	call   80a773 <htons>
  811797:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  81179a:	0f b7 c0             	movzwl %ax,%eax
  81179d:	89 04 24             	mov    %eax,(%esp)
  8117a0:	e8 db 8f ff ff       	call   80a780 <ntohs>
  8117a5:	b0 00                	mov    $0x0,%al
  8117a7:	66 0b 45 0c          	or     0xc(%ebp),%ax
  8117ab:	0f b7 c0             	movzwl %ax,%eax
  8117ae:	89 04 24             	mov    %eax,(%esp)
  8117b1:	e8 bd 8f ff ff       	call   80a773 <htons>
  8117b6:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  8117b9:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  8117c0:	00 
  8117c1:	8b 47 04             	mov    0x4(%edi),%eax
  8117c4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8117c8:	8b 43 04             	mov    0x4(%ebx),%eax
  8117cb:	83 c0 08             	add    $0x8,%eax
  8117ce:	89 04 24             	mov    %eax,(%esp)
  8117d1:	e8 9b fb fe ff       	call   801371 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  8117d6:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  8117dc:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8117e0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8117e4:	89 34 24             	mov    %esi,(%esp)
  8117e7:	e8 6e 8c ff ff       	call   80a45a <inet_chksum>
  8117ec:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  8117f0:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  8117f7:	00 
  8117f8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8117ff:	00 
  811800:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811807:	00 
  811808:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81180b:	83 c0 0c             	add    $0xc,%eax
  81180e:	89 44 24 08          	mov    %eax,0x8(%esp)
  811812:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811819:	00 
  81181a:	89 1c 24             	mov    %ebx,(%esp)
  81181d:	e8 9b 7d ff ff       	call   8095bd <ip_output>
  pbuf_free(q);
  811822:	89 1c 24             	mov    %ebx,(%esp)
  811825:	e8 53 61 ff ff       	call   80797d <pbuf_free>
}
  81182a:	83 c4 3c             	add    $0x3c,%esp
  81182d:	5b                   	pop    %ebx
  81182e:	5e                   	pop    %esi
  81182f:	5f                   	pop    %edi
  811830:	5d                   	pop    %ebp
  811831:	c3                   	ret    

00811832 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  811832:	55                   	push   %ebp
  811833:	89 e5                	mov    %esp,%ebp
  811835:	57                   	push   %edi
  811836:	56                   	push   %esi
  811837:	53                   	push   %ebx
  811838:	83 ec 3c             	sub    $0x3c,%esp
  81183b:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  81183e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811845:	00 
  811846:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  81184d:	00 
  81184e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811855:	e8 df 63 ff ff       	call   807c39 <pbuf_alloc>
  81185a:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  81185c:	85 c0                	test   %eax,%eax
  81185e:	0f 84 d8 00 00 00    	je     81193c <icmp_dest_unreach+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  811864:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  811869:	77 1c                	ja     811887 <icmp_dest_unreach+0x55>
  81186b:	c7 44 24 08 a0 4b 81 	movl   $0x814ba0,0x8(%esp)
  811872:	00 
  811873:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  81187a:	00 
  81187b:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811882:	e8 8d f0 fe ff       	call   800914 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  811887:	8b 47 04             	mov    0x4(%edi),%eax
  81188a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = q->payload;
  81188d:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  811890:	0f b7 06             	movzwl (%esi),%eax
  811893:	89 04 24             	mov    %eax,(%esp)
  811896:	e8 e5 8e ff ff       	call   80a780 <ntohs>
  81189b:	0f b6 c0             	movzbl %al,%eax
  81189e:	80 cc 03             	or     $0x3,%ah
  8118a1:	89 04 24             	mov    %eax,(%esp)
  8118a4:	e8 ca 8e ff ff       	call   80a773 <htons>
  8118a9:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  8118ac:	0f b7 c0             	movzwl %ax,%eax
  8118af:	89 04 24             	mov    %eax,(%esp)
  8118b2:	e8 c9 8e ff ff       	call   80a780 <ntohs>
  8118b7:	b0 00                	mov    $0x0,%al
  8118b9:	66 0b 45 0c          	or     0xc(%ebp),%ax
  8118bd:	0f b7 c0             	movzwl %ax,%eax
  8118c0:	89 04 24             	mov    %eax,(%esp)
  8118c3:	e8 ab 8e ff ff       	call   80a773 <htons>
  8118c8:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  8118cb:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  8118d2:	00 
  8118d3:	8b 47 04             	mov    0x4(%edi),%eax
  8118d6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8118da:	8b 43 04             	mov    0x4(%ebx),%eax
  8118dd:	83 c0 08             	add    $0x8,%eax
  8118e0:	89 04 24             	mov    %eax,(%esp)
  8118e3:	e8 89 fa fe ff       	call   801371 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  8118e8:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  8118ee:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8118f2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8118f6:	89 34 24             	mov    %esi,(%esp)
  8118f9:	e8 5c 8b ff ff       	call   80a45a <inet_chksum>
  8118fe:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811902:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811909:	00 
  81190a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811911:	00 
  811912:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811919:	00 
  81191a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81191d:	83 c0 0c             	add    $0xc,%eax
  811920:	89 44 24 08          	mov    %eax,0x8(%esp)
  811924:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  81192b:	00 
  81192c:	89 1c 24             	mov    %ebx,(%esp)
  81192f:	e8 89 7c ff ff       	call   8095bd <ip_output>
  pbuf_free(q);
  811934:	89 1c 24             	mov    %ebx,(%esp)
  811937:	e8 41 60 ff ff       	call   80797d <pbuf_free>
}
  81193c:	83 c4 3c             	add    $0x3c,%esp
  81193f:	5b                   	pop    %ebx
  811940:	5e                   	pop    %esi
  811941:	5f                   	pop    %edi
  811942:	5d                   	pop    %ebp
  811943:	c3                   	ret    

00811944 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  811944:	55                   	push   %ebp
  811945:	89 e5                	mov    %esp,%ebp
  811947:	83 ec 48             	sub    $0x48,%esp
  81194a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  81194d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  811950:	89 7d fc             	mov    %edi,-0x4(%ebp)
  811953:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  811956:	8b 73 04             	mov    0x4(%ebx),%esi
  hlen = IPH_HL(iphdr) * 4;
  811959:	0f b7 06             	movzwl (%esi),%eax
  81195c:	89 04 24             	mov    %eax,(%esp)
  81195f:	e8 1c 8e ff ff       	call   80a780 <ntohs>
  811964:	66 c1 e8 06          	shr    $0x6,%ax
  811968:	83 e0 3c             	and    $0x3c,%eax
  81196b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  81196f:	89 c7                	mov    %eax,%edi
  811971:	f7 df                	neg    %edi
  811973:	0f bf ff             	movswl %di,%edi
  811976:	89 7c 24 04          	mov    %edi,0x4(%esp)
  81197a:	89 1c 24             	mov    %ebx,(%esp)
  81197d:	e8 91 5c ff ff       	call   807613 <pbuf_header>
  811982:	84 c0                	test   %al,%al
  811984:	0f 85 ee 02 00 00    	jne    811c78 <icmp_input+0x334>
  81198a:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  81198f:	0f 86 e3 02 00 00    	jbe    811c78 <icmp_input+0x334>

  type = *((u8_t *)p->payload);
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  811995:	8b 43 04             	mov    0x4(%ebx),%eax
  811998:	80 38 08             	cmpb   $0x8,(%eax)
  81199b:	0f 85 cd 02 00 00    	jne    811c6e <icmp_input+0x32a>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  8119a1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8119a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8119a8:	8d 46 10             	lea    0x10(%esi),%eax
  8119ab:	89 04 24             	mov    %eax,(%esp)
  8119ae:	e8 b5 79 ff ff       	call   809368 <ip_addr_isbroadcast>
  8119b3:	84 c0                	test   %al,%al
  8119b5:	75 2b                	jne    8119e2 <icmp_input+0x9e>
  8119b7:	8b 56 10             	mov    0x10(%esi),%edx
  8119ba:	89 55 dc             	mov    %edx,-0x24(%ebp)
  8119bd:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  8119c4:	e8 ec 8f ff ff       	call   80a9b5 <ntohl>
  8119c9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8119cc:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8119d3:	e8 dd 8f ff ff       	call   80a9b5 <ntohl>
  8119d8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8119db:	23 55 dc             	and    -0x24(%ebp),%edx
  8119de:	39 c2                	cmp    %eax,%edx
  8119e0:	75 0d                	jne    8119ef <icmp_input+0xab>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  8119e2:	89 1c 24             	mov    %ebx,(%esp)
  8119e5:	e8 93 5f ff ff       	call   80797d <pbuf_free>
      return;
  8119ea:	e9 9b 02 00 00       	jmp    811c8a <icmp_input+0x346>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  8119ef:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  8119f4:	0f 86 7e 02 00 00    	jbe    811c78 <icmp_input+0x334>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  8119fa:	89 1c 24             	mov    %ebx,(%esp)
  8119fd:	8d 76 00             	lea    0x0(%esi),%esi
  811a00:	e8 d0 89 ff ff       	call   80a3d5 <inet_chksum_pbuf>
  811a05:	66 85 c0             	test   %ax,%ax
  811a08:	74 0d                	je     811a17 <icmp_input+0xd3>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  811a0a:	89 1c 24             	mov    %ebx,(%esp)
  811a0d:	e8 6b 5f ff ff       	call   80797d <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  811a12:	e9 73 02 00 00       	jmp    811c8a <icmp_input+0x346>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811a17:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  811a1e:	00 
  811a1f:	89 1c 24             	mov    %ebx,(%esp)
  811a22:	e8 ec 5b ff ff       	call   807613 <pbuf_header>
  811a27:	84 c0                	test   %al,%al
  811a29:	0f 84 f0 00 00 00    	je     811b1f <icmp_input+0x1db>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  811a2f:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  811a33:	89 44 24 04          	mov    %eax,0x4(%esp)
  811a37:	89 1c 24             	mov    %ebx,(%esp)
  811a3a:	e8 d4 5b ff ff       	call   807613 <pbuf_header>
  811a3f:	84 c0                	test   %al,%al
  811a41:	74 1c                	je     811a5f <icmp_input+0x11b>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  811a43:	c7 44 24 08 cc 4b 81 	movl   $0x814bcc,0x8(%esp)
  811a4a:	00 
  811a4b:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  811a52:	00 
  811a53:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811a5a:	e8 b5 ee fe ff       	call   800914 <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  811a5f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811a66:	00 
  811a67:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  811a6b:	89 44 24 04          	mov    %eax,0x4(%esp)
  811a6f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  811a76:	e8 be 61 ff ff       	call   807c39 <pbuf_alloc>
  811a7b:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  811a7e:	85 c0                	test   %eax,%eax
  811a80:	0f 84 fc 01 00 00    	je     811c82 <icmp_input+0x33e>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  811a86:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  811a8a:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  811a8e:	83 c0 08             	add    $0x8,%eax
  811a91:	39 c2                	cmp    %eax,%edx
  811a93:	73 1c                	jae    811ab1 <icmp_input+0x16d>
  811a95:	c7 44 24 08 00 4c 81 	movl   $0x814c00,0x8(%esp)
  811a9c:	00 
  811a9d:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  811aa4:	00 
  811aa5:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811aac:	e8 63 ee fe ff       	call   800914 <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  811ab1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811ab5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  811ab8:	89 04 24             	mov    %eax,(%esp)
  811abb:	e8 14 5d ff ff       	call   8077d4 <pbuf_copy>
  811ac0:	84 c0                	test   %al,%al
  811ac2:	74 1c                	je     811ae0 <icmp_input+0x19c>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  811ac4:	c7 44 24 08 38 4c 81 	movl   $0x814c38,0x8(%esp)
  811acb:	00 
  811acc:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  811ad3:	00 
  811ad4:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811adb:	e8 34 ee fe ff       	call   800914 <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  811ae0:	8b 55 e0             	mov    -0x20(%ebp),%edx
  811ae3:	8b 72 04             	mov    0x4(%edx),%esi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  811ae6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811aea:	89 14 24             	mov    %edx,(%esp)
  811aed:	e8 21 5b ff ff       	call   807613 <pbuf_header>
  811af2:	84 c0                	test   %al,%al
  811af4:	74 1c                	je     811b12 <icmp_input+0x1ce>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  811af6:	c7 44 24 08 60 4c 81 	movl   $0x814c60,0x8(%esp)
  811afd:	00 
  811afe:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  811b05:	00 
  811b06:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811b0d:	e8 02 ee fe ff       	call   800914 <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  811b12:	89 1c 24             	mov    %ebx,(%esp)
  811b15:	e8 63 5e ff ff       	call   80797d <pbuf_free>
  811b1a:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  811b1d:	eb 30                	jmp    811b4f <icmp_input+0x20b>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811b1f:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  811b26:	ff 
  811b27:	89 1c 24             	mov    %ebx,(%esp)
  811b2a:	e8 e4 5a ff ff       	call   807613 <pbuf_header>
  811b2f:	84 c0                	test   %al,%al
  811b31:	74 1c                	je     811b4f <icmp_input+0x20b>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  811b33:	c7 44 24 08 60 4c 81 	movl   $0x814c60,0x8(%esp)
  811b3a:	00 
  811b3b:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  811b42:	00 
  811b43:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811b4a:	e8 c5 ed fe ff       	call   800914 <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  811b4f:	8b 7b 04             	mov    0x4(%ebx),%edi
    tmpaddr.addr = iphdr->src.addr;
  811b52:	8b 46 0c             	mov    0xc(%esi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  811b55:	8b 56 10             	mov    0x10(%esi),%edx
  811b58:	89 56 0c             	mov    %edx,0xc(%esi)
    iphdr->dest.addr = tmpaddr.addr;
  811b5b:	89 46 10             	mov    %eax,0x10(%esi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  811b5e:	0f b7 07             	movzwl (%edi),%eax
  811b61:	89 04 24             	mov    %eax,(%esp)
  811b64:	e8 17 8c ff ff       	call   80a780 <ntohs>
  811b69:	0f b6 c0             	movzbl %al,%eax
  811b6c:	89 04 24             	mov    %eax,(%esp)
  811b6f:	e8 ff 8b ff ff       	call   80a773 <htons>
  811b74:	66 89 07             	mov    %ax,(%edi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  811b77:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  811b7b:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  811b7f:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  811b86:	e8 e8 8b ff ff       	call   80a773 <htons>
  811b8b:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  811b8f:	72 22                	jb     811bb3 <icmp_input+0x26f>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  811b91:	0f b7 57 02          	movzwl 0x2(%edi),%edx
  811b95:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
  811b99:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  811ba0:	e8 ce 8b ff ff       	call   80a773 <htons>
  811ba5:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
  811ba9:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  811bad:	66 89 47 02          	mov    %ax,0x2(%edi)
  811bb1:	eb 1c                	jmp    811bcf <icmp_input+0x28b>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  811bb3:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  811bb7:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  811bbb:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  811bc2:	e8 ac 8b ff ff       	call   80a773 <htons>
  811bc7:	66 03 45 e0          	add    -0x20(%ebp),%ax
  811bcb:	66 89 47 02          	mov    %ax,0x2(%edi)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  811bcf:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811bd3:	89 04 24             	mov    %eax,(%esp)
  811bd6:	e8 a5 8b ff ff       	call   80a780 <ntohs>
  811bdb:	66 0d 00 ff          	or     $0xff00,%ax
  811bdf:	0f b7 c0             	movzwl %ax,%eax
  811be2:	89 04 24             	mov    %eax,(%esp)
  811be5:	e8 89 8b ff ff       	call   80a773 <htons>
  811bea:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  811bee:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  811bf4:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  811bfb:	00 
  811bfc:	89 34 24             	mov    %esi,(%esp)
  811bff:	e8 56 88 ff ff       	call   80a45a <inet_chksum>
  811c04:	66 89 46 0a          	mov    %ax,0xa(%esi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  811c08:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  811c0c:	89 44 24 04          	mov    %eax,0x4(%esp)
  811c10:	89 1c 24             	mov    %ebx,(%esp)
  811c13:	e8 fb 59 ff ff       	call   807613 <pbuf_header>
  811c18:	84 c0                	test   %al,%al
  811c1a:	74 1c                	je     811c38 <icmp_input+0x2f4>
      LWIP_ASSERT("Can't move over header in packet", 0);
  811c1c:	c7 44 24 08 a4 3c 81 	movl   $0x813ca4,0x8(%esp)
  811c23:	00 
  811c24:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  811c2b:	00 
  811c2c:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811c33:	e8 dc ec fe ff       	call   800914 <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  811c38:	8b 55 0c             	mov    0xc(%ebp),%edx
  811c3b:	89 54 24 18          	mov    %edx,0x18(%esp)
  811c3f:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811c46:	00 
  811c47:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811c4e:	00 
  811c4f:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811c56:	00 
  811c57:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811c5e:	00 
  811c5f:	83 c6 0c             	add    $0xc,%esi
  811c62:	89 74 24 04          	mov    %esi,0x4(%esp)
  811c66:	89 1c 24             	mov    %ebx,(%esp)
  811c69:	e8 42 77 ff ff       	call   8093b0 <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  811c6e:	89 1c 24             	mov    %ebx,(%esp)
  811c71:	e8 07 5d ff ff       	call   80797d <pbuf_free>
  return;
  811c76:	eb 12                	jmp    811c8a <icmp_input+0x346>
lenerr:
  pbuf_free(p);
  811c78:	89 1c 24             	mov    %ebx,(%esp)
  811c7b:	e8 fd 5c ff ff       	call   80797d <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  811c80:	eb 08                	jmp    811c8a <icmp_input+0x346>
memerr:
  pbuf_free(p);
  811c82:	89 1c 24             	mov    %ebx,(%esp)
  811c85:	e8 f3 5c ff ff       	call   80797d <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  811c8a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  811c8d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  811c90:	8b 7d fc             	mov    -0x4(%ebp),%edi
  811c93:	89 ec                	mov    %ebp,%esp
  811c95:	5d                   	pop    %ebp
  811c96:	c3                   	ret    
	...

00811ca0 <__udivdi3>:
  811ca0:	55                   	push   %ebp
  811ca1:	89 e5                	mov    %esp,%ebp
  811ca3:	57                   	push   %edi
  811ca4:	56                   	push   %esi
  811ca5:	83 ec 10             	sub    $0x10,%esp
  811ca8:	8b 45 14             	mov    0x14(%ebp),%eax
  811cab:	8b 55 08             	mov    0x8(%ebp),%edx
  811cae:	8b 75 10             	mov    0x10(%ebp),%esi
  811cb1:	8b 7d 0c             	mov    0xc(%ebp),%edi
  811cb4:	85 c0                	test   %eax,%eax
  811cb6:	89 55 f0             	mov    %edx,-0x10(%ebp)
  811cb9:	75 35                	jne    811cf0 <__udivdi3+0x50>
  811cbb:	39 fe                	cmp    %edi,%esi
  811cbd:	77 61                	ja     811d20 <__udivdi3+0x80>
  811cbf:	85 f6                	test   %esi,%esi
  811cc1:	75 0b                	jne    811cce <__udivdi3+0x2e>
  811cc3:	b8 01 00 00 00       	mov    $0x1,%eax
  811cc8:	31 d2                	xor    %edx,%edx
  811cca:	f7 f6                	div    %esi
  811ccc:	89 c6                	mov    %eax,%esi
  811cce:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  811cd1:	31 d2                	xor    %edx,%edx
  811cd3:	89 f8                	mov    %edi,%eax
  811cd5:	f7 f6                	div    %esi
  811cd7:	89 c7                	mov    %eax,%edi
  811cd9:	89 c8                	mov    %ecx,%eax
  811cdb:	f7 f6                	div    %esi
  811cdd:	89 c1                	mov    %eax,%ecx
  811cdf:	89 fa                	mov    %edi,%edx
  811ce1:	89 c8                	mov    %ecx,%eax
  811ce3:	83 c4 10             	add    $0x10,%esp
  811ce6:	5e                   	pop    %esi
  811ce7:	5f                   	pop    %edi
  811ce8:	5d                   	pop    %ebp
  811ce9:	c3                   	ret    
  811cea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  811cf0:	39 f8                	cmp    %edi,%eax
  811cf2:	77 1c                	ja     811d10 <__udivdi3+0x70>
  811cf4:	0f bd d0             	bsr    %eax,%edx
  811cf7:	83 f2 1f             	xor    $0x1f,%edx
  811cfa:	89 55 f4             	mov    %edx,-0xc(%ebp)
  811cfd:	75 39                	jne    811d38 <__udivdi3+0x98>
  811cff:	3b 75 f0             	cmp    -0x10(%ebp),%esi
  811d02:	0f 86 a0 00 00 00    	jbe    811da8 <__udivdi3+0x108>
  811d08:	39 f8                	cmp    %edi,%eax
  811d0a:	0f 82 98 00 00 00    	jb     811da8 <__udivdi3+0x108>
  811d10:	31 ff                	xor    %edi,%edi
  811d12:	31 c9                	xor    %ecx,%ecx
  811d14:	89 c8                	mov    %ecx,%eax
  811d16:	89 fa                	mov    %edi,%edx
  811d18:	83 c4 10             	add    $0x10,%esp
  811d1b:	5e                   	pop    %esi
  811d1c:	5f                   	pop    %edi
  811d1d:	5d                   	pop    %ebp
  811d1e:	c3                   	ret    
  811d1f:	90                   	nop
  811d20:	89 d1                	mov    %edx,%ecx
  811d22:	89 fa                	mov    %edi,%edx
  811d24:	89 c8                	mov    %ecx,%eax
  811d26:	31 ff                	xor    %edi,%edi
  811d28:	f7 f6                	div    %esi
  811d2a:	89 c1                	mov    %eax,%ecx
  811d2c:	89 fa                	mov    %edi,%edx
  811d2e:	89 c8                	mov    %ecx,%eax
  811d30:	83 c4 10             	add    $0x10,%esp
  811d33:	5e                   	pop    %esi
  811d34:	5f                   	pop    %edi
  811d35:	5d                   	pop    %ebp
  811d36:	c3                   	ret    
  811d37:	90                   	nop
  811d38:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  811d3c:	89 f2                	mov    %esi,%edx
  811d3e:	d3 e0                	shl    %cl,%eax
  811d40:	89 45 ec             	mov    %eax,-0x14(%ebp)
  811d43:	b8 20 00 00 00       	mov    $0x20,%eax
  811d48:	2b 45 f4             	sub    -0xc(%ebp),%eax
  811d4b:	89 c1                	mov    %eax,%ecx
  811d4d:	d3 ea                	shr    %cl,%edx
  811d4f:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  811d53:	0b 55 ec             	or     -0x14(%ebp),%edx
  811d56:	d3 e6                	shl    %cl,%esi
  811d58:	89 c1                	mov    %eax,%ecx
  811d5a:	89 75 e8             	mov    %esi,-0x18(%ebp)
  811d5d:	89 fe                	mov    %edi,%esi
  811d5f:	d3 ee                	shr    %cl,%esi
  811d61:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  811d65:	89 55 ec             	mov    %edx,-0x14(%ebp)
  811d68:	8b 55 f0             	mov    -0x10(%ebp),%edx
  811d6b:	d3 e7                	shl    %cl,%edi
  811d6d:	89 c1                	mov    %eax,%ecx
  811d6f:	d3 ea                	shr    %cl,%edx
  811d71:	09 d7                	or     %edx,%edi
  811d73:	89 f2                	mov    %esi,%edx
  811d75:	89 f8                	mov    %edi,%eax
  811d77:	f7 75 ec             	divl   -0x14(%ebp)
  811d7a:	89 d6                	mov    %edx,%esi
  811d7c:	89 c7                	mov    %eax,%edi
  811d7e:	f7 65 e8             	mull   -0x18(%ebp)
  811d81:	39 d6                	cmp    %edx,%esi
  811d83:	89 55 ec             	mov    %edx,-0x14(%ebp)
  811d86:	72 30                	jb     811db8 <__udivdi3+0x118>
  811d88:	8b 55 f0             	mov    -0x10(%ebp),%edx
  811d8b:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  811d8f:	d3 e2                	shl    %cl,%edx
  811d91:	39 c2                	cmp    %eax,%edx
  811d93:	73 05                	jae    811d9a <__udivdi3+0xfa>
  811d95:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  811d98:	74 1e                	je     811db8 <__udivdi3+0x118>
  811d9a:	89 f9                	mov    %edi,%ecx
  811d9c:	31 ff                	xor    %edi,%edi
  811d9e:	e9 71 ff ff ff       	jmp    811d14 <__udivdi3+0x74>
  811da3:	90                   	nop
  811da4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811da8:	31 ff                	xor    %edi,%edi
  811daa:	b9 01 00 00 00       	mov    $0x1,%ecx
  811daf:	e9 60 ff ff ff       	jmp    811d14 <__udivdi3+0x74>
  811db4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811db8:	8d 4f ff             	lea    -0x1(%edi),%ecx
  811dbb:	31 ff                	xor    %edi,%edi
  811dbd:	89 c8                	mov    %ecx,%eax
  811dbf:	89 fa                	mov    %edi,%edx
  811dc1:	83 c4 10             	add    $0x10,%esp
  811dc4:	5e                   	pop    %esi
  811dc5:	5f                   	pop    %edi
  811dc6:	5d                   	pop    %ebp
  811dc7:	c3                   	ret    
	...

00811dd0 <__umoddi3>:
  811dd0:	55                   	push   %ebp
  811dd1:	89 e5                	mov    %esp,%ebp
  811dd3:	57                   	push   %edi
  811dd4:	56                   	push   %esi
  811dd5:	83 ec 20             	sub    $0x20,%esp
  811dd8:	8b 55 14             	mov    0x14(%ebp),%edx
  811ddb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  811dde:	8b 7d 10             	mov    0x10(%ebp),%edi
  811de1:	8b 75 0c             	mov    0xc(%ebp),%esi
  811de4:	85 d2                	test   %edx,%edx
  811de6:	89 c8                	mov    %ecx,%eax
  811de8:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  811deb:	75 13                	jne    811e00 <__umoddi3+0x30>
  811ded:	39 f7                	cmp    %esi,%edi
  811def:	76 3f                	jbe    811e30 <__umoddi3+0x60>
  811df1:	89 f2                	mov    %esi,%edx
  811df3:	f7 f7                	div    %edi
  811df5:	89 d0                	mov    %edx,%eax
  811df7:	31 d2                	xor    %edx,%edx
  811df9:	83 c4 20             	add    $0x20,%esp
  811dfc:	5e                   	pop    %esi
  811dfd:	5f                   	pop    %edi
  811dfe:	5d                   	pop    %ebp
  811dff:	c3                   	ret    
  811e00:	39 f2                	cmp    %esi,%edx
  811e02:	77 4c                	ja     811e50 <__umoddi3+0x80>
  811e04:	0f bd ca             	bsr    %edx,%ecx
  811e07:	83 f1 1f             	xor    $0x1f,%ecx
  811e0a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  811e0d:	75 51                	jne    811e60 <__umoddi3+0x90>
  811e0f:	3b 7d f4             	cmp    -0xc(%ebp),%edi
  811e12:	0f 87 e0 00 00 00    	ja     811ef8 <__umoddi3+0x128>
  811e18:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811e1b:	29 f8                	sub    %edi,%eax
  811e1d:	19 d6                	sbb    %edx,%esi
  811e1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  811e22:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811e25:	89 f2                	mov    %esi,%edx
  811e27:	83 c4 20             	add    $0x20,%esp
  811e2a:	5e                   	pop    %esi
  811e2b:	5f                   	pop    %edi
  811e2c:	5d                   	pop    %ebp
  811e2d:	c3                   	ret    
  811e2e:	66 90                	xchg   %ax,%ax
  811e30:	85 ff                	test   %edi,%edi
  811e32:	75 0b                	jne    811e3f <__umoddi3+0x6f>
  811e34:	b8 01 00 00 00       	mov    $0x1,%eax
  811e39:	31 d2                	xor    %edx,%edx
  811e3b:	f7 f7                	div    %edi
  811e3d:	89 c7                	mov    %eax,%edi
  811e3f:	89 f0                	mov    %esi,%eax
  811e41:	31 d2                	xor    %edx,%edx
  811e43:	f7 f7                	div    %edi
  811e45:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811e48:	f7 f7                	div    %edi
  811e4a:	eb a9                	jmp    811df5 <__umoddi3+0x25>
  811e4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811e50:	89 c8                	mov    %ecx,%eax
  811e52:	89 f2                	mov    %esi,%edx
  811e54:	83 c4 20             	add    $0x20,%esp
  811e57:	5e                   	pop    %esi
  811e58:	5f                   	pop    %edi
  811e59:	5d                   	pop    %ebp
  811e5a:	c3                   	ret    
  811e5b:	90                   	nop
  811e5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811e60:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811e64:	d3 e2                	shl    %cl,%edx
  811e66:	89 55 f4             	mov    %edx,-0xc(%ebp)
  811e69:	ba 20 00 00 00       	mov    $0x20,%edx
  811e6e:	2b 55 f0             	sub    -0x10(%ebp),%edx
  811e71:	89 55 ec             	mov    %edx,-0x14(%ebp)
  811e74:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  811e78:	89 fa                	mov    %edi,%edx
  811e7a:	d3 ea                	shr    %cl,%edx
  811e7c:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811e80:	0b 55 f4             	or     -0xc(%ebp),%edx
  811e83:	d3 e7                	shl    %cl,%edi
  811e85:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  811e89:	89 55 f4             	mov    %edx,-0xc(%ebp)
  811e8c:	89 f2                	mov    %esi,%edx
  811e8e:	89 7d e8             	mov    %edi,-0x18(%ebp)
  811e91:	89 c7                	mov    %eax,%edi
  811e93:	d3 ea                	shr    %cl,%edx
  811e95:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811e99:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  811e9c:	89 c2                	mov    %eax,%edx
  811e9e:	d3 e6                	shl    %cl,%esi
  811ea0:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  811ea4:	d3 ea                	shr    %cl,%edx
  811ea6:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811eaa:	09 d6                	or     %edx,%esi
  811eac:	89 f0                	mov    %esi,%eax
  811eae:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  811eb1:	d3 e7                	shl    %cl,%edi
  811eb3:	89 f2                	mov    %esi,%edx
  811eb5:	f7 75 f4             	divl   -0xc(%ebp)
  811eb8:	89 d6                	mov    %edx,%esi
  811eba:	f7 65 e8             	mull   -0x18(%ebp)
  811ebd:	39 d6                	cmp    %edx,%esi
  811ebf:	72 2b                	jb     811eec <__umoddi3+0x11c>
  811ec1:	39 c7                	cmp    %eax,%edi
  811ec3:	72 23                	jb     811ee8 <__umoddi3+0x118>
  811ec5:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811ec9:	29 c7                	sub    %eax,%edi
  811ecb:	19 d6                	sbb    %edx,%esi
  811ecd:	89 f0                	mov    %esi,%eax
  811ecf:	89 f2                	mov    %esi,%edx
  811ed1:	d3 ef                	shr    %cl,%edi
  811ed3:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  811ed7:	d3 e0                	shl    %cl,%eax
  811ed9:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811edd:	09 f8                	or     %edi,%eax
  811edf:	d3 ea                	shr    %cl,%edx
  811ee1:	83 c4 20             	add    $0x20,%esp
  811ee4:	5e                   	pop    %esi
  811ee5:	5f                   	pop    %edi
  811ee6:	5d                   	pop    %ebp
  811ee7:	c3                   	ret    
  811ee8:	39 d6                	cmp    %edx,%esi
  811eea:	75 d9                	jne    811ec5 <__umoddi3+0xf5>
  811eec:	2b 45 e8             	sub    -0x18(%ebp),%eax
  811eef:	1b 55 f4             	sbb    -0xc(%ebp),%edx
  811ef2:	eb d1                	jmp    811ec5 <__umoddi3+0xf5>
  811ef4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811ef8:	39 f2                	cmp    %esi,%edx
  811efa:	0f 82 18 ff ff ff    	jb     811e18 <__umoddi3+0x48>
  811f00:	e9 1d ff ff ff       	jmp    811e22 <__umoddi3+0x52>
