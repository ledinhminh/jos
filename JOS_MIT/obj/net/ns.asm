
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 77 08 00 00       	call   8008a8 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...

00800040 <put_buffer>:

	return va;
}

static void
put_buffer(void *va) {
  800040:	55                   	push   %ebp
  800041:	89 e5                	mov    %esp,%ebp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  800043:	2d 00 b0 fe 0f       	sub    $0xffeb000,%eax
  800048:	c1 e8 0c             	shr    $0xc,%eax
  80004b:	c7 04 85 40 60 81 00 	movl   $0x0,0x816040(,%eax,4)
  800052:	00 00 00 00 
}
  800056:	5d                   	pop    %ebp
  800057:	c3                   	ret    

00800058 <umain>:
	serve();
}

void
umain(int argc, char **argv)
{
  800058:	55                   	push   %ebp
  800059:	89 e5                	mov    %esp,%ebp
  80005b:	53                   	push   %ebx
  80005c:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  80005f:	e8 b3 17 00 00       	call   801817 <sys_getenvid>
  800064:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800066:	c7 05 00 50 81 00 20 	movl   $0x811f20,0x815000
  80006d:	1f 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800070:	e8 ad 18 00 00       	call   801922 <fork>
  800075:	a3 24 60 81 00       	mov    %eax,0x816024
	if (timer_envid < 0)
  80007a:	85 c0                	test   %eax,%eax
  80007c:	79 1c                	jns    80009a <umain+0x42>
		panic("error forking");
  80007e:	c7 44 24 08 23 1f 81 	movl   $0x811f23,0x8(%esp)
  800085:	00 
  800086:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  80008d:	00 
  80008e:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  800095:	e8 7a 08 00 00       	call   800914 <_panic>
	else if (timer_envid == 0) {
  80009a:	85 c0                	test   %eax,%eax
  80009c:	75 15                	jne    8000b3 <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  80009e:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  8000a5:	00 
  8000a6:	89 1c 24             	mov    %ebx,(%esp)
  8000a9:	e8 d2 06 00 00       	call   800780 <timer>
		return;
  8000ae:	e9 a3 00 00 00       	jmp    800156 <umain+0xfe>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8000b3:	e8 6a 18 00 00       	call   801922 <fork>
  8000b8:	a3 28 60 81 00       	mov    %eax,0x816028
	if (input_envid < 0)
  8000bd:	85 c0                	test   %eax,%eax
  8000bf:	79 1c                	jns    8000dd <umain+0x85>
		panic("error forking");
  8000c1:	c7 44 24 08 23 1f 81 	movl   $0x811f23,0x8(%esp)
  8000c8:	00 
  8000c9:	c7 44 24 04 4d 01 00 	movl   $0x14d,0x4(%esp)
  8000d0:	00 
  8000d1:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  8000d8:	e8 37 08 00 00       	call   800914 <_panic>
	else if (input_envid == 0) {
  8000dd:	85 c0                	test   %eax,%eax
  8000df:	75 0a                	jne    8000eb <umain+0x93>
		input(ns_envid);
  8000e1:	89 1c 24             	mov    %ebx,(%esp)
  8000e4:	e8 5f 07 00 00       	call   800848 <input>
		return;
  8000e9:	eb 6b                	jmp    800156 <umain+0xfe>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8000eb:	90                   	nop
  8000ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8000f0:	e8 2d 18 00 00       	call   801922 <fork>
  8000f5:	a3 2c 60 81 00       	mov    %eax,0x81602c
	if (output_envid < 0)
  8000fa:	85 c0                	test   %eax,%eax
  8000fc:	79 1c                	jns    80011a <umain+0xc2>
		panic("error forking");
  8000fe:	c7 44 24 08 23 1f 81 	movl   $0x811f23,0x8(%esp)
  800105:	00 
  800106:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
  80010d:	00 
  80010e:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  800115:	e8 fa 07 00 00       	call   800914 <_panic>
	else if (output_envid == 0) {
  80011a:	85 c0                	test   %eax,%eax
  80011c:	75 0a                	jne    800128 <umain+0xd0>
		output(ns_envid);
  80011e:	89 1c 24             	mov    %ebx,(%esp)
  800121:	e8 32 07 00 00       	call   800858 <output>
		return;
  800126:	eb 2e                	jmp    800156 <umain+0xfe>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  800128:	e8 13 d8 00 00       	call   80d940 <thread_init>
	thread_create(0, "main", tmain, 0);
  80012d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800134:	00 
  800135:	c7 44 24 08 14 07 80 	movl   $0x800714,0x8(%esp)
  80013c:	00 
  80013d:	c7 44 24 04 3c 1f 81 	movl   $0x811f3c,0x4(%esp)
  800144:	00 
  800145:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80014c:	e8 d6 d9 00 00       	call   80db27 <thread_create>
	thread_yield();
  800151:	e8 8a d8 00 00       	call   80d9e0 <thread_yield>
	// never coming here!
}
  800156:	83 c4 14             	add    $0x14,%esp
  800159:	5b                   	pop    %ebx
  80015a:	5d                   	pop    %ebp
  80015b:	c3                   	ret    

0080015c <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80015c:	55                   	push   %ebp
  80015d:	89 e5                	mov    %esp,%ebp
  80015f:	57                   	push   %edi
  800160:	56                   	push   %esi
  800161:	53                   	push   %ebx
  800162:	83 ec 3c             	sub    $0x3c,%esp
  800165:	bb 00 00 00 00       	mov    $0x0,%ebx
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80016a:	8d 7d e0             	lea    -0x20(%ebp),%edi
  80016d:	eb 08                	jmp    800177 <serve+0x1b>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  80016f:	e8 6c d8 00 00       	call   80d9e0 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800174:	83 c3 01             	add    $0x1,%ebx
  800177:	e8 15 d8 00 00       	call   80d991 <thread_wakeups_pending>
  80017c:	85 c0                	test   %eax,%eax
  80017e:	74 05                	je     800185 <serve+0x29>
  800180:	83 fb 1f             	cmp    $0x1f,%ebx
  800183:	7e ea                	jle    80016f <serve+0x13>
			thread_yield();

		perm = 0;
  800185:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
		if (!buse[i]) break;
  80018c:	83 3d 40 60 81 00 00 	cmpl   $0x0,0x816040
  800193:	74 3b                	je     8001d0 <serve+0x74>
  800195:	b8 01 00 00 00       	mov    $0x1,%eax
  80019a:	ba 40 60 81 00       	mov    $0x816040,%edx
  80019f:	83 3c 82 00          	cmpl   $0x0,(%edx,%eax,4)
  8001a3:	74 0a                	je     8001af <serve+0x53>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8001a5:	83 c0 01             	add    $0x1,%eax
  8001a8:	83 f8 14             	cmp    $0x14,%eax
  8001ab:	75 f2                	jne    80019f <serve+0x43>
  8001ad:	eb 05                	jmp    8001b4 <serve+0x58>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8001af:	83 f8 14             	cmp    $0x14,%eax
  8001b2:	75 21                	jne    8001d5 <serve+0x79>
		panic("NS: buffer overflow");
  8001b4:	c7 44 24 08 41 1f 81 	movl   $0x811f41,0x8(%esp)
  8001bb:	00 
  8001bc:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8001c3:	00 
  8001c4:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  8001cb:	e8 44 07 00 00       	call   800914 <_panic>
  8001d0:	b8 00 00 00 00       	mov    $0x0,%eax
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8001d5:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  8001db:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  8001de:	c7 04 85 40 60 81 00 	movl   $0x1,0x816040(,%eax,4)
  8001e5:	01 00 00 00 
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8001e9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8001ed:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8001f1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8001f4:	89 04 24             	mov    %eax,(%esp)
  8001f7:	e8 08 1c 00 00       	call   801e04 <ipc_recv>
  8001fc:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  8001fe:	83 f8 0c             	cmp    $0xc,%eax
  800201:	75 67                	jne    80026a <serve+0x10e>
			process_timer(whom);
  800203:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800206:	3b 35 24 60 81 00    	cmp    0x816024,%esi
  80020c:	74 12                	je     800220 <serve+0xc4>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80020e:	89 74 24 04          	mov    %esi,0x4(%esp)
  800212:	c7 04 24 d0 1f 81 00 	movl   $0x811fd0,(%esp)
  800219:	e8 af 07 00 00       	call   8009cd <cprintf>
  80021e:	eb 39                	jmp    800259 <serve+0xfd>
		return;
	}

	start = sys_time_msec();
  800220:	e8 85 13 00 00       	call   8015aa <sys_time_msec>
  800225:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800228:	e8 b3 d7 00 00       	call   80d9e0 <thread_yield>
	now = sys_time_msec();
  80022d:	e8 78 13 00 00       	call   8015aa <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  800232:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800239:	00 
  80023a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800241:	00 
  800242:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800245:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  80024b:	29 c2                	sub    %eax,%edx
  80024d:	89 54 24 04          	mov    %edx,0x4(%esp)
  800251:	89 34 24             	mov    %esi,(%esp)
  800254:	e8 40 1b 00 00       	call   801d99 <ipc_send>
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
  800259:	89 d8                	mov    %ebx,%eax
  80025b:	e8 e0 fd ff ff       	call   800040 <put_buffer>
  800260:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue;
  800265:	e9 0d ff ff ff       	jmp    800177 <serve+0x1b>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80026a:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80026e:	66 90                	xchg   %ax,%ax
  800270:	75 1d                	jne    80028f <serve+0x133>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800272:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800275:	89 44 24 04          	mov    %eax,0x4(%esp)
  800279:	c7 04 24 0c 20 81 00 	movl   $0x81200c,(%esp)
  800280:	e8 48 07 00 00       	call   8009cd <cprintf>
  800285:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue; // just leave it hanging...
  80028a:	e9 e8 fe ff ff       	jmp    800177 <serve+0x1b>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  80028f:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  800296:	e8 d8 2a 00 00       	call   802d73 <malloc>
		if (!args)
  80029b:	85 c0                	test   %eax,%eax
  80029d:	75 1c                	jne    8002bb <serve+0x15f>
			panic("could not allocate thread args structure");
  80029f:	c7 44 24 08 3c 20 81 	movl   $0x81203c,0x8(%esp)
  8002a6:	00 
  8002a7:	c7 44 24 04 26 01 00 	movl   $0x126,0x4(%esp)
  8002ae:	00 
  8002af:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  8002b6:	e8 59 06 00 00       	call   800914 <_panic>

		args->reqno = reqno;
  8002bb:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8002bd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8002c0:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8002c3:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8002c6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8002ca:	c7 44 24 08 f5 02 80 	movl   $0x8002f5,0x8(%esp)
  8002d1:	00 
  8002d2:	c7 44 24 04 55 1f 81 	movl   $0x811f55,0x4(%esp)
  8002d9:	00 
  8002da:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8002e1:	e8 41 d8 00 00       	call   80db27 <thread_create>
		thread_yield(); // let the thread created run
  8002e6:	e8 f5 d6 00 00       	call   80d9e0 <thread_yield>
  8002eb:	bb 00 00 00 00       	mov    $0x0,%ebx
  8002f0:	e9 82 fe ff ff       	jmp    800177 <serve+0x1b>

008002f5 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8002f5:	55                   	push   %ebp
  8002f6:	89 e5                	mov    %esp,%ebp
  8002f8:	81 ec 98 00 00 00    	sub    $0x98,%esp
  8002fe:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  800301:	89 75 f8             	mov    %esi,-0x8(%ebp)
  800304:	89 7d fc             	mov    %edi,-0x4(%ebp)
	struct st_args *args = (struct st_args *)a;
  800307:	8b 5d 08             	mov    0x8(%ebp),%ebx
	union Nsipc *req = args->req;
  80030a:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  80030d:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800310:	0f 87 34 01 00 00    	ja     80044a <serve_thread+0x155>
  800316:	8b 03                	mov    (%ebx),%eax
  800318:	ff 24 85 08 21 81 00 	jmp    *0x812108(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  80031f:	8d 45 94             	lea    -0x6c(%ebp),%eax
  800322:	89 44 24 08          	mov    %eax,0x8(%esp)
  800326:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800329:	89 44 24 04          	mov    %eax,0x4(%esp)
  80032d:	8b 06                	mov    (%esi),%eax
  80032f:	89 04 24             	mov    %eax,(%esp)
  800332:	e8 b0 44 00 00       	call   8047e7 <lwip_accept>
  800337:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  800339:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  800340:	00 
  800341:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800344:	89 44 24 04          	mov    %eax,0x4(%esp)
  800348:	89 34 24             	mov    %esi,(%esp)
  80034b:	e8 a5 0f 00 00       	call   8012f5 <memmove>
		break;
  800350:	e9 13 01 00 00       	jmp    800468 <serve_thread+0x173>
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800355:	8b 46 14             	mov    0x14(%esi),%eax
  800358:	89 44 24 08          	mov    %eax,0x8(%esp)
  80035c:	8d 46 04             	lea    0x4(%esi),%eax
  80035f:	89 44 24 04          	mov    %eax,0x4(%esp)
  800363:	8b 06                	mov    (%esi),%eax
  800365:	89 04 24             	mov    %eax,(%esp)
  800368:	e8 c1 43 00 00       	call   80472e <lwip_bind>
  80036d:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  80036f:	e9 f4 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800374:	8b 46 04             	mov    0x4(%esi),%eax
  800377:	89 44 24 04          	mov    %eax,0x4(%esp)
  80037b:	8b 06                	mov    (%esi),%eax
  80037d:	89 04 24             	mov    %eax,(%esp)
  800380:	e8 4f 42 00 00       	call   8045d4 <lwip_shutdown>
  800385:	89 c7                	mov    %eax,%edi
		break;
  800387:	e9 dc 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  80038c:	8b 06                	mov    (%esi),%eax
  80038e:	89 04 24             	mov    %eax,(%esp)
  800391:	e8 c2 41 00 00       	call   804558 <lwip_close>
  800396:	89 c7                	mov    %eax,%edi
		break;
  800398:	e9 cb 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80039d:	8b 46 14             	mov    0x14(%esi),%eax
  8003a0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003a4:	8d 46 04             	lea    0x4(%esi),%eax
  8003a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003ab:	8b 06                	mov    (%esi),%eax
  8003ad:	89 04 24             	mov    %eax,(%esp)
  8003b0:	e8 c0 42 00 00       	call   804675 <lwip_connect>
  8003b5:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  8003b7:	e9 ac 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8003bc:	8b 46 04             	mov    0x4(%esi),%eax
  8003bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003c3:	8b 06                	mov    (%esi),%eax
  8003c5:	89 04 24             	mov    %eax,(%esp)
  8003c8:	e8 1a 42 00 00       	call   8045e7 <lwip_listen>
  8003cd:	89 c7                	mov    %eax,%edi
		break;
  8003cf:	e9 94 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8003d4:	8b 46 08             	mov    0x8(%esi),%eax
  8003d7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003db:	8b 46 04             	mov    0x4(%esi),%eax
  8003de:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003e2:	89 74 24 04          	mov    %esi,0x4(%esp)
  8003e6:	8b 06                	mov    (%esi),%eax
  8003e8:	89 04 24             	mov    %eax,(%esp)
  8003eb:	e8 f7 40 00 00       	call   8044e7 <lwip_recv>
  8003f0:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  8003f2:	eb 74                	jmp    800468 <serve_thread+0x173>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8003f4:	8b 46 08             	mov    0x8(%esi),%eax
  8003f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003fb:	8b 46 04             	mov    0x4(%esi),%eax
  8003fe:	89 44 24 08          	mov    %eax,0x8(%esp)
  800402:	8d 46 0c             	lea    0xc(%esi),%eax
  800405:	89 44 24 04          	mov    %eax,0x4(%esp)
  800409:	8b 06                	mov    (%esi),%eax
  80040b:	89 04 24             	mov    %eax,(%esp)
  80040e:	e8 57 3c 00 00       	call   80406a <lwip_send>
  800413:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  800415:	eb 51                	jmp    800468 <serve_thread+0x173>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800417:	8b 46 08             	mov    0x8(%esi),%eax
  80041a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80041e:	8b 46 04             	mov    0x4(%esi),%eax
  800421:	89 44 24 04          	mov    %eax,0x4(%esp)
  800425:	8b 06                	mov    (%esi),%eax
  800427:	89 04 24             	mov    %eax,(%esp)
  80042a:	e8 50 3b 00 00       	call   803f7f <lwip_socket>
  80042f:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  800431:	eb 35                	jmp    800468 <serve_thread+0x173>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800433:	89 74 24 04          	mov    %esi,0x4(%esp)
  800437:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  80043e:	e8 27 db 00 00       	call   80df6a <jif_input>
  800443:	bf 00 00 00 00       	mov    $0x0,%edi
		r = 0;
		break;
  800448:	eb 4c                	jmp    800496 <serve_thread+0x1a1>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80044a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80044e:	8b 43 04             	mov    0x4(%ebx),%eax
  800451:	89 44 24 04          	mov    %eax,0x4(%esp)
  800455:	c7 04 24 68 20 81 00 	movl   $0x812068,(%esp)
  80045c:	e8 6c 05 00 00       	call   8009cd <cprintf>
  800461:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800466:	eb 2e                	jmp    800496 <serve_thread+0x1a1>
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800468:	83 ff ff             	cmp    $0xffffffff,%edi
  80046b:	75 29                	jne    800496 <serve_thread+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  80046d:	8b 03                	mov    (%ebx),%eax
  80046f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800473:	c7 44 24 08 62 1f 81 	movl   $0x811f62,0x8(%esp)
  80047a:	00 
  80047b:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  800482:	00 
  800483:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800486:	89 34 24             	mov    %esi,(%esp)
  800489:	e8 da 0b 00 00       	call   801068 <snprintf>
		perror(buf);
  80048e:	89 34 24             	mov    %esi,(%esp)
  800491:	e8 a1 d8 00 00       	call   80dd37 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  800496:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800499:	74 1f                	je     8004ba <serve_thread+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  80049b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8004a2:	00 
  8004a3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8004aa:	00 
  8004ab:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8004af:	8b 43 04             	mov    0x4(%ebx),%eax
  8004b2:	89 04 24             	mov    %eax,(%esp)
  8004b5:	e8 df 18 00 00       	call   801d99 <ipc_send>

	put_buffer(args->req);
  8004ba:	8b 43 08             	mov    0x8(%ebx),%eax
  8004bd:	e8 7e fb ff ff       	call   800040 <put_buffer>
	sys_page_unmap(0, (void*) args->req);
  8004c2:	8b 43 08             	mov    0x8(%ebx),%eax
  8004c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8004c9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8004d0:	e8 27 12 00 00       	call   8016fc <sys_page_unmap>
	free(args);
  8004d5:	89 1c 24             	mov    %ebx,(%esp)
  8004d8:	e8 c3 27 00 00       	call   802ca0 <free>
}
  8004dd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8004e0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8004e3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8004e6:	89 ec                	mov    %ebp,%esp
  8004e8:	5d                   	pop    %ebp
  8004e9:	c3                   	ret    

008004ea <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  8004ea:	55                   	push   %ebp
  8004eb:	89 e5                	mov    %esp,%ebp
  8004ed:	56                   	push   %esi
  8004ee:	53                   	push   %ebx
  8004ef:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  8004f2:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  8004f5:	e8 b0 10 00 00       	call   8015aa <sys_time_msec>
  8004fa:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  8004fc:	e8 08 cb 00 00       	call   80d009 <lwip_core_lock>
		t->func();
  800501:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  800504:	e8 05 cb 00 00       	call   80d00e <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  800509:	03 33                	add    (%ebx),%esi
  80050b:	89 74 24 08          	mov    %esi,0x8(%esp)
  80050f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800516:	00 
  800517:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80051e:	e8 4c d7 00 00       	call   80dc6f <thread_wait>
  800523:	eb d0                	jmp    8004f5 <net_timer+0xb>

00800525 <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800525:	55                   	push   %ebp
  800526:	89 e5                	mov    %esp,%ebp
  800528:	53                   	push   %ebx
  800529:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  80052c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80052f:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800531:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800534:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800537:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80053b:	c7 44 24 08 ea 04 80 	movl   $0x8004ea,0x8(%esp)
  800542:	00 
  800543:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800547:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80054e:	e8 d4 d5 00 00       	call   80db27 <thread_create>
	if (r < 0)
  800553:	85 c0                	test   %eax,%eax
  800555:	79 28                	jns    80057f <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  800557:	89 04 24             	mov    %eax,(%esp)
  80055a:	e8 c9 d7 00 00       	call   80dd28 <e2s>
  80055f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800563:	c7 44 24 08 8c 20 81 	movl   $0x81208c,0x8(%esp)
  80056a:	00 
  80056b:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  800572:	00 
  800573:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  80057a:	e8 95 03 00 00       	call   800914 <_panic>
}
  80057f:	83 c4 14             	add    $0x14,%esp
  800582:	5b                   	pop    %ebx
  800583:	5d                   	pop    %ebp
  800584:	c3                   	ret    

00800585 <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800585:	55                   	push   %ebp
  800586:	89 e5                	mov    %esp,%ebp
  800588:	56                   	push   %esi
  800589:	53                   	push   %ebx
  80058a:	83 ec 30             	sub    $0x30,%esp
  80058d:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800590:	e8 74 ca 00 00       	call   80d009 <lwip_core_lock>

	uint32_t done = 0;
  800595:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  80059c:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80059f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8005a3:	c7 04 24 67 07 80 00 	movl   $0x800767,(%esp)
  8005aa:	e8 24 44 00 00       	call   8049d3 <tcpip_init>
	lwip_core_unlock();
  8005af:	e8 5a ca 00 00       	call   80d00e <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8005b4:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  8005bb:	ff 
  8005bc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8005c3:	00 
  8005c4:	89 1c 24             	mov    %ebx,(%esp)
  8005c7:	e8 a3 d6 00 00       	call   80dc6f <thread_wait>
	lwip_core_lock();
  8005cc:	e8 38 ca 00 00       	call   80d009 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8005d1:	89 75 f0             	mov    %esi,-0x10(%ebp)
	netmask.addr = init_mask;
  8005d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8005d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8005da:	8b 45 10             	mov    0x10(%ebp),%eax
  8005dd:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8005e0:	c7 44 24 18 44 96 80 	movl   $0x809644,0x18(%esp)
  8005e7:	00 
  8005e8:	c7 44 24 14 70 dd 80 	movl   $0x80dd70,0x14(%esp)
  8005ef:	00 
  8005f0:	c7 44 24 10 2c 60 81 	movl   $0x81602c,0x10(%esp)
  8005f7:	00 
  8005f8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8005fb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005ff:	8d 45 ec             	lea    -0x14(%ebp),%eax
  800602:	89 44 24 08          	mov    %eax,0x8(%esp)
  800606:	8d 45 f0             	lea    -0x10(%ebp),%eax
  800609:	89 44 24 04          	mov    %eax,0x4(%esp)
  80060d:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  800614:	e8 88 6e 00 00       	call   8074a1 <netif_add>
  800619:	85 c0                	test   %eax,%eax
  80061b:	75 1c                	jne    800639 <serve_init+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  80061d:	c7 44 24 08 ac 20 81 	movl   $0x8120ac,0x8(%esp)
  800624:	00 
  800625:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  80062c:	00 
  80062d:	c7 04 24 31 1f 81 00 	movl   $0x811f31,(%esp)
  800634:	e8 db 02 00 00       	call   800914 <_panic>

	netif_set_default(nif);
  800639:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  800640:	e8 dc 6c 00 00       	call   807321 <netif_set_default>
	netif_set_up(nif);
  800645:	c7 04 24 40 c2 b3 00 	movl   $0xb3c240,(%esp)
  80064c:	e8 5d 6d 00 00       	call   8073ae <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800651:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800658:	b9 71 1f 81 00       	mov    $0x811f71,%ecx
  80065d:	ba a9 ca 80 00       	mov    $0x80caa9,%edx
  800662:	b8 00 60 81 00       	mov    $0x816000,%eax
  800667:	e8 b9 fe ff ff       	call   800525 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80066c:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  800673:	b9 7b 1f 81 00       	mov    $0x811f7b,%ecx
  800678:	ba 3c 84 80 00       	mov    $0x80843c,%edx
  80067d:	b8 0c 60 81 00       	mov    $0x81600c,%eax
  800682:	e8 9e fe ff ff       	call   800525 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800687:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80068e:	b9 87 1f 81 00       	mov    $0x811f87,%ecx
  800693:	ba 6e 8d 80 00       	mov    $0x808d6e,%edx
  800698:	b8 18 60 81 00       	mov    $0x816018,%eax
  80069d:	e8 83 fe ff ff       	call   800525 <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  8006a2:	89 34 24             	mov    %esi,(%esp)
  8006a5:	e8 06 a0 00 00       	call   80a6b0 <inet_ntoa>
  8006aa:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  8006ae:	0f b6 05 6a c2 b3 00 	movzbl 0xb3c26a,%eax
  8006b5:	89 44 24 18          	mov    %eax,0x18(%esp)
  8006b9:	0f b6 05 69 c2 b3 00 	movzbl 0xb3c269,%eax
  8006c0:	89 44 24 14          	mov    %eax,0x14(%esp)
  8006c4:	0f b6 05 68 c2 b3 00 	movzbl 0xb3c268,%eax
  8006cb:	89 44 24 10          	mov    %eax,0x10(%esp)
  8006cf:	0f b6 05 67 c2 b3 00 	movzbl 0xb3c267,%eax
  8006d6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8006da:	0f b6 05 66 c2 b3 00 	movzbl 0xb3c266,%eax
  8006e1:	89 44 24 08          	mov    %eax,0x8(%esp)
  8006e5:	0f b6 05 65 c2 b3 00 	movzbl 0xb3c265,%eax
  8006ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  8006f0:	c7 04 24 cc 20 81 00 	movl   $0x8120cc,(%esp)
  8006f7:	e8 d1 02 00 00       	call   8009cd <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8006fc:	e8 0d c9 00 00       	call   80d00e <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  800701:	c7 04 24 93 1f 81 00 	movl   $0x811f93,(%esp)
  800708:	e8 c0 02 00 00       	call   8009cd <cprintf>
}
  80070d:	83 c4 30             	add    $0x30,%esp
  800710:	5b                   	pop    %ebx
  800711:	5e                   	pop    %esi
  800712:	5d                   	pop    %ebp
  800713:	c3                   	ret    

00800714 <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  800714:	55                   	push   %ebp
  800715:	89 e5                	mov    %esp,%ebp
  800717:	83 ec 18             	sub    $0x18,%esp
  80071a:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80071d:	89 75 fc             	mov    %esi,-0x4(%ebp)
	serve_init(inet_addr(IP),
  800720:	c7 04 24 ac 1f 81 00 	movl   $0x811fac,(%esp)
  800727:	e8 74 a2 00 00       	call   80a9a0 <inet_addr>
  80072c:	89 c3                	mov    %eax,%ebx
  80072e:	c7 04 24 b5 1f 81 00 	movl   $0x811fb5,(%esp)
  800735:	e8 66 a2 00 00       	call   80a9a0 <inet_addr>
  80073a:	89 c6                	mov    %eax,%esi
  80073c:	c7 04 24 c3 1f 81 00 	movl   $0x811fc3,(%esp)
  800743:	e8 58 a2 00 00       	call   80a9a0 <inet_addr>
  800748:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80074c:	89 74 24 04          	mov    %esi,0x4(%esp)
  800750:	89 04 24             	mov    %eax,(%esp)
  800753:	e8 2d fe ff ff       	call   800585 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800758:	e8 ff f9 ff ff       	call   80015c <serve>
}
  80075d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  800760:	8b 75 fc             	mov    -0x4(%ebp),%esi
  800763:	89 ec                	mov    %ebp,%esp
  800765:	5d                   	pop    %ebp
  800766:	c3                   	ret    

00800767 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800767:	55                   	push   %ebp
  800768:	89 e5                	mov    %esp,%ebp
  80076a:	83 ec 18             	sub    $0x18,%esp
  80076d:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800770:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800776:	89 04 24             	mov    %eax,(%esp)
  800779:	e8 f1 d1 00 00       	call   80d96f <thread_wakeup>
}
  80077e:	c9                   	leave  
  80077f:	c3                   	ret    

00800780 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800780:	55                   	push   %ebp
  800781:	89 e5                	mov    %esp,%ebp
  800783:	57                   	push   %edi
  800784:	56                   	push   %esi
  800785:	53                   	push   %ebx
  800786:	83 ec 2c             	sub    $0x2c,%esp
  800789:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80078c:	e8 19 0e 00 00       	call   8015aa <sys_time_msec>
  800791:	89 c3                	mov    %eax,%ebx
  800793:	03 5d 0c             	add    0xc(%ebp),%ebx

	binaryname = "ns_timer";
  800796:	c7 05 00 50 81 00 34 	movl   $0x812134,0x815000
  80079d:	21 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007a0:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  8007a3:	eb 05                	jmp    8007aa <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  8007a5:	e8 fa 0f 00 00       	call   8017a4 <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  8007aa:	e8 fb 0d 00 00       	call   8015aa <sys_time_msec>
  8007af:	39 c3                	cmp    %eax,%ebx
  8007b1:	76 07                	jbe    8007ba <timer+0x3a>
  8007b3:	85 c0                	test   %eax,%eax
  8007b5:	79 ee                	jns    8007a5 <timer+0x25>
  8007b7:	90                   	nop
  8007b8:	eb 08                	jmp    8007c2 <timer+0x42>
			sys_yield();
		}
		if (r < 0)
  8007ba:	85 c0                	test   %eax,%eax
  8007bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8007c0:	79 20                	jns    8007e2 <timer+0x62>
			panic("sys_time_msec: %e", r);
  8007c2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8007c6:	c7 44 24 08 3d 21 81 	movl   $0x81213d,0x8(%esp)
  8007cd:	00 
  8007ce:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  8007d5:	00 
  8007d6:	c7 04 24 4f 21 81 00 	movl   $0x81214f,(%esp)
  8007dd:	e8 32 01 00 00       	call   800914 <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007e2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007e9:	00 
  8007ea:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007f1:	00 
  8007f2:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007f9:	00 
  8007fa:	89 34 24             	mov    %esi,(%esp)
  8007fd:	e8 97 15 00 00       	call   801d99 <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800802:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800809:	00 
  80080a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800811:	00 
  800812:	89 3c 24             	mov    %edi,(%esp)
  800815:	e8 ea 15 00 00       	call   801e04 <ipc_recv>
  80081a:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  80081c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80081f:	39 c6                	cmp    %eax,%esi
  800821:	74 12                	je     800835 <timer+0xb5>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  800823:	89 44 24 04          	mov    %eax,0x4(%esp)
  800827:	c7 04 24 5c 21 81 00 	movl   $0x81215c,(%esp)
  80082e:	e8 9a 01 00 00       	call   8009cd <cprintf>
				continue;
			}

			stop = sys_time_msec() + to;
			break;
		}
  800833:	eb cd                	jmp    800802 <timer+0x82>
			if (whom != ns_envid) {
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  800835:	e8 70 0d 00 00       	call   8015aa <sys_time_msec>
  80083a:	01 c3                	add    %eax,%ebx
  80083c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800840:	e9 65 ff ff ff       	jmp    8007aa <timer+0x2a>
  800845:	00 00                	add    %al,(%eax)
	...

00800848 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  800848:	55                   	push   %ebp
  800849:	89 e5                	mov    %esp,%ebp
	binaryname = "ns_input";
  80084b:	c7 05 00 50 81 00 97 	movl   $0x812197,0x815000
  800852:	21 81 00 
	// 	- read a packet from the device driver
	//	- send it to the network server
	// Hint: When you IPC a page to the network server, it will be
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
}
  800855:	5d                   	pop    %ebp
  800856:	c3                   	ret    
	...

00800858 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  800858:	55                   	push   %ebp
  800859:	89 e5                	mov    %esp,%ebp
  80085b:	56                   	push   %esi
  80085c:	53                   	push   %ebx
  80085d:	83 ec 10             	sub    $0x10,%esp
  800860:	8b 75 08             	mov    0x8(%ebp),%esi
	binaryname = "ns_output";
  800863:	c7 05 00 50 81 00 a0 	movl   $0x8121a0,0x815000
  80086a:	21 81 00 
	// 	- read a packet from the network server
	//	- send the packet to the device driver
    int r;

    while (1) {
        r = sys_ipc_recv(&nsipcbuf);
  80086d:	bb 00 e0 b3 00       	mov    $0xb3e000,%ebx
  800872:	89 1c 24             	mov    %ebx,(%esp)
  800875:	e8 6b 0d 00 00       	call   8015e5 <sys_ipc_recv>
        if ((thisenv->env_ipc_from != ns_envid) ||
  80087a:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  80087f:	8b 50 74             	mov    0x74(%eax),%edx
  800882:	39 f2                	cmp    %esi,%edx
  800884:	75 ec                	jne    800872 <output+0x1a>
            (thisenv->env_ipc_value != NSREQ_OUTPUT)) {
  800886:	8b 40 70             	mov    0x70(%eax),%eax
	//	- send the packet to the device driver
    int r;

    while (1) {
        r = sys_ipc_recv(&nsipcbuf);
        if ((thisenv->env_ipc_from != ns_envid) ||
  800889:	83 f8 0b             	cmp    $0xb,%eax
  80088c:	75 e4                	jne    800872 <output+0x1a>
            (thisenv->env_ipc_value != NSREQ_OUTPUT)) {
            continue;
        }

        while ((r = sys_net_try_send(nsipcbuf.pkt.jp_data,
  80088e:	8b 03                	mov    (%ebx),%eax
  800890:	89 44 24 04          	mov    %eax,0x4(%esp)
  800894:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  80089b:	e8 d2 0c 00 00       	call   801572 <sys_net_try_send>
  8008a0:	85 c0                	test   %eax,%eax
  8008a2:	78 ea                	js     80088e <output+0x36>
  8008a4:	eb cc                	jmp    800872 <output+0x1a>
	...

008008a8 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  8008a8:	55                   	push   %ebp
  8008a9:	89 e5                	mov    %esp,%ebp
  8008ab:	83 ec 18             	sub    $0x18,%esp
  8008ae:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8008b1:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8008b4:	8b 75 08             	mov    0x8(%ebp),%esi
  8008b7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = envs + ENVX(sys_getenvid ());
  8008ba:	e8 58 0f 00 00       	call   801817 <sys_getenvid>
  8008bf:	25 ff 03 00 00       	and    $0x3ff,%eax
  8008c4:	c1 e0 07             	shl    $0x7,%eax
  8008c7:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  8008cc:	a3 74 c2 b3 00       	mov    %eax,0xb3c274

	// save the name of the program so that panic() can use it
	if (argc > 0)
  8008d1:	85 f6                	test   %esi,%esi
  8008d3:	7e 07                	jle    8008dc <libmain+0x34>
		binaryname = argv[0];
  8008d5:	8b 03                	mov    (%ebx),%eax
  8008d7:	a3 00 50 81 00       	mov    %eax,0x815000

	// call user main routine
	umain(argc, argv);
  8008dc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8008e0:	89 34 24             	mov    %esi,(%esp)
  8008e3:	e8 70 f7 ff ff       	call   800058 <umain>

	// exit gracefully
	exit();
  8008e8:	e8 0b 00 00 00       	call   8008f8 <exit>
}
  8008ed:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8008f0:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8008f3:	89 ec                	mov    %ebp,%esp
  8008f5:	5d                   	pop    %ebp
  8008f6:	c3                   	ret    
	...

008008f8 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  8008f8:	55                   	push   %ebp
  8008f9:	89 e5                	mov    %esp,%ebp
  8008fb:	83 ec 18             	sub    $0x18,%esp
	close_all();
  8008fe:	e8 86 1a 00 00       	call   802389 <close_all>
	sys_env_destroy(0);
  800903:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80090a:	e8 43 0f 00 00       	call   801852 <sys_env_destroy>
}
  80090f:	c9                   	leave  
  800910:	c3                   	ret    
  800911:	00 00                	add    %al,(%eax)
	...

00800914 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  800914:	55                   	push   %ebp
  800915:	89 e5                	mov    %esp,%ebp
  800917:	56                   	push   %esi
  800918:	53                   	push   %ebx
  800919:	83 ec 20             	sub    $0x20,%esp
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
  80091c:	8d 75 14             	lea    0x14(%ebp),%esi
	va_list ap;

	va_start(ap, fmt);

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80091f:	8b 1d 00 50 81 00    	mov    0x815000,%ebx
  800925:	e8 ed 0e 00 00       	call   801817 <sys_getenvid>
  80092a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80092d:	89 54 24 10          	mov    %edx,0x10(%esp)
  800931:	8b 55 08             	mov    0x8(%ebp),%edx
  800934:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800938:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80093c:	89 44 24 04          	mov    %eax,0x4(%esp)
  800940:	c7 04 24 b4 21 81 00 	movl   $0x8121b4,(%esp)
  800947:	e8 81 00 00 00       	call   8009cd <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80094c:	89 74 24 04          	mov    %esi,0x4(%esp)
  800950:	8b 45 10             	mov    0x10(%ebp),%eax
  800953:	89 04 24             	mov    %eax,(%esp)
  800956:	e8 11 00 00 00       	call   80096c <vcprintf>
	cprintf("\n");
  80095b:	c7 04 24 aa 1f 81 00 	movl   $0x811faa,(%esp)
  800962:	e8 66 00 00 00       	call   8009cd <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  800967:	cc                   	int3   
  800968:	eb fd                	jmp    800967 <_panic+0x53>
	...

0080096c <vcprintf>:
	b->cnt++;
}

int
vcprintf(const char *fmt, va_list ap)
{
  80096c:	55                   	push   %ebp
  80096d:	89 e5                	mov    %esp,%ebp
  80096f:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  800975:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80097c:	00 00 00 
	b.cnt = 0;
  80097f:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  800986:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  800989:	8b 45 0c             	mov    0xc(%ebp),%eax
  80098c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800990:	8b 45 08             	mov    0x8(%ebp),%eax
  800993:	89 44 24 08          	mov    %eax,0x8(%esp)
  800997:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80099d:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009a1:	c7 04 24 e7 09 80 00 	movl   $0x8009e7,(%esp)
  8009a8:	e8 d0 01 00 00       	call   800b7d <vprintfmt>
	sys_cputs(b.buf, b.idx);
  8009ad:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  8009b3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009b7:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  8009bd:	89 04 24             	mov    %eax,(%esp)
  8009c0:	e8 01 0f 00 00       	call   8018c6 <sys_cputs>

	return b.cnt;
}
  8009c5:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  8009cb:	c9                   	leave  
  8009cc:	c3                   	ret    

008009cd <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8009cd:	55                   	push   %ebp
  8009ce:	89 e5                	mov    %esp,%ebp
  8009d0:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
cprintf(const char *fmt, ...)
  8009d3:	8d 45 0c             	lea    0xc(%ebp),%eax
{
	va_list ap;
	int cnt;

	va_start(ap, fmt);
	cnt = vcprintf(fmt, ap);
  8009d6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009da:	8b 45 08             	mov    0x8(%ebp),%eax
  8009dd:	89 04 24             	mov    %eax,(%esp)
  8009e0:	e8 87 ff ff ff       	call   80096c <vcprintf>
	va_end(ap);

	return cnt;
}
  8009e5:	c9                   	leave  
  8009e6:	c3                   	ret    

008009e7 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  8009e7:	55                   	push   %ebp
  8009e8:	89 e5                	mov    %esp,%ebp
  8009ea:	53                   	push   %ebx
  8009eb:	83 ec 14             	sub    $0x14,%esp
  8009ee:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  8009f1:	8b 03                	mov    (%ebx),%eax
  8009f3:	8b 55 08             	mov    0x8(%ebp),%edx
  8009f6:	88 54 03 08          	mov    %dl,0x8(%ebx,%eax,1)
  8009fa:	83 c0 01             	add    $0x1,%eax
  8009fd:	89 03                	mov    %eax,(%ebx)
	if (b->idx == 256-1) {
  8009ff:	3d ff 00 00 00       	cmp    $0xff,%eax
  800a04:	75 19                	jne    800a1f <putch+0x38>
		sys_cputs(b->buf, b->idx);
  800a06:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  800a0d:	00 
  800a0e:	8d 43 08             	lea    0x8(%ebx),%eax
  800a11:	89 04 24             	mov    %eax,(%esp)
  800a14:	e8 ad 0e 00 00       	call   8018c6 <sys_cputs>
		b->idx = 0;
  800a19:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  800a1f:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  800a23:	83 c4 14             	add    $0x14,%esp
  800a26:	5b                   	pop    %ebx
  800a27:	5d                   	pop    %ebp
  800a28:	c3                   	ret    
  800a29:	00 00                	add    %al,(%eax)
  800a2b:	00 00                	add    %al,(%eax)
  800a2d:	00 00                	add    %al,(%eax)
	...

00800a30 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800a30:	55                   	push   %ebp
  800a31:	89 e5                	mov    %esp,%ebp
  800a33:	57                   	push   %edi
  800a34:	56                   	push   %esi
  800a35:	53                   	push   %ebx
  800a36:	83 ec 4c             	sub    $0x4c,%esp
  800a39:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800a3c:	89 d6                	mov    %edx,%esi
  800a3e:	8b 45 08             	mov    0x8(%ebp),%eax
  800a41:	89 45 d8             	mov    %eax,-0x28(%ebp)
  800a44:	8b 55 0c             	mov    0xc(%ebp),%edx
  800a47:	89 55 e0             	mov    %edx,-0x20(%ebp)
  800a4a:	8b 45 10             	mov    0x10(%ebp),%eax
  800a4d:	8b 5d 14             	mov    0x14(%ebp),%ebx
  800a50:	8b 7d 18             	mov    0x18(%ebp),%edi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800a53:	89 45 dc             	mov    %eax,-0x24(%ebp)
  800a56:	b9 00 00 00 00       	mov    $0x0,%ecx
  800a5b:	39 d1                	cmp    %edx,%ecx
  800a5d:	72 15                	jb     800a74 <printnum+0x44>
  800a5f:	77 07                	ja     800a68 <printnum+0x38>
  800a61:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800a64:	39 d0                	cmp    %edx,%eax
  800a66:	76 0c                	jbe    800a74 <printnum+0x44>
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800a68:	83 eb 01             	sub    $0x1,%ebx
  800a6b:	85 db                	test   %ebx,%ebx
  800a6d:	8d 76 00             	lea    0x0(%esi),%esi
  800a70:	7f 61                	jg     800ad3 <printnum+0xa3>
  800a72:	eb 70                	jmp    800ae4 <printnum+0xb4>
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800a74:	89 7c 24 10          	mov    %edi,0x10(%esp)
  800a78:	83 eb 01             	sub    $0x1,%ebx
  800a7b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800a7f:	89 44 24 08          	mov    %eax,0x8(%esp)
  800a83:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  800a87:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  800a8b:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  800a8e:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  800a91:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  800a94:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800a98:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800a9f:	00 
  800aa0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800aa3:	89 04 24             	mov    %eax,(%esp)
  800aa6:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800aa9:	89 54 24 04          	mov    %edx,0x4(%esp)
  800aad:	e8 fe 11 01 00       	call   811cb0 <__udivdi3>
  800ab2:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  800ab5:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  800ab8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  800abc:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800ac0:	89 04 24             	mov    %eax,(%esp)
  800ac3:	89 54 24 04          	mov    %edx,0x4(%esp)
  800ac7:	89 f2                	mov    %esi,%edx
  800ac9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800acc:	e8 5f ff ff ff       	call   800a30 <printnum>
  800ad1:	eb 11                	jmp    800ae4 <printnum+0xb4>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  800ad3:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ad7:	89 3c 24             	mov    %edi,(%esp)
  800ada:	ff 55 e4             	call   *-0x1c(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800add:	83 eb 01             	sub    $0x1,%ebx
  800ae0:	85 db                	test   %ebx,%ebx
  800ae2:	7f ef                	jg     800ad3 <printnum+0xa3>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800ae4:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ae8:	8b 74 24 04          	mov    0x4(%esp),%esi
  800aec:	8b 45 dc             	mov    -0x24(%ebp),%eax
  800aef:	89 44 24 08          	mov    %eax,0x8(%esp)
  800af3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800afa:	00 
  800afb:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800afe:	89 14 24             	mov    %edx,(%esp)
  800b01:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800b04:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800b08:	e8 d3 12 01 00       	call   811de0 <__umoddi3>
  800b0d:	89 74 24 04          	mov    %esi,0x4(%esp)
  800b11:	0f be 80 d7 21 81 00 	movsbl 0x8121d7(%eax),%eax
  800b18:	89 04 24             	mov    %eax,(%esp)
  800b1b:	ff 55 e4             	call   *-0x1c(%ebp)
}
  800b1e:	83 c4 4c             	add    $0x4c,%esp
  800b21:	5b                   	pop    %ebx
  800b22:	5e                   	pop    %esi
  800b23:	5f                   	pop    %edi
  800b24:	5d                   	pop    %ebp
  800b25:	c3                   	ret    

00800b26 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800b26:	55                   	push   %ebp
  800b27:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  800b29:	83 fa 01             	cmp    $0x1,%edx
  800b2c:	7e 0e                	jle    800b3c <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  800b2e:	8b 10                	mov    (%eax),%edx
  800b30:	8d 4a 08             	lea    0x8(%edx),%ecx
  800b33:	89 08                	mov    %ecx,(%eax)
  800b35:	8b 02                	mov    (%edx),%eax
  800b37:	8b 52 04             	mov    0x4(%edx),%edx
  800b3a:	eb 22                	jmp    800b5e <getuint+0x38>
	else if (lflag)
  800b3c:	85 d2                	test   %edx,%edx
  800b3e:	74 10                	je     800b50 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  800b40:	8b 10                	mov    (%eax),%edx
  800b42:	8d 4a 04             	lea    0x4(%edx),%ecx
  800b45:	89 08                	mov    %ecx,(%eax)
  800b47:	8b 02                	mov    (%edx),%eax
  800b49:	ba 00 00 00 00       	mov    $0x0,%edx
  800b4e:	eb 0e                	jmp    800b5e <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  800b50:	8b 10                	mov    (%eax),%edx
  800b52:	8d 4a 04             	lea    0x4(%edx),%ecx
  800b55:	89 08                	mov    %ecx,(%eax)
  800b57:	8b 02                	mov    (%edx),%eax
  800b59:	ba 00 00 00 00       	mov    $0x0,%edx
}
  800b5e:	5d                   	pop    %ebp
  800b5f:	c3                   	ret    

00800b60 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800b60:	55                   	push   %ebp
  800b61:	89 e5                	mov    %esp,%ebp
  800b63:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  800b66:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  800b6a:	8b 10                	mov    (%eax),%edx
  800b6c:	3b 50 04             	cmp    0x4(%eax),%edx
  800b6f:	73 0a                	jae    800b7b <sprintputch+0x1b>
		*b->buf++ = ch;
  800b71:	8b 4d 08             	mov    0x8(%ebp),%ecx
  800b74:	88 0a                	mov    %cl,(%edx)
  800b76:	83 c2 01             	add    $0x1,%edx
  800b79:	89 10                	mov    %edx,(%eax)
}
  800b7b:	5d                   	pop    %ebp
  800b7c:	c3                   	ret    

00800b7d <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800b7d:	55                   	push   %ebp
  800b7e:	89 e5                	mov    %esp,%ebp
  800b80:	57                   	push   %edi
  800b81:	56                   	push   %esi
  800b82:	53                   	push   %ebx
  800b83:	83 ec 5c             	sub    $0x5c,%esp
  800b86:	8b 7d 08             	mov    0x8(%ebp),%edi
  800b89:	8b 75 0c             	mov    0xc(%ebp),%esi
  800b8c:	8b 5d 10             	mov    0x10(%ebp),%ebx
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  800b8f:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
  800b96:	eb 11                	jmp    800ba9 <vprintfmt+0x2c>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  800b98:	85 c0                	test   %eax,%eax
  800b9a:	0f 84 68 04 00 00    	je     801008 <vprintfmt+0x48b>
				return;
			putch(ch, putdat);
  800ba0:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ba4:	89 04 24             	mov    %eax,(%esp)
  800ba7:	ff d7                	call   *%edi
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800ba9:	0f b6 03             	movzbl (%ebx),%eax
  800bac:	83 c3 01             	add    $0x1,%ebx
  800baf:	83 f8 25             	cmp    $0x25,%eax
  800bb2:	75 e4                	jne    800b98 <vprintfmt+0x1b>
  800bb4:	c7 45 cc ff ff ff ff 	movl   $0xffffffff,-0x34(%ebp)
  800bbb:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
  800bc2:	b9 00 00 00 00       	mov    $0x0,%ecx
  800bc7:	c6 45 e0 20          	movb   $0x20,-0x20(%ebp)
  800bcb:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  800bd2:	eb 06                	jmp    800bda <vprintfmt+0x5d>
  800bd4:	c6 45 e0 2d          	movb   $0x2d,-0x20(%ebp)
  800bd8:	89 c3                	mov    %eax,%ebx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800bda:	0f b6 13             	movzbl (%ebx),%edx
  800bdd:	0f b6 c2             	movzbl %dl,%eax
  800be0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800be3:	8d 43 01             	lea    0x1(%ebx),%eax
  800be6:	83 ea 23             	sub    $0x23,%edx
  800be9:	80 fa 55             	cmp    $0x55,%dl
  800bec:	0f 87 f9 03 00 00    	ja     800feb <vprintfmt+0x46e>
  800bf2:	0f b6 d2             	movzbl %dl,%edx
  800bf5:	ff 24 95 c0 23 81 00 	jmp    *0x8123c0(,%edx,4)
  800bfc:	c6 45 e0 30          	movb   $0x30,-0x20(%ebp)
  800c00:	eb d6                	jmp    800bd8 <vprintfmt+0x5b>
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  800c02:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800c05:	83 ea 30             	sub    $0x30,%edx
  800c08:	89 55 cc             	mov    %edx,-0x34(%ebp)
				ch = *fmt;
  800c0b:	0f be 10             	movsbl (%eax),%edx
				if (ch < '0' || ch > '9')
  800c0e:	8d 5a d0             	lea    -0x30(%edx),%ebx
  800c11:	83 fb 09             	cmp    $0x9,%ebx
  800c14:	77 54                	ja     800c6a <vprintfmt+0xed>
  800c16:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  800c19:	8b 4d cc             	mov    -0x34(%ebp),%ecx
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800c1c:	83 c0 01             	add    $0x1,%eax
				precision = precision * 10 + ch - '0';
  800c1f:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  800c22:	8d 4c 4a d0          	lea    -0x30(%edx,%ecx,2),%ecx
				ch = *fmt;
  800c26:	0f be 10             	movsbl (%eax),%edx
				if (ch < '0' || ch > '9')
  800c29:	8d 5a d0             	lea    -0x30(%edx),%ebx
  800c2c:	83 fb 09             	cmp    $0x9,%ebx
  800c2f:	76 eb                	jbe    800c1c <vprintfmt+0x9f>
  800c31:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  800c34:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  800c37:	eb 31                	jmp    800c6a <vprintfmt+0xed>
					break;
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  800c39:	8b 55 14             	mov    0x14(%ebp),%edx
  800c3c:	8d 5a 04             	lea    0x4(%edx),%ebx
  800c3f:	89 5d 14             	mov    %ebx,0x14(%ebp)
  800c42:	8b 12                	mov    (%edx),%edx
  800c44:	89 55 cc             	mov    %edx,-0x34(%ebp)
			goto process_precision;
  800c47:	eb 21                	jmp    800c6a <vprintfmt+0xed>

		case '.':
			if (width < 0)
  800c49:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  800c4d:	ba 00 00 00 00       	mov    $0x0,%edx
  800c52:	0f 49 55 d4          	cmovns -0x2c(%ebp),%edx
  800c56:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  800c59:	e9 7a ff ff ff       	jmp    800bd8 <vprintfmt+0x5b>
  800c5e:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
			goto reswitch;
  800c65:	e9 6e ff ff ff       	jmp    800bd8 <vprintfmt+0x5b>

		process_precision:
			if (width < 0)
  800c6a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  800c6e:	0f 89 64 ff ff ff    	jns    800bd8 <vprintfmt+0x5b>
  800c74:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800c77:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  800c7a:	8b 55 c8             	mov    -0x38(%ebp),%edx
  800c7d:	89 55 cc             	mov    %edx,-0x34(%ebp)
  800c80:	e9 53 ff ff ff       	jmp    800bd8 <vprintfmt+0x5b>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800c85:	83 c1 01             	add    $0x1,%ecx
			goto reswitch;
  800c88:	e9 4b ff ff ff       	jmp    800bd8 <vprintfmt+0x5b>
  800c8d:	89 45 d0             	mov    %eax,-0x30(%ebp)

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  800c90:	8b 45 14             	mov    0x14(%ebp),%eax
  800c93:	8d 50 04             	lea    0x4(%eax),%edx
  800c96:	89 55 14             	mov    %edx,0x14(%ebp)
  800c99:	89 74 24 04          	mov    %esi,0x4(%esp)
  800c9d:	8b 00                	mov    (%eax),%eax
  800c9f:	89 04 24             	mov    %eax,(%esp)
  800ca2:	ff d7                	call   *%edi
  800ca4:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  800ca7:	e9 fd fe ff ff       	jmp    800ba9 <vprintfmt+0x2c>
  800cac:	89 45 d0             	mov    %eax,-0x30(%ebp)

		// error message
		case 'e':
			err = va_arg(ap, int);
  800caf:	8b 45 14             	mov    0x14(%ebp),%eax
  800cb2:	8d 50 04             	lea    0x4(%eax),%edx
  800cb5:	89 55 14             	mov    %edx,0x14(%ebp)
  800cb8:	8b 00                	mov    (%eax),%eax
  800cba:	89 c2                	mov    %eax,%edx
  800cbc:	c1 fa 1f             	sar    $0x1f,%edx
  800cbf:	31 d0                	xor    %edx,%eax
  800cc1:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800cc3:	83 f8 0f             	cmp    $0xf,%eax
  800cc6:	7f 0b                	jg     800cd3 <vprintfmt+0x156>
  800cc8:	8b 14 85 20 25 81 00 	mov    0x812520(,%eax,4),%edx
  800ccf:	85 d2                	test   %edx,%edx
  800cd1:	75 20                	jne    800cf3 <vprintfmt+0x176>
				printfmt(putch, putdat, "error %d", err);
  800cd3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800cd7:	c7 44 24 08 e8 21 81 	movl   $0x8121e8,0x8(%esp)
  800cde:	00 
  800cdf:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ce3:	89 3c 24             	mov    %edi,(%esp)
  800ce6:	e8 a5 03 00 00       	call   801090 <printfmt>
  800ceb:	8b 5d d0             	mov    -0x30(%ebp),%ebx
		// error message
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800cee:	e9 b6 fe ff ff       	jmp    800ba9 <vprintfmt+0x2c>
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800cf3:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800cf7:	c7 44 24 08 b3 28 81 	movl   $0x8128b3,0x8(%esp)
  800cfe:	00 
  800cff:	89 74 24 04          	mov    %esi,0x4(%esp)
  800d03:	89 3c 24             	mov    %edi,(%esp)
  800d06:	e8 85 03 00 00       	call   801090 <printfmt>
  800d0b:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  800d0e:	e9 96 fe ff ff       	jmp    800ba9 <vprintfmt+0x2c>
  800d13:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800d16:	89 c3                	mov    %eax,%ebx
  800d18:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  800d1b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800d1e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  800d21:	8b 45 14             	mov    0x14(%ebp),%eax
  800d24:	8d 50 04             	lea    0x4(%eax),%edx
  800d27:	89 55 14             	mov    %edx,0x14(%ebp)
  800d2a:	8b 00                	mov    (%eax),%eax
  800d2c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800d2f:	85 c0                	test   %eax,%eax
  800d31:	b8 f1 21 81 00       	mov    $0x8121f1,%eax
  800d36:	0f 45 45 e4          	cmovne -0x1c(%ebp),%eax
  800d3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				p = "(null)";
			if (width > 0 && padc != '-')
  800d3d:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  800d41:	7e 06                	jle    800d49 <vprintfmt+0x1cc>
  800d43:	80 7d e0 2d          	cmpb   $0x2d,-0x20(%ebp)
  800d47:	75 13                	jne    800d5c <vprintfmt+0x1df>
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800d49:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800d4c:	0f be 02             	movsbl (%edx),%eax
  800d4f:	85 c0                	test   %eax,%eax
  800d51:	0f 85 a2 00 00 00    	jne    800df9 <vprintfmt+0x27c>
  800d57:	e9 8f 00 00 00       	jmp    800deb <vprintfmt+0x26e>
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800d5c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800d60:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  800d63:	89 0c 24             	mov    %ecx,(%esp)
  800d66:	e8 70 03 00 00       	call   8010db <strnlen>
  800d6b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  800d6e:	29 c2                	sub    %eax,%edx
  800d70:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  800d73:	85 d2                	test   %edx,%edx
  800d75:	7e d2                	jle    800d49 <vprintfmt+0x1cc>
					putch(padc, putdat);
  800d77:	0f be 4d e0          	movsbl -0x20(%ebp),%ecx
  800d7b:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  800d7e:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
  800d81:	89 d3                	mov    %edx,%ebx
  800d83:	89 74 24 04          	mov    %esi,0x4(%esp)
  800d87:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800d8a:	89 04 24             	mov    %eax,(%esp)
  800d8d:	ff d7                	call   *%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800d8f:	83 eb 01             	sub    $0x1,%ebx
  800d92:	85 db                	test   %ebx,%ebx
  800d94:	7f ed                	jg     800d83 <vprintfmt+0x206>
  800d96:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
  800d99:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  800da0:	eb a7                	jmp    800d49 <vprintfmt+0x1cc>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  800da2:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  800da6:	74 1b                	je     800dc3 <vprintfmt+0x246>
  800da8:	8d 50 e0             	lea    -0x20(%eax),%edx
  800dab:	83 fa 5e             	cmp    $0x5e,%edx
  800dae:	76 13                	jbe    800dc3 <vprintfmt+0x246>
					putch('?', putdat);
  800db0:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800db3:	89 54 24 04          	mov    %edx,0x4(%esp)
  800db7:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  800dbe:	ff 55 e4             	call   *-0x1c(%ebp)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  800dc1:	eb 0d                	jmp    800dd0 <vprintfmt+0x253>
					putch('?', putdat);
				else
					putch(ch, putdat);
  800dc3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800dc6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800dca:	89 04 24             	mov    %eax,(%esp)
  800dcd:	ff 55 e4             	call   *-0x1c(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800dd0:	83 ef 01             	sub    $0x1,%edi
  800dd3:	0f be 03             	movsbl (%ebx),%eax
  800dd6:	85 c0                	test   %eax,%eax
  800dd8:	74 05                	je     800ddf <vprintfmt+0x262>
  800dda:	83 c3 01             	add    $0x1,%ebx
  800ddd:	eb 31                	jmp    800e10 <vprintfmt+0x293>
  800ddf:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  800de2:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  800de5:	8b 75 e0             	mov    -0x20(%ebp),%esi
  800de8:	8b 5d cc             	mov    -0x34(%ebp),%ebx
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800deb:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  800def:	7f 36                	jg     800e27 <vprintfmt+0x2aa>
  800df1:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  800df4:	e9 b0 fd ff ff       	jmp    800ba9 <vprintfmt+0x2c>
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800df9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800dfc:	83 c2 01             	add    $0x1,%edx
  800dff:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  800e02:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  800e05:	89 75 e0             	mov    %esi,-0x20(%ebp)
  800e08:	8b 75 cc             	mov    -0x34(%ebp),%esi
  800e0b:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  800e0e:	89 d3                	mov    %edx,%ebx
  800e10:	85 f6                	test   %esi,%esi
  800e12:	78 8e                	js     800da2 <vprintfmt+0x225>
  800e14:	83 ee 01             	sub    $0x1,%esi
  800e17:	79 89                	jns    800da2 <vprintfmt+0x225>
  800e19:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  800e1c:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  800e1f:	8b 75 e0             	mov    -0x20(%ebp),%esi
  800e22:	8b 5d cc             	mov    -0x34(%ebp),%ebx
  800e25:	eb c4                	jmp    800deb <vprintfmt+0x26e>
  800e27:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  800e2a:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  800e2d:	89 74 24 04          	mov    %esi,0x4(%esp)
  800e31:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  800e38:	ff d7                	call   *%edi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800e3a:	83 eb 01             	sub    $0x1,%ebx
  800e3d:	85 db                	test   %ebx,%ebx
  800e3f:	7f ec                	jg     800e2d <vprintfmt+0x2b0>
  800e41:	8b 5d d8             	mov    -0x28(%ebp),%ebx
  800e44:	e9 60 fd ff ff       	jmp    800ba9 <vprintfmt+0x2c>
  800e49:	89 45 d0             	mov    %eax,-0x30(%ebp)
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  800e4c:	83 f9 01             	cmp    $0x1,%ecx
  800e4f:	7e 16                	jle    800e67 <vprintfmt+0x2ea>
		return va_arg(*ap, long long);
  800e51:	8b 45 14             	mov    0x14(%ebp),%eax
  800e54:	8d 50 08             	lea    0x8(%eax),%edx
  800e57:	89 55 14             	mov    %edx,0x14(%ebp)
  800e5a:	8b 10                	mov    (%eax),%edx
  800e5c:	8b 48 04             	mov    0x4(%eax),%ecx
  800e5f:	89 55 d8             	mov    %edx,-0x28(%ebp)
  800e62:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  800e65:	eb 32                	jmp    800e99 <vprintfmt+0x31c>
	else if (lflag)
  800e67:	85 c9                	test   %ecx,%ecx
  800e69:	74 18                	je     800e83 <vprintfmt+0x306>
		return va_arg(*ap, long);
  800e6b:	8b 45 14             	mov    0x14(%ebp),%eax
  800e6e:	8d 50 04             	lea    0x4(%eax),%edx
  800e71:	89 55 14             	mov    %edx,0x14(%ebp)
  800e74:	8b 00                	mov    (%eax),%eax
  800e76:	89 45 d8             	mov    %eax,-0x28(%ebp)
  800e79:	89 c1                	mov    %eax,%ecx
  800e7b:	c1 f9 1f             	sar    $0x1f,%ecx
  800e7e:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  800e81:	eb 16                	jmp    800e99 <vprintfmt+0x31c>
	else
		return va_arg(*ap, int);
  800e83:	8b 45 14             	mov    0x14(%ebp),%eax
  800e86:	8d 50 04             	lea    0x4(%eax),%edx
  800e89:	89 55 14             	mov    %edx,0x14(%ebp)
  800e8c:	8b 00                	mov    (%eax),%eax
  800e8e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  800e91:	89 c2                	mov    %eax,%edx
  800e93:	c1 fa 1f             	sar    $0x1f,%edx
  800e96:	89 55 dc             	mov    %edx,-0x24(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  800e99:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800e9c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  800e9f:	bb 0a 00 00 00       	mov    $0xa,%ebx
			if ((long long) num < 0) {
  800ea4:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  800ea8:	0f 89 8a 00 00 00    	jns    800f38 <vprintfmt+0x3bb>
				putch('-', putdat);
  800eae:	89 74 24 04          	mov    %esi,0x4(%esp)
  800eb2:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  800eb9:	ff d7                	call   *%edi
				num = -(long long) num;
  800ebb:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800ebe:	8b 55 dc             	mov    -0x24(%ebp),%edx
  800ec1:	f7 d8                	neg    %eax
  800ec3:	83 d2 00             	adc    $0x0,%edx
  800ec6:	f7 da                	neg    %edx
  800ec8:	eb 6e                	jmp    800f38 <vprintfmt+0x3bb>
  800eca:	89 45 d0             	mov    %eax,-0x30(%ebp)
			base = 10;
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  800ecd:	89 ca                	mov    %ecx,%edx
  800ecf:	8d 45 14             	lea    0x14(%ebp),%eax
  800ed2:	e8 4f fc ff ff       	call   800b26 <getuint>
  800ed7:	bb 0a 00 00 00       	mov    $0xa,%ebx
			base = 10;
			goto number;
  800edc:	eb 5a                	jmp    800f38 <vprintfmt+0x3bb>
  800ede:	89 45 d0             	mov    %eax,-0x30(%ebp)
		case 'o':
			// Replace this with your code.
			// putch('X', putdat);
			// putch('X', putdat);
			// putch('X', putdat);
			num = getuint(&ap, lflag);
  800ee1:	89 ca                	mov    %ecx,%edx
  800ee3:	8d 45 14             	lea    0x14(%ebp),%eax
  800ee6:	e8 3b fc ff ff       	call   800b26 <getuint>
  800eeb:	bb 08 00 00 00       	mov    $0x8,%ebx
			base = 8;
			goto number;
  800ef0:	eb 46                	jmp    800f38 <vprintfmt+0x3bb>
  800ef2:	89 45 d0             	mov    %eax,-0x30(%ebp)
			

		// pointer
		case 'p':
			putch('0', putdat);
  800ef5:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ef9:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  800f00:	ff d7                	call   *%edi
			putch('x', putdat);
  800f02:	89 74 24 04          	mov    %esi,0x4(%esp)
  800f06:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  800f0d:	ff d7                	call   *%edi
			num = (unsigned long long)
  800f0f:	8b 45 14             	mov    0x14(%ebp),%eax
  800f12:	8d 50 04             	lea    0x4(%eax),%edx
  800f15:	89 55 14             	mov    %edx,0x14(%ebp)
  800f18:	8b 00                	mov    (%eax),%eax
  800f1a:	ba 00 00 00 00       	mov    $0x0,%edx
  800f1f:	bb 10 00 00 00       	mov    $0x10,%ebx
				(uintptr_t) va_arg(ap, void *);
			base = 16;
			goto number;
  800f24:	eb 12                	jmp    800f38 <vprintfmt+0x3bb>
  800f26:	89 45 d0             	mov    %eax,-0x30(%ebp)

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  800f29:	89 ca                	mov    %ecx,%edx
  800f2b:	8d 45 14             	lea    0x14(%ebp),%eax
  800f2e:	e8 f3 fb ff ff       	call   800b26 <getuint>
  800f33:	bb 10 00 00 00       	mov    $0x10,%ebx
			base = 16;
		number:
			printnum(putch, putdat, num, base, width, padc);
  800f38:	0f be 4d e0          	movsbl -0x20(%ebp),%ecx
  800f3c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  800f40:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  800f43:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  800f47:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800f4b:	89 04 24             	mov    %eax,(%esp)
  800f4e:	89 54 24 04          	mov    %edx,0x4(%esp)
  800f52:	89 f2                	mov    %esi,%edx
  800f54:	89 f8                	mov    %edi,%eax
  800f56:	e8 d5 fa ff ff       	call   800a30 <printnum>
  800f5b:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  800f5e:	e9 46 fc ff ff       	jmp    800ba9 <vprintfmt+0x2c>
  800f63:	89 45 d0             	mov    %eax,-0x30(%ebp)

            const char *null_error = "\nerror! writing through NULL pointer! (%n argument)\n";
            const char *overflow_error = "\nwarning! The value %n argument pointed to has been overflowed!\n";

            // Your code here
		if ((p = va_arg(ap, void *)) == NULL)
  800f66:	8b 45 14             	mov    0x14(%ebp),%eax
  800f69:	8d 50 04             	lea    0x4(%eax),%edx
  800f6c:	89 55 14             	mov    %edx,0x14(%ebp)
  800f6f:	8b 00                	mov    (%eax),%eax
  800f71:	85 c0                	test   %eax,%eax
  800f73:	75 24                	jne    800f99 <vprintfmt+0x41c>
		{		
			printfmt(putch, putdat, "%s", null_error);
  800f75:	c7 44 24 0c 0c 23 81 	movl   $0x81230c,0xc(%esp)
  800f7c:	00 
  800f7d:	c7 44 24 08 b3 28 81 	movl   $0x8128b3,0x8(%esp)
  800f84:	00 
  800f85:	89 74 24 04          	mov    %esi,0x4(%esp)
  800f89:	89 3c 24             	mov    %edi,(%esp)
  800f8c:	e8 ff 00 00 00       	call   801090 <printfmt>
  800f91:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  800f94:	e9 10 fc ff ff       	jmp    800ba9 <vprintfmt+0x2c>
		}		
		if( (*(int *)putdat) > 127)
  800f99:	83 3e 7f             	cmpl   $0x7f,(%esi)
  800f9c:	7e 29                	jle    800fc7 <vprintfmt+0x44a>
		{
			(*((unsigned char *)p)) = (*((unsigned char *)putdat));
  800f9e:	0f b6 16             	movzbl (%esi),%edx
  800fa1:	88 10                	mov    %dl,(%eax)
			printfmt(putch, putdat, "%s", overflow_error);			
  800fa3:	c7 44 24 0c 44 23 81 	movl   $0x812344,0xc(%esp)
  800faa:	00 
  800fab:	c7 44 24 08 b3 28 81 	movl   $0x8128b3,0x8(%esp)
  800fb2:	00 
  800fb3:	89 74 24 04          	mov    %esi,0x4(%esp)
  800fb7:	89 3c 24             	mov    %edi,(%esp)
  800fba:	e8 d1 00 00 00       	call   801090 <printfmt>
  800fbf:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  800fc2:	e9 e2 fb ff ff       	jmp    800ba9 <vprintfmt+0x2c>
		}

		(*((char *)p)) = (*((char *)putdat));		
  800fc7:	0f b6 16             	movzbl (%esi),%edx
  800fca:	88 10                	mov    %dl,(%eax)
  800fcc:	8b 5d d0             	mov    -0x30(%ebp),%ebx

            break;
  800fcf:	e9 d5 fb ff ff       	jmp    800ba9 <vprintfmt+0x2c>
  800fd4:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800fd7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
        }

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  800fda:	89 74 24 04          	mov    %esi,0x4(%esp)
  800fde:	89 14 24             	mov    %edx,(%esp)
  800fe1:	ff d7                	call   *%edi
  800fe3:	8b 5d d0             	mov    -0x30(%ebp),%ebx
			break;
  800fe6:	e9 be fb ff ff       	jmp    800ba9 <vprintfmt+0x2c>
			
		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800feb:	89 74 24 04          	mov    %esi,0x4(%esp)
  800fef:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  800ff6:	ff d7                	call   *%edi
			for (fmt--; fmt[-1] != '%'; fmt--)
  800ff8:	8d 43 ff             	lea    -0x1(%ebx),%eax
  800ffb:	80 38 25             	cmpb   $0x25,(%eax)
  800ffe:	0f 84 a5 fb ff ff    	je     800ba9 <vprintfmt+0x2c>
  801004:	89 c3                	mov    %eax,%ebx
  801006:	eb f0                	jmp    800ff8 <vprintfmt+0x47b>
				/* do nothing */;
			break;
		}
	}
}
  801008:	83 c4 5c             	add    $0x5c,%esp
  80100b:	5b                   	pop    %ebx
  80100c:	5e                   	pop    %esi
  80100d:	5f                   	pop    %edi
  80100e:	5d                   	pop    %ebp
  80100f:	c3                   	ret    

00801010 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801010:	55                   	push   %ebp
  801011:	89 e5                	mov    %esp,%ebp
  801013:	83 ec 28             	sub    $0x28,%esp
  801016:	8b 45 08             	mov    0x8(%ebp),%eax
  801019:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
  80101c:	85 c0                	test   %eax,%eax
  80101e:	74 04                	je     801024 <vsnprintf+0x14>
  801020:	85 d2                	test   %edx,%edx
  801022:	7f 07                	jg     80102b <vsnprintf+0x1b>
  801024:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  801029:	eb 3b                	jmp    801066 <vsnprintf+0x56>
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};
  80102b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80102e:	8d 44 10 ff          	lea    -0x1(%eax,%edx,1),%eax
  801032:	89 45 f0             	mov    %eax,-0x10(%ebp)
  801035:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80103c:	8b 45 14             	mov    0x14(%ebp),%eax
  80103f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801043:	8b 45 10             	mov    0x10(%ebp),%eax
  801046:	89 44 24 08          	mov    %eax,0x8(%esp)
  80104a:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80104d:	89 44 24 04          	mov    %eax,0x4(%esp)
  801051:	c7 04 24 60 0b 80 00 	movl   $0x800b60,(%esp)
  801058:	e8 20 fb ff ff       	call   800b7d <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80105d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  801060:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  801063:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  801066:	c9                   	leave  
  801067:	c3                   	ret    

00801068 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801068:	55                   	push   %ebp
  801069:	89 e5                	mov    %esp,%ebp
  80106b:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
snprintf(char *buf, int n, const char *fmt, ...)
  80106e:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;
	int rc;

	va_start(ap, fmt);
	rc = vsnprintf(buf, n, fmt, ap);
  801071:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801075:	8b 45 10             	mov    0x10(%ebp),%eax
  801078:	89 44 24 08          	mov    %eax,0x8(%esp)
  80107c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80107f:	89 44 24 04          	mov    %eax,0x4(%esp)
  801083:	8b 45 08             	mov    0x8(%ebp),%eax
  801086:	89 04 24             	mov    %eax,(%esp)
  801089:	e8 82 ff ff ff       	call   801010 <vsnprintf>
	va_end(ap);

	return rc;
}
  80108e:	c9                   	leave  
  80108f:	c3                   	ret    

00801090 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  801090:	55                   	push   %ebp
  801091:	89 e5                	mov    %esp,%ebp
  801093:	83 ec 18             	sub    $0x18,%esp
		}
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
  801096:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;

	va_start(ap, fmt);
	vprintfmt(putch, putdat, fmt, ap);
  801099:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80109d:	8b 45 10             	mov    0x10(%ebp),%eax
  8010a0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8010a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8010a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8010ab:	8b 45 08             	mov    0x8(%ebp),%eax
  8010ae:	89 04 24             	mov    %eax,(%esp)
  8010b1:	e8 c7 fa ff ff       	call   800b7d <vprintfmt>
	va_end(ap);
}
  8010b6:	c9                   	leave  
  8010b7:	c3                   	ret    
	...

008010c0 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  8010c0:	55                   	push   %ebp
  8010c1:	89 e5                	mov    %esp,%ebp
  8010c3:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  8010c6:	b8 00 00 00 00       	mov    $0x0,%eax
  8010cb:	80 3a 00             	cmpb   $0x0,(%edx)
  8010ce:	74 09                	je     8010d9 <strlen+0x19>
		n++;
  8010d0:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  8010d3:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  8010d7:	75 f7                	jne    8010d0 <strlen+0x10>
		n++;
	return n;
}
  8010d9:	5d                   	pop    %ebp
  8010da:	c3                   	ret    

008010db <strnlen>:

int
strnlen(const char *s, size_t size)
{
  8010db:	55                   	push   %ebp
  8010dc:	89 e5                	mov    %esp,%ebp
  8010de:	53                   	push   %ebx
  8010df:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8010e2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8010e5:	85 c9                	test   %ecx,%ecx
  8010e7:	74 19                	je     801102 <strnlen+0x27>
  8010e9:	80 3b 00             	cmpb   $0x0,(%ebx)
  8010ec:	74 14                	je     801102 <strnlen+0x27>
  8010ee:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
  8010f3:	83 c0 01             	add    $0x1,%eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8010f6:	39 c8                	cmp    %ecx,%eax
  8010f8:	74 0d                	je     801107 <strnlen+0x2c>
  8010fa:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
  8010fe:	75 f3                	jne    8010f3 <strnlen+0x18>
  801100:	eb 05                	jmp    801107 <strnlen+0x2c>
  801102:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
	return n;
}
  801107:	5b                   	pop    %ebx
  801108:	5d                   	pop    %ebp
  801109:	c3                   	ret    

0080110a <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80110a:	55                   	push   %ebp
  80110b:	89 e5                	mov    %esp,%ebp
  80110d:	53                   	push   %ebx
  80110e:	8b 45 08             	mov    0x8(%ebp),%eax
  801111:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801114:	ba 00 00 00 00       	mov    $0x0,%edx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  801119:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  80111d:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  801120:	83 c2 01             	add    $0x1,%edx
  801123:	84 c9                	test   %cl,%cl
  801125:	75 f2                	jne    801119 <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  801127:	5b                   	pop    %ebx
  801128:	5d                   	pop    %ebp
  801129:	c3                   	ret    

0080112a <strcat>:

char *
strcat(char *dst, const char *src)
{
  80112a:	55                   	push   %ebp
  80112b:	89 e5                	mov    %esp,%ebp
  80112d:	53                   	push   %ebx
  80112e:	83 ec 08             	sub    $0x8,%esp
  801131:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  801134:	89 1c 24             	mov    %ebx,(%esp)
  801137:	e8 84 ff ff ff       	call   8010c0 <strlen>
	strcpy(dst + len, src);
  80113c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80113f:	89 54 24 04          	mov    %edx,0x4(%esp)
  801143:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  801146:	89 04 24             	mov    %eax,(%esp)
  801149:	e8 bc ff ff ff       	call   80110a <strcpy>
	return dst;
}
  80114e:	89 d8                	mov    %ebx,%eax
  801150:	83 c4 08             	add    $0x8,%esp
  801153:	5b                   	pop    %ebx
  801154:	5d                   	pop    %ebp
  801155:	c3                   	ret    

00801156 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  801156:	55                   	push   %ebp
  801157:	89 e5                	mov    %esp,%ebp
  801159:	56                   	push   %esi
  80115a:	53                   	push   %ebx
  80115b:	8b 45 08             	mov    0x8(%ebp),%eax
  80115e:	8b 55 0c             	mov    0xc(%ebp),%edx
  801161:	8b 75 10             	mov    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801164:	85 f6                	test   %esi,%esi
  801166:	74 18                	je     801180 <strncpy+0x2a>
  801168:	b9 00 00 00 00       	mov    $0x0,%ecx
		*dst++ = *src;
  80116d:	0f b6 1a             	movzbl (%edx),%ebx
  801170:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  801173:	80 3a 01             	cmpb   $0x1,(%edx)
  801176:	83 da ff             	sbb    $0xffffffff,%edx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801179:	83 c1 01             	add    $0x1,%ecx
  80117c:	39 ce                	cmp    %ecx,%esi
  80117e:	77 ed                	ja     80116d <strncpy+0x17>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  801180:	5b                   	pop    %ebx
  801181:	5e                   	pop    %esi
  801182:	5d                   	pop    %ebp
  801183:	c3                   	ret    

00801184 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801184:	55                   	push   %ebp
  801185:	89 e5                	mov    %esp,%ebp
  801187:	56                   	push   %esi
  801188:	53                   	push   %ebx
  801189:	8b 75 08             	mov    0x8(%ebp),%esi
  80118c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80118f:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  801192:	89 f0                	mov    %esi,%eax
  801194:	85 c9                	test   %ecx,%ecx
  801196:	74 27                	je     8011bf <strlcpy+0x3b>
		while (--size > 0 && *src != '\0')
  801198:	83 e9 01             	sub    $0x1,%ecx
  80119b:	74 1d                	je     8011ba <strlcpy+0x36>
  80119d:	0f b6 1a             	movzbl (%edx),%ebx
  8011a0:	84 db                	test   %bl,%bl
  8011a2:	74 16                	je     8011ba <strlcpy+0x36>
			*dst++ = *src++;
  8011a4:	88 18                	mov    %bl,(%eax)
  8011a6:	83 c0 01             	add    $0x1,%eax
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  8011a9:	83 e9 01             	sub    $0x1,%ecx
  8011ac:	74 0e                	je     8011bc <strlcpy+0x38>
			*dst++ = *src++;
  8011ae:	83 c2 01             	add    $0x1,%edx
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  8011b1:	0f b6 1a             	movzbl (%edx),%ebx
  8011b4:	84 db                	test   %bl,%bl
  8011b6:	75 ec                	jne    8011a4 <strlcpy+0x20>
  8011b8:	eb 02                	jmp    8011bc <strlcpy+0x38>
  8011ba:	89 f0                	mov    %esi,%eax
			*dst++ = *src++;
		*dst = '\0';
  8011bc:	c6 00 00             	movb   $0x0,(%eax)
  8011bf:	29 f0                	sub    %esi,%eax
	}
	return dst - dst_in;
}
  8011c1:	5b                   	pop    %ebx
  8011c2:	5e                   	pop    %esi
  8011c3:	5d                   	pop    %ebp
  8011c4:	c3                   	ret    

008011c5 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  8011c5:	55                   	push   %ebp
  8011c6:	89 e5                	mov    %esp,%ebp
  8011c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8011cb:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  8011ce:	0f b6 01             	movzbl (%ecx),%eax
  8011d1:	84 c0                	test   %al,%al
  8011d3:	74 15                	je     8011ea <strcmp+0x25>
  8011d5:	3a 02                	cmp    (%edx),%al
  8011d7:	75 11                	jne    8011ea <strcmp+0x25>
		p++, q++;
  8011d9:	83 c1 01             	add    $0x1,%ecx
  8011dc:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  8011df:	0f b6 01             	movzbl (%ecx),%eax
  8011e2:	84 c0                	test   %al,%al
  8011e4:	74 04                	je     8011ea <strcmp+0x25>
  8011e6:	3a 02                	cmp    (%edx),%al
  8011e8:	74 ef                	je     8011d9 <strcmp+0x14>
  8011ea:	0f b6 c0             	movzbl %al,%eax
  8011ed:	0f b6 12             	movzbl (%edx),%edx
  8011f0:	29 d0                	sub    %edx,%eax
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
}
  8011f2:	5d                   	pop    %ebp
  8011f3:	c3                   	ret    

008011f4 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  8011f4:	55                   	push   %ebp
  8011f5:	89 e5                	mov    %esp,%ebp
  8011f7:	53                   	push   %ebx
  8011f8:	8b 55 08             	mov    0x8(%ebp),%edx
  8011fb:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8011fe:	8b 45 10             	mov    0x10(%ebp),%eax
	while (n > 0 && *p && *p == *q)
  801201:	85 c0                	test   %eax,%eax
  801203:	74 23                	je     801228 <strncmp+0x34>
  801205:	0f b6 1a             	movzbl (%edx),%ebx
  801208:	84 db                	test   %bl,%bl
  80120a:	74 25                	je     801231 <strncmp+0x3d>
  80120c:	3a 19                	cmp    (%ecx),%bl
  80120e:	75 21                	jne    801231 <strncmp+0x3d>
  801210:	83 e8 01             	sub    $0x1,%eax
  801213:	74 13                	je     801228 <strncmp+0x34>
		n--, p++, q++;
  801215:	83 c2 01             	add    $0x1,%edx
  801218:	83 c1 01             	add    $0x1,%ecx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80121b:	0f b6 1a             	movzbl (%edx),%ebx
  80121e:	84 db                	test   %bl,%bl
  801220:	74 0f                	je     801231 <strncmp+0x3d>
  801222:	3a 19                	cmp    (%ecx),%bl
  801224:	74 ea                	je     801210 <strncmp+0x1c>
  801226:	eb 09                	jmp    801231 <strncmp+0x3d>
  801228:	b8 00 00 00 00       	mov    $0x0,%eax
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80122d:	5b                   	pop    %ebx
  80122e:	5d                   	pop    %ebp
  80122f:	90                   	nop
  801230:	c3                   	ret    
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  801231:	0f b6 02             	movzbl (%edx),%eax
  801234:	0f b6 11             	movzbl (%ecx),%edx
  801237:	29 d0                	sub    %edx,%eax
  801239:	eb f2                	jmp    80122d <strncmp+0x39>

0080123b <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80123b:	55                   	push   %ebp
  80123c:	89 e5                	mov    %esp,%ebp
  80123e:	8b 45 08             	mov    0x8(%ebp),%eax
  801241:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801245:	0f b6 10             	movzbl (%eax),%edx
  801248:	84 d2                	test   %dl,%dl
  80124a:	74 18                	je     801264 <strchr+0x29>
		if (*s == c)
  80124c:	38 ca                	cmp    %cl,%dl
  80124e:	75 0a                	jne    80125a <strchr+0x1f>
  801250:	eb 17                	jmp    801269 <strchr+0x2e>
  801252:	38 ca                	cmp    %cl,%dl
  801254:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  801258:	74 0f                	je     801269 <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80125a:	83 c0 01             	add    $0x1,%eax
  80125d:	0f b6 10             	movzbl (%eax),%edx
  801260:	84 d2                	test   %dl,%dl
  801262:	75 ee                	jne    801252 <strchr+0x17>
  801264:	b8 00 00 00 00       	mov    $0x0,%eax
		if (*s == c)
			return (char *) s;
	return 0;
}
  801269:	5d                   	pop    %ebp
  80126a:	c3                   	ret    

0080126b <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80126b:	55                   	push   %ebp
  80126c:	89 e5                	mov    %esp,%ebp
  80126e:	8b 45 08             	mov    0x8(%ebp),%eax
  801271:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801275:	0f b6 10             	movzbl (%eax),%edx
  801278:	84 d2                	test   %dl,%dl
  80127a:	74 18                	je     801294 <strfind+0x29>
		if (*s == c)
  80127c:	38 ca                	cmp    %cl,%dl
  80127e:	75 0a                	jne    80128a <strfind+0x1f>
  801280:	eb 12                	jmp    801294 <strfind+0x29>
  801282:	38 ca                	cmp    %cl,%dl
  801284:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  801288:	74 0a                	je     801294 <strfind+0x29>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80128a:	83 c0 01             	add    $0x1,%eax
  80128d:	0f b6 10             	movzbl (%eax),%edx
  801290:	84 d2                	test   %dl,%dl
  801292:	75 ee                	jne    801282 <strfind+0x17>
		if (*s == c)
			break;
	return (char *) s;
}
  801294:	5d                   	pop    %ebp
  801295:	c3                   	ret    

00801296 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  801296:	55                   	push   %ebp
  801297:	89 e5                	mov    %esp,%ebp
  801299:	83 ec 0c             	sub    $0xc,%esp
  80129c:	89 1c 24             	mov    %ebx,(%esp)
  80129f:	89 74 24 04          	mov    %esi,0x4(%esp)
  8012a3:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8012a7:	8b 7d 08             	mov    0x8(%ebp),%edi
  8012aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8012ad:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  8012b0:	85 c9                	test   %ecx,%ecx
  8012b2:	74 30                	je     8012e4 <memset+0x4e>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  8012b4:	f7 c7 03 00 00 00    	test   $0x3,%edi
  8012ba:	75 25                	jne    8012e1 <memset+0x4b>
  8012bc:	f6 c1 03             	test   $0x3,%cl
  8012bf:	75 20                	jne    8012e1 <memset+0x4b>
		c &= 0xFF;
  8012c1:	0f b6 d0             	movzbl %al,%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  8012c4:	89 d3                	mov    %edx,%ebx
  8012c6:	c1 e3 08             	shl    $0x8,%ebx
  8012c9:	89 d6                	mov    %edx,%esi
  8012cb:	c1 e6 18             	shl    $0x18,%esi
  8012ce:	89 d0                	mov    %edx,%eax
  8012d0:	c1 e0 10             	shl    $0x10,%eax
  8012d3:	09 f0                	or     %esi,%eax
  8012d5:	09 d0                	or     %edx,%eax
		asm volatile("cld; rep stosl\n"
  8012d7:	09 d8                	or     %ebx,%eax
  8012d9:	c1 e9 02             	shr    $0x2,%ecx
  8012dc:	fc                   	cld    
  8012dd:	f3 ab                	rep stos %eax,%es:(%edi)
{
	char *p;

	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  8012df:	eb 03                	jmp    8012e4 <memset+0x4e>
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8012e1:	fc                   	cld    
  8012e2:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  8012e4:	89 f8                	mov    %edi,%eax
  8012e6:	8b 1c 24             	mov    (%esp),%ebx
  8012e9:	8b 74 24 04          	mov    0x4(%esp),%esi
  8012ed:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8012f1:	89 ec                	mov    %ebp,%esp
  8012f3:	5d                   	pop    %ebp
  8012f4:	c3                   	ret    

008012f5 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8012f5:	55                   	push   %ebp
  8012f6:	89 e5                	mov    %esp,%ebp
  8012f8:	83 ec 08             	sub    $0x8,%esp
  8012fb:	89 34 24             	mov    %esi,(%esp)
  8012fe:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801302:	8b 45 08             	mov    0x8(%ebp),%eax
  801305:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;
	
	s = src;
  801308:	8b 75 0c             	mov    0xc(%ebp),%esi
	d = dst;
  80130b:	89 c7                	mov    %eax,%edi
	if (s < d && s + n > d) {
  80130d:	39 c6                	cmp    %eax,%esi
  80130f:	73 35                	jae    801346 <memmove+0x51>
  801311:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  801314:	39 d0                	cmp    %edx,%eax
  801316:	73 2e                	jae    801346 <memmove+0x51>
		s += n;
		d += n;
  801318:	01 cf                	add    %ecx,%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80131a:	f6 c2 03             	test   $0x3,%dl
  80131d:	75 1b                	jne    80133a <memmove+0x45>
  80131f:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801325:	75 13                	jne    80133a <memmove+0x45>
  801327:	f6 c1 03             	test   $0x3,%cl
  80132a:	75 0e                	jne    80133a <memmove+0x45>
			asm volatile("std; rep movsl\n"
  80132c:	83 ef 04             	sub    $0x4,%edi
  80132f:	8d 72 fc             	lea    -0x4(%edx),%esi
  801332:	c1 e9 02             	shr    $0x2,%ecx
  801335:	fd                   	std    
  801336:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801338:	eb 09                	jmp    801343 <memmove+0x4e>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80133a:	83 ef 01             	sub    $0x1,%edi
  80133d:	8d 72 ff             	lea    -0x1(%edx),%esi
  801340:	fd                   	std    
  801341:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  801343:	fc                   	cld    
	const char *s;
	char *d;
	
	s = src;
	d = dst;
	if (s < d && s + n > d) {
  801344:	eb 20                	jmp    801366 <memmove+0x71>
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801346:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80134c:	75 15                	jne    801363 <memmove+0x6e>
  80134e:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801354:	75 0d                	jne    801363 <memmove+0x6e>
  801356:	f6 c1 03             	test   $0x3,%cl
  801359:	75 08                	jne    801363 <memmove+0x6e>
			asm volatile("cld; rep movsl\n"
  80135b:	c1 e9 02             	shr    $0x2,%ecx
  80135e:	fc                   	cld    
  80135f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801361:	eb 03                	jmp    801366 <memmove+0x71>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  801363:	fc                   	cld    
  801364:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  801366:	8b 34 24             	mov    (%esp),%esi
  801369:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80136d:	89 ec                	mov    %ebp,%esp
  80136f:	5d                   	pop    %ebp
  801370:	c3                   	ret    

00801371 <memcpy>:

/* sigh - gcc emits references to this for structure assignments! */
/* it is *not* prototyped in inc/string.h - do not use directly. */
void *
memcpy(void *dst, void *src, size_t n)
{
  801371:	55                   	push   %ebp
  801372:	89 e5                	mov    %esp,%ebp
  801374:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  801377:	8b 45 10             	mov    0x10(%ebp),%eax
  80137a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80137e:	8b 45 0c             	mov    0xc(%ebp),%eax
  801381:	89 44 24 04          	mov    %eax,0x4(%esp)
  801385:	8b 45 08             	mov    0x8(%ebp),%eax
  801388:	89 04 24             	mov    %eax,(%esp)
  80138b:	e8 65 ff ff ff       	call   8012f5 <memmove>
}
  801390:	c9                   	leave  
  801391:	c3                   	ret    

00801392 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  801392:	55                   	push   %ebp
  801393:	89 e5                	mov    %esp,%ebp
  801395:	57                   	push   %edi
  801396:	56                   	push   %esi
  801397:	53                   	push   %ebx
  801398:	8b 75 08             	mov    0x8(%ebp),%esi
  80139b:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80139e:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8013a1:	85 c9                	test   %ecx,%ecx
  8013a3:	74 36                	je     8013db <memcmp+0x49>
		if (*s1 != *s2)
  8013a5:	0f b6 06             	movzbl (%esi),%eax
  8013a8:	0f b6 1f             	movzbl (%edi),%ebx
  8013ab:	38 d8                	cmp    %bl,%al
  8013ad:	74 20                	je     8013cf <memcmp+0x3d>
  8013af:	eb 14                	jmp    8013c5 <memcmp+0x33>
  8013b1:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  8013b6:	0f b6 5c 17 01       	movzbl 0x1(%edi,%edx,1),%ebx
  8013bb:	83 c2 01             	add    $0x1,%edx
  8013be:	83 e9 01             	sub    $0x1,%ecx
  8013c1:	38 d8                	cmp    %bl,%al
  8013c3:	74 12                	je     8013d7 <memcmp+0x45>
			return (int) *s1 - (int) *s2;
  8013c5:	0f b6 c0             	movzbl %al,%eax
  8013c8:	0f b6 db             	movzbl %bl,%ebx
  8013cb:	29 d8                	sub    %ebx,%eax
  8013cd:	eb 11                	jmp    8013e0 <memcmp+0x4e>
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8013cf:	83 e9 01             	sub    $0x1,%ecx
  8013d2:	ba 00 00 00 00       	mov    $0x0,%edx
  8013d7:	85 c9                	test   %ecx,%ecx
  8013d9:	75 d6                	jne    8013b1 <memcmp+0x1f>
  8013db:	b8 00 00 00 00       	mov    $0x0,%eax
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
}
  8013e0:	5b                   	pop    %ebx
  8013e1:	5e                   	pop    %esi
  8013e2:	5f                   	pop    %edi
  8013e3:	5d                   	pop    %ebp
  8013e4:	c3                   	ret    

008013e5 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8013e5:	55                   	push   %ebp
  8013e6:	89 e5                	mov    %esp,%ebp
  8013e8:	8b 45 08             	mov    0x8(%ebp),%eax
	const void *ends = (const char *) s + n;
  8013eb:	89 c2                	mov    %eax,%edx
  8013ed:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  8013f0:	39 d0                	cmp    %edx,%eax
  8013f2:	73 15                	jae    801409 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
  8013f4:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
  8013f8:	38 08                	cmp    %cl,(%eax)
  8013fa:	75 06                	jne    801402 <memfind+0x1d>
  8013fc:	eb 0b                	jmp    801409 <memfind+0x24>
  8013fe:	38 08                	cmp    %cl,(%eax)
  801400:	74 07                	je     801409 <memfind+0x24>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  801402:	83 c0 01             	add    $0x1,%eax
  801405:	39 c2                	cmp    %eax,%edx
  801407:	77 f5                	ja     8013fe <memfind+0x19>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  801409:	5d                   	pop    %ebp
  80140a:	c3                   	ret    

0080140b <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80140b:	55                   	push   %ebp
  80140c:	89 e5                	mov    %esp,%ebp
  80140e:	57                   	push   %edi
  80140f:	56                   	push   %esi
  801410:	53                   	push   %ebx
  801411:	83 ec 04             	sub    $0x4,%esp
  801414:	8b 55 08             	mov    0x8(%ebp),%edx
  801417:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80141a:	0f b6 02             	movzbl (%edx),%eax
  80141d:	3c 20                	cmp    $0x20,%al
  80141f:	74 04                	je     801425 <strtol+0x1a>
  801421:	3c 09                	cmp    $0x9,%al
  801423:	75 0e                	jne    801433 <strtol+0x28>
		s++;
  801425:	83 c2 01             	add    $0x1,%edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  801428:	0f b6 02             	movzbl (%edx),%eax
  80142b:	3c 20                	cmp    $0x20,%al
  80142d:	74 f6                	je     801425 <strtol+0x1a>
  80142f:	3c 09                	cmp    $0x9,%al
  801431:	74 f2                	je     801425 <strtol+0x1a>
		s++;

	// plus/minus sign
	if (*s == '+')
  801433:	3c 2b                	cmp    $0x2b,%al
  801435:	75 0c                	jne    801443 <strtol+0x38>
		s++;
  801437:	83 c2 01             	add    $0x1,%edx
  80143a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  801441:	eb 15                	jmp    801458 <strtol+0x4d>
	else if (*s == '-')
  801443:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  80144a:	3c 2d                	cmp    $0x2d,%al
  80144c:	75 0a                	jne    801458 <strtol+0x4d>
		s++, neg = 1;
  80144e:	83 c2 01             	add    $0x1,%edx
  801451:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  801458:	85 db                	test   %ebx,%ebx
  80145a:	0f 94 c0             	sete   %al
  80145d:	74 05                	je     801464 <strtol+0x59>
  80145f:	83 fb 10             	cmp    $0x10,%ebx
  801462:	75 18                	jne    80147c <strtol+0x71>
  801464:	80 3a 30             	cmpb   $0x30,(%edx)
  801467:	75 13                	jne    80147c <strtol+0x71>
  801469:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80146d:	8d 76 00             	lea    0x0(%esi),%esi
  801470:	75 0a                	jne    80147c <strtol+0x71>
		s += 2, base = 16;
  801472:	83 c2 02             	add    $0x2,%edx
  801475:	bb 10 00 00 00       	mov    $0x10,%ebx
		s++;
	else if (*s == '-')
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80147a:	eb 15                	jmp    801491 <strtol+0x86>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80147c:	84 c0                	test   %al,%al
  80147e:	66 90                	xchg   %ax,%ax
  801480:	74 0f                	je     801491 <strtol+0x86>
  801482:	bb 0a 00 00 00       	mov    $0xa,%ebx
  801487:	80 3a 30             	cmpb   $0x30,(%edx)
  80148a:	75 05                	jne    801491 <strtol+0x86>
		s++, base = 8;
  80148c:	83 c2 01             	add    $0x1,%edx
  80148f:	b3 08                	mov    $0x8,%bl
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  801491:	b8 00 00 00 00       	mov    $0x0,%eax
  801496:	89 de                	mov    %ebx,%esi

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  801498:	0f b6 0a             	movzbl (%edx),%ecx
  80149b:	89 cf                	mov    %ecx,%edi
  80149d:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  8014a0:	80 fb 09             	cmp    $0x9,%bl
  8014a3:	77 08                	ja     8014ad <strtol+0xa2>
			dig = *s - '0';
  8014a5:	0f be c9             	movsbl %cl,%ecx
  8014a8:	83 e9 30             	sub    $0x30,%ecx
  8014ab:	eb 1e                	jmp    8014cb <strtol+0xc0>
		else if (*s >= 'a' && *s <= 'z')
  8014ad:	8d 5f 9f             	lea    -0x61(%edi),%ebx
  8014b0:	80 fb 19             	cmp    $0x19,%bl
  8014b3:	77 08                	ja     8014bd <strtol+0xb2>
			dig = *s - 'a' + 10;
  8014b5:	0f be c9             	movsbl %cl,%ecx
  8014b8:	83 e9 57             	sub    $0x57,%ecx
  8014bb:	eb 0e                	jmp    8014cb <strtol+0xc0>
		else if (*s >= 'A' && *s <= 'Z')
  8014bd:	8d 5f bf             	lea    -0x41(%edi),%ebx
  8014c0:	80 fb 19             	cmp    $0x19,%bl
  8014c3:	77 15                	ja     8014da <strtol+0xcf>
			dig = *s - 'A' + 10;
  8014c5:	0f be c9             	movsbl %cl,%ecx
  8014c8:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  8014cb:	39 f1                	cmp    %esi,%ecx
  8014cd:	7d 0b                	jge    8014da <strtol+0xcf>
			break;
		s++, val = (val * base) + dig;
  8014cf:	83 c2 01             	add    $0x1,%edx
  8014d2:	0f af c6             	imul   %esi,%eax
  8014d5:	8d 04 01             	lea    (%ecx,%eax,1),%eax
		// we don't properly detect overflow!
	}
  8014d8:	eb be                	jmp    801498 <strtol+0x8d>
  8014da:	89 c1                	mov    %eax,%ecx

	if (endptr)
  8014dc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8014e0:	74 05                	je     8014e7 <strtol+0xdc>
		*endptr = (char *) s;
  8014e2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8014e5:	89 13                	mov    %edx,(%ebx)
	return (neg ? -val : val);
  8014e7:	89 ca                	mov    %ecx,%edx
  8014e9:	f7 da                	neg    %edx
  8014eb:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  8014ef:	0f 45 c2             	cmovne %edx,%eax
}
  8014f2:	83 c4 04             	add    $0x4,%esp
  8014f5:	5b                   	pop    %ebx
  8014f6:	5e                   	pop    %esi
  8014f7:	5f                   	pop    %edi
  8014f8:	5d                   	pop    %ebp
  8014f9:	c3                   	ret    
	...

008014fc <syscall>:
#include <inc/syscall.h>
#include <inc/lib.h>

static int32_t
syscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)
{
  8014fc:	55                   	push   %ebp
  8014fd:	89 e5                	mov    %esp,%ebp
  8014ff:	83 ec 48             	sub    $0x48,%esp
  801502:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801505:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801508:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80150b:	89 c6                	mov    %eax,%esi
  80150d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  801510:	89 ca                	mov    %ecx,%edx
	int32_t ret;
	asm volatile("pushl %%ecx\n\t"
  801512:	8b 7d 10             	mov    0x10(%ebp),%edi
  801515:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801518:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80151b:	51                   	push   %ecx
  80151c:	52                   	push   %edx
  80151d:	53                   	push   %ebx
  80151e:	54                   	push   %esp
  80151f:	55                   	push   %ebp
  801520:	56                   	push   %esi
  801521:	57                   	push   %edi
  801522:	89 e5                	mov    %esp,%ebp
  801524:	8d 35 2c 15 80 00    	lea    0x80152c,%esi
  80152a:	0f 34                	sysenter 

0080152c <.after_sysenter_label>:
  80152c:	5f                   	pop    %edi
  80152d:	5e                   	pop    %esi
  80152e:	5d                   	pop    %ebp
  80152f:	5c                   	pop    %esp
  801530:	5b                   	pop    %ebx
  801531:	5a                   	pop    %edx
  801532:	59                   	pop    %ecx
  801533:	89 c2                	mov    %eax,%edx
                   "b" (a3),
                   "D" (a4)
                 : "cc", "memory");


	if(check && ret > 0)
  801535:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  801539:	74 28                	je     801563 <.after_sysenter_label+0x37>
  80153b:	85 c0                	test   %eax,%eax
  80153d:	7e 24                	jle    801563 <.after_sysenter_label+0x37>
		panic("syscall %d returned %d (> 0)", num, ret);
  80153f:	89 44 24 10          	mov    %eax,0x10(%esp)
  801543:	89 74 24 0c          	mov    %esi,0xc(%esp)
  801547:	c7 44 24 08 60 25 81 	movl   $0x812560,0x8(%esp)
  80154e:	00 
  80154f:	c7 44 24 04 2b 00 00 	movl   $0x2b,0x4(%esp)
  801556:	00 
  801557:	c7 04 24 7d 25 81 00 	movl   $0x81257d,(%esp)
  80155e:	e8 b1 f3 ff ff       	call   800914 <_panic>

	return ret;
}
  801563:	89 d0                	mov    %edx,%eax
  801565:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801568:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80156b:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80156e:	89 ec                	mov    %ebp,%esp
  801570:	5d                   	pop    %ebp
  801571:	c3                   	ret    

00801572 <sys_net_try_send>:
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}

int
sys_net_try_send(void *data, size_t len)
{
  801572:	55                   	push   %ebp
  801573:	89 e5                	mov    %esp,%ebp
  801575:	83 ec 18             	sub    $0x18,%esp
  return syscall(SYS_net_try_send, 0, (uint32_t)data, len, 0, 0, 0);
  801578:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80157f:	00 
  801580:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801587:	00 
  801588:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80158f:	00 
  801590:	8b 45 0c             	mov    0xc(%ebp),%eax
  801593:	89 04 24             	mov    %eax,(%esp)
  801596:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801599:	ba 00 00 00 00       	mov    $0x0,%edx
  80159e:	b8 10 00 00 00       	mov    $0x10,%eax
  8015a3:	e8 54 ff ff ff       	call   8014fc <syscall>
}
  8015a8:	c9                   	leave  
  8015a9:	c3                   	ret    

008015aa <sys_time_msec>:
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}

unsigned int
sys_time_msec(void)
{
  8015aa:	55                   	push   %ebp
  8015ab:	89 e5                	mov    %esp,%ebp
  8015ad:	83 ec 18             	sub    $0x18,%esp
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
  8015b0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8015b7:	00 
  8015b8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8015bf:	00 
  8015c0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8015c7:	00 
  8015c8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8015cf:	b9 00 00 00 00       	mov    $0x0,%ecx
  8015d4:	ba 00 00 00 00       	mov    $0x0,%edx
  8015d9:	b8 0f 00 00 00       	mov    $0xf,%eax
  8015de:	e8 19 ff ff ff       	call   8014fc <syscall>
}
  8015e3:	c9                   	leave  
  8015e4:	c3                   	ret    

008015e5 <sys_ipc_recv>:
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}

int
sys_ipc_recv(void *dstva)
{
  8015e5:	55                   	push   %ebp
  8015e6:	89 e5                	mov    %esp,%ebp
  8015e8:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
  8015eb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8015f2:	00 
  8015f3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8015fa:	00 
  8015fb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801602:	00 
  801603:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80160a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80160d:	ba 01 00 00 00       	mov    $0x1,%edx
  801612:	b8 0e 00 00 00       	mov    $0xe,%eax
  801617:	e8 e0 fe ff ff       	call   8014fc <syscall>
}
  80161c:	c9                   	leave  
  80161d:	c3                   	ret    

0080161e <sys_ipc_try_send>:
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80161e:	55                   	push   %ebp
  80161f:	89 e5                	mov    %esp,%ebp
  801621:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
  801624:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80162b:	00 
  80162c:	8b 45 14             	mov    0x14(%ebp),%eax
  80162f:	89 44 24 08          	mov    %eax,0x8(%esp)
  801633:	8b 45 10             	mov    0x10(%ebp),%eax
  801636:	89 44 24 04          	mov    %eax,0x4(%esp)
  80163a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80163d:	89 04 24             	mov    %eax,(%esp)
  801640:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801643:	ba 00 00 00 00       	mov    $0x0,%edx
  801648:	b8 0d 00 00 00       	mov    $0xd,%eax
  80164d:	e8 aa fe ff ff       	call   8014fc <syscall>
}
  801652:	c9                   	leave  
  801653:	c3                   	ret    

00801654 <sys_env_set_pgfault_upcall>:
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  801654:	55                   	push   %ebp
  801655:	89 e5                	mov    %esp,%ebp
  801657:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
  80165a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801661:	00 
  801662:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801669:	00 
  80166a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801671:	00 
  801672:	8b 45 0c             	mov    0xc(%ebp),%eax
  801675:	89 04 24             	mov    %eax,(%esp)
  801678:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80167b:	ba 01 00 00 00       	mov    $0x1,%edx
  801680:	b8 0b 00 00 00       	mov    $0xb,%eax
  801685:	e8 72 fe ff ff       	call   8014fc <syscall>
}
  80168a:	c9                   	leave  
  80168b:	c3                   	ret    

0080168c <sys_env_set_trapframe>:
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80168c:	55                   	push   %ebp
  80168d:	89 e5                	mov    %esp,%ebp
  80168f:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
  801692:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801699:	00 
  80169a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8016a1:	00 
  8016a2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8016a9:	00 
  8016aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8016ad:	89 04 24             	mov    %eax,(%esp)
  8016b0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8016b3:	ba 01 00 00 00       	mov    $0x1,%edx
  8016b8:	b8 0a 00 00 00       	mov    $0xa,%eax
  8016bd:	e8 3a fe ff ff       	call   8014fc <syscall>
}
  8016c2:	c9                   	leave  
  8016c3:	c3                   	ret    

008016c4 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  8016c4:	55                   	push   %ebp
  8016c5:	89 e5                	mov    %esp,%ebp
  8016c7:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
  8016ca:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8016d1:	00 
  8016d2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8016d9:	00 
  8016da:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8016e1:	00 
  8016e2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8016e5:	89 04 24             	mov    %eax,(%esp)
  8016e8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8016eb:	ba 01 00 00 00       	mov    $0x1,%edx
  8016f0:	b8 09 00 00 00       	mov    $0x9,%eax
  8016f5:	e8 02 fe ff ff       	call   8014fc <syscall>
}
  8016fa:	c9                   	leave  
  8016fb:	c3                   	ret    

008016fc <sys_page_unmap>:
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva | perm, 0);
}

int
sys_page_unmap(envid_t envid, void *va)
{
  8016fc:	55                   	push   %ebp
  8016fd:	89 e5                	mov    %esp,%ebp
  8016ff:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
  801702:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801709:	00 
  80170a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801711:	00 
  801712:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801719:	00 
  80171a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80171d:	89 04 24             	mov    %eax,(%esp)
  801720:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801723:	ba 01 00 00 00       	mov    $0x1,%edx
  801728:	b8 07 00 00 00       	mov    $0x7,%eax
  80172d:	e8 ca fd ff ff       	call   8014fc <syscall>
}
  801732:	c9                   	leave  
  801733:	c3                   	ret    

00801734 <sys_page_map>:
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  801734:	55                   	push   %ebp
  801735:	89 e5                	mov    %esp,%ebp
  801737:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva | perm, 0);
  80173a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801741:	00 
  801742:	8b 45 18             	mov    0x18(%ebp),%eax
  801745:	0b 45 14             	or     0x14(%ebp),%eax
  801748:	89 44 24 08          	mov    %eax,0x8(%esp)
  80174c:	8b 45 10             	mov    0x10(%ebp),%eax
  80174f:	89 44 24 04          	mov    %eax,0x4(%esp)
  801753:	8b 45 0c             	mov    0xc(%ebp),%eax
  801756:	89 04 24             	mov    %eax,(%esp)
  801759:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80175c:	ba 01 00 00 00       	mov    $0x1,%edx
  801761:	b8 06 00 00 00       	mov    $0x6,%eax
  801766:	e8 91 fd ff ff       	call   8014fc <syscall>
}
  80176b:	c9                   	leave  
  80176c:	c3                   	ret    

0080176d <sys_page_alloc>:
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80176d:	55                   	push   %ebp
  80176e:	89 e5                	mov    %esp,%ebp
  801770:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
  801773:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80177a:	00 
  80177b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801782:	00 
  801783:	8b 45 10             	mov    0x10(%ebp),%eax
  801786:	89 44 24 04          	mov    %eax,0x4(%esp)
  80178a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80178d:	89 04 24             	mov    %eax,(%esp)
  801790:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801793:	ba 01 00 00 00       	mov    $0x1,%edx
  801798:	b8 05 00 00 00       	mov    $0x5,%eax
  80179d:	e8 5a fd ff ff       	call   8014fc <syscall>
}
  8017a2:	c9                   	leave  
  8017a3:	c3                   	ret    

008017a4 <sys_yield>:
	 return syscall(SYS_map_kernel_page, 0, (uint32_t)kpage, (uint32_t)va, 0, 0, 0);
}

void
sys_yield(void)
{
  8017a4:	55                   	push   %ebp
  8017a5:	89 e5                	mov    %esp,%ebp
  8017a7:	83 ec 18             	sub    $0x18,%esp
	//cprintf("%s:sys_yield[%d]: [%x] calling sys_yield\n", __FILE__, __LINE__, thisenv->env_id);
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
  8017aa:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8017b1:	00 
  8017b2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8017b9:	00 
  8017ba:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8017c1:	00 
  8017c2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8017c9:	b9 00 00 00 00       	mov    $0x0,%ecx
  8017ce:	ba 00 00 00 00       	mov    $0x0,%edx
  8017d3:	b8 0c 00 00 00       	mov    $0xc,%eax
  8017d8:	e8 1f fd ff ff       	call   8014fc <syscall>
}
  8017dd:	c9                   	leave  
  8017de:	c3                   	ret    

008017df <sys_map_kernel_page>:
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}

int
sys_map_kernel_page(void* kpage, void* va)
{
  8017df:	55                   	push   %ebp
  8017e0:	89 e5                	mov    %esp,%ebp
  8017e2:	83 ec 18             	sub    $0x18,%esp
	 return syscall(SYS_map_kernel_page, 0, (uint32_t)kpage, (uint32_t)va, 0, 0, 0);
  8017e5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8017ec:	00 
  8017ed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8017f4:	00 
  8017f5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8017fc:	00 
  8017fd:	8b 45 0c             	mov    0xc(%ebp),%eax
  801800:	89 04 24             	mov    %eax,(%esp)
  801803:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801806:	ba 00 00 00 00       	mov    $0x0,%edx
  80180b:	b8 04 00 00 00       	mov    $0x4,%eax
  801810:	e8 e7 fc ff ff       	call   8014fc <syscall>
}
  801815:	c9                   	leave  
  801816:	c3                   	ret    

00801817 <sys_getenvid>:
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}

envid_t
sys_getenvid(void)
{
  801817:	55                   	push   %ebp
  801818:	89 e5                	mov    %esp,%ebp
  80181a:	83 ec 18             	sub    $0x18,%esp
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
  80181d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801824:	00 
  801825:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80182c:	00 
  80182d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801834:	00 
  801835:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80183c:	b9 00 00 00 00       	mov    $0x0,%ecx
  801841:	ba 00 00 00 00       	mov    $0x0,%edx
  801846:	b8 02 00 00 00       	mov    $0x2,%eax
  80184b:	e8 ac fc ff ff       	call   8014fc <syscall>
}
  801850:	c9                   	leave  
  801851:	c3                   	ret    

00801852 <sys_env_destroy>:
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}

int
sys_env_destroy(envid_t envid)
{
  801852:	55                   	push   %ebp
  801853:	89 e5                	mov    %esp,%ebp
  801855:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
  801858:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80185f:	00 
  801860:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801867:	00 
  801868:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80186f:	00 
  801870:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801877:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80187a:	ba 01 00 00 00       	mov    $0x1,%edx
  80187f:	b8 03 00 00 00       	mov    $0x3,%eax
  801884:	e8 73 fc ff ff       	call   8014fc <syscall>
}
  801889:	c9                   	leave  
  80188a:	c3                   	ret    

0080188b <sys_cgetc>:
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}

int
sys_cgetc(void)
{
  80188b:	55                   	push   %ebp
  80188c:	89 e5                	mov    %esp,%ebp
  80188e:	83 ec 18             	sub    $0x18,%esp
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
  801891:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801898:	00 
  801899:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8018a0:	00 
  8018a1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8018a8:	00 
  8018a9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8018b0:	b9 00 00 00 00       	mov    $0x0,%ecx
  8018b5:	ba 00 00 00 00       	mov    $0x0,%edx
  8018ba:	b8 01 00 00 00       	mov    $0x1,%eax
  8018bf:	e8 38 fc ff ff       	call   8014fc <syscall>
}
  8018c4:	c9                   	leave  
  8018c5:	c3                   	ret    

008018c6 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  8018c6:	55                   	push   %ebp
  8018c7:	89 e5                	mov    %esp,%ebp
  8018c9:	83 ec 18             	sub    $0x18,%esp
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
  8018cc:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8018d3:	00 
  8018d4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8018db:	00 
  8018dc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8018e3:	00 
  8018e4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8018e7:	89 04 24             	mov    %eax,(%esp)
  8018ea:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8018ed:	ba 00 00 00 00       	mov    $0x0,%edx
  8018f2:	b8 00 00 00 00       	mov    $0x0,%eax
  8018f7:	e8 00 fc ff ff       	call   8014fc <syscall>
}
  8018fc:	c9                   	leave  
  8018fd:	c3                   	ret    
	...

00801900 <sfork>:
}

// Challenge!
int
sfork(void)
{
  801900:	55                   	push   %ebp
  801901:	89 e5                	mov    %esp,%ebp
  801903:	83 ec 18             	sub    $0x18,%esp
	panic("sfork not implemented");
  801906:	c7 44 24 08 8b 25 81 	movl   $0x81258b,0x8(%esp)
  80190d:	00 
  80190e:	c7 44 24 04 a4 00 00 	movl   $0xa4,0x4(%esp)
  801915:	00 
  801916:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  80191d:	e8 f2 ef ff ff       	call   800914 <_panic>

00801922 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  801922:	55                   	push   %ebp
  801923:	89 e5                	mov    %esp,%ebp
  801925:	57                   	push   %edi
  801926:	56                   	push   %esi
  801927:	53                   	push   %ebx
  801928:	83 ec 3c             	sub    $0x3c,%esp
	envid_t envidnum;
	uint32_t addr;
	int r;
	extern void _pgfault_upcall(void);
	
	set_pgfault_handler(pgfault);
  80192b:	c7 04 24 e6 1b 80 00 	movl   $0x801be6,(%esp)
  801932:	e8 15 16 00 00       	call   802f4c <set_pgfault_handler>
static __inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	//if I push esp it will be a pagefault.I come across a bug here.
	__asm __volatile(  
  801937:	ba 08 00 00 00       	mov    $0x8,%edx
  80193c:	89 d0                	mov    %edx,%eax
  80193e:	51                   	push   %ecx
  80193f:	52                   	push   %edx
  801940:	53                   	push   %ebx
  801941:	55                   	push   %ebp
  801942:	56                   	push   %esi
  801943:	57                   	push   %edi
  801944:	89 e5                	mov    %esp,%ebp
  801946:	8d 35 4e 19 80 00    	lea    0x80194e,%esi
  80194c:	0f 34                	sysenter 

0080194e <.after_sysenter_label>:
  80194e:	5f                   	pop    %edi
  80194f:	5e                   	pop    %esi
  801950:	5d                   	pop    %ebp
  801951:	5b                   	pop    %ebx
  801952:	5a                   	pop    %edx
  801953:	59                   	pop    %ecx
  801954:	89 45 e0             	mov    %eax,-0x20(%ebp)
	
	envidnum = sys_exofork();
	cprintf("%s:fork[%d]: sys_exofork() return %x\n",__FILE__, __LINE__, envidnum);
  801957:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80195b:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  801962:	00 
  801963:	c7 44 24 04 a1 25 81 	movl   $0x8125a1,0x4(%esp)
  80196a:	00 
  80196b:	c7 04 24 e8 25 81 00 	movl   $0x8125e8,(%esp)
  801972:	e8 56 f0 ff ff       	call   8009cd <cprintf>
	if (envidnum < 0)
  801977:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80197b:	79 23                	jns    8019a0 <.after_sysenter_label+0x52>
		panic("sys_exofork: %e", envidnum);
  80197d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801980:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801984:	c7 44 24 08 ac 25 81 	movl   $0x8125ac,0x8(%esp)
  80198b:	00 
  80198c:	c7 44 24 04 82 00 00 	movl   $0x82,0x4(%esp)
  801993:	00 
  801994:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  80199b:	e8 74 ef ff ff       	call   800914 <_panic>
	// We’re the child
	if (envidnum == 0) {
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
  8019a0:	bb 00 00 80 00       	mov    $0x800000,%ebx
	}
	// We’re the parent.
	for (addr =  UTEXT; addr < UXSTACKTOP - PGSIZE; addr += PGSIZE) 
	{
		if(	(vpd[PDX(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_U) > 0)
  8019a5:	be 00 d0 7b ef       	mov    $0xef7bd000,%esi
  8019aa:	bf 00 00 40 ef       	mov    $0xef400000,%edi
	envidnum = sys_exofork();
	cprintf("%s:fork[%d]: sys_exofork() return %x\n",__FILE__, __LINE__, envidnum);
	if (envidnum < 0)
		panic("sys_exofork: %e", envidnum);
	// We’re the child
	if (envidnum == 0) {
  8019af:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8019b3:	75 1c                	jne    8019d1 <.after_sysenter_label+0x83>
		thisenv = &envs[ENVX(sys_getenvid())];
  8019b5:	e8 5d fe ff ff       	call   801817 <sys_getenvid>
  8019ba:	25 ff 03 00 00       	and    $0x3ff,%eax
  8019bf:	c1 e0 07             	shl    $0x7,%eax
  8019c2:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  8019c7:	a3 74 c2 b3 00       	mov    %eax,0xb3c274
		return 0;
  8019cc:	e9 0a 02 00 00       	jmp    801bdb <.after_sysenter_label+0x28d>
	}
	// We’re the parent.
	for (addr =  UTEXT; addr < UXSTACKTOP - PGSIZE; addr += PGSIZE) 
	{
		if(	(vpd[PDX(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_U) > 0)
  8019d1:	89 d8                	mov    %ebx,%eax
  8019d3:	c1 e8 16             	shr    $0x16,%eax
  8019d6:	8b 04 86             	mov    (%esi,%eax,4),%eax
  8019d9:	a8 01                	test   $0x1,%al
  8019db:	0f 84 43 01 00 00    	je     801b24 <.after_sysenter_label+0x1d6>
  8019e1:	89 d8                	mov    %ebx,%eax
  8019e3:	c1 e8 0c             	shr    $0xc,%eax
  8019e6:	8b 14 87             	mov    (%edi,%eax,4),%edx
  8019e9:	f6 c2 01             	test   $0x1,%dl
  8019ec:	0f 84 32 01 00 00    	je     801b24 <.after_sysenter_label+0x1d6>
  8019f2:	8b 14 87             	mov    (%edi,%eax,4),%edx
  8019f5:	f6 c2 04             	test   $0x4,%dl
  8019f8:	0f 84 26 01 00 00    	je     801b24 <.after_sysenter_label+0x1d6>
{
	int r;

	// LAB 4: Your code here.
	int perm;
	void * addr = (void *) ((uint32_t) pn * PGSIZE);
  8019fe:	c1 e0 0c             	shl    $0xc,%eax
  801a01:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	pte_t pte = vpt[PGNUM(addr)];
  801a04:	c1 e8 0c             	shr    $0xc,%eax
  801a07:	8b 04 87             	mov    (%edi,%eax,4),%eax
	perm = pte & PTE_SYSCALL;
  801a0a:	89 c2                	mov    %eax,%edx
  801a0c:	81 e2 07 0e 00 00    	and    $0xe07,%edx
	
	if (perm & (PTE_W|PTE_COW)) 
  801a12:	a9 02 08 00 00       	test   $0x802,%eax
  801a17:	0f 84 a0 00 00 00    	je     801abd <.after_sysenter_label+0x16f>
	{
		 perm &= ~PTE_W;
  801a1d:	83 e2 fd             	and    $0xfffffffd,%edx
		 perm |= PTE_COW;
  801a20:	80 ce 08             	or     $0x8,%dh
  801a23:	89 55 dc             	mov    %edx,-0x24(%ebp)
		//map in child
		if ((r = sys_page_map(0, addr, envid, addr, perm)) < 0)
  801a26:	89 54 24 10          	mov    %edx,0x10(%esp)
  801a2a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801a2d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801a31:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801a34:	89 44 24 08          	mov    %eax,0x8(%esp)
  801a38:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801a3b:	89 44 24 04          	mov    %eax,0x4(%esp)
  801a3f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801a46:	e8 e9 fc ff ff       	call   801734 <sys_page_map>
  801a4b:	85 c0                	test   %eax,%eax
  801a4d:	79 20                	jns    801a6f <.after_sysenter_label+0x121>
			panic ("duppage: page re-mapping failed at 1 : %e", r);
  801a4f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801a53:	c7 44 24 08 10 26 81 	movl   $0x812610,0x8(%esp)
  801a5a:	00 
  801a5b:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  801a62:	00 
  801a63:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801a6a:	e8 a5 ee ff ff       	call   800914 <_panic>
		//remap in the parent		
		if ((r = sys_page_map(0, addr, 0, addr, perm)) < 0)
  801a6f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801a72:	89 44 24 10          	mov    %eax,0x10(%esp)
  801a76:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801a79:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801a7d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801a84:	00 
  801a85:	89 44 24 04          	mov    %eax,0x4(%esp)
  801a89:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801a90:	e8 9f fc ff ff       	call   801734 <sys_page_map>
  801a95:	85 c0                	test   %eax,%eax
  801a97:	0f 89 87 00 00 00    	jns    801b24 <.after_sysenter_label+0x1d6>
			panic ("duppage: page re-mapping failed at 2 : %e", r);
  801a9d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801aa1:	c7 44 24 08 3c 26 81 	movl   $0x81263c,0x8(%esp)
  801aa8:	00 
  801aa9:	c7 44 24 04 57 00 00 	movl   $0x57,0x4(%esp)
  801ab0:	00 
  801ab1:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801ab8:	e8 57 ee ff ff       	call   800914 <_panic>
	}
	else //include PTE_SHARE
	{
		cprintf("map two %x----%x\n",envid,addr);
  801abd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801ac0:	89 44 24 08          	mov    %eax,0x8(%esp)
  801ac4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801ac7:	89 44 24 04          	mov    %eax,0x4(%esp)
  801acb:	c7 04 24 bc 25 81 00 	movl   $0x8125bc,(%esp)
  801ad2:	e8 f6 ee ff ff       	call   8009cd <cprintf>
		if ((r = sys_page_map (0, addr, envid, addr, PTE_U|PTE_P)) < 0)
  801ad7:	c7 44 24 10 05 00 00 	movl   $0x5,0x10(%esp)
  801ade:	00 
  801adf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801ae2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801ae6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801ae9:	89 44 24 08          	mov    %eax,0x8(%esp)
  801aed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801af0:	89 44 24 04          	mov    %eax,0x4(%esp)
  801af4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801afb:	e8 34 fc ff ff       	call   801734 <sys_page_map>
  801b00:	85 c0                	test   %eax,%eax
  801b02:	79 20                	jns    801b24 <.after_sysenter_label+0x1d6>
			panic ("duppage: page re-mapping failed at 3 : %e", r);
  801b04:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801b08:	c7 44 24 08 68 26 81 	movl   $0x812668,0x8(%esp)
  801b0f:	00 
  801b10:	c7 44 24 04 5d 00 00 	movl   $0x5d,0x4(%esp)
  801b17:	00 
  801b18:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801b1f:	e8 f0 ed ff ff       	call   800914 <_panic>
	if (envidnum == 0) {
		thisenv = &envs[ENVX(sys_getenvid())];
		return 0;
	}
	// We’re the parent.
	for (addr =  UTEXT; addr < UXSTACKTOP - PGSIZE; addr += PGSIZE) 
  801b24:	81 c3 00 10 00 00    	add    $0x1000,%ebx
  801b2a:	81 fb 00 f0 bf ee    	cmp    $0xeebff000,%ebx
  801b30:	0f 85 9b fe ff ff    	jne    8019d1 <.after_sysenter_label+0x83>
	{
		if(	(vpd[PDX(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_P) > 0 && (vpt[PGNUM(addr)] & PTE_U) > 0)
			duppage(envidnum,PGNUM(addr));
	}
	if ((r = sys_page_alloc (envidnum, (void *)(UXSTACKTOP - PGSIZE), PTE_U|PTE_W|PTE_P)) < 0)
  801b36:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801b3d:	00 
  801b3e:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  801b45:	ee 
  801b46:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801b49:	89 04 24             	mov    %eax,(%esp)
  801b4c:	e8 1c fc ff ff       	call   80176d <sys_page_alloc>
  801b51:	85 c0                	test   %eax,%eax
  801b53:	79 20                	jns    801b75 <.after_sysenter_label+0x227>
		panic ("fork: page allocation failed : %e", r);
  801b55:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801b59:	c7 44 24 08 94 26 81 	movl   $0x812694,0x8(%esp)
  801b60:	00 
  801b61:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  801b68:	00 
  801b69:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801b70:	e8 9f ed ff ff       	call   800914 <_panic>
	//cprintf("%x-----%x\n",&envid,envid);
	sys_env_set_pgfault_upcall (envidnum, _pgfault_upcall);
  801b75:	c7 44 24 04 bc 2f 80 	movl   $0x802fbc,0x4(%esp)
  801b7c:	00 
  801b7d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801b80:	89 04 24             	mov    %eax,(%esp)
  801b83:	e8 cc fa ff ff       	call   801654 <sys_env_set_pgfault_upcall>
	//cprintf("%x-----%x\n",&envid,envid);
	// Start the child environment running
	if((r = sys_env_set_status(envidnum, ENV_RUNNABLE)) < 0)
  801b88:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  801b8f:	00 
  801b90:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801b93:	89 04 24             	mov    %eax,(%esp)
  801b96:	e8 29 fb ff ff       	call   8016c4 <sys_env_set_status>
  801b9b:	85 c0                	test   %eax,%eax
  801b9d:	79 20                	jns    801bbf <.after_sysenter_label+0x271>
		panic("fork: set child env status failed : %e", r);
  801b9f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801ba3:	c7 44 24 08 b8 26 81 	movl   $0x8126b8,0x8(%esp)
  801baa:	00 
  801bab:	c7 44 24 04 95 00 00 	movl   $0x95,0x4(%esp)
  801bb2:	00 
  801bb3:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801bba:	e8 55 ed ff ff       	call   800914 <_panic>
	//cprintf("%x-----%x\n",&envid,envid);
	//cprintf("fork in %x have set %x ,runnable\n",sys_getenvid(),envidnum);
	//cprintf("fork in %x have set %x ,runnable\n",sys_getenvid(),envidnum);
	//cprintf("%x-----%x\n",&envidnum,envidnum);
	cprintf("%s:fork[%d]: fork return\n", __FILE__, __LINE__);
  801bbf:	c7 44 24 08 9a 00 00 	movl   $0x9a,0x8(%esp)
  801bc6:	00 
  801bc7:	c7 44 24 04 a1 25 81 	movl   $0x8125a1,0x4(%esp)
  801bce:	00 
  801bcf:	c7 04 24 ce 25 81 00 	movl   $0x8125ce,(%esp)
  801bd6:	e8 f2 ed ff ff       	call   8009cd <cprintf>
	return envidnum;

	//panic("fork not implemented");
}
  801bdb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801bde:	83 c4 3c             	add    $0x3c,%esp
  801be1:	5b                   	pop    %ebx
  801be2:	5e                   	pop    %esi
  801be3:	5f                   	pop    %edi
  801be4:	5d                   	pop    %ebp
  801be5:	c3                   	ret    

00801be6 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  801be6:	55                   	push   %ebp
  801be7:	89 e5                	mov    %esp,%ebp
  801be9:	53                   	push   %ebx
  801bea:	83 ec 24             	sub    $0x24,%esp
  801bed:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  801bf0:	8b 18                	mov    (%eax),%ebx
	uint32_t err = utf->utf_err;
  801bf2:	8b 50 04             	mov    0x4(%eax),%edx
	// Hint:
	//   Use the read-only page table mappings at vpt
	//   (see <inc/memlayout.h>).
	//cprintf("pgfault: do page fault here %x\n",utf->utf_eflags);
	// LAB 4: Your code here.
	if((err & FEC_WR) == 0)
  801bf5:	f6 c2 02             	test   $0x2,%dl
  801bf8:	75 2b                	jne    801c25 <pgfault+0x3f>
		panic("pgfault: fault is not a write (err: %08x va: %08x ip: %08x)",err, addr, utf->utf_eip);
  801bfa:	8b 40 28             	mov    0x28(%eax),%eax
  801bfd:	89 44 24 14          	mov    %eax,0x14(%esp)
  801c01:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  801c05:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801c09:	c7 44 24 08 e0 26 81 	movl   $0x8126e0,0x8(%esp)
  801c10:	00 
  801c11:	c7 44 24 04 1c 00 00 	movl   $0x1c,0x4(%esp)
  801c18:	00 
  801c19:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801c20:	e8 ef ec ff ff       	call   800914 <_panic>
	if ((vpd[PDX(addr)] & PTE_P) == 0 || (vpt[PGNUM(addr)] & PTE_COW) == 0)
  801c25:	89 d8                	mov    %ebx,%eax
  801c27:	c1 e8 16             	shr    $0x16,%eax
  801c2a:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  801c31:	a8 01                	test   $0x1,%al
  801c33:	74 11                	je     801c46 <pgfault+0x60>
  801c35:	89 d8                	mov    %ebx,%eax
  801c37:	c1 e8 0c             	shr    $0xc,%eax
  801c3a:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  801c41:	f6 c4 08             	test   $0x8,%ah
  801c44:	75 1c                	jne    801c62 <pgfault+0x7c>
		panic ("pgfault: not a write or attempting to access a non-COW page");
  801c46:	c7 44 24 08 1c 27 81 	movl   $0x81271c,0x8(%esp)
  801c4d:	00 
  801c4e:	c7 44 24 04 1e 00 00 	movl   $0x1e,0x4(%esp)
  801c55:	00 
  801c56:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801c5d:	e8 b2 ec ff ff       	call   800914 <_panic>
	// Hint:
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.

	// LAB 4: Your code here.
	if ((r = sys_page_alloc (0, (void *)PFTEMP, PTE_U|PTE_P|PTE_W)) < 0)
  801c62:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801c69:	00 
  801c6a:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801c71:	00 
  801c72:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801c79:	e8 ef fa ff ff       	call   80176d <sys_page_alloc>
  801c7e:	85 c0                	test   %eax,%eax
  801c80:	79 20                	jns    801ca2 <pgfault+0xbc>
		panic ("pgfault: page allocation failed : %e", r);
  801c82:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801c86:	c7 44 24 08 58 27 81 	movl   $0x812758,0x8(%esp)
  801c8d:	00 
  801c8e:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  801c95:	00 
  801c96:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801c9d:	e8 72 ec ff ff       	call   800914 <_panic>
	addr = ROUNDDOWN (addr, PGSIZE);
  801ca2:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	memmove (PFTEMP, addr, PGSIZE);
  801ca8:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  801caf:	00 
  801cb0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  801cb4:	c7 04 24 00 f0 7f 00 	movl   $0x7ff000,(%esp)
  801cbb:	e8 35 f6 ff ff       	call   8012f5 <memmove>
	if((r = sys_page_map (0, PFTEMP, 0, addr, PTE_U|PTE_P|PTE_W)) < 0)
  801cc0:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  801cc7:	00 
  801cc8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  801ccc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801cd3:	00 
  801cd4:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801cdb:	00 
  801cdc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801ce3:	e8 4c fa ff ff       	call   801734 <sys_page_map>
  801ce8:	85 c0                	test   %eax,%eax
  801cea:	79 20                	jns    801d0c <pgfault+0x126>
		panic ("pgfault: page mapping failed : %e", r);
  801cec:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801cf0:	c7 44 24 08 80 27 81 	movl   $0x812780,0x8(%esp)
  801cf7:	00 
  801cf8:	c7 44 24 04 2c 00 00 	movl   $0x2c,0x4(%esp)
  801cff:	00 
  801d00:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801d07:	e8 08 ec ff ff       	call   800914 <_panic>
	if((r = sys_page_unmap(0,PFTEMP)) < 0)
  801d0c:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801d13:	00 
  801d14:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801d1b:	e8 dc f9 ff ff       	call   8016fc <sys_page_unmap>
  801d20:	85 c0                	test   %eax,%eax
  801d22:	79 20                	jns    801d44 <pgfault+0x15e>
		panic("pgfault: page unmapping failed : %e", r);
  801d24:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801d28:	c7 44 24 08 a4 27 81 	movl   $0x8127a4,0x8(%esp)
  801d2f:	00 
  801d30:	c7 44 24 04 2e 00 00 	movl   $0x2e,0x4(%esp)
  801d37:	00 
  801d38:	c7 04 24 a1 25 81 00 	movl   $0x8125a1,(%esp)
  801d3f:	e8 d0 eb ff ff       	call   800914 <_panic>
	/* __asm__ volatile("movl %%esp, %0\n\t" */
	/* 		 :"=r"(gaga) */
	/* 		 ::); */
	/* cprintf("gaga----------%x\n", gaga); */
	//panic("pgfault not implemented");
}
  801d44:	83 c4 24             	add    $0x24,%esp
  801d47:	5b                   	pop    %ebx
  801d48:	5d                   	pop    %ebp
  801d49:	c3                   	ret    
  801d4a:	00 00                	add    %al,(%eax)
  801d4c:	00 00                	add    %al,(%eax)
	...

00801d50 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  801d50:	55                   	push   %ebp
  801d51:	89 e5                	mov    %esp,%ebp
  801d53:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
		if (envs[i].env_type == type)
  801d56:	8b 15 50 00 c0 ee    	mov    0xeec00050,%edx
  801d5c:	b8 01 00 00 00       	mov    $0x1,%eax
  801d61:	39 ca                	cmp    %ecx,%edx
  801d63:	75 04                	jne    801d69 <ipc_find_env+0x19>
  801d65:	b0 00                	mov    $0x0,%al
  801d67:	eb 11                	jmp    801d7a <ipc_find_env+0x2a>
  801d69:	89 c2                	mov    %eax,%edx
  801d6b:	c1 e2 07             	shl    $0x7,%edx
  801d6e:	81 c2 50 00 c0 ee    	add    $0xeec00050,%edx
  801d74:	8b 12                	mov    (%edx),%edx
  801d76:	39 ca                	cmp    %ecx,%edx
  801d78:	75 0f                	jne    801d89 <ipc_find_env+0x39>
			return envs[i].env_id;
  801d7a:	8d 44 00 01          	lea    0x1(%eax,%eax,1),%eax
  801d7e:	c1 e0 06             	shl    $0x6,%eax
  801d81:	8b 80 08 00 c0 ee    	mov    -0x113ffff8(%eax),%eax
  801d87:	eb 0e                	jmp    801d97 <ipc_find_env+0x47>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  801d89:	83 c0 01             	add    $0x1,%eax
  801d8c:	3d 00 04 00 00       	cmp    $0x400,%eax
  801d91:	75 d6                	jne    801d69 <ipc_find_env+0x19>
  801d93:	66 b8 00 00          	mov    $0x0,%ax
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
}
  801d97:	5d                   	pop    %ebp
  801d98:	c3                   	ret    

00801d99 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  801d99:	55                   	push   %ebp
  801d9a:	89 e5                	mov    %esp,%ebp
  801d9c:	57                   	push   %edi
  801d9d:	56                   	push   %esi
  801d9e:	53                   	push   %ebx
  801d9f:	83 ec 1c             	sub    $0x1c,%esp
  801da2:	8b 75 08             	mov    0x8(%ebp),%esi
  801da5:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801da8:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	int r;
	if(!pg)
  801dab:	85 db                	test   %ebx,%ebx
  801dad:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
  801db2:	0f 44 d8             	cmove  %eax,%ebx
  801db5:	eb 25                	jmp    801ddc <ipc_send+0x43>
		pg = (void*)UTOP; 
	while((r = sys_ipc_try_send(to_env,val,pg,perm)) != 0)
	{
		if(/* r < 0 && */r != -E_IPC_NOT_RECV )
  801db7:	83 f8 f9             	cmp    $0xfffffff9,%eax
  801dba:	74 20                	je     801ddc <ipc_send+0x43>
			panic ("ipc: sys try send failed : %e", r);
  801dbc:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801dc0:	c7 44 24 08 c8 27 81 	movl   $0x8127c8,0x8(%esp)
  801dc7:	00 
  801dc8:	c7 44 24 04 41 00 00 	movl   $0x41,0x4(%esp)
  801dcf:	00 
  801dd0:	c7 04 24 e6 27 81 00 	movl   $0x8127e6,(%esp)
  801dd7:	e8 38 eb ff ff       	call   800914 <_panic>
{
	// LAB 4: Your code here.
	int r;
	if(!pg)
		pg = (void*)UTOP; 
	while((r = sys_ipc_try_send(to_env,val,pg,perm)) != 0)
  801ddc:	8b 45 14             	mov    0x14(%ebp),%eax
  801ddf:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801de3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  801de7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801deb:	89 34 24             	mov    %esi,(%esp)
  801dee:	e8 2b f8 ff ff       	call   80161e <sys_ipc_try_send>
  801df3:	85 c0                	test   %eax,%eax
  801df5:	75 c0                	jne    801db7 <ipc_send+0x1e>
	{
		if(/* r < 0 && */r != -E_IPC_NOT_RECV )
			panic ("ipc: sys try send failed : %e", r);
	}
	sys_yield();
  801df7:	e8 a8 f9 ff ff       	call   8017a4 <sys_yield>
}
  801dfc:	83 c4 1c             	add    $0x1c,%esp
  801dff:	5b                   	pop    %ebx
  801e00:	5e                   	pop    %esi
  801e01:	5f                   	pop    %edi
  801e02:	5d                   	pop    %ebp
  801e03:	c3                   	ret    

00801e04 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  801e04:	55                   	push   %ebp
  801e05:	89 e5                	mov    %esp,%ebp
  801e07:	83 ec 28             	sub    $0x28,%esp
  801e0a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801e0d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801e10:	89 7d fc             	mov    %edi,-0x4(%ebp)
  801e13:	8b 75 08             	mov    0x8(%ebp),%esi
  801e16:	8b 45 0c             	mov    0xc(%ebp),%eax
  801e19:	8b 7d 10             	mov    0x10(%ebp),%edi
	// LAB 4: Your code here.
	int r;
	if(!pg)
  801e1c:	85 c0                	test   %eax,%eax
  801e1e:	ba 00 00 c0 ee       	mov    $0xeec00000,%edx
  801e23:	0f 44 c2             	cmove  %edx,%eax
		pg = (void*)UTOP;

	if((r = sys_ipc_recv(pg)) < 0)
  801e26:	89 04 24             	mov    %eax,(%esp)
  801e29:	e8 b7 f7 ff ff       	call   8015e5 <sys_ipc_recv>
  801e2e:	89 c3                	mov    %eax,%ebx
  801e30:	85 c0                	test   %eax,%eax
  801e32:	79 2a                	jns    801e5e <ipc_recv+0x5a>
	{
		cprintf("recv wrong %e %x\n",r,r);
  801e34:	89 44 24 08          	mov    %eax,0x8(%esp)
  801e38:	89 44 24 04          	mov    %eax,0x4(%esp)
  801e3c:	c7 04 24 f0 27 81 00 	movl   $0x8127f0,(%esp)
  801e43:	e8 85 eb ff ff       	call   8009cd <cprintf>
		if(from_env_store != NULL)
  801e48:	85 f6                	test   %esi,%esi
  801e4a:	74 06                	je     801e52 <ipc_recv+0x4e>
			*from_env_store = 0;
  801e4c:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		if(perm_store != NULL)
  801e52:	85 ff                	test   %edi,%edi
  801e54:	74 2c                	je     801e82 <ipc_recv+0x7e>
			*perm_store = 0;
  801e56:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
  801e5c:	eb 24                	jmp    801e82 <ipc_recv+0x7e>
		return r;
	}
	if(from_env_store != NULL)
  801e5e:	85 f6                	test   %esi,%esi
  801e60:	74 0a                	je     801e6c <ipc_recv+0x68>
		*from_env_store = thisenv->env_ipc_from;
  801e62:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  801e67:	8b 40 74             	mov    0x74(%eax),%eax
  801e6a:	89 06                	mov    %eax,(%esi)
	if(perm_store != NULL)
  801e6c:	85 ff                	test   %edi,%edi
  801e6e:	74 0a                	je     801e7a <ipc_recv+0x76>
		*perm_store = thisenv->env_ipc_perm;
  801e70:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  801e75:	8b 40 78             	mov    0x78(%eax),%eax
  801e78:	89 07                	mov    %eax,(%edi)
	//panic("ipc_recv not implemented");
	return thisenv->env_ipc_value;
  801e7a:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  801e7f:	8b 58 70             	mov    0x70(%eax),%ebx
}
  801e82:	89 d8                	mov    %ebx,%eax
  801e84:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801e87:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801e8a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801e8d:	89 ec                	mov    %ebp,%esp
  801e8f:	5d                   	pop    %ebp
  801e90:	c3                   	ret    
	...

00801ea0 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  801ea0:	55                   	push   %ebp
  801ea1:	89 e5                	mov    %esp,%ebp
  801ea3:	8b 45 08             	mov    0x8(%ebp),%eax
  801ea6:	05 00 00 00 30       	add    $0x30000000,%eax
  801eab:	c1 e8 0c             	shr    $0xc,%eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
}
  801eae:	5d                   	pop    %ebp
  801eaf:	c3                   	ret    

00801eb0 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  801eb0:	55                   	push   %ebp
  801eb1:	89 e5                	mov    %esp,%ebp
  801eb3:	83 ec 04             	sub    $0x4,%esp
	return INDEX2DATA(fd2num(fd));
  801eb6:	8b 45 08             	mov    0x8(%ebp),%eax
  801eb9:	89 04 24             	mov    %eax,(%esp)
  801ebc:	e8 df ff ff ff       	call   801ea0 <fd2num>
  801ec1:	05 20 00 0d 00       	add    $0xd0020,%eax
  801ec6:	c1 e0 0c             	shl    $0xc,%eax
}
  801ec9:	c9                   	leave  
  801eca:	c3                   	ret    

00801ecb <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  801ecb:	55                   	push   %ebp
  801ecc:	89 e5                	mov    %esp,%ebp
  801ece:	57                   	push   %edi
  801ecf:	56                   	push   %esi
  801ed0:	53                   	push   %ebx
  801ed1:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[PGNUM(fd)] & PTE_P) == 0) {
  801ed4:	a1 00 dd 7b ef       	mov    0xef7bdd00,%eax
  801ed9:	a8 01                	test   $0x1,%al
  801edb:	74 36                	je     801f13 <fd_alloc+0x48>
  801edd:	a1 00 00 74 ef       	mov    0xef740000,%eax
  801ee2:	a8 01                	test   $0x1,%al
  801ee4:	74 2d                	je     801f13 <fd_alloc+0x48>
  801ee6:	b8 00 10 00 d0       	mov    $0xd0001000,%eax
  801eeb:	b9 00 d0 7b ef       	mov    $0xef7bd000,%ecx
  801ef0:	be 00 00 40 ef       	mov    $0xef400000,%esi
  801ef5:	89 c3                	mov    %eax,%ebx
  801ef7:	89 c2                	mov    %eax,%edx
  801ef9:	c1 ea 16             	shr    $0x16,%edx
  801efc:	8b 14 91             	mov    (%ecx,%edx,4),%edx
  801eff:	f6 c2 01             	test   $0x1,%dl
  801f02:	74 14                	je     801f18 <fd_alloc+0x4d>
  801f04:	89 c2                	mov    %eax,%edx
  801f06:	c1 ea 0c             	shr    $0xc,%edx
  801f09:	8b 14 96             	mov    (%esi,%edx,4),%edx
  801f0c:	f6 c2 01             	test   $0x1,%dl
  801f0f:	75 10                	jne    801f21 <fd_alloc+0x56>
  801f11:	eb 05                	jmp    801f18 <fd_alloc+0x4d>
  801f13:	bb 00 00 00 d0       	mov    $0xd0000000,%ebx
			*fd_store = fd;
  801f18:	89 1f                	mov    %ebx,(%edi)
  801f1a:	b8 00 00 00 00       	mov    $0x0,%eax
			return 0;
  801f1f:	eb 17                	jmp    801f38 <fd_alloc+0x6d>
  801f21:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  801f26:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  801f2b:	75 c8                	jne    801ef5 <fd_alloc+0x2a>
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  801f2d:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
  801f33:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
	return -E_MAX_OPEN;
}
  801f38:	5b                   	pop    %ebx
  801f39:	5e                   	pop    %esi
  801f3a:	5f                   	pop    %edi
  801f3b:	5d                   	pop    %ebp
  801f3c:	c3                   	ret    

00801f3d <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  801f3d:	55                   	push   %ebp
  801f3e:	89 e5                	mov    %esp,%ebp
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  801f40:	8b 45 08             	mov    0x8(%ebp),%eax
  801f43:	83 f8 1f             	cmp    $0x1f,%eax
  801f46:	77 36                	ja     801f7e <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fd);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  801f48:	05 00 00 0d 00       	add    $0xd0000,%eax
  801f4d:	c1 e0 0c             	shl    $0xc,%eax
	if (!(vpd[PDX(fd)] & PTE_P) || !(vpt[PGNUM(fd)] & PTE_P)) {
  801f50:	89 c2                	mov    %eax,%edx
  801f52:	c1 ea 16             	shr    $0x16,%edx
  801f55:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  801f5c:	f6 c2 01             	test   $0x1,%dl
  801f5f:	74 1d                	je     801f7e <fd_lookup+0x41>
  801f61:	89 c2                	mov    %eax,%edx
  801f63:	c1 ea 0c             	shr    $0xc,%edx
  801f66:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  801f6d:	f6 c2 01             	test   $0x1,%dl
  801f70:	74 0c                	je     801f7e <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fd);
		return -E_INVAL;
	}
	*fd_store = fd;
  801f72:	8b 55 0c             	mov    0xc(%ebp),%edx
  801f75:	89 02                	mov    %eax,(%edx)
  801f77:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
  801f7c:	eb 05                	jmp    801f83 <fd_lookup+0x46>
  801f7e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  801f83:	5d                   	pop    %ebp
  801f84:	c3                   	ret    

00801f85 <seek>:
	return (*dev->dev_write)(fd, buf, n);
}

int
seek(int fdnum, off_t offset)
{
  801f85:	55                   	push   %ebp
  801f86:	89 e5                	mov    %esp,%ebp
  801f88:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  801f8b:	8d 45 fc             	lea    -0x4(%ebp),%eax
  801f8e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801f92:	8b 45 08             	mov    0x8(%ebp),%eax
  801f95:	89 04 24             	mov    %eax,(%esp)
  801f98:	e8 a0 ff ff ff       	call   801f3d <fd_lookup>
  801f9d:	85 c0                	test   %eax,%eax
  801f9f:	78 0e                	js     801faf <seek+0x2a>
		return r;
	fd->fd_offset = offset;
  801fa1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  801fa4:	8b 55 0c             	mov    0xc(%ebp),%edx
  801fa7:	89 50 04             	mov    %edx,0x4(%eax)
  801faa:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  801faf:	c9                   	leave  
  801fb0:	c3                   	ret    

00801fb1 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  801fb1:	55                   	push   %ebp
  801fb2:	89 e5                	mov    %esp,%ebp
  801fb4:	56                   	push   %esi
  801fb5:	53                   	push   %ebx
  801fb6:	83 ec 10             	sub    $0x10,%esp
  801fb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  801fbc:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int i;
	for (i = 0; devtab[i]; i++)
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
  801fbf:	ba 00 00 00 00       	mov    $0x0,%edx
int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
		if (devtab[i]->dev_id == dev_id) {
  801fc4:	b8 04 50 81 00       	mov    $0x815004,%eax
  801fc9:	39 0d 04 50 81 00    	cmp    %ecx,0x815004
  801fcf:	75 11                	jne    801fe2 <dev_lookup+0x31>
  801fd1:	eb 04                	jmp    801fd7 <dev_lookup+0x26>
  801fd3:	39 08                	cmp    %ecx,(%eax)
  801fd5:	75 10                	jne    801fe7 <dev_lookup+0x36>
			*dev = devtab[i];
  801fd7:	89 03                	mov    %eax,(%ebx)
  801fd9:	b8 00 00 00 00       	mov    $0x0,%eax
			return 0;
  801fde:	66 90                	xchg   %ax,%ax
  801fe0:	eb 36                	jmp    802018 <dev_lookup+0x67>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  801fe2:	be 80 28 81 00       	mov    $0x812880,%esi
  801fe7:	83 c2 01             	add    $0x1,%edx
  801fea:	8b 04 96             	mov    (%esi,%edx,4),%eax
  801fed:	85 c0                	test   %eax,%eax
  801fef:	75 e2                	jne    801fd3 <dev_lookup+0x22>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  801ff1:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  801ff6:	8b 40 48             	mov    0x48(%eax),%eax
  801ff9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  801ffd:	89 44 24 04          	mov    %eax,0x4(%esp)
  802001:	c7 04 24 04 28 81 00 	movl   $0x812804,(%esp)
  802008:	e8 c0 e9 ff ff       	call   8009cd <cprintf>
	*dev = 0;
  80200d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  802013:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	return -E_INVAL;
}
  802018:	83 c4 10             	add    $0x10,%esp
  80201b:	5b                   	pop    %ebx
  80201c:	5e                   	pop    %esi
  80201d:	5d                   	pop    %ebp
  80201e:	c3                   	ret    

0080201f <fstat>:
	return (*dev->dev_trunc)(fd, newsize);
}

int
fstat(int fdnum, struct Stat *stat)
{
  80201f:	55                   	push   %ebp
  802020:	89 e5                	mov    %esp,%ebp
  802022:	53                   	push   %ebx
  802023:	83 ec 24             	sub    $0x24,%esp
  802026:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802029:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80202c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802030:	8b 45 08             	mov    0x8(%ebp),%eax
  802033:	89 04 24             	mov    %eax,(%esp)
  802036:	e8 02 ff ff ff       	call   801f3d <fd_lookup>
  80203b:	85 c0                	test   %eax,%eax
  80203d:	78 53                	js     802092 <fstat+0x73>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80203f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802042:	89 44 24 04          	mov    %eax,0x4(%esp)
  802046:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802049:	8b 00                	mov    (%eax),%eax
  80204b:	89 04 24             	mov    %eax,(%esp)
  80204e:	e8 5e ff ff ff       	call   801fb1 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802053:	85 c0                	test   %eax,%eax
  802055:	78 3b                	js     802092 <fstat+0x73>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
  802057:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80205c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80205f:	83 7a 14 00          	cmpl   $0x0,0x14(%edx)
  802063:	74 2d                	je     802092 <fstat+0x73>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  802065:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  802068:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80206f:	00 00 00 
	stat->st_isdir = 0;
  802072:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  802079:	00 00 00 
	stat->st_dev = dev;
  80207c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80207f:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  802085:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802089:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80208c:	89 14 24             	mov    %edx,(%esp)
  80208f:	ff 50 14             	call   *0x14(%eax)
}
  802092:	83 c4 24             	add    $0x24,%esp
  802095:	5b                   	pop    %ebx
  802096:	5d                   	pop    %ebp
  802097:	c3                   	ret    

00802098 <ftruncate>:
	return 0;
}

int
ftruncate(int fdnum, off_t newsize)
{
  802098:	55                   	push   %ebp
  802099:	89 e5                	mov    %esp,%ebp
  80209b:	53                   	push   %ebx
  80209c:	83 ec 24             	sub    $0x24,%esp
  80209f:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  8020a2:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8020a5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020a9:	89 1c 24             	mov    %ebx,(%esp)
  8020ac:	e8 8c fe ff ff       	call   801f3d <fd_lookup>
  8020b1:	85 c0                	test   %eax,%eax
  8020b3:	78 5f                	js     802114 <ftruncate+0x7c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8020b5:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8020b8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8020bf:	8b 00                	mov    (%eax),%eax
  8020c1:	89 04 24             	mov    %eax,(%esp)
  8020c4:	e8 e8 fe ff ff       	call   801fb1 <dev_lookup>
ftruncate(int fdnum, off_t newsize)
{
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  8020c9:	85 c0                	test   %eax,%eax
  8020cb:	78 47                	js     802114 <ftruncate+0x7c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8020cd:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8020d0:	f6 42 08 03          	testb  $0x3,0x8(%edx)
  8020d4:	75 23                	jne    8020f9 <ftruncate+0x61>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  8020d6:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  8020db:	8b 40 48             	mov    0x48(%eax),%eax
  8020de:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8020e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020e6:	c7 04 24 24 28 81 00 	movl   $0x812824,(%esp)
  8020ed:	e8 db e8 ff ff       	call   8009cd <cprintf>
  8020f2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
			thisenv->env_id, fdnum);
		return -E_INVAL;
  8020f7:	eb 1b                	jmp    802114 <ftruncate+0x7c>
	}
	if (!dev->dev_trunc)
  8020f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8020fc:	8b 48 18             	mov    0x18(%eax),%ecx
  8020ff:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  802104:	85 c9                	test   %ecx,%ecx
  802106:	74 0c                	je     802114 <ftruncate+0x7c>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  802108:	8b 45 0c             	mov    0xc(%ebp),%eax
  80210b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80210f:	89 14 24             	mov    %edx,(%esp)
  802112:	ff d1                	call   *%ecx
}
  802114:	83 c4 24             	add    $0x24,%esp
  802117:	5b                   	pop    %ebx
  802118:	5d                   	pop    %ebp
  802119:	c3                   	ret    

0080211a <write>:
	return tot;
}

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  80211a:	55                   	push   %ebp
  80211b:	89 e5                	mov    %esp,%ebp
  80211d:	53                   	push   %ebx
  80211e:	83 ec 24             	sub    $0x24,%esp
  802121:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802124:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802127:	89 44 24 04          	mov    %eax,0x4(%esp)
  80212b:	89 1c 24             	mov    %ebx,(%esp)
  80212e:	e8 0a fe ff ff       	call   801f3d <fd_lookup>
  802133:	85 c0                	test   %eax,%eax
  802135:	78 66                	js     80219d <write+0x83>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  802137:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80213a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80213e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802141:	8b 00                	mov    (%eax),%eax
  802143:	89 04 24             	mov    %eax,(%esp)
  802146:	e8 66 fe ff ff       	call   801fb1 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80214b:	85 c0                	test   %eax,%eax
  80214d:	78 4e                	js     80219d <write+0x83>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  80214f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  802152:	f6 42 08 03          	testb  $0x3,0x8(%edx)
  802156:	75 23                	jne    80217b <write+0x61>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  802158:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  80215d:	8b 40 48             	mov    0x48(%eax),%eax
  802160:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802164:	89 44 24 04          	mov    %eax,0x4(%esp)
  802168:	c7 04 24 45 28 81 00 	movl   $0x812845,(%esp)
  80216f:	e8 59 e8 ff ff       	call   8009cd <cprintf>
  802174:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		return -E_INVAL;
  802179:	eb 22                	jmp    80219d <write+0x83>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  80217b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80217e:	8b 48 0c             	mov    0xc(%eax),%ecx
  802181:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  802186:	85 c9                	test   %ecx,%ecx
  802188:	74 13                	je     80219d <write+0x83>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  80218a:	8b 45 10             	mov    0x10(%ebp),%eax
  80218d:	89 44 24 08          	mov    %eax,0x8(%esp)
  802191:	8b 45 0c             	mov    0xc(%ebp),%eax
  802194:	89 44 24 04          	mov    %eax,0x4(%esp)
  802198:	89 14 24             	mov    %edx,(%esp)
  80219b:	ff d1                	call   *%ecx
}
  80219d:	83 c4 24             	add    $0x24,%esp
  8021a0:	5b                   	pop    %ebx
  8021a1:	5d                   	pop    %ebp
  8021a2:	c3                   	ret    

008021a3 <read>:
	return r;
}

ssize_t
read(int fdnum, void *buf, size_t n)
{
  8021a3:	55                   	push   %ebp
  8021a4:	89 e5                	mov    %esp,%ebp
  8021a6:	53                   	push   %ebx
  8021a7:	83 ec 24             	sub    $0x24,%esp
  8021aa:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8021ad:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8021b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021b4:	89 1c 24             	mov    %ebx,(%esp)
  8021b7:	e8 81 fd ff ff       	call   801f3d <fd_lookup>
  8021bc:	85 c0                	test   %eax,%eax
  8021be:	78 6b                	js     80222b <read+0x88>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8021c0:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8021c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8021ca:	8b 00                	mov    (%eax),%eax
  8021cc:	89 04 24             	mov    %eax,(%esp)
  8021cf:	e8 dd fd ff ff       	call   801fb1 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8021d4:	85 c0                	test   %eax,%eax
  8021d6:	78 53                	js     80222b <read+0x88>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  8021d8:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8021db:	8b 42 08             	mov    0x8(%edx),%eax
  8021de:	83 e0 03             	and    $0x3,%eax
  8021e1:	83 f8 01             	cmp    $0x1,%eax
  8021e4:	75 23                	jne    802209 <read+0x66>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  8021e6:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  8021eb:	8b 40 48             	mov    0x48(%eax),%eax
  8021ee:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8021f2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021f6:	c7 04 24 62 28 81 00 	movl   $0x812862,(%esp)
  8021fd:	e8 cb e7 ff ff       	call   8009cd <cprintf>
  802202:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		return -E_INVAL;
  802207:	eb 22                	jmp    80222b <read+0x88>
	}
	if (!dev->dev_read)
  802209:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80220c:	8b 48 08             	mov    0x8(%eax),%ecx
  80220f:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  802214:	85 c9                	test   %ecx,%ecx
  802216:	74 13                	je     80222b <read+0x88>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  802218:	8b 45 10             	mov    0x10(%ebp),%eax
  80221b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80221f:	8b 45 0c             	mov    0xc(%ebp),%eax
  802222:	89 44 24 04          	mov    %eax,0x4(%esp)
  802226:	89 14 24             	mov    %edx,(%esp)
  802229:	ff d1                	call   *%ecx
}
  80222b:	83 c4 24             	add    $0x24,%esp
  80222e:	5b                   	pop    %ebx
  80222f:	5d                   	pop    %ebp
  802230:	c3                   	ret    

00802231 <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  802231:	55                   	push   %ebp
  802232:	89 e5                	mov    %esp,%ebp
  802234:	57                   	push   %edi
  802235:	56                   	push   %esi
  802236:	53                   	push   %ebx
  802237:	83 ec 1c             	sub    $0x1c,%esp
  80223a:	8b 7d 08             	mov    0x8(%ebp),%edi
  80223d:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  802240:	ba 00 00 00 00       	mov    $0x0,%edx
  802245:	bb 00 00 00 00       	mov    $0x0,%ebx
  80224a:	b8 00 00 00 00       	mov    $0x0,%eax
  80224f:	85 f6                	test   %esi,%esi
  802251:	74 29                	je     80227c <readn+0x4b>
		m = read(fdnum, (char*)buf + tot, n - tot);
  802253:	89 f0                	mov    %esi,%eax
  802255:	29 d0                	sub    %edx,%eax
  802257:	89 44 24 08          	mov    %eax,0x8(%esp)
  80225b:	03 55 0c             	add    0xc(%ebp),%edx
  80225e:	89 54 24 04          	mov    %edx,0x4(%esp)
  802262:	89 3c 24             	mov    %edi,(%esp)
  802265:	e8 39 ff ff ff       	call   8021a3 <read>
		if (m < 0)
  80226a:	85 c0                	test   %eax,%eax
  80226c:	78 0e                	js     80227c <readn+0x4b>
			return m;
		if (m == 0)
  80226e:	85 c0                	test   %eax,%eax
  802270:	74 08                	je     80227a <readn+0x49>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  802272:	01 c3                	add    %eax,%ebx
  802274:	89 da                	mov    %ebx,%edx
  802276:	39 f3                	cmp    %esi,%ebx
  802278:	72 d9                	jb     802253 <readn+0x22>
  80227a:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  80227c:	83 c4 1c             	add    $0x1c,%esp
  80227f:	5b                   	pop    %ebx
  802280:	5e                   	pop    %esi
  802281:	5f                   	pop    %edi
  802282:	5d                   	pop    %ebp
  802283:	c3                   	ret    

00802284 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  802284:	55                   	push   %ebp
  802285:	89 e5                	mov    %esp,%ebp
  802287:	83 ec 28             	sub    $0x28,%esp
  80228a:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80228d:	89 75 fc             	mov    %esi,-0x4(%ebp)
  802290:	8b 75 08             	mov    0x8(%ebp),%esi
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  802293:	89 34 24             	mov    %esi,(%esp)
  802296:	e8 05 fc ff ff       	call   801ea0 <fd2num>
  80229b:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80229e:	89 54 24 04          	mov    %edx,0x4(%esp)
  8022a2:	89 04 24             	mov    %eax,(%esp)
  8022a5:	e8 93 fc ff ff       	call   801f3d <fd_lookup>
  8022aa:	89 c3                	mov    %eax,%ebx
  8022ac:	85 c0                	test   %eax,%eax
  8022ae:	78 05                	js     8022b5 <fd_close+0x31>
  8022b0:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  8022b3:	74 0e                	je     8022c3 <fd_close+0x3f>
	    || fd != fd2)
		return (must_exist ? r : 0);
  8022b5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8022b9:	b8 00 00 00 00       	mov    $0x0,%eax
  8022be:	0f 44 d8             	cmove  %eax,%ebx
  8022c1:	eb 3d                	jmp    802300 <fd_close+0x7c>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  8022c3:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8022c6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8022ca:	8b 06                	mov    (%esi),%eax
  8022cc:	89 04 24             	mov    %eax,(%esp)
  8022cf:	e8 dd fc ff ff       	call   801fb1 <dev_lookup>
  8022d4:	89 c3                	mov    %eax,%ebx
  8022d6:	85 c0                	test   %eax,%eax
  8022d8:	78 16                	js     8022f0 <fd_close+0x6c>
		if (dev->dev_close)
  8022da:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8022dd:	8b 40 10             	mov    0x10(%eax),%eax
  8022e0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8022e5:	85 c0                	test   %eax,%eax
  8022e7:	74 07                	je     8022f0 <fd_close+0x6c>
			r = (*dev->dev_close)(fd);
  8022e9:	89 34 24             	mov    %esi,(%esp)
  8022ec:	ff d0                	call   *%eax
  8022ee:	89 c3                	mov    %eax,%ebx
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  8022f0:	89 74 24 04          	mov    %esi,0x4(%esp)
  8022f4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8022fb:	e8 fc f3 ff ff       	call   8016fc <sys_page_unmap>
	return r;
}
  802300:	89 d8                	mov    %ebx,%eax
  802302:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802305:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802308:	89 ec                	mov    %ebp,%esp
  80230a:	5d                   	pop    %ebp
  80230b:	c3                   	ret    

0080230c <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  80230c:	55                   	push   %ebp
  80230d:	89 e5                	mov    %esp,%ebp
  80230f:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  802312:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802315:	89 44 24 04          	mov    %eax,0x4(%esp)
  802319:	8b 45 08             	mov    0x8(%ebp),%eax
  80231c:	89 04 24             	mov    %eax,(%esp)
  80231f:	e8 19 fc ff ff       	call   801f3d <fd_lookup>
  802324:	85 c0                	test   %eax,%eax
  802326:	78 13                	js     80233b <close+0x2f>
		return r;
	else
		return fd_close(fd, 1);
  802328:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80232f:	00 
  802330:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802333:	89 04 24             	mov    %eax,(%esp)
  802336:	e8 49 ff ff ff       	call   802284 <fd_close>
}
  80233b:	c9                   	leave  
  80233c:	c3                   	ret    

0080233d <stat>:
	return (*dev->dev_stat)(fd, stat);
}

int
stat(const char *path, struct Stat *stat)
{
  80233d:	55                   	push   %ebp
  80233e:	89 e5                	mov    %esp,%ebp
  802340:	83 ec 18             	sub    $0x18,%esp
  802343:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802346:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  802349:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802350:	00 
  802351:	8b 45 08             	mov    0x8(%ebp),%eax
  802354:	89 04 24             	mov    %eax,(%esp)
  802357:	e8 78 03 00 00       	call   8026d4 <open>
  80235c:	89 c3                	mov    %eax,%ebx
  80235e:	85 c0                	test   %eax,%eax
  802360:	78 1b                	js     80237d <stat+0x40>
		return fd;
	r = fstat(fd, stat);
  802362:	8b 45 0c             	mov    0xc(%ebp),%eax
  802365:	89 44 24 04          	mov    %eax,0x4(%esp)
  802369:	89 1c 24             	mov    %ebx,(%esp)
  80236c:	e8 ae fc ff ff       	call   80201f <fstat>
  802371:	89 c6                	mov    %eax,%esi
	close(fd);
  802373:	89 1c 24             	mov    %ebx,(%esp)
  802376:	e8 91 ff ff ff       	call   80230c <close>
  80237b:	89 f3                	mov    %esi,%ebx
	return r;
}
  80237d:	89 d8                	mov    %ebx,%eax
  80237f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802382:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802385:	89 ec                	mov    %ebp,%esp
  802387:	5d                   	pop    %ebp
  802388:	c3                   	ret    

00802389 <close_all>:
		return fd_close(fd, 1);
}

void
close_all(void)
{
  802389:	55                   	push   %ebp
  80238a:	89 e5                	mov    %esp,%ebp
  80238c:	53                   	push   %ebx
  80238d:	83 ec 14             	sub    $0x14,%esp
  802390:	bb 00 00 00 00       	mov    $0x0,%ebx
	int i;
	for (i = 0; i < MAXFD; i++)
		close(i);
  802395:	89 1c 24             	mov    %ebx,(%esp)
  802398:	e8 6f ff ff ff       	call   80230c <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  80239d:	83 c3 01             	add    $0x1,%ebx
  8023a0:	83 fb 20             	cmp    $0x20,%ebx
  8023a3:	75 f0                	jne    802395 <close_all+0xc>
		close(i);
}
  8023a5:	83 c4 14             	add    $0x14,%esp
  8023a8:	5b                   	pop    %ebx
  8023a9:	5d                   	pop    %ebp
  8023aa:	c3                   	ret    

008023ab <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  8023ab:	55                   	push   %ebp
  8023ac:	89 e5                	mov    %esp,%ebp
  8023ae:	83 ec 58             	sub    $0x58,%esp
  8023b1:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8023b4:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8023b7:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8023ba:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  8023bd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8023c0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8023c7:	89 04 24             	mov    %eax,(%esp)
  8023ca:	e8 6e fb ff ff       	call   801f3d <fd_lookup>
  8023cf:	89 c3                	mov    %eax,%ebx
  8023d1:	85 c0                	test   %eax,%eax
  8023d3:	0f 88 e0 00 00 00    	js     8024b9 <dup+0x10e>
		return r;
	close(newfdnum);
  8023d9:	89 3c 24             	mov    %edi,(%esp)
  8023dc:	e8 2b ff ff ff       	call   80230c <close>

	newfd = INDEX2FD(newfdnum);
  8023e1:	8d b7 00 00 0d 00    	lea    0xd0000(%edi),%esi
  8023e7:	c1 e6 0c             	shl    $0xc,%esi
	ova = fd2data(oldfd);
  8023ea:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8023ed:	89 04 24             	mov    %eax,(%esp)
  8023f0:	e8 bb fa ff ff       	call   801eb0 <fd2data>
  8023f5:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  8023f7:	89 34 24             	mov    %esi,(%esp)
  8023fa:	e8 b1 fa ff ff       	call   801eb0 <fd2data>
  8023ff:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((vpd[PDX(ova)] & PTE_P) && (vpt[PGNUM(ova)] & PTE_P))
  802402:	89 da                	mov    %ebx,%edx
  802404:	89 d8                	mov    %ebx,%eax
  802406:	c1 e8 16             	shr    $0x16,%eax
  802409:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  802410:	a8 01                	test   $0x1,%al
  802412:	74 43                	je     802457 <dup+0xac>
  802414:	c1 ea 0c             	shr    $0xc,%edx
  802417:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80241e:	a8 01                	test   $0x1,%al
  802420:	74 35                	je     802457 <dup+0xac>
		if ((r = sys_page_map(0, ova, 0, nva, vpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  802422:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  802429:	25 07 0e 00 00       	and    $0xe07,%eax
  80242e:	89 44 24 10          	mov    %eax,0x10(%esp)
  802432:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  802435:	89 44 24 0c          	mov    %eax,0xc(%esp)
  802439:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802440:	00 
  802441:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802445:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80244c:	e8 e3 f2 ff ff       	call   801734 <sys_page_map>
  802451:	89 c3                	mov    %eax,%ebx
  802453:	85 c0                	test   %eax,%eax
  802455:	78 3f                	js     802496 <dup+0xeb>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, vpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  802457:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80245a:	89 c2                	mov    %eax,%edx
  80245c:	c1 ea 0c             	shr    $0xc,%edx
  80245f:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  802466:	81 e2 07 0e 00 00    	and    $0xe07,%edx
  80246c:	89 54 24 10          	mov    %edx,0x10(%esp)
  802470:	89 74 24 0c          	mov    %esi,0xc(%esp)
  802474:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80247b:	00 
  80247c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802480:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802487:	e8 a8 f2 ff ff       	call   801734 <sys_page_map>
  80248c:	89 c3                	mov    %eax,%ebx
  80248e:	85 c0                	test   %eax,%eax
  802490:	78 04                	js     802496 <dup+0xeb>
  802492:	89 fb                	mov    %edi,%ebx
  802494:	eb 23                	jmp    8024b9 <dup+0x10e>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  802496:	89 74 24 04          	mov    %esi,0x4(%esp)
  80249a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8024a1:	e8 56 f2 ff ff       	call   8016fc <sys_page_unmap>
	sys_page_unmap(0, nva);
  8024a6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8024a9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8024ad:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8024b4:	e8 43 f2 ff ff       	call   8016fc <sys_page_unmap>
	return r;
}
  8024b9:	89 d8                	mov    %ebx,%eax
  8024bb:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8024be:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8024c1:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8024c4:	89 ec                	mov    %ebp,%esp
  8024c6:	5d                   	pop    %ebp
  8024c7:	c3                   	ret    

008024c8 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  8024c8:	55                   	push   %ebp
  8024c9:	89 e5                	mov    %esp,%ebp
  8024cb:	83 ec 18             	sub    $0x18,%esp
  8024ce:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8024d1:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8024d4:	89 c3                	mov    %eax,%ebx
  8024d6:	89 d6                	mov    %edx,%esi
	static envid_t fsenv;
	if (fsenv == 0)
  8024d8:	83 3d 90 60 81 00 00 	cmpl   $0x0,0x816090
  8024df:	75 11                	jne    8024f2 <fsipc+0x2a>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  8024e1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8024e8:	e8 63 f8 ff ff       	call   801d50 <ipc_find_env>
  8024ed:	a3 90 60 81 00       	mov    %eax,0x816090
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  8024f2:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  8024f9:	00 
  8024fa:	c7 44 24 08 00 d0 b3 	movl   $0xb3d000,0x8(%esp)
  802501:	00 
  802502:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802506:	a1 90 60 81 00       	mov    0x816090,%eax
  80250b:	89 04 24             	mov    %eax,(%esp)
  80250e:	e8 86 f8 ff ff       	call   801d99 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  802513:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80251a:	00 
  80251b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80251f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802526:	e8 d9 f8 ff ff       	call   801e04 <ipc_recv>
}
  80252b:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80252e:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802531:	89 ec                	mov    %ebp,%esp
  802533:	5d                   	pop    %ebp
  802534:	c3                   	ret    

00802535 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  802535:	55                   	push   %ebp
  802536:	89 e5                	mov    %esp,%ebp
  802538:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80253b:	8b 45 08             	mov    0x8(%ebp),%eax
  80253e:	8b 40 0c             	mov    0xc(%eax),%eax
  802541:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.set_size.req_size = newsize;
  802546:	8b 45 0c             	mov    0xc(%ebp),%eax
  802549:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80254e:	ba 00 00 00 00       	mov    $0x0,%edx
  802553:	b8 02 00 00 00       	mov    $0x2,%eax
  802558:	e8 6b ff ff ff       	call   8024c8 <fsipc>
}
  80255d:	c9                   	leave  
  80255e:	c3                   	ret    

0080255f <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  80255f:	55                   	push   %ebp
  802560:	89 e5                	mov    %esp,%ebp
  802562:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  802565:	8b 45 08             	mov    0x8(%ebp),%eax
  802568:	8b 40 0c             	mov    0xc(%eax),%eax
  80256b:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return fsipc(FSREQ_FLUSH, NULL);
  802570:	ba 00 00 00 00       	mov    $0x0,%edx
  802575:	b8 06 00 00 00       	mov    $0x6,%eax
  80257a:	e8 49 ff ff ff       	call   8024c8 <fsipc>
}
  80257f:	c9                   	leave  
  802580:	c3                   	ret    

00802581 <sync>:
}

// Synchronize disk with buffer cache
int
sync(void)
{
  802581:	55                   	push   %ebp
  802582:	89 e5                	mov    %esp,%ebp
  802584:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  802587:	ba 00 00 00 00       	mov    $0x0,%edx
  80258c:	b8 08 00 00 00       	mov    $0x8,%eax
  802591:	e8 32 ff ff ff       	call   8024c8 <fsipc>
}
  802596:	c9                   	leave  
  802597:	c3                   	ret    

00802598 <devfile_stat>:
  return fsipc(FSREQ_WRITE, NULL);	
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  802598:	55                   	push   %ebp
  802599:	89 e5                	mov    %esp,%ebp
  80259b:	53                   	push   %ebx
  80259c:	83 ec 14             	sub    $0x14,%esp
  80259f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  8025a2:	8b 45 08             	mov    0x8(%ebp),%eax
  8025a5:	8b 40 0c             	mov    0xc(%eax),%eax
  8025a8:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  8025ad:	ba 00 00 00 00       	mov    $0x0,%edx
  8025b2:	b8 05 00 00 00       	mov    $0x5,%eax
  8025b7:	e8 0c ff ff ff       	call   8024c8 <fsipc>
  8025bc:	85 c0                	test   %eax,%eax
  8025be:	78 2b                	js     8025eb <devfile_stat+0x53>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  8025c0:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  8025c7:	00 
  8025c8:	89 1c 24             	mov    %ebx,(%esp)
  8025cb:	e8 3a eb ff ff       	call   80110a <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  8025d0:	a1 80 d0 b3 00       	mov    0xb3d080,%eax
  8025d5:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  8025db:	a1 84 d0 b3 00       	mov    0xb3d084,%eax
  8025e0:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
  8025e6:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  8025eb:	83 c4 14             	add    $0x14,%esp
  8025ee:	5b                   	pop    %ebx
  8025ef:	5d                   	pop    %ebp
  8025f0:	c3                   	ret    

008025f1 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  8025f1:	55                   	push   %ebp
  8025f2:	89 e5                	mov    %esp,%ebp
  8025f4:	83 ec 18             	sub    $0x18,%esp
  8025f7:	8b 45 10             	mov    0x10(%ebp),%eax
	// Make an FSREQ_WRITE request to the file system server.  Be
	// careful: fsipcbuf.write.req_buf is only so large, but
	// remember that write is always allowed to write *fewer*
	// bytes than requested.
	// LAB 5: Your code here
  fsipcbuf.write.req_fileid = fd->fd_file.id;
  8025fa:	8b 55 08             	mov    0x8(%ebp),%edx
  8025fd:	8b 52 0c             	mov    0xc(%edx),%edx
  802600:	89 15 00 d0 b3 00    	mov    %edx,0xb3d000
  fsipcbuf.write.req_n = n;
  802606:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
  memmove(fsipcbuf.write.req_buf, buf,
  80260b:	3d f8 0f 00 00       	cmp    $0xff8,%eax
  802610:	ba f8 0f 00 00       	mov    $0xff8,%edx
  802615:	0f 47 c2             	cmova  %edx,%eax
  802618:	89 44 24 08          	mov    %eax,0x8(%esp)
  80261c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80261f:	89 44 24 04          	mov    %eax,0x4(%esp)
  802623:	c7 04 24 08 d0 b3 00 	movl   $0xb3d008,(%esp)
  80262a:	e8 c6 ec ff ff       	call   8012f5 <memmove>
      MIN(n, PGSIZE - sizeof(int) - sizeof(size_t)));
  return fsipc(FSREQ_WRITE, NULL);	
  80262f:	ba 00 00 00 00       	mov    $0x0,%edx
  802634:	b8 04 00 00 00       	mov    $0x4,%eax
  802639:	e8 8a fe ff ff       	call   8024c8 <fsipc>
}
  80263e:	c9                   	leave  
  80263f:	c3                   	ret    

00802640 <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  802640:	55                   	push   %ebp
  802641:	89 e5                	mov    %esp,%ebp
  802643:	53                   	push   %ebx
  802644:	83 ec 14             	sub    $0x14,%esp
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	// LAB 5: Your code here
  int r;

  fsipcbuf.read.req_fileid = fd->fd_file.id;
  802647:	8b 45 08             	mov    0x8(%ebp),%eax
  80264a:	8b 40 0c             	mov    0xc(%eax),%eax
  80264d:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
  fsipcbuf.read.req_n = n;
  802652:	8b 45 10             	mov    0x10(%ebp),%eax
  802655:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
  if((r = fsipc(FSREQ_READ, NULL)) < 0)
  80265a:	ba 00 00 00 00       	mov    $0x0,%edx
  80265f:	b8 03 00 00 00       	mov    $0x3,%eax
  802664:	e8 5f fe ff ff       	call   8024c8 <fsipc>
  802669:	89 c3                	mov    %eax,%ebx
  80266b:	85 c0                	test   %eax,%eax
  80266d:	78 17                	js     802686 <devfile_read+0x46>
    return r;
  memmove(buf, fsipcbuf.readRet.ret_buf, r);
  80266f:	89 44 24 08          	mov    %eax,0x8(%esp)
  802673:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  80267a:	00 
  80267b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80267e:	89 04 24             	mov    %eax,(%esp)
  802681:	e8 6f ec ff ff       	call   8012f5 <memmove>
  return r;	
}
  802686:	89 d8                	mov    %ebx,%eax
  802688:	83 c4 14             	add    $0x14,%esp
  80268b:	5b                   	pop    %ebx
  80268c:	5d                   	pop    %ebp
  80268d:	c3                   	ret    

0080268e <remove>:
}

// Delete a file
int
remove(const char *path)
{
  80268e:	55                   	push   %ebp
  80268f:	89 e5                	mov    %esp,%ebp
  802691:	53                   	push   %ebx
  802692:	83 ec 14             	sub    $0x14,%esp
  802695:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (strlen(path) >= MAXPATHLEN)
  802698:	89 1c 24             	mov    %ebx,(%esp)
  80269b:	e8 20 ea ff ff       	call   8010c0 <strlen>
  8026a0:	89 c2                	mov    %eax,%edx
  8026a2:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  8026a7:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
  8026ad:	7f 1f                	jg     8026ce <remove+0x40>
		return -E_BAD_PATH;
	strcpy(fsipcbuf.remove.req_path, path);
  8026af:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8026b3:	c7 04 24 00 d0 b3 00 	movl   $0xb3d000,(%esp)
  8026ba:	e8 4b ea ff ff       	call   80110a <strcpy>
	return fsipc(FSREQ_REMOVE, NULL);
  8026bf:	ba 00 00 00 00       	mov    $0x0,%edx
  8026c4:	b8 07 00 00 00       	mov    $0x7,%eax
  8026c9:	e8 fa fd ff ff       	call   8024c8 <fsipc>
}
  8026ce:	83 c4 14             	add    $0x14,%esp
  8026d1:	5b                   	pop    %ebx
  8026d2:	5d                   	pop    %ebp
  8026d3:	c3                   	ret    

008026d4 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  8026d4:	55                   	push   %ebp
  8026d5:	89 e5                	mov    %esp,%ebp
  8026d7:	83 ec 28             	sub    $0x28,%esp
  8026da:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8026dd:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8026e0:	8b 75 08             	mov    0x8(%ebp),%esi

	// LAB 5: Your code here.
  int r;
  struct Fd *fd;

  r = fd_alloc(&fd);
  8026e3:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8026e6:	89 04 24             	mov    %eax,(%esp)
  8026e9:	e8 dd f7 ff ff       	call   801ecb <fd_alloc>
  8026ee:	89 c3                	mov    %eax,%ebx
  if (r < 0) return r;
  8026f0:	85 c0                	test   %eax,%eax
  8026f2:	0f 88 89 00 00 00    	js     802781 <open+0xad>

        // DO NOT ALLOCATE !!
        //r = sys_page_alloc(0, fd, PTE_U|PTE_W|PTE_P);
        //if (r < 0) goto out;

  if (strlen(path) >= MAXPATHLEN)
  8026f8:	89 34 24             	mov    %esi,(%esp)
  8026fb:	e8 c0 e9 ff ff       	call   8010c0 <strlen>
  fsipcbuf.open.req_omode = mode;
  r = fsipc(FSREQ_OPEN, fd);
  if (r < 0) goto out;
  return fd2num(fd);
out:
  assert(fd_close(fd, 0) == 0);
  802700:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx

        // DO NOT ALLOCATE !!
        //r = sys_page_alloc(0, fd, PTE_U|PTE_W|PTE_P);
        //if (r < 0) goto out;

  if (strlen(path) >= MAXPATHLEN)
  802705:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  80270a:	7f 75                	jg     802781 <open+0xad>
    return -E_BAD_PATH;
  strcpy(fsipcbuf.open.req_path, path);
  80270c:	89 74 24 04          	mov    %esi,0x4(%esp)
  802710:	c7 04 24 00 d0 b3 00 	movl   $0xb3d000,(%esp)
  802717:	e8 ee e9 ff ff       	call   80110a <strcpy>
  fsipcbuf.open.req_omode = mode;
  80271c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80271f:	a3 00 d4 b3 00       	mov    %eax,0xb3d400
  r = fsipc(FSREQ_OPEN, fd);
  802724:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802727:	b8 01 00 00 00       	mov    $0x1,%eax
  80272c:	e8 97 fd ff ff       	call   8024c8 <fsipc>
  802731:	89 c3                	mov    %eax,%ebx
  if (r < 0) goto out;
  802733:	85 c0                	test   %eax,%eax
  802735:	78 0f                	js     802746 <open+0x72>
  return fd2num(fd);
  802737:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80273a:	89 04 24             	mov    %eax,(%esp)
  80273d:	e8 5e f7 ff ff       	call   801ea0 <fd2num>
  802742:	89 c3                	mov    %eax,%ebx
  802744:	eb 3b                	jmp    802781 <open+0xad>
out:
  assert(fd_close(fd, 0) == 0);
  802746:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80274d:	00 
  80274e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802751:	89 04 24             	mov    %eax,(%esp)
  802754:	e8 2b fb ff ff       	call   802284 <fd_close>
  802759:	85 c0                	test   %eax,%eax
  80275b:	74 24                	je     802781 <open+0xad>
  80275d:	c7 44 24 0c 8c 28 81 	movl   $0x81288c,0xc(%esp)
  802764:	00 
  802765:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80276c:	00 
  80276d:	c7 44 24 04 5a 00 00 	movl   $0x5a,0x4(%esp)
  802774:	00 
  802775:	c7 04 24 b6 28 81 00 	movl   $0x8128b6,(%esp)
  80277c:	e8 93 e1 ff ff       	call   800914 <_panic>
  return r;
}
  802781:	89 d8                	mov    %ebx,%eax
  802783:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802786:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802789:	89 ec                	mov    %ebp,%esp
  80278b:	5d                   	pop    %ebp
  80278c:	c3                   	ret    
  80278d:	00 00                	add    %al,(%eax)
	...

00802790 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  802790:	55                   	push   %ebp
  802791:	89 e5                	mov    %esp,%ebp
  802793:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<sock>");
  802796:	c7 44 24 04 c1 28 81 	movl   $0x8128c1,0x4(%esp)
  80279d:	00 
  80279e:	8b 45 0c             	mov    0xc(%ebp),%eax
  8027a1:	89 04 24             	mov    %eax,(%esp)
  8027a4:	e8 61 e9 ff ff       	call   80110a <strcpy>
	return 0;
}
  8027a9:	b8 00 00 00 00       	mov    $0x0,%eax
  8027ae:	c9                   	leave  
  8027af:	c3                   	ret    

008027b0 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  8027b0:	55                   	push   %ebp
  8027b1:	89 e5                	mov    %esp,%ebp
  8027b3:	53                   	push   %ebx
  8027b4:	83 ec 14             	sub    $0x14,%esp
  8027b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  8027ba:	89 1c 24             	mov    %ebx,(%esp)
  8027bd:	e8 22 08 00 00       	call   802fe4 <pageref>
  8027c2:	89 c2                	mov    %eax,%edx
  8027c4:	b8 00 00 00 00       	mov    $0x0,%eax
  8027c9:	83 fa 01             	cmp    $0x1,%edx
  8027cc:	75 0b                	jne    8027d9 <devsock_close+0x29>
		return nsipc_close(fd->fd_sock.sockid);
  8027ce:	8b 43 0c             	mov    0xc(%ebx),%eax
  8027d1:	89 04 24             	mov    %eax,(%esp)
  8027d4:	e8 b9 02 00 00       	call   802a92 <nsipc_close>
	else
		return 0;
}
  8027d9:	83 c4 14             	add    $0x14,%esp
  8027dc:	5b                   	pop    %ebx
  8027dd:	5d                   	pop    %ebp
  8027de:	c3                   	ret    

008027df <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  8027df:	55                   	push   %ebp
  8027e0:	89 e5                	mov    %esp,%ebp
  8027e2:	83 ec 18             	sub    $0x18,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  8027e5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8027ec:	00 
  8027ed:	8b 45 10             	mov    0x10(%ebp),%eax
  8027f0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8027f4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8027f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027fb:	8b 45 08             	mov    0x8(%ebp),%eax
  8027fe:	8b 40 0c             	mov    0xc(%eax),%eax
  802801:	89 04 24             	mov    %eax,(%esp)
  802804:	e8 c5 02 00 00       	call   802ace <nsipc_send>
}
  802809:	c9                   	leave  
  80280a:	c3                   	ret    

0080280b <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  80280b:	55                   	push   %ebp
  80280c:	89 e5                	mov    %esp,%ebp
  80280e:	83 ec 18             	sub    $0x18,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  802811:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  802818:	00 
  802819:	8b 45 10             	mov    0x10(%ebp),%eax
  80281c:	89 44 24 08          	mov    %eax,0x8(%esp)
  802820:	8b 45 0c             	mov    0xc(%ebp),%eax
  802823:	89 44 24 04          	mov    %eax,0x4(%esp)
  802827:	8b 45 08             	mov    0x8(%ebp),%eax
  80282a:	8b 40 0c             	mov    0xc(%eax),%eax
  80282d:	89 04 24             	mov    %eax,(%esp)
  802830:	e8 0c 03 00 00       	call   802b41 <nsipc_recv>
}
  802835:	c9                   	leave  
  802836:	c3                   	ret    

00802837 <alloc_sockfd>:
	return sfd->fd_sock.sockid;
}

static int
alloc_sockfd(int sockid)
{
  802837:	55                   	push   %ebp
  802838:	89 e5                	mov    %esp,%ebp
  80283a:	56                   	push   %esi
  80283b:	53                   	push   %ebx
  80283c:	83 ec 20             	sub    $0x20,%esp
  80283f:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  802841:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802844:	89 04 24             	mov    %eax,(%esp)
  802847:	e8 7f f6 ff ff       	call   801ecb <fd_alloc>
  80284c:	89 c3                	mov    %eax,%ebx
  80284e:	85 c0                	test   %eax,%eax
  802850:	78 21                	js     802873 <alloc_sockfd+0x3c>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  802852:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  802859:	00 
  80285a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80285d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802861:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802868:	e8 00 ef ff ff       	call   80176d <sys_page_alloc>
  80286d:	89 c3                	mov    %eax,%ebx
alloc_sockfd(int sockid)
{
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  80286f:	85 c0                	test   %eax,%eax
  802871:	79 0a                	jns    80287d <alloc_sockfd+0x46>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
		nsipc_close(sockid);
  802873:	89 34 24             	mov    %esi,(%esp)
  802876:	e8 17 02 00 00       	call   802a92 <nsipc_close>
		return r;
  80287b:	eb 28                	jmp    8028a5 <alloc_sockfd+0x6e>
	}

	sfd->fd_dev_id = devsock.dev_id;
  80287d:	8b 15 20 50 81 00    	mov    0x815020,%edx
  802883:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802886:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  802888:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80288b:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  802892:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802895:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  802898:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80289b:	89 04 24             	mov    %eax,(%esp)
  80289e:	e8 fd f5 ff ff       	call   801ea0 <fd2num>
  8028a3:	89 c3                	mov    %eax,%ebx
}
  8028a5:	89 d8                	mov    %ebx,%eax
  8028a7:	83 c4 20             	add    $0x20,%esp
  8028aa:	5b                   	pop    %ebx
  8028ab:	5e                   	pop    %esi
  8028ac:	5d                   	pop    %ebp
  8028ad:	c3                   	ret    

008028ae <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  8028ae:	55                   	push   %ebp
  8028af:	89 e5                	mov    %esp,%ebp
  8028b1:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  8028b4:	8b 45 10             	mov    0x10(%ebp),%eax
  8028b7:	89 44 24 08          	mov    %eax,0x8(%esp)
  8028bb:	8b 45 0c             	mov    0xc(%ebp),%eax
  8028be:	89 44 24 04          	mov    %eax,0x4(%esp)
  8028c2:	8b 45 08             	mov    0x8(%ebp),%eax
  8028c5:	89 04 24             	mov    %eax,(%esp)
  8028c8:	e8 79 01 00 00       	call   802a46 <nsipc_socket>
  8028cd:	85 c0                	test   %eax,%eax
  8028cf:	78 05                	js     8028d6 <socket+0x28>
		return r;
	return alloc_sockfd(r);
  8028d1:	e8 61 ff ff ff       	call   802837 <alloc_sockfd>
}
  8028d6:	c9                   	leave  
  8028d7:	c3                   	ret    

008028d8 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  8028d8:	55                   	push   %ebp
  8028d9:	89 e5                	mov    %esp,%ebp
  8028db:	83 ec 28             	sub    $0x28,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  8028de:	8d 55 f4             	lea    -0xc(%ebp),%edx
  8028e1:	89 54 24 04          	mov    %edx,0x4(%esp)
  8028e5:	89 04 24             	mov    %eax,(%esp)
  8028e8:	e8 50 f6 ff ff       	call   801f3d <fd_lookup>
  8028ed:	85 c0                	test   %eax,%eax
  8028ef:	78 15                	js     802906 <fd2sockid+0x2e>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  8028f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8028f4:	8b 0a                	mov    (%edx),%ecx
  8028f6:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8028fb:	3b 0d 20 50 81 00    	cmp    0x815020,%ecx
  802901:	75 03                	jne    802906 <fd2sockid+0x2e>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  802903:	8b 42 0c             	mov    0xc(%edx),%eax
}
  802906:	c9                   	leave  
  802907:	c3                   	ret    

00802908 <listen>:
	return nsipc_connect(r, name, namelen);
}

int
listen(int s, int backlog)
{
  802908:	55                   	push   %ebp
  802909:	89 e5                	mov    %esp,%ebp
  80290b:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80290e:	8b 45 08             	mov    0x8(%ebp),%eax
  802911:	e8 c2 ff ff ff       	call   8028d8 <fd2sockid>
  802916:	85 c0                	test   %eax,%eax
  802918:	78 0f                	js     802929 <listen+0x21>
		return r;
	return nsipc_listen(r, backlog);
  80291a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80291d:	89 54 24 04          	mov    %edx,0x4(%esp)
  802921:	89 04 24             	mov    %eax,(%esp)
  802924:	e8 47 01 00 00       	call   802a70 <nsipc_listen>
}
  802929:	c9                   	leave  
  80292a:	c3                   	ret    

0080292b <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  80292b:	55                   	push   %ebp
  80292c:	89 e5                	mov    %esp,%ebp
  80292e:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802931:	8b 45 08             	mov    0x8(%ebp),%eax
  802934:	e8 9f ff ff ff       	call   8028d8 <fd2sockid>
  802939:	85 c0                	test   %eax,%eax
  80293b:	78 16                	js     802953 <connect+0x28>
		return r;
	return nsipc_connect(r, name, namelen);
  80293d:	8b 55 10             	mov    0x10(%ebp),%edx
  802940:	89 54 24 08          	mov    %edx,0x8(%esp)
  802944:	8b 55 0c             	mov    0xc(%ebp),%edx
  802947:	89 54 24 04          	mov    %edx,0x4(%esp)
  80294b:	89 04 24             	mov    %eax,(%esp)
  80294e:	e8 6e 02 00 00       	call   802bc1 <nsipc_connect>
}
  802953:	c9                   	leave  
  802954:	c3                   	ret    

00802955 <shutdown>:
	return nsipc_bind(r, name, namelen);
}

int
shutdown(int s, int how)
{
  802955:	55                   	push   %ebp
  802956:	89 e5                	mov    %esp,%ebp
  802958:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80295b:	8b 45 08             	mov    0x8(%ebp),%eax
  80295e:	e8 75 ff ff ff       	call   8028d8 <fd2sockid>
  802963:	85 c0                	test   %eax,%eax
  802965:	78 0f                	js     802976 <shutdown+0x21>
		return r;
	return nsipc_shutdown(r, how);
  802967:	8b 55 0c             	mov    0xc(%ebp),%edx
  80296a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80296e:	89 04 24             	mov    %eax,(%esp)
  802971:	e8 36 01 00 00       	call   802aac <nsipc_shutdown>
}
  802976:	c9                   	leave  
  802977:	c3                   	ret    

00802978 <bind>:
	return alloc_sockfd(r);
}

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  802978:	55                   	push   %ebp
  802979:	89 e5                	mov    %esp,%ebp
  80297b:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80297e:	8b 45 08             	mov    0x8(%ebp),%eax
  802981:	e8 52 ff ff ff       	call   8028d8 <fd2sockid>
  802986:	85 c0                	test   %eax,%eax
  802988:	78 16                	js     8029a0 <bind+0x28>
		return r;
	return nsipc_bind(r, name, namelen);
  80298a:	8b 55 10             	mov    0x10(%ebp),%edx
  80298d:	89 54 24 08          	mov    %edx,0x8(%esp)
  802991:	8b 55 0c             	mov    0xc(%ebp),%edx
  802994:	89 54 24 04          	mov    %edx,0x4(%esp)
  802998:	89 04 24             	mov    %eax,(%esp)
  80299b:	e8 60 02 00 00       	call   802c00 <nsipc_bind>
}
  8029a0:	c9                   	leave  
  8029a1:	c3                   	ret    

008029a2 <accept>:
	return fd2num(sfd);
}

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8029a2:	55                   	push   %ebp
  8029a3:	89 e5                	mov    %esp,%ebp
  8029a5:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  8029a8:	8b 45 08             	mov    0x8(%ebp),%eax
  8029ab:	e8 28 ff ff ff       	call   8028d8 <fd2sockid>
  8029b0:	85 c0                	test   %eax,%eax
  8029b2:	78 1f                	js     8029d3 <accept+0x31>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  8029b4:	8b 55 10             	mov    0x10(%ebp),%edx
  8029b7:	89 54 24 08          	mov    %edx,0x8(%esp)
  8029bb:	8b 55 0c             	mov    0xc(%ebp),%edx
  8029be:	89 54 24 04          	mov    %edx,0x4(%esp)
  8029c2:	89 04 24             	mov    %eax,(%esp)
  8029c5:	e8 75 02 00 00       	call   802c3f <nsipc_accept>
  8029ca:	85 c0                	test   %eax,%eax
  8029cc:	78 05                	js     8029d3 <accept+0x31>
		return r;
	return alloc_sockfd(r);
  8029ce:	e8 64 fe ff ff       	call   802837 <alloc_sockfd>
}
  8029d3:	c9                   	leave  
  8029d4:	c3                   	ret    
	...

008029e0 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  8029e0:	55                   	push   %ebp
  8029e1:	89 e5                	mov    %esp,%ebp
  8029e3:	53                   	push   %ebx
  8029e4:	83 ec 14             	sub    $0x14,%esp
  8029e7:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  8029e9:	83 3d 94 60 81 00 00 	cmpl   $0x0,0x816094
  8029f0:	75 11                	jne    802a03 <nsipc+0x23>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  8029f2:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  8029f9:	e8 52 f3 ff ff       	call   801d50 <ipc_find_env>
  8029fe:	a3 94 60 81 00       	mov    %eax,0x816094
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  802a03:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  802a0a:	00 
  802a0b:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  802a12:	00 
  802a13:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802a17:	a1 94 60 81 00       	mov    0x816094,%eax
  802a1c:	89 04 24             	mov    %eax,(%esp)
  802a1f:	e8 75 f3 ff ff       	call   801d99 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  802a24:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802a2b:	00 
  802a2c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802a33:	00 
  802a34:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802a3b:	e8 c4 f3 ff ff       	call   801e04 <ipc_recv>
}
  802a40:	83 c4 14             	add    $0x14,%esp
  802a43:	5b                   	pop    %ebx
  802a44:	5d                   	pop    %ebp
  802a45:	c3                   	ret    

00802a46 <nsipc_socket>:
	return nsipc(NSREQ_SEND);
}

int
nsipc_socket(int domain, int type, int protocol)
{
  802a46:	55                   	push   %ebp
  802a47:	89 e5                	mov    %esp,%ebp
  802a49:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  802a4c:	8b 45 08             	mov    0x8(%ebp),%eax
  802a4f:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.socket.req_type = type;
  802a54:	8b 45 0c             	mov    0xc(%ebp),%eax
  802a57:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	nsipcbuf.socket.req_protocol = protocol;
  802a5c:	8b 45 10             	mov    0x10(%ebp),%eax
  802a5f:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SOCKET);
  802a64:	b8 09 00 00 00       	mov    $0x9,%eax
  802a69:	e8 72 ff ff ff       	call   8029e0 <nsipc>
}
  802a6e:	c9                   	leave  
  802a6f:	c3                   	ret    

00802a70 <nsipc_listen>:
	return nsipc(NSREQ_CONNECT);
}

int
nsipc_listen(int s, int backlog)
{
  802a70:	55                   	push   %ebp
  802a71:	89 e5                	mov    %esp,%ebp
  802a73:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  802a76:	8b 45 08             	mov    0x8(%ebp),%eax
  802a79:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.listen.req_backlog = backlog;
  802a7e:	8b 45 0c             	mov    0xc(%ebp),%eax
  802a81:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_LISTEN);
  802a86:	b8 06 00 00 00       	mov    $0x6,%eax
  802a8b:	e8 50 ff ff ff       	call   8029e0 <nsipc>
}
  802a90:	c9                   	leave  
  802a91:	c3                   	ret    

00802a92 <nsipc_close>:
	return nsipc(NSREQ_SHUTDOWN);
}

int
nsipc_close(int s)
{
  802a92:	55                   	push   %ebp
  802a93:	89 e5                	mov    %esp,%ebp
  802a95:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  802a98:	8b 45 08             	mov    0x8(%ebp),%eax
  802a9b:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	return nsipc(NSREQ_CLOSE);
  802aa0:	b8 04 00 00 00       	mov    $0x4,%eax
  802aa5:	e8 36 ff ff ff       	call   8029e0 <nsipc>
}
  802aaa:	c9                   	leave  
  802aab:	c3                   	ret    

00802aac <nsipc_shutdown>:
	return nsipc(NSREQ_BIND);
}

int
nsipc_shutdown(int s, int how)
{
  802aac:	55                   	push   %ebp
  802aad:	89 e5                	mov    %esp,%ebp
  802aaf:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  802ab2:	8b 45 08             	mov    0x8(%ebp),%eax
  802ab5:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.shutdown.req_how = how;
  802aba:	8b 45 0c             	mov    0xc(%ebp),%eax
  802abd:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_SHUTDOWN);
  802ac2:	b8 03 00 00 00       	mov    $0x3,%eax
  802ac7:	e8 14 ff ff ff       	call   8029e0 <nsipc>
}
  802acc:	c9                   	leave  
  802acd:	c3                   	ret    

00802ace <nsipc_send>:
	return r;
}

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  802ace:	55                   	push   %ebp
  802acf:	89 e5                	mov    %esp,%ebp
  802ad1:	53                   	push   %ebx
  802ad2:	83 ec 14             	sub    $0x14,%esp
  802ad5:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  802ad8:	8b 45 08             	mov    0x8(%ebp),%eax
  802adb:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	assert(size < 1600);
  802ae0:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  802ae6:	7e 24                	jle    802b0c <nsipc_send+0x3e>
  802ae8:	c7 44 24 0c cd 28 81 	movl   $0x8128cd,0xc(%esp)
  802aef:	00 
  802af0:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  802af7:	00 
  802af8:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  802aff:	00 
  802b00:	c7 04 24 d9 28 81 00 	movl   $0x8128d9,(%esp)
  802b07:	e8 08 de ff ff       	call   800914 <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  802b0c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802b10:	8b 45 0c             	mov    0xc(%ebp),%eax
  802b13:	89 44 24 04          	mov    %eax,0x4(%esp)
  802b17:	c7 04 24 0c e0 b3 00 	movl   $0xb3e00c,(%esp)
  802b1e:	e8 d2 e7 ff ff       	call   8012f5 <memmove>
	nsipcbuf.send.req_size = size;
  802b23:	89 1d 04 e0 b3 00    	mov    %ebx,0xb3e004
	nsipcbuf.send.req_flags = flags;
  802b29:	8b 45 14             	mov    0x14(%ebp),%eax
  802b2c:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SEND);
  802b31:	b8 08 00 00 00       	mov    $0x8,%eax
  802b36:	e8 a5 fe ff ff       	call   8029e0 <nsipc>
}
  802b3b:	83 c4 14             	add    $0x14,%esp
  802b3e:	5b                   	pop    %ebx
  802b3f:	5d                   	pop    %ebp
  802b40:	c3                   	ret    

00802b41 <nsipc_recv>:
	return nsipc(NSREQ_LISTEN);
}

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  802b41:	55                   	push   %ebp
  802b42:	89 e5                	mov    %esp,%ebp
  802b44:	56                   	push   %esi
  802b45:	53                   	push   %ebx
  802b46:	83 ec 10             	sub    $0x10,%esp
  802b49:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  802b4c:	8b 45 08             	mov    0x8(%ebp),%eax
  802b4f:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.recv.req_len = len;
  802b54:	89 35 04 e0 b3 00    	mov    %esi,0xb3e004
	nsipcbuf.recv.req_flags = flags;
  802b5a:	8b 45 14             	mov    0x14(%ebp),%eax
  802b5d:	a3 08 e0 b3 00       	mov    %eax,0xb3e008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  802b62:	b8 07 00 00 00       	mov    $0x7,%eax
  802b67:	e8 74 fe ff ff       	call   8029e0 <nsipc>
  802b6c:	89 c3                	mov    %eax,%ebx
  802b6e:	85 c0                	test   %eax,%eax
  802b70:	78 46                	js     802bb8 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  802b72:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  802b77:	7f 04                	jg     802b7d <nsipc_recv+0x3c>
  802b79:	39 c6                	cmp    %eax,%esi
  802b7b:	7d 24                	jge    802ba1 <nsipc_recv+0x60>
  802b7d:	c7 44 24 0c e5 28 81 	movl   $0x8128e5,0xc(%esp)
  802b84:	00 
  802b85:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  802b8c:	00 
  802b8d:	c7 44 24 04 61 00 00 	movl   $0x61,0x4(%esp)
  802b94:	00 
  802b95:	c7 04 24 d9 28 81 00 	movl   $0x8128d9,(%esp)
  802b9c:	e8 73 dd ff ff       	call   800914 <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  802ba1:	89 44 24 08          	mov    %eax,0x8(%esp)
  802ba5:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  802bac:	00 
  802bad:	8b 45 0c             	mov    0xc(%ebp),%eax
  802bb0:	89 04 24             	mov    %eax,(%esp)
  802bb3:	e8 3d e7 ff ff       	call   8012f5 <memmove>
	}

	return r;
}
  802bb8:	89 d8                	mov    %ebx,%eax
  802bba:	83 c4 10             	add    $0x10,%esp
  802bbd:	5b                   	pop    %ebx
  802bbe:	5e                   	pop    %esi
  802bbf:	5d                   	pop    %ebp
  802bc0:	c3                   	ret    

00802bc1 <nsipc_connect>:
	return nsipc(NSREQ_CLOSE);
}

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  802bc1:	55                   	push   %ebp
  802bc2:	89 e5                	mov    %esp,%ebp
  802bc4:	53                   	push   %ebx
  802bc5:	83 ec 14             	sub    $0x14,%esp
  802bc8:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  802bcb:	8b 45 08             	mov    0x8(%ebp),%eax
  802bce:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  802bd3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802bd7:	8b 45 0c             	mov    0xc(%ebp),%eax
  802bda:	89 44 24 04          	mov    %eax,0x4(%esp)
  802bde:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  802be5:	e8 0b e7 ff ff       	call   8012f5 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  802bea:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_CONNECT);
  802bf0:	b8 05 00 00 00       	mov    $0x5,%eax
  802bf5:	e8 e6 fd ff ff       	call   8029e0 <nsipc>
}
  802bfa:	83 c4 14             	add    $0x14,%esp
  802bfd:	5b                   	pop    %ebx
  802bfe:	5d                   	pop    %ebp
  802bff:	c3                   	ret    

00802c00 <nsipc_bind>:
	return r;
}

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  802c00:	55                   	push   %ebp
  802c01:	89 e5                	mov    %esp,%ebp
  802c03:	53                   	push   %ebx
  802c04:	83 ec 14             	sub    $0x14,%esp
  802c07:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  802c0a:	8b 45 08             	mov    0x8(%ebp),%eax
  802c0d:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  802c12:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802c16:	8b 45 0c             	mov    0xc(%ebp),%eax
  802c19:	89 44 24 04          	mov    %eax,0x4(%esp)
  802c1d:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  802c24:	e8 cc e6 ff ff       	call   8012f5 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  802c29:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_BIND);
  802c2f:	b8 02 00 00 00       	mov    $0x2,%eax
  802c34:	e8 a7 fd ff ff       	call   8029e0 <nsipc>
}
  802c39:	83 c4 14             	add    $0x14,%esp
  802c3c:	5b                   	pop    %ebx
  802c3d:	5d                   	pop    %ebp
  802c3e:	c3                   	ret    

00802c3f <nsipc_accept>:
	return ipc_recv(NULL, NULL, NULL);
}

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  802c3f:	55                   	push   %ebp
  802c40:	89 e5                	mov    %esp,%ebp
  802c42:	83 ec 18             	sub    $0x18,%esp
  802c45:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802c48:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int r;

	nsipcbuf.accept.req_s = s;
  802c4b:	8b 45 08             	mov    0x8(%ebp),%eax
  802c4e:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  802c53:	b8 01 00 00 00       	mov    $0x1,%eax
  802c58:	e8 83 fd ff ff       	call   8029e0 <nsipc>
  802c5d:	89 c3                	mov    %eax,%ebx
  802c5f:	85 c0                	test   %eax,%eax
  802c61:	78 25                	js     802c88 <nsipc_accept+0x49>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  802c63:	be 10 e0 b3 00       	mov    $0xb3e010,%esi
  802c68:	8b 06                	mov    (%esi),%eax
  802c6a:	89 44 24 08          	mov    %eax,0x8(%esp)
  802c6e:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  802c75:	00 
  802c76:	8b 45 0c             	mov    0xc(%ebp),%eax
  802c79:	89 04 24             	mov    %eax,(%esp)
  802c7c:	e8 74 e6 ff ff       	call   8012f5 <memmove>
		*addrlen = ret->ret_addrlen;
  802c81:	8b 16                	mov    (%esi),%edx
  802c83:	8b 45 10             	mov    0x10(%ebp),%eax
  802c86:	89 10                	mov    %edx,(%eax)
	}
	return r;
}
  802c88:	89 d8                	mov    %ebx,%eax
  802c8a:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802c8d:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802c90:	89 ec                	mov    %ebp,%esp
  802c92:	5d                   	pop    %ebp
  802c93:	c3                   	ret    
	...

00802ca0 <free>:
	return v;
}

void
free(void *v)
{
  802ca0:	55                   	push   %ebp
  802ca1:	89 e5                	mov    %esp,%ebp
  802ca3:	56                   	push   %esi
  802ca4:	53                   	push   %ebx
  802ca5:	83 ec 10             	sub    $0x10,%esp
  802ca8:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  802cab:	85 db                	test   %ebx,%ebx
  802cad:	0f 84 b9 00 00 00    	je     802d6c <free+0xcc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  802cb3:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  802cb9:	76 08                	jbe    802cc3 <free+0x23>
  802cbb:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  802cc1:	76 24                	jbe    802ce7 <free+0x47>
  802cc3:	c7 44 24 0c fc 28 81 	movl   $0x8128fc,0xc(%esp)
  802cca:	00 
  802ccb:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  802cd2:	00 
  802cd3:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  802cda:	00 
  802cdb:	c7 04 24 2a 29 81 00 	movl   $0x81292a,(%esp)
  802ce2:	e8 2d dc ff ff       	call   800914 <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  802ce7:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (vpt[PGNUM(c)] & PTE_CONTINUED) {
  802ced:	be 00 00 40 ef       	mov    $0xef400000,%esi
  802cf2:	eb 4a                	jmp    802d3e <free+0x9e>
		sys_page_unmap(0, c);
  802cf4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802cf8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802cff:	e8 f8 e9 ff ff       	call   8016fc <sys_page_unmap>
		c += PGSIZE;
  802d04:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  802d0a:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  802d10:	76 08                	jbe    802d1a <free+0x7a>
  802d12:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  802d18:	76 24                	jbe    802d3e <free+0x9e>
  802d1a:	c7 44 24 0c 37 29 81 	movl   $0x812937,0xc(%esp)
  802d21:	00 
  802d22:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  802d29:	00 
  802d2a:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  802d31:	00 
  802d32:	c7 04 24 2a 29 81 00 	movl   $0x81292a,(%esp)
  802d39:	e8 d6 db ff ff       	call   800914 <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (vpt[PGNUM(c)] & PTE_CONTINUED) {
  802d3e:	89 d8                	mov    %ebx,%eax
  802d40:	c1 e8 0c             	shr    $0xc,%eax
  802d43:	8b 04 86             	mov    (%esi,%eax,4),%eax
  802d46:	f6 c4 04             	test   $0x4,%ah
  802d49:	75 a9                	jne    802cf4 <free+0x54>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  802d4b:	8d 93 fc 0f 00 00    	lea    0xffc(%ebx),%edx
	if (--(*ref) == 0)
  802d51:	8b 02                	mov    (%edx),%eax
  802d53:	83 e8 01             	sub    $0x1,%eax
  802d56:	89 02                	mov    %eax,(%edx)
  802d58:	85 c0                	test   %eax,%eax
  802d5a:	75 10                	jne    802d6c <free+0xcc>
		sys_page_unmap(0, c);
  802d5c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802d60:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802d67:	e8 90 e9 ff ff       	call   8016fc <sys_page_unmap>
}
  802d6c:	83 c4 10             	add    $0x10,%esp
  802d6f:	5b                   	pop    %ebx
  802d70:	5e                   	pop    %esi
  802d71:	5d                   	pop    %ebp
  802d72:	c3                   	ret    

00802d73 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  802d73:	55                   	push   %ebp
  802d74:	89 e5                	mov    %esp,%ebp
  802d76:	57                   	push   %edi
  802d77:	56                   	push   %esi
  802d78:	53                   	push   %ebx
  802d79:	83 ec 3c             	sub    $0x3c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  802d7c:	83 3d 98 60 81 00 00 	cmpl   $0x0,0x816098
  802d83:	75 0a                	jne    802d8f <malloc+0x1c>
		mptr = mbegin;
  802d85:	c7 05 98 60 81 00 00 	movl   $0x8000000,0x816098
  802d8c:	00 00 08 

	n = ROUNDUP(n, 4);
  802d8f:	8b 45 08             	mov    0x8(%ebp),%eax
  802d92:	83 c0 03             	add    $0x3,%eax
  802d95:	83 e0 fc             	and    $0xfffffffc,%eax
  802d98:	89 45 d8             	mov    %eax,-0x28(%ebp)

	if (n >= MAXMALLOC)
  802d9b:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  802da0:	0f 87 97 01 00 00    	ja     802f3d <malloc+0x1ca>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  802da6:	a1 98 60 81 00       	mov    0x816098,%eax
  802dab:	89 c2                	mov    %eax,%edx
  802dad:	a9 ff 0f 00 00       	test   $0xfff,%eax
  802db2:	74 4d                	je     802e01 <malloc+0x8e>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  802db4:	89 c3                	mov    %eax,%ebx
  802db6:	c1 eb 0c             	shr    $0xc,%ebx
  802db9:	8b 75 d8             	mov    -0x28(%ebp),%esi
  802dbc:	8d 4c 30 03          	lea    0x3(%eax,%esi,1),%ecx
  802dc0:	c1 e9 0c             	shr    $0xc,%ecx
  802dc3:	39 cb                	cmp    %ecx,%ebx
  802dc5:	75 1e                	jne    802de5 <malloc+0x72>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  802dc7:	81 c2 ff 0f 00 00    	add    $0xfff,%edx
  802dcd:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  802dd3:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  802dd7:	8d 14 30             	lea    (%eax,%esi,1),%edx
  802dda:	89 15 98 60 81 00    	mov    %edx,0x816098
			return v;
  802de0:	e9 5d 01 00 00       	jmp    802f42 <malloc+0x1cf>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  802de5:	89 04 24             	mov    %eax,(%esp)
  802de8:	e8 b3 fe ff ff       	call   802ca0 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  802ded:	a1 98 60 81 00       	mov    0x816098,%eax
  802df2:	05 00 10 00 00       	add    $0x1000,%eax
  802df7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  802dfc:	a3 98 60 81 00       	mov    %eax,0x816098
  802e01:	8b 3d 98 60 81 00    	mov    0x816098,%edi
  802e07:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			return 0;
	return 1;
}

void*
malloc(size_t n)
  802e0e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  802e11:	83 c0 04             	add    $0x4,%eax
  802e14:	89 45 dc             	mov    %eax,-0x24(%ebp)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[PGNUM(va)] & PTE_P)))
  802e17:	bb 00 d0 7b ef       	mov    $0xef7bd000,%ebx
  802e1c:	be 00 00 40 ef       	mov    $0xef400000,%esi
			return 0;
	return 1;
}

void*
malloc(size_t n)
  802e21:	8b 45 dc             	mov    -0x24(%ebp),%eax
  802e24:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  802e27:	8d 0c 07             	lea    (%edi,%eax,1),%ecx
  802e2a:	89 7d e4             	mov    %edi,-0x1c(%ebp)
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  802e2d:	39 cf                	cmp    %ecx,%edi
  802e2f:	0f 83 d7 00 00 00    	jae    802f0c <malloc+0x199>
		if (va >= (uintptr_t) mend
  802e35:	89 f8                	mov    %edi,%eax
  802e37:	81 ff ff ff ff 0f    	cmp    $0xfffffff,%edi
  802e3d:	76 09                	jbe    802e48 <malloc+0xd5>
  802e3f:	eb 38                	jmp    802e79 <malloc+0x106>
  802e41:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  802e46:	77 31                	ja     802e79 <malloc+0x106>
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[PGNUM(va)] & PTE_P)))
  802e48:	89 c2                	mov    %eax,%edx
  802e4a:	c1 ea 16             	shr    $0x16,%edx
  802e4d:	8b 14 93             	mov    (%ebx,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  802e50:	f6 c2 01             	test   $0x1,%dl
  802e53:	74 0d                	je     802e62 <malloc+0xef>
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[PGNUM(va)] & PTE_P)))
  802e55:	89 c2                	mov    %eax,%edx
  802e57:	c1 ea 0c             	shr    $0xc,%edx
  802e5a:	8b 14 96             	mov    (%esi,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  802e5d:	f6 c2 01             	test   $0x1,%dl
  802e60:	75 17                	jne    802e79 <malloc+0x106>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  802e62:	05 00 10 00 00       	add    $0x1000,%eax
  802e67:	39 c8                	cmp    %ecx,%eax
  802e69:	72 d6                	jb     802e41 <malloc+0xce>
  802e6b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802e6e:	89 35 98 60 81 00    	mov    %esi,0x816098
  802e74:	e9 9b 00 00 00       	jmp    802f14 <malloc+0x1a1>
  802e79:	81 c7 00 10 00 00    	add    $0x1000,%edi
  802e7f:	81 c1 00 10 00 00    	add    $0x1000,%ecx
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  802e85:	81 ff 00 00 00 10    	cmp    $0x10000000,%edi
  802e8b:	75 9d                	jne    802e2a <malloc+0xb7>
			mptr = mbegin;
			if (++nwrap == 2)
  802e8d:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  802e91:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
  802e95:	74 07                	je     802e9e <malloc+0x12b>
  802e97:	bf 00 00 00 08       	mov    $0x8000000,%edi
  802e9c:	eb 83                	jmp    802e21 <malloc+0xae>
  802e9e:	c7 05 98 60 81 00 00 	movl   $0x8000000,0x816098
  802ea5:	00 00 08 
  802ea8:	b8 00 00 00 00       	mov    $0x0,%eax
  802ead:	e9 90 00 00 00       	jmp    802f42 <malloc+0x1cf>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  802eb2:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  802eb8:	39 fe                	cmp    %edi,%esi
  802eba:	19 c0                	sbb    %eax,%eax
  802ebc:	25 00 04 00 00       	and    $0x400,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  802ec1:	83 c8 07             	or     $0x7,%eax
  802ec4:	89 44 24 08          	mov    %eax,0x8(%esp)
  802ec8:	03 15 98 60 81 00    	add    0x816098,%edx
  802ece:	89 54 24 04          	mov    %edx,0x4(%esp)
  802ed2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802ed9:	e8 8f e8 ff ff       	call   80176d <sys_page_alloc>
  802ede:	85 c0                	test   %eax,%eax
  802ee0:	78 04                	js     802ee6 <malloc+0x173>
  802ee2:	89 f3                	mov    %esi,%ebx
  802ee4:	eb 36                	jmp    802f1c <malloc+0x1a9>
			for (; i >= 0; i -= PGSIZE)
  802ee6:	85 db                	test   %ebx,%ebx
  802ee8:	78 53                	js     802f3d <malloc+0x1ca>
				sys_page_unmap(0, mptr + i);
  802eea:	89 d8                	mov    %ebx,%eax
  802eec:	03 05 98 60 81 00    	add    0x816098,%eax
  802ef2:	89 44 24 04          	mov    %eax,0x4(%esp)
  802ef6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802efd:	e8 fa e7 ff ff       	call   8016fc <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  802f02:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  802f08:	79 e0                	jns    802eea <malloc+0x177>
  802f0a:	eb 31                	jmp    802f3d <malloc+0x1ca>
  802f0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802f0f:	a3 98 60 81 00       	mov    %eax,0x816098
  802f14:	bb 00 00 00 00       	mov    $0x0,%ebx
  802f19:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  802f1c:	89 da                	mov    %ebx,%edx
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  802f1e:	39 fb                	cmp    %edi,%ebx
  802f20:	72 90                	jb     802eb2 <malloc+0x13f>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  802f22:	a1 98 60 81 00       	mov    0x816098,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  802f27:	c7 44 18 fc 02 00 00 	movl   $0x2,-0x4(%eax,%ebx,1)
  802f2e:	00 
	v = mptr;
	mptr += n;
  802f2f:	8b 55 d8             	mov    -0x28(%ebp),%edx
  802f32:	8d 14 10             	lea    (%eax,%edx,1),%edx
  802f35:	89 15 98 60 81 00    	mov    %edx,0x816098
	return v;
  802f3b:	eb 05                	jmp    802f42 <malloc+0x1cf>
  802f3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802f42:	83 c4 3c             	add    $0x3c,%esp
  802f45:	5b                   	pop    %ebx
  802f46:	5e                   	pop    %esi
  802f47:	5f                   	pop    %edi
  802f48:	5d                   	pop    %ebp
  802f49:	c3                   	ret    
	...

00802f4c <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  802f4c:	55                   	push   %ebp
  802f4d:	89 e5                	mov    %esp,%ebp
  802f4f:	83 ec 18             	sub    $0x18,%esp
	int r;

	if (_pgfault_handler == 0) {
  802f52:	83 3d 00 f0 b3 00 00 	cmpl   $0x0,0xb3f000
  802f59:	75 54                	jne    802faf <set_pgfault_handler+0x63>
		// First time through!
		// LAB 4: Your code here.
		if ((r = sys_page_alloc(0, (void*) (UXSTACKTOP - PGSIZE), PTE_U|PTE_P|PTE_W)) < 0)
  802f5b:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  802f62:	00 
  802f63:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  802f6a:	ee 
  802f6b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802f72:	e8 f6 e7 ff ff       	call   80176d <sys_page_alloc>
  802f77:	85 c0                	test   %eax,%eax
  802f79:	79 20                	jns    802f9b <set_pgfault_handler+0x4f>
			panic ("set_pgfault_handler: %e", r);
  802f7b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  802f7f:	c7 44 24 08 4f 29 81 	movl   $0x81294f,0x8(%esp)
  802f86:	00 
  802f87:	c7 44 24 04 21 00 00 	movl   $0x21,0x4(%esp)
  802f8e:	00 
  802f8f:	c7 04 24 67 29 81 00 	movl   $0x812967,(%esp)
  802f96:	e8 79 d9 ff ff       	call   800914 <_panic>
		sys_env_set_pgfault_upcall (0, _pgfault_upcall);
  802f9b:	c7 44 24 04 bc 2f 80 	movl   $0x802fbc,0x4(%esp)
  802fa2:	00 
  802fa3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802faa:	e8 a5 e6 ff ff       	call   801654 <sys_env_set_pgfault_upcall>

			//panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  802faf:	8b 45 08             	mov    0x8(%ebp),%eax
  802fb2:	a3 00 f0 b3 00       	mov    %eax,0xb3f000
}
  802fb7:	c9                   	leave  
  802fb8:	c3                   	ret    
  802fb9:	00 00                	add    %al,(%eax)
	...

00802fbc <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  802fbc:	54                   	push   %esp
	movl _pgfault_handler, %eax
  802fbd:	a1 00 f0 b3 00       	mov    0xb3f000,%eax
	call *%eax
  802fc2:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  802fc4:	83 c4 04             	add    $0x4,%esp
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.

	movl 0x30(%esp), %eax
  802fc7:	8b 44 24 30          	mov    0x30(%esp),%eax
	subl $0x4, %eax
  802fcb:	83 e8 04             	sub    $0x4,%eax
	movl %eax, 0x30(%esp)
  802fce:	89 44 24 30          	mov    %eax,0x30(%esp)
	# put old eip in the pre-reserved 4 bytes space
	movl 0x28(%esp), %ebx
  802fd2:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	movl %ebx, (%eax)
  802fd6:	89 18                	mov    %ebx,(%eax)

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	
	addl $0x8, %esp
  802fd8:	83 c4 08             	add    $0x8,%esp
	popal
  802fdb:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.

	addl $0x4, %esp
  802fdc:	83 c4 04             	add    $0x4,%esp
	popfl
  802fdf:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	pop %esp
  802fe0:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	ret
  802fe1:	c3                   	ret    
	...

00802fe4 <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  802fe4:	55                   	push   %ebp
  802fe5:	89 e5                	mov    %esp,%ebp
	pte_t pte;

	if (!(vpd[PDX(v)] & PTE_P))
  802fe7:	8b 45 08             	mov    0x8(%ebp),%eax
  802fea:	89 c2                	mov    %eax,%edx
  802fec:	c1 ea 16             	shr    $0x16,%edx
  802fef:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  802ff6:	f6 c2 01             	test   $0x1,%dl
  802ff9:	74 20                	je     80301b <pageref+0x37>
		return 0;
	pte = vpt[PGNUM(v)];
  802ffb:	c1 e8 0c             	shr    $0xc,%eax
  802ffe:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if (!(pte & PTE_P))
  803005:	a8 01                	test   $0x1,%al
  803007:	74 12                	je     80301b <pageref+0x37>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  803009:	c1 e8 0c             	shr    $0xc,%eax
  80300c:	ba 00 00 00 ef       	mov    $0xef000000,%edx
  803011:	0f b7 44 c2 04       	movzwl 0x4(%edx,%eax,8),%eax
  803016:	0f b7 c0             	movzwl %ax,%eax
  803019:	eb 05                	jmp    803020 <pageref+0x3c>
  80301b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803020:	5d                   	pop    %ebp
  803021:	c3                   	ret    
	...

00803030 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  803030:	55                   	push   %ebp
  803031:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  803033:	83 f8 1f             	cmp    $0x1f,%eax
  803036:	76 11                	jbe    803049 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  803038:	c7 05 20 c2 b3 00 09 	movl   $0x9,0xb3c220
  80303f:	00 00 00 
  803042:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  803047:	eb 1e                	jmp    803067 <get_socket+0x37>
  }

  sock = &sockets[s];
  803049:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80304c:	8d 04 85 a0 60 81 00 	lea    0x8160a0(,%eax,4),%eax

  if (!sock->conn) {
  803053:	83 38 00             	cmpl   $0x0,(%eax)
  803056:	75 0f                	jne    803067 <get_socket+0x37>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  803058:	c7 05 20 c2 b3 00 09 	movl   $0x9,0xb3c220
  80305f:	00 00 00 
  803062:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  }

  return sock;
}
  803067:	5d                   	pop    %ebp
  803068:	c3                   	ret    

00803069 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  803069:	55                   	push   %ebp
  80306a:	89 e5                	mov    %esp,%ebp
  80306c:	56                   	push   %esi
  80306d:	53                   	push   %ebx
  80306e:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  803071:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  803074:	8b 45 08             	mov    0x8(%ebp),%eax
  803077:	e8 b4 ff ff ff       	call   803030 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  80307c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  803081:	85 c0                	test   %eax,%eax
  803083:	0f 84 a6 00 00 00    	je     80312f <lwip_ioctl+0xc6>
    return -1;

  switch (cmd) {
  803089:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  80308f:	74 59                	je     8030ea <lwip_ioctl+0x81>
  803091:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  803097:	0f 85 7c 00 00 00    	jne    803119 <lwip_ioctl+0xb0>
  case FIONREAD:
    if (!argp) {
  80309d:	85 f6                	test   %esi,%esi
  80309f:	90                   	nop
  8030a0:	75 13                	jne    8030b5 <lwip_ioctl+0x4c>
      sock_set_errno(sock, EINVAL);
  8030a2:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  8030a9:	c7 05 20 c2 b3 00 16 	movl   $0x16,0xb3c220
  8030b0:	00 00 00 
      return -1;
  8030b3:	eb 7a                	jmp    80312f <lwip_ioctl+0xc6>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  8030b5:	8b 10                	mov    (%eax),%edx
  8030b7:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  8030bb:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  8030be:	8b 48 04             	mov    0x4(%eax),%ecx
  8030c1:	85 c9                	test   %ecx,%ecx
  8030c3:	74 0d                	je     8030d2 <lwip_ioctl+0x69>
      buflen = netbuf_len(sock->lastdata);
  8030c5:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  8030c7:	66 03 51 08          	add    0x8(%ecx),%dx
  8030cb:	66 2b 50 08          	sub    0x8(%eax),%dx
  8030cf:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  8030d2:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  8030d9:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8030e0:	00 00 00 
  8030e3:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  8030e8:	eb 45                	jmp    80312f <lwip_ioctl+0xc6>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8030ea:	85 f6                	test   %esi,%esi
  8030ec:	74 0d                	je     8030fb <lwip_ioctl+0x92>
  8030ee:	83 3e 00             	cmpl   $0x0,(%esi)
  8030f1:	74 08                	je     8030fb <lwip_ioctl+0x92>
      sock->flags |= O_NONBLOCK;
  8030f3:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
    return 0;

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8030f9:	eb 06                	jmp    803101 <lwip_ioctl+0x98>
      sock->flags |= O_NONBLOCK;
    else
      sock->flags &= ~O_NONBLOCK;
  8030fb:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  803101:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  803108:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  80310f:	00 00 00 
  803112:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  803117:	eb 16                	jmp    80312f <lwip_ioctl+0xc6>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  803119:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  803120:	c7 05 20 c2 b3 00 26 	movl   $0x26,0xb3c220
  803127:	00 00 00 
  80312a:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    return -1;
  } /* switch (cmd) */
}
  80312f:	89 d0                	mov    %edx,%eax
  803131:	5b                   	pop    %ebx
  803132:	5e                   	pop    %esi
  803133:	5d                   	pop    %ebp
  803134:	c3                   	ret    

00803135 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  803135:	55                   	push   %ebp
  803136:	89 e5                	mov    %esp,%ebp
  803138:	83 ec 48             	sub    $0x48,%esp
  80313b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80313e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803141:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803144:	8b 75 0c             	mov    0xc(%ebp),%esi
  803147:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  80314a:	8b 45 08             	mov    0x8(%ebp),%eax
  80314d:	e8 de fe ff ff       	call   803030 <get_socket>
  803152:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  803154:	85 c0                	test   %eax,%eax
  803156:	0f 84 52 01 00 00    	je     8032ae <lwip_setsockopt+0x179>
    return -1;

  if (NULL == optval) {
  80315c:	85 ff                	test   %edi,%edi
  80315e:	75 1b                	jne    80317b <lwip_setsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  803160:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  803167:	c7 05 20 c2 b3 00 0e 	movl   $0xe,0xb3c220
  80316e:	00 00 00 
  803171:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  803176:	e9 3f 01 00 00       	jmp    8032ba <lwip_setsockopt+0x185>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  80317b:	83 fe 06             	cmp    $0x6,%esi
  80317e:	0f 84 8e 00 00 00    	je     803212 <lwip_setsockopt+0xdd>
  803184:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  80318a:	74 11                	je     80319d <lwip_setsockopt+0x68>
  80318c:	85 f6                	test   %esi,%esi
  80318e:	66 90                	xchg   %ax,%ax
  803190:	74 66                	je     8031f8 <lwip_setsockopt+0xc3>
  803192:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  803198:	e9 a0 00 00 00       	jmp    80323d <lwip_setsockopt+0x108>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80319d:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8031a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8031a8:	74 1c                	je     8031c6 <lwip_setsockopt+0x91>
  8031aa:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8031b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8031b8:	74 1b                	je     8031d5 <lwip_setsockopt+0xa0>
  8031ba:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8031be:	66 90                	xchg   %ax,%ax
  8031c0:	0f 85 77 00 00 00    	jne    80323d <lwip_setsockopt+0x108>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  8031c6:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8031ca:	0f 86 f7 00 00 00    	jbe    8032c7 <lwip_setsockopt+0x192>
  8031d0:	e9 80 00 00 00       	jmp    803255 <lwip_setsockopt+0x120>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  8031d5:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  8031d9:	19 c0                	sbb    %eax,%eax
  8031db:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8031de:	8b 13                	mov    (%ebx),%edx
  8031e0:	83 3a 20             	cmpl   $0x20,(%edx)
  8031e3:	0f 85 e8 00 00 00    	jne    8032d1 <lwip_setsockopt+0x19c>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  8031e9:	8b 52 08             	mov    0x8(%edx),%edx
  8031ec:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  8031f0:	0f 85 db 00 00 00    	jne    8032d1 <lwip_setsockopt+0x19c>
  8031f6:	eb 4a                	jmp    803242 <lwip_setsockopt+0x10d>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8031f8:	8b 45 10             	mov    0x10(%ebp),%eax
  8031fb:	83 e8 01             	sub    $0x1,%eax
  8031fe:	83 f8 01             	cmp    $0x1,%eax
  803201:	77 3a                	ja     80323d <lwip_setsockopt+0x108>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  803203:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  803207:	0f 86 ba 00 00 00    	jbe    8032c7 <lwip_setsockopt+0x192>
  80320d:	8d 76 00             	lea    0x0(%esi),%esi
  803210:	eb 43                	jmp    803255 <lwip_setsockopt+0x120>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  803212:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  803216:	66 90                	xchg   %ax,%ax
  803218:	0f 86 a9 00 00 00    	jbe    8032c7 <lwip_setsockopt+0x192>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  80321e:	8b 00                	mov    (%eax),%eax
  803220:	83 38 10             	cmpl   $0x10,(%eax)
  803223:	0f 85 8c 00 00 00    	jne    8032b5 <lwip_setsockopt+0x180>
      return 0;

    switch (optname) {
  803229:	8b 55 10             	mov    0x10(%ebp),%edx
  80322c:	83 ea 01             	sub    $0x1,%edx
  80322f:	b8 5c 00 00 00       	mov    $0x5c,%eax
  803234:	83 fa 01             	cmp    $0x1,%edx
  803237:	77 0d                	ja     803246 <lwip_setsockopt+0x111>
  803239:	b0 00                	mov    $0x0,%al
  80323b:	eb 05                	jmp    803242 <lwip_setsockopt+0x10d>
  80323d:	b8 5c 00 00 00       	mov    $0x5c,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  803242:	85 c0                	test   %eax,%eax
  803244:	74 0f                	je     803255 <lwip_setsockopt+0x120>
    sock_set_errno(sock, err);
  803246:	89 43 10             	mov    %eax,0x10(%ebx)
  803249:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  80324e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  803253:	eb 65                	jmp    8032ba <lwip_setsockopt+0x185>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  803255:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  803258:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  80325b:	8b 45 10             	mov    0x10(%ebp),%eax
  80325e:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  803261:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  803264:	8d 45 18             	lea    0x18(%ebp),%eax
  803267:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  80326a:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  80326e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  803275:	00 
  803276:	8d 45 cc             	lea    -0x34(%ebp),%eax
  803279:	89 44 24 04          	mov    %eax,0x4(%esp)
  80327d:	c7 04 24 bd 34 80 00 	movl   $0x8034bd,(%esp)
  803284:	e8 bd 1a 00 00       	call   804d46 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  803289:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803290:	00 
  803291:	8b 03                	mov    (%ebx),%eax
  803293:	8b 40 10             	mov    0x10(%eax),%eax
  803296:	89 04 24             	mov    %eax,(%esp)
  803299:	e8 e8 a0 00 00       	call   80d386 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  80329e:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  8032a2:	89 43 10             	mov    %eax,0x10(%ebx)
  8032a5:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  return err ? -1 : 0;
  8032aa:	85 c0                	test   %eax,%eax
  8032ac:	74 07                	je     8032b5 <lwip_setsockopt+0x180>
  8032ae:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8032b3:	eb 05                	jmp    8032ba <lwip_setsockopt+0x185>
  8032b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8032ba:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8032bd:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8032c0:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8032c3:	89 ec                	mov    %ebp,%esp
  8032c5:	5d                   	pop    %ebp
  8032c6:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  8032c7:	b8 16 00 00 00       	mov    $0x16,%eax
  8032cc:	e9 75 ff ff ff       	jmp    803246 <lwip_setsockopt+0x111>
  8032d1:	b8 61 00 00 00       	mov    $0x61,%eax
  8032d6:	e9 6b ff ff ff       	jmp    803246 <lwip_setsockopt+0x111>

008032db <lwip_getsockopt>:
  return lwip_getaddrname(s, name, namelen, 1);
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  8032db:	55                   	push   %ebp
  8032dc:	89 e5                	mov    %esp,%ebp
  8032de:	57                   	push   %edi
  8032df:	56                   	push   %esi
  8032e0:	53                   	push   %ebx
  8032e1:	83 ec 3c             	sub    $0x3c,%esp
  8032e4:	8b 75 0c             	mov    0xc(%ebp),%esi
  8032e7:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  8032ea:	8b 45 08             	mov    0x8(%ebp),%eax
  8032ed:	e8 3e fd ff ff       	call   803030 <get_socket>
  8032f2:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8032f4:	85 c0                	test   %eax,%eax
  8032f6:	0f 84 99 01 00 00    	je     803495 <lwip_getsockopt+0x1ba>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  8032fc:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803300:	74 04                	je     803306 <lwip_getsockopt+0x2b>
  803302:	85 ff                	test   %edi,%edi
  803304:	75 1b                	jne    803321 <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  803306:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  80330d:	c7 05 20 c2 b3 00 0e 	movl   $0xe,0xb3c220
  803314:	00 00 00 
  803317:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  80331c:	e9 80 01 00 00       	jmp    8034a1 <lwip_getsockopt+0x1c6>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  803321:	83 fe 06             	cmp    $0x6,%esi
  803324:	0f 84 c3 00 00 00    	je     8033ed <lwip_getsockopt+0x112>
  80332a:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  803330:	74 13                	je     803345 <lwip_getsockopt+0x6a>
  803332:	85 f6                	test   %esi,%esi
  803334:	0f 84 9d 00 00 00    	je     8033d7 <lwip_getsockopt+0xfc>
  80333a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  803340:	e9 d8 00 00 00       	jmp    80341d <lwip_getsockopt+0x142>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  803345:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  803349:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803350:	74 50                	je     8033a2 <lwip_getsockopt+0xc7>
  803352:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  803356:	66 90                	xchg   %ax,%ax
  803358:	7f 18                	jg     803372 <lwip_getsockopt+0x97>
  80335a:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  80335e:	66 90                	xchg   %ax,%ax
  803360:	74 40                	je     8033a2 <lwip_getsockopt+0xc7>
  803362:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  803366:	0f 85 b1 00 00 00    	jne    80341d <lwip_getsockopt+0x142>
  80336c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803370:	eb 30                	jmp    8033a2 <lwip_getsockopt+0xc7>
  803372:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  803379:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803380:	0f 8c 97 00 00 00    	jl     80341d <lwip_getsockopt+0x142>
  803386:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  80338d:	8d 76 00             	lea    0x0(%esi),%esi
  803390:	7e 10                	jle    8033a2 <lwip_getsockopt+0xc7>
  803392:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  803399:	0f 85 7e 00 00 00    	jne    80341d <lwip_getsockopt+0x142>
  80339f:	90                   	nop
  8033a0:	eb 13                	jmp    8033b5 <lwip_getsockopt+0xda>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  8033a2:	83 3f 03             	cmpl   $0x3,(%edi)
  8033a5:	8d 76 00             	lea    0x0(%esi),%esi
  8033a8:	0f 86 fb 00 00 00    	jbe    8034a9 <lwip_getsockopt+0x1ce>
  8033ae:	66 90                	xchg   %ax,%ax
  8033b0:	e9 83 00 00 00       	jmp    803438 <lwip_getsockopt+0x15d>
        err = EINVAL;
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  8033b5:	83 3f 04             	cmpl   $0x4,(%edi)
  8033b8:	19 c0                	sbb    %eax,%eax
  8033ba:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8033bd:	8b 13                	mov    (%ebx),%edx
  8033bf:	83 3a 20             	cmpl   $0x20,(%edx)
  8033c2:	0f 85 eb 00 00 00    	jne    8034b3 <lwip_getsockopt+0x1d8>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  8033c8:	8b 52 08             	mov    0x8(%edx),%edx
  8033cb:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  8033cf:	0f 85 de 00 00 00    	jne    8034b3 <lwip_getsockopt+0x1d8>
  8033d5:	eb 4b                	jmp    803422 <lwip_getsockopt+0x147>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8033d7:	8b 45 10             	mov    0x10(%ebp),%eax
  8033da:	83 e8 01             	sub    $0x1,%eax
  8033dd:	83 f8 01             	cmp    $0x1,%eax
  8033e0:	77 3b                	ja     80341d <lwip_getsockopt+0x142>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  8033e2:	83 3f 03             	cmpl   $0x3,(%edi)
  8033e5:	0f 86 be 00 00 00    	jbe    8034a9 <lwip_getsockopt+0x1ce>
  8033eb:	eb 4b                	jmp    803438 <lwip_getsockopt+0x15d>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  8033ed:	83 3f 03             	cmpl   $0x3,(%edi)
  8033f0:	0f 86 b3 00 00 00    	jbe    8034a9 <lwip_getsockopt+0x1ce>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  8033f6:	8b 00                	mov    (%eax),%eax
  8033f8:	83 38 10             	cmpl   $0x10,(%eax)
  8033fb:	90                   	nop
  8033fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803400:	0f 85 96 00 00 00    	jne    80349c <lwip_getsockopt+0x1c1>
      return 0;

    switch (optname) {
  803406:	8b 55 10             	mov    0x10(%ebp),%edx
  803409:	83 ea 01             	sub    $0x1,%edx
  80340c:	b8 5c 00 00 00       	mov    $0x5c,%eax
  803411:	83 fa 01             	cmp    $0x1,%edx
  803414:	77 10                	ja     803426 <lwip_getsockopt+0x14b>
  803416:	b8 00 00 00 00       	mov    $0x0,%eax
  80341b:	eb 05                	jmp    803422 <lwip_getsockopt+0x147>
  80341d:	b8 5c 00 00 00       	mov    $0x5c,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  803422:	84 c0                	test   %al,%al
  803424:	74 12                	je     803438 <lwip_getsockopt+0x15d>
    sock_set_errno(sock, err);
  803426:	0f be c0             	movsbl %al,%eax
  803429:	89 43 10             	mov    %eax,0x10(%ebx)
  80342c:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  803431:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  803436:	eb 69                	jmp    8034a1 <lwip_getsockopt+0x1c6>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  803438:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  80343b:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  80343e:	8b 45 10             	mov    0x10(%ebp),%eax
  803441:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  803444:	8b 45 14             	mov    0x14(%ebp),%eax
  803447:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  80344a:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  80344d:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  803451:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  803458:	00 
  803459:	8d 45 cc             	lea    -0x34(%ebp),%eax
  80345c:	89 44 24 04          	mov    %eax,0x4(%esp)
  803460:	c7 04 24 d0 35 80 00 	movl   $0x8035d0,(%esp)
  803467:	e8 da 18 00 00       	call   804d46 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  80346c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803473:	00 
  803474:	8b 03                	mov    (%ebx),%eax
  803476:	8b 40 10             	mov    0x10(%eax),%eax
  803479:	89 04 24             	mov    %eax,(%esp)
  80347c:	e8 05 9f 00 00       	call   80d386 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  803481:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  803485:	0f be d0             	movsbl %al,%edx
  803488:	89 53 10             	mov    %edx,0x10(%ebx)
  80348b:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  return err ? -1 : 0;
  803491:	84 c0                	test   %al,%al
  803493:	74 07                	je     80349c <lwip_getsockopt+0x1c1>
  803495:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80349a:	eb 05                	jmp    8034a1 <lwip_getsockopt+0x1c6>
  80349c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8034a1:	83 c4 3c             	add    $0x3c,%esp
  8034a4:	5b                   	pop    %ebx
  8034a5:	5e                   	pop    %esi
  8034a6:	5f                   	pop    %edi
  8034a7:	5d                   	pop    %ebp
  8034a8:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  8034a9:	b8 16 00 00 00       	mov    $0x16,%eax
  8034ae:	e9 73 ff ff ff       	jmp    803426 <lwip_getsockopt+0x14b>
  8034b3:	b8 61 00 00 00       	mov    $0x61,%eax
  8034b8:	e9 69 ff ff ff       	jmp    803426 <lwip_getsockopt+0x14b>

008034bd <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  8034bd:	55                   	push   %ebp
  8034be:	89 e5                	mov    %esp,%ebp
  8034c0:	53                   	push   %ebx
  8034c1:	83 ec 14             	sub    $0x14,%esp
  8034c4:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8034c7:	85 c0                	test   %eax,%eax
  8034c9:	75 1c                	jne    8034e7 <lwip_setsockopt_internal+0x2a>
  8034cb:	c7 44 24 08 75 29 81 	movl   $0x812975,0x8(%esp)
  8034d2:	00 
  8034d3:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  8034da:	00 
  8034db:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  8034e2:	e8 2d d4 ff ff       	call   800914 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  8034e7:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  8034e9:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  8034ec:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  8034ef:	8b 40 08             	mov    0x8(%eax),%eax
  8034f2:	83 f8 06             	cmp    $0x6,%eax
  8034f5:	0f 84 88 00 00 00    	je     803583 <lwip_setsockopt_internal+0xc6>
  8034fb:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  803500:	74 0b                	je     80350d <lwip_setsockopt_internal+0x50>
  803502:	85 c0                	test   %eax,%eax
  803504:	74 5b                	je     803561 <lwip_setsockopt_internal+0xa4>
  803506:	66 90                	xchg   %ax,%ax
  803508:	e9 b0 00 00 00       	jmp    8035bd <lwip_setsockopt_internal+0x100>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80350d:	83 f9 20             	cmp    $0x20,%ecx
  803510:	74 14                	je     803526 <lwip_setsockopt_internal+0x69>
  803512:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  803518:	74 2c                	je     803546 <lwip_setsockopt_internal+0x89>
  80351a:	83 f9 08             	cmp    $0x8,%ecx
  80351d:	8d 76 00             	lea    0x0(%esi),%esi
  803520:	0f 85 97 00 00 00    	jne    8035bd <lwip_setsockopt_internal+0x100>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  803526:	83 3b 00             	cmpl   $0x0,(%ebx)
  803529:	74 0e                	je     803539 <lwip_setsockopt_internal+0x7c>
        sock->conn->pcb.ip->so_options |= optname;
  80352b:	8b 02                	mov    (%edx),%eax
  80352d:	8b 40 08             	mov    0x8(%eax),%eax
  803530:	66 09 48 08          	or     %cx,0x8(%eax)
  803534:	e9 84 00 00 00       	jmp    8035bd <lwip_setsockopt_internal+0x100>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  803539:	8b 02                	mov    (%edx),%eax
  80353b:	8b 40 08             	mov    0x8(%eax),%eax
  80353e:	f7 d1                	not    %ecx
  803540:	66 21 48 08          	and    %cx,0x8(%eax)
  803544:	eb 77                	jmp    8035bd <lwip_setsockopt_internal+0x100>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  803546:	83 3b 00             	cmpl   $0x0,(%ebx)
  803549:	74 0b                	je     803556 <lwip_setsockopt_internal+0x99>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  80354b:	8b 02                	mov    (%edx),%eax
  80354d:	8b 40 08             	mov    0x8(%eax),%eax
  803550:	80 48 10 01          	orb    $0x1,0x10(%eax)
  803554:	eb 67                	jmp    8035bd <lwip_setsockopt_internal+0x100>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  803556:	8b 02                	mov    (%edx),%eax
  803558:	8b 40 08             	mov    0x8(%eax),%eax
  80355b:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  80355f:	eb 5c                	jmp    8035bd <lwip_setsockopt_internal+0x100>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803561:	83 f9 01             	cmp    $0x1,%ecx
  803564:	74 11                	je     803577 <lwip_setsockopt_internal+0xba>
  803566:	83 f9 02             	cmp    $0x2,%ecx
  803569:	75 52                	jne    8035bd <lwip_setsockopt_internal+0x100>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  80356b:	8b 02                	mov    (%edx),%eax
  80356d:	8b 40 08             	mov    0x8(%eax),%eax
  803570:	8b 0b                	mov    (%ebx),%ecx
  803572:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  803575:	eb 46                	jmp    8035bd <lwip_setsockopt_internal+0x100>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  803577:	8b 02                	mov    (%edx),%eax
  803579:	8b 40 08             	mov    0x8(%eax),%eax
  80357c:	8b 0b                	mov    (%ebx),%ecx
  80357e:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
  803581:	eb 3a                	jmp    8035bd <lwip_setsockopt_internal+0x100>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  803583:	83 f9 01             	cmp    $0x1,%ecx
  803586:	74 0a                	je     803592 <lwip_setsockopt_internal+0xd5>
  803588:	83 f9 02             	cmp    $0x2,%ecx
  80358b:	75 30                	jne    8035bd <lwip_setsockopt_internal+0x100>
  80358d:	8d 76 00             	lea    0x0(%esi),%esi
  803590:	eb 1e                	jmp    8035b0 <lwip_setsockopt_internal+0xf3>
    case TCP_NODELAY:
      if (*(int*)optval) {
  803592:	83 3b 00             	cmpl   $0x0,(%ebx)
  803595:	8d 76 00             	lea    0x0(%esi),%esi
  803598:	74 0b                	je     8035a5 <lwip_setsockopt_internal+0xe8>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  80359a:	8b 02                	mov    (%edx),%eax
  80359c:	8b 40 08             	mov    0x8(%eax),%eax
  80359f:	80 48 20 40          	orb    $0x40,0x20(%eax)
  8035a3:	eb 18                	jmp    8035bd <lwip_setsockopt_internal+0x100>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  8035a5:	8b 02                	mov    (%edx),%eax
  8035a7:	8b 40 08             	mov    0x8(%eax),%eax
  8035aa:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  8035ae:	eb 0d                	jmp    8035bd <lwip_setsockopt_internal+0x100>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  8035b0:	8b 02                	mov    (%edx),%eax
  8035b2:	8b 40 08             	mov    0x8(%eax),%eax
  8035b5:	8b 0b                	mov    (%ebx),%ecx
  8035b7:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  8035bd:	8b 02                	mov    (%edx),%eax
  8035bf:	8b 40 10             	mov    0x10(%eax),%eax
  8035c2:	89 04 24             	mov    %eax,(%esp)
  8035c5:	e8 ad a0 00 00       	call   80d677 <sys_sem_signal>
}
  8035ca:	83 c4 14             	add    $0x14,%esp
  8035cd:	5b                   	pop    %ebx
  8035ce:	5d                   	pop    %ebp
  8035cf:	c3                   	ret    

008035d0 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  8035d0:	55                   	push   %ebp
  8035d1:	89 e5                	mov    %esp,%ebp
  8035d3:	53                   	push   %ebx
  8035d4:	83 ec 14             	sub    $0x14,%esp
  8035d7:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  8035da:	85 c0                	test   %eax,%eax
  8035dc:	75 1c                	jne    8035fa <lwip_getsockopt_internal+0x2a>
  8035de:	c7 44 24 08 75 29 81 	movl   $0x812975,0x8(%esp)
  8035e5:	00 
  8035e6:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  8035ed:	00 
  8035ee:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  8035f5:	e8 1a d3 ff ff       	call   800914 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  8035fa:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  8035fc:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  8035ff:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  803602:	8b 40 08             	mov    0x8(%eax),%eax
  803605:	83 f8 06             	cmp    $0x6,%eax
  803608:	0f 84 17 01 00 00    	je     803725 <lwip_getsockopt_internal+0x155>
  80360e:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  803613:	74 10                	je     803625 <lwip_getsockopt_internal+0x55>
  803615:	85 c0                	test   %eax,%eax
  803617:	0f 84 e4 00 00 00    	je     803701 <lwip_getsockopt_internal+0x131>
  80361d:	8d 76 00             	lea    0x0(%esi),%esi
  803620:	e9 2a 01 00 00       	jmp    80374f <lwip_getsockopt_internal+0x17f>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  803625:	83 f9 20             	cmp    $0x20,%ecx
  803628:	74 40                	je     80366a <lwip_getsockopt_internal+0x9a>
  80362a:	83 f9 20             	cmp    $0x20,%ecx
  80362d:	8d 76 00             	lea    0x0(%esi),%esi
  803630:	7f 10                	jg     803642 <lwip_getsockopt_internal+0x72>
  803632:	83 f9 02             	cmp    $0x2,%ecx
  803635:	74 33                	je     80366a <lwip_getsockopt_internal+0x9a>
  803637:	83 f9 08             	cmp    $0x8,%ecx
  80363a:	0f 85 0f 01 00 00    	jne    80374f <lwip_getsockopt_internal+0x17f>
  803640:	eb 28                	jmp    80366a <lwip_getsockopt_internal+0x9a>
  803642:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  803648:	74 32                	je     80367c <lwip_getsockopt_internal+0xac>
  80364a:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  803650:	0f 84 9b 00 00 00    	je     8036f1 <lwip_getsockopt_internal+0x121>
  803656:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  80365c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803660:	0f 85 e9 00 00 00    	jne    80374f <lwip_getsockopt_internal+0x17f>
  803666:	66 90                	xchg   %ax,%ax
  803668:	eb 4f                	jmp    8036b9 <lwip_getsockopt_internal+0xe9>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  80366a:	8b 02                	mov    (%edx),%eax
  80366c:	8b 40 08             	mov    0x8(%eax),%eax
  80366f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  803673:	21 c1                	and    %eax,%ecx
  803675:	89 0b                	mov    %ecx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  803677:	e9 d3 00 00 00       	jmp    80374f <lwip_getsockopt_internal+0x17f>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  80367c:	8b 02                	mov    (%edx),%eax
  80367e:	8b 08                	mov    (%eax),%ecx
  803680:	89 c8                	mov    %ecx,%eax
  803682:	25 f0 00 00 00       	and    $0xf0,%eax
  803687:	83 f8 20             	cmp    $0x20,%eax
  80368a:	74 22                	je     8036ae <lwip_getsockopt_internal+0xde>
  80368c:	83 f8 40             	cmp    $0x40,%eax
  80368f:	74 12                	je     8036a3 <lwip_getsockopt_internal+0xd3>
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  803691:	83 f8 10             	cmp    $0x10,%eax
  803694:	b8 01 00 00 00       	mov    $0x1,%eax
  803699:	0f 44 c8             	cmove  %eax,%ecx
  80369c:	89 0b                	mov    %ecx,(%ebx)
  80369e:	e9 ac 00 00 00       	jmp    80374f <lwip_getsockopt_internal+0x17f>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  8036a3:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  8036a9:	e9 a1 00 00 00       	jmp    80374f <lwip_getsockopt_internal+0x17f>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  8036ae:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  8036b4:	e9 96 00 00 00       	jmp    80374f <lwip_getsockopt_internal+0x17f>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  8036b9:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  8036bd:	8d 76 00             	lea    0x0(%esi),%esi
  8036c0:	75 21                	jne    8036e3 <lwip_getsockopt_internal+0x113>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  8036c2:	8b 02                	mov    (%edx),%eax
  8036c4:	0f be 48 0c          	movsbl 0xc(%eax),%ecx
  8036c8:	f7 d9                	neg    %ecx
  8036ca:	b8 05 00 00 00       	mov    $0x5,%eax
  8036cf:	83 f9 0e             	cmp    $0xe,%ecx
  8036d2:	77 07                	ja     8036db <lwip_getsockopt_internal+0x10b>
  8036d4:	8b 04 8d 60 2a 81 00 	mov    0x812a60(,%ecx,4),%eax
  8036db:	89 42 10             	mov    %eax,0x10(%edx)
  8036de:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
      } 
      *(int *)optval = sock->err;
  8036e3:	8b 42 10             	mov    0x10(%edx),%eax
  8036e6:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  8036e8:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  8036ef:	eb 5e                	jmp    80374f <lwip_getsockopt_internal+0x17f>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  8036f1:	8b 02                	mov    (%edx),%eax
  8036f3:	8b 40 08             	mov    0x8(%eax),%eax
  8036f6:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  8036fa:	83 e0 01             	and    $0x1,%eax
  8036fd:	89 03                	mov    %eax,(%ebx)
  8036ff:	eb 4e                	jmp    80374f <lwip_getsockopt_internal+0x17f>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803701:	83 f9 01             	cmp    $0x1,%ecx
  803704:	74 12                	je     803718 <lwip_getsockopt_internal+0x148>
  803706:	83 f9 02             	cmp    $0x2,%ecx
  803709:	75 44                	jne    80374f <lwip_getsockopt_internal+0x17f>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  80370b:	8b 02                	mov    (%edx),%eax
  80370d:	8b 40 08             	mov    0x8(%eax),%eax
  803710:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  803714:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  803716:	eb 37                	jmp    80374f <lwip_getsockopt_internal+0x17f>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  803718:	8b 02                	mov    (%edx),%eax
  80371a:	8b 40 08             	mov    0x8(%eax),%eax
  80371d:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  803721:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
  803723:	eb 2a                	jmp    80374f <lwip_getsockopt_internal+0x17f>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  803725:	83 f9 01             	cmp    $0x1,%ecx
  803728:	74 08                	je     803732 <lwip_getsockopt_internal+0x162>
  80372a:	83 f9 02             	cmp    $0x2,%ecx
  80372d:	75 20                	jne    80374f <lwip_getsockopt_internal+0x17f>
  80372f:	90                   	nop
  803730:	eb 10                	jmp    803742 <lwip_getsockopt_internal+0x172>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  803732:	8b 02                	mov    (%edx),%eax
  803734:	8b 40 08             	mov    0x8(%eax),%eax
  803737:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  80373b:	83 e0 40             	and    $0x40,%eax
  80373e:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  803740:	eb 0d                	jmp    80374f <lwip_getsockopt_internal+0x17f>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  803742:	8b 02                	mov    (%edx),%eax
  803744:	8b 40 08             	mov    0x8(%eax),%eax
  803747:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  80374d:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  80374f:	8b 02                	mov    (%edx),%eax
  803751:	8b 40 10             	mov    0x10(%eax),%eax
  803754:	89 04 24             	mov    %eax,(%esp)
  803757:	e8 1b 9f 00 00       	call   80d677 <sys_sem_signal>
}
  80375c:	83 c4 14             	add    $0x14,%esp
  80375f:	5b                   	pop    %ebx
  803760:	5d                   	pop    %ebp
  803761:	c3                   	ret    

00803762 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  803762:	55                   	push   %ebp
  803763:	89 e5                	mov    %esp,%ebp
  803765:	57                   	push   %edi
  803766:	56                   	push   %esi
  803767:	53                   	push   %ebx
  803768:	83 ec 3c             	sub    $0x3c,%esp
  80376b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80376e:	89 55 d0             	mov    %edx,-0x30(%ebp)
  803771:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  803774:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80377b:	00 
  80377c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803783:	00 
  803784:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803787:	89 04 24             	mov    %eax,(%esp)
  80378a:	e8 07 db ff ff       	call   801296 <memset>
  FD_ZERO(&lwriteset);
  80378f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803796:	00 
  803797:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80379e:	00 
  80379f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8037a2:	89 04 24             	mov    %eax,(%esp)
  8037a5:	e8 ec da ff ff       	call   801296 <memset>
  FD_ZERO(&lexceptset);
  8037aa:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8037b1:	00 
  8037b2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8037b9:	00 
  8037ba:	8d 45 dc             	lea    -0x24(%ebp),%eax
  8037bd:	89 04 24             	mov    %eax,(%esp)
  8037c0:	e8 d1 da ff ff       	call   801296 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  8037c5:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  8037cc:	bb 00 00 00 00       	mov    $0x0,%ebx
  8037d1:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  8037d5:	7e 7c                	jle    803853 <lwip_selscan+0xf1>
    if (FD_ISSET(i, readset)) {
  8037d7:	8d 73 07             	lea    0x7(%ebx),%esi
  8037da:	85 db                	test   %ebx,%ebx
  8037dc:	0f 49 f3             	cmovns %ebx,%esi
  8037df:	c1 fe 03             	sar    $0x3,%esi
  8037e2:	89 df                	mov    %ebx,%edi
  8037e4:	83 e7 07             	and    $0x7,%edi
  8037e7:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8037ea:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  8037ee:	0f a3 f8             	bt     %edi,%eax
  8037f1:	73 29                	jae    80381c <lwip_selscan+0xba>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  8037f3:	89 d8                	mov    %ebx,%eax
  8037f5:	e8 36 f8 ff ff       	call   803030 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  8037fa:	85 c0                	test   %eax,%eax
  8037fc:	74 1e                	je     80381c <lwip_selscan+0xba>
  8037fe:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  803802:	75 07                	jne    80380b <lwip_selscan+0xa9>
  803804:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  803809:	74 11                	je     80381c <lwip_selscan+0xba>
        FD_SET(i, &lreadset);
  80380b:	b8 01 00 00 00       	mov    $0x1,%eax
  803810:	89 f9                	mov    %edi,%ecx
  803812:	d3 e0                	shl    %cl,%eax
  803814:	08 44 35 e4          	or     %al,-0x1c(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  803818:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  80381c:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80381f:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  803823:	0f a3 f8             	bt     %edi,%eax
  803826:	73 23                	jae    80384b <lwip_selscan+0xe9>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  803828:	89 d8                	mov    %ebx,%eax
  80382a:	e8 01 f8 ff ff       	call   803030 <get_socket>
      if (p_sock && p_sock->sendevent) {
  80382f:	85 c0                	test   %eax,%eax
  803831:	74 18                	je     80384b <lwip_selscan+0xe9>
  803833:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  803838:	74 11                	je     80384b <lwip_selscan+0xe9>
        FD_SET(i, &lwriteset);
  80383a:	b8 01 00 00 00       	mov    $0x1,%eax
  80383f:	89 f9                	mov    %edi,%ecx
  803841:	d3 e0                	shl    %cl,%eax
  803843:	08 44 35 e0          	or     %al,-0x20(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  803847:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  80384b:	83 c3 01             	add    $0x1,%ebx
  80384e:	39 5d d4             	cmp    %ebx,-0x2c(%ebp)
  803851:	7f 84                	jg     8037d7 <lwip_selscan+0x75>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  803853:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803856:	8b 55 d0             	mov    -0x30(%ebp),%edx
  803859:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  80385b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80385e:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  803861:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  803863:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80386a:	00 
  80386b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803872:	00 
  803873:	8b 45 08             	mov    0x8(%ebp),%eax
  803876:	89 04 24             	mov    %eax,(%esp)
  803879:	e8 18 da ff ff       	call   801296 <memset>
  
  return nready;
}
  80387e:	8b 45 c8             	mov    -0x38(%ebp),%eax
  803881:	83 c4 3c             	add    $0x3c,%esp
  803884:	5b                   	pop    %ebx
  803885:	5e                   	pop    %esi
  803886:	5f                   	pop    %edi
  803887:	5d                   	pop    %ebp
  803888:	c3                   	ret    

00803889 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  803889:	55                   	push   %ebp
  80388a:	89 e5                	mov    %esp,%ebp
  80388c:	83 ec 58             	sub    $0x58,%esp
  80388f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803892:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803895:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803898:	89 d7                	mov    %edx,%edi
  80389a:	89 ce                	mov    %ecx,%esi
  80389c:	0f b6 55 08          	movzbl 0x8(%ebp),%edx
  8038a0:	88 55 c7             	mov    %dl,-0x39(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  8038a3:	e8 88 f7 ff ff       	call   803030 <get_socket>
  8038a8:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8038aa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8038af:	85 db                	test   %ebx,%ebx
  8038b1:	0f 84 8f 00 00 00    	je     803946 <lwip_getaddrname+0xbd>
    return -1;

  memset(&sin, 0, sizeof(sin));
  8038b7:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  8038be:	00 
  8038bf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8038c6:	00 
  8038c7:	8d 45 d8             	lea    -0x28(%ebp),%eax
  8038ca:	89 04 24             	mov    %eax,(%esp)
  8038cd:	e8 c4 d9 ff ff       	call   801296 <memset>
  sin.sin_len = sizeof(sin);
  8038d2:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  8038d6:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  8038da:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  8038de:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8038e2:	8d 45 da             	lea    -0x26(%ebp),%eax
  8038e5:	89 44 24 08          	mov    %eax,0x8(%esp)
  8038e9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8038ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  8038f0:	8b 03                	mov    (%ebx),%eax
  8038f2:	89 04 24             	mov    %eax,(%esp)
  8038f5:	e8 39 aa 00 00       	call   80e333 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  8038fa:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  8038fe:	89 04 24             	mov    %eax,(%esp)
  803901:	e8 7d 6e 00 00       	call   80a783 <htons>
  803906:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  80390a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80390d:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  803910:	83 3e 10             	cmpl   $0x10,(%esi)
  803913:	76 06                	jbe    80391b <lwip_getaddrname+0x92>
    *namelen = sizeof(sin);
  803915:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  80391b:	8b 06                	mov    (%esi),%eax
  80391d:	89 44 24 08          	mov    %eax,0x8(%esp)
  803921:	8d 45 d8             	lea    -0x28(%ebp),%eax
  803924:	89 44 24 04          	mov    %eax,0x4(%esp)
  803928:	89 3c 24             	mov    %edi,(%esp)
  80392b:	e8 41 da ff ff       	call   801371 <memcpy>
  sock_set_errno(sock, 0);
  803930:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  803937:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  80393e:	00 00 00 
  803941:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  803946:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803949:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80394c:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80394f:	89 ec                	mov    %ebp,%esp
  803951:	5d                   	pop    %ebp
  803952:	c3                   	ret    

00803953 <lwip_getsockname>:
  return lwip_getaddrname(s, name, namelen, 0);
}

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  803953:	55                   	push   %ebp
  803954:	89 e5                	mov    %esp,%ebp
  803956:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  803959:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803960:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803963:	8b 55 0c             	mov    0xc(%ebp),%edx
  803966:	8b 45 08             	mov    0x8(%ebp),%eax
  803969:	e8 1b ff ff ff       	call   803889 <lwip_getaddrname>
}
  80396e:	c9                   	leave  
  80396f:	c3                   	ret    

00803970 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  803970:	55                   	push   %ebp
  803971:	89 e5                	mov    %esp,%ebp
  803973:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  803976:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80397d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803980:	8b 55 0c             	mov    0xc(%ebp),%edx
  803983:	8b 45 08             	mov    0x8(%ebp),%eax
  803986:	e8 fe fe ff ff       	call   803889 <lwip_getaddrname>
}
  80398b:	c9                   	leave  
  80398c:	c3                   	ret    

0080398d <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  80398d:	55                   	push   %ebp
  80398e:	89 e5                	mov    %esp,%ebp
  803990:	56                   	push   %esi
  803991:	53                   	push   %ebx
  803992:	83 ec 10             	sub    $0x10,%esp
  803995:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  803997:	a1 24 63 81 00       	mov    0x816324,%eax
  80399c:	89 04 24             	mov    %eax,(%esp)
  80399f:	e8 b6 46 00 00       	call   80805a <sys_sem_wait>

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
    if (!sockets[i].conn) {
  8039a4:	b8 b4 60 81 00       	mov    $0x8160b4,%eax
  8039a9:	bb 01 00 00 00       	mov    $0x1,%ebx
  8039ae:	83 3d a0 60 81 00 00 	cmpl   $0x0,0x8160a0
  8039b5:	75 04                	jne    8039bb <alloc_socket+0x2e>
  8039b7:	b3 00                	mov    $0x0,%bl
  8039b9:	eb 05                	jmp    8039c0 <alloc_socket+0x33>
  8039bb:	83 38 00             	cmpl   $0x0,(%eax)
  8039be:	75 50                	jne    803a10 <alloc_socket+0x83>
      sockets[i].conn       = newconn;
  8039c0:	ba a0 60 81 00       	mov    $0x8160a0,%edx
  8039c5:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
  8039cc:	8d 0c 18             	lea    (%eax,%ebx,1),%ecx
  8039cf:	89 34 8a             	mov    %esi,(%edx,%ecx,4)
      sockets[i].lastdata   = NULL;
  8039d2:	c7 44 8a 04 00 00 00 	movl   $0x0,0x4(%edx,%ecx,4)
  8039d9:	00 
      sockets[i].lastoffset = 0;
  8039da:	66 c7 44 8a 08 00 00 	movw   $0x0,0x8(%edx,%ecx,4)
      sockets[i].rcvevent   = 0;
  8039e1:	66 c7 44 8a 0a 00 00 	movw   $0x0,0xa(%edx,%ecx,4)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  8039e8:	66 c7 44 8a 0c 01 00 	movw   $0x1,0xc(%edx,%ecx,4)
      sockets[i].flags      = 0;
  8039ef:	66 c7 44 8a 0e 00 00 	movw   $0x0,0xe(%edx,%ecx,4)
      sockets[i].err        = 0;
  8039f6:	c7 04 8d b0 60 81 00 	movl   $0x0,0x8160b0(,%ecx,4)
  8039fd:	00 00 00 00 
      sys_sem_signal(socksem);
  803a01:	a1 24 63 81 00       	mov    0x816324,%eax
  803a06:	89 04 24             	mov    %eax,(%esp)
  803a09:	e8 69 9c 00 00       	call   80d677 <sys_sem_signal>
      return i;
  803a0e:	eb 1d                	jmp    803a2d <alloc_socket+0xa0>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  803a10:	83 c3 01             	add    $0x1,%ebx
  803a13:	83 c0 14             	add    $0x14,%eax
  803a16:	83 fb 20             	cmp    $0x20,%ebx
  803a19:	75 a0                	jne    8039bb <alloc_socket+0x2e>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  803a1b:	a1 24 63 81 00       	mov    0x816324,%eax
  803a20:	89 04 24             	mov    %eax,(%esp)
  803a23:	e8 4f 9c 00 00       	call   80d677 <sys_sem_signal>
  803a28:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return -1;
}
  803a2d:	89 d8                	mov    %ebx,%eax
  803a2f:	83 c4 10             	add    $0x10,%esp
  803a32:	5b                   	pop    %ebx
  803a33:	5e                   	pop    %esi
  803a34:	5d                   	pop    %ebp
  803a35:	c3                   	ret    

00803a36 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  803a36:	55                   	push   %ebp
  803a37:	89 e5                	mov    %esp,%ebp
  803a39:	57                   	push   %edi
  803a3a:	56                   	push   %esi
  803a3b:	53                   	push   %ebx
  803a3c:	83 ec 2c             	sub    $0x2c,%esp
  803a3f:	8b 75 08             	mov    0x8(%ebp),%esi
  803a42:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  803a45:	85 f6                	test   %esi,%esi
  803a47:	0f 84 73 01 00 00    	je     803bc0 <event_callback+0x18a>
    s = conn->socket;
  803a4d:	8b 5e 1c             	mov    0x1c(%esi),%ebx
    if (s < 0) {
  803a50:	85 db                	test   %ebx,%ebx
  803a52:	79 3d                	jns    803a91 <event_callback+0x5b>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  803a54:	a1 24 63 81 00       	mov    0x816324,%eax
  803a59:	89 04 24             	mov    %eax,(%esp)
  803a5c:	e8 f9 45 00 00       	call   80805a <sys_sem_wait>
      if (conn->socket < 0) {
  803a61:	8b 46 1c             	mov    0x1c(%esi),%eax
  803a64:	85 c0                	test   %eax,%eax
  803a66:	79 1c                	jns    803a84 <event_callback+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  803a68:	85 ff                	test   %edi,%edi
  803a6a:	75 06                	jne    803a72 <event_callback+0x3c>
          conn->socket--;
  803a6c:	83 e8 01             	sub    $0x1,%eax
  803a6f:	89 46 1c             	mov    %eax,0x1c(%esi)
        }
        sys_sem_signal(socksem);
  803a72:	a1 24 63 81 00       	mov    0x816324,%eax
  803a77:	89 04 24             	mov    %eax,(%esp)
  803a7a:	e8 f8 9b 00 00       	call   80d677 <sys_sem_signal>
        return;
  803a7f:	e9 3c 01 00 00       	jmp    803bc0 <event_callback+0x18a>
      }
      sys_sem_signal(socksem);
  803a84:	a1 24 63 81 00       	mov    0x816324,%eax
  803a89:	89 04 24             	mov    %eax,(%esp)
  803a8c:	e8 e6 9b 00 00       	call   80d677 <sys_sem_signal>
    }

    sock = get_socket(s);
  803a91:	89 d8                	mov    %ebx,%eax
  803a93:	e8 98 f5 ff ff       	call   803030 <get_socket>
  803a98:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  803a9b:	85 c0                	test   %eax,%eax
  803a9d:	0f 84 1d 01 00 00    	je     803bc0 <event_callback+0x18a>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  803aa3:	a1 28 63 81 00       	mov    0x816328,%eax
  803aa8:	89 04 24             	mov    %eax,(%esp)
  803aab:	e8 aa 45 00 00       	call   80805a <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  803ab0:	83 ff 01             	cmp    $0x1,%edi
  803ab3:	74 1f                	je     803ad4 <event_callback+0x9e>
  803ab5:	83 ff 01             	cmp    $0x1,%edi
  803ab8:	72 10                	jb     803aca <event_callback+0x94>
  803aba:	83 ff 02             	cmp    $0x2,%edi
  803abd:	8d 76 00             	lea    0x0(%esi),%esi
  803ac0:	74 1c                	je     803ade <event_callback+0xa8>
  803ac2:	83 ff 03             	cmp    $0x3,%edi
  803ac5:	75 2d                	jne    803af4 <event_callback+0xbe>
  803ac7:	90                   	nop
  803ac8:	eb 1f                	jmp    803ae9 <event_callback+0xb3>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  803aca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803acd:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  803ad2:	eb 3c                	jmp    803b10 <event_callback+0xda>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  803ad4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803ad7:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  803adc:	eb 32                	jmp    803b10 <event_callback+0xda>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  803ade:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803ae1:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  803ae7:	eb 27                	jmp    803b10 <event_callback+0xda>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  803ae9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803aec:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  803af2:	eb 1c                	jmp    803b10 <event_callback+0xda>
    default:
      LWIP_ASSERT("unknown event", 0);
  803af4:	c7 44 24 08 98 29 81 	movl   $0x812998,0x8(%esp)
  803afb:	00 
  803afc:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  803b03:	00 
  803b04:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  803b0b:	e8 04 ce ff ff       	call   800914 <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  803b10:	a1 28 63 81 00       	mov    0x816328,%eax
  803b15:	89 04 24             	mov    %eax,(%esp)
  803b18:	e8 5a 9b 00 00       	call   80d677 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  803b1d:	8d 73 07             	lea    0x7(%ebx),%esi
  803b20:	85 db                	test   %ebx,%ebx
  803b22:	0f 49 f3             	cmovns %ebx,%esi
  803b25:	c1 fe 03             	sar    $0x3,%esi
  803b28:	89 d9                	mov    %ebx,%ecx
  803b2a:	83 e1 07             	and    $0x7,%ecx
  803b2d:	b8 01 00 00 00       	mov    $0x1,%eax
  803b32:	89 c7                	mov    %eax,%edi
  803b34:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  803b36:	a1 28 63 81 00       	mov    0x816328,%eax
  803b3b:	89 04 24             	mov    %eax,(%esp)
  803b3e:	e8 17 45 00 00       	call   80805a <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  803b43:	8b 1d 20 63 81 00    	mov    0x816320,%ebx
  803b49:	85 db                	test   %ebx,%ebx
  803b4b:	74 66                	je     803bb3 <event_callback+0x17d>
      if (scb->sem_signalled == 0) {
  803b4d:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  803b51:	75 32                	jne    803b85 <event_callback+0x14f>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  803b53:	8b 43 04             	mov    0x4(%ebx),%eax
  803b56:	85 c0                	test   %eax,%eax
  803b58:	74 12                	je     803b6c <event_callback+0x136>
  803b5a:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  803b5e:	85 f8                	test   %edi,%eax
  803b60:	74 0a                	je     803b6c <event_callback+0x136>
          if (sock->rcvevent)
  803b62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803b65:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  803b6a:	75 21                	jne    803b8d <event_callback+0x157>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  803b6c:	8b 43 08             	mov    0x8(%ebx),%eax
  803b6f:	85 c0                	test   %eax,%eax
  803b71:	74 12                	je     803b85 <event_callback+0x14f>
  803b73:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  803b77:	85 f8                	test   %edi,%eax
  803b79:	74 0a                	je     803b85 <event_callback+0x14f>
          if (sock->sendevent)
  803b7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803b7e:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  803b83:	75 08                	jne    803b8d <event_callback+0x157>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  803b85:	8b 1b                	mov    (%ebx),%ebx
  803b87:	85 db                	test   %ebx,%ebx
  803b89:	75 c2                	jne    803b4d <event_callback+0x117>
  803b8b:	eb 26                	jmp    803bb3 <event_callback+0x17d>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
  803b8d:	85 db                	test   %ebx,%ebx
  803b8f:	90                   	nop
  803b90:	74 21                	je     803bb3 <event_callback+0x17d>
      scb->sem_signalled = 1;
  803b92:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  803b99:	a1 28 63 81 00       	mov    0x816328,%eax
  803b9e:	89 04 24             	mov    %eax,(%esp)
  803ba1:	e8 d1 9a 00 00       	call   80d677 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  803ba6:	8b 43 14             	mov    0x14(%ebx),%eax
  803ba9:	89 04 24             	mov    %eax,(%esp)
  803bac:	e8 c6 9a 00 00       	call   80d677 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  803bb1:	eb 83                	jmp    803b36 <event_callback+0x100>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  803bb3:	a1 28 63 81 00       	mov    0x816328,%eax
  803bb8:	89 04 24             	mov    %eax,(%esp)
  803bbb:	e8 b7 9a 00 00       	call   80d677 <sys_sem_signal>
      break;
    }
  }
}
  803bc0:	83 c4 2c             	add    $0x2c,%esp
  803bc3:	5b                   	pop    %ebx
  803bc4:	5e                   	pop    %esi
  803bc5:	5f                   	pop    %edi
  803bc6:	5d                   	pop    %ebp
  803bc7:	c3                   	ret    

00803bc8 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  803bc8:	55                   	push   %ebp
  803bc9:	89 e5                	mov    %esp,%ebp
  803bcb:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  803bce:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803bd5:	e8 fb 98 00 00       	call   80d4d5 <sys_sem_new>
  803bda:	a3 24 63 81 00       	mov    %eax,0x816324
  selectsem = sys_sem_new(1);
  803bdf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803be6:	e8 ea 98 00 00       	call   80d4d5 <sys_sem_new>
  803beb:	a3 28 63 81 00       	mov    %eax,0x816328
}
  803bf0:	c9                   	leave  
  803bf1:	c3                   	ret    

00803bf2 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  803bf2:	55                   	push   %ebp
  803bf3:	89 e5                	mov    %esp,%ebp
  803bf5:	57                   	push   %edi
  803bf6:	56                   	push   %esi
  803bf7:	53                   	push   %ebx
  803bf8:	83 ec 5c             	sub    $0x5c,%esp
  803bfb:	8b 7d 0c             	mov    0xc(%ebp),%edi
  803bfe:	8b 75 10             	mov    0x10(%ebp),%esi
  803c01:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  803c04:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  803c0b:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  803c0e:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  803c11:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  803c14:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  803c1b:	a1 28 63 81 00       	mov    0x816328,%eax
  803c20:	89 04 24             	mov    %eax,(%esp)
  803c23:	e8 32 44 00 00       	call   80805a <sys_sem_wait>

  if (readset)
  803c28:	85 ff                	test   %edi,%edi
  803c2a:	74 07                	je     803c33 <lwip_select+0x41>
    lreadset = *readset;
  803c2c:	8b 07                	mov    (%edi),%eax
  803c2e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803c31:	eb 1b                	jmp    803c4e <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  803c33:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803c3a:	00 
  803c3b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c42:	00 
  803c43:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803c46:	89 04 24             	mov    %eax,(%esp)
  803c49:	e8 48 d6 ff ff       	call   801296 <memset>
  if (writeset)
  803c4e:	85 f6                	test   %esi,%esi
  803c50:	74 07                	je     803c59 <lwip_select+0x67>
    lwriteset = *writeset;
  803c52:	8b 06                	mov    (%esi),%eax
  803c54:	89 45 e0             	mov    %eax,-0x20(%ebp)
  803c57:	eb 1b                	jmp    803c74 <lwip_select+0x82>
  else
    FD_ZERO(&lwriteset);
  803c59:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803c60:	00 
  803c61:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c68:	00 
  803c69:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803c6c:	89 04 24             	mov    %eax,(%esp)
  803c6f:	e8 22 d6 ff ff       	call   801296 <memset>
  if (exceptset)
  803c74:	85 db                	test   %ebx,%ebx
  803c76:	74 07                	je     803c7f <lwip_select+0x8d>
    lexceptset = *exceptset;
  803c78:	8b 03                	mov    (%ebx),%eax
  803c7a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  803c7d:	eb 1b                	jmp    803c9a <lwip_select+0xa8>
  else
    FD_ZERO(&lexceptset);
  803c7f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803c86:	00 
  803c87:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803c8e:	00 
  803c8f:	8d 45 dc             	lea    -0x24(%ebp),%eax
  803c92:	89 04 24             	mov    %eax,(%esp)
  803c95:	e8 fc d5 ff ff       	call   801296 <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  803c9a:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  803c9d:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  803ca0:	8d 45 dc             	lea    -0x24(%ebp),%eax
  803ca3:	89 04 24             	mov    %eax,(%esp)
  803ca6:	8b 45 08             	mov    0x8(%ebp),%eax
  803ca9:	e8 b4 fa ff ff       	call   803762 <lwip_selscan>
  803cae:	89 45 b0             	mov    %eax,-0x50(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  803cb1:	85 c0                	test   %eax,%eax
  803cb3:	0f 85 28 02 00 00    	jne    803ee1 <lwip_select+0x2ef>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  803cb9:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  803cbd:	0f 84 86 00 00 00    	je     803d49 <lwip_select+0x157>
  803cc3:	8b 45 18             	mov    0x18(%ebp),%eax
  803cc6:	83 38 00             	cmpl   $0x0,(%eax)
  803cc9:	0f 85 4f 02 00 00    	jne    803f1e <lwip_select+0x32c>
  803ccf:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  803cd3:	0f 85 45 02 00 00    	jne    803f1e <lwip_select+0x32c>
      sys_sem_signal(selectsem);
  803cd9:	a1 28 63 81 00       	mov    0x816328,%eax
  803cde:	89 04 24             	mov    %eax,(%esp)
  803ce1:	e8 91 99 00 00       	call   80d677 <sys_sem_signal>
      if (readset)
  803ce6:	85 ff                	test   %edi,%edi
  803ce8:	74 18                	je     803d02 <lwip_select+0x110>
        FD_ZERO(readset);
  803cea:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803cf1:	00 
  803cf2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803cf9:	00 
  803cfa:	89 3c 24             	mov    %edi,(%esp)
  803cfd:	e8 94 d5 ff ff       	call   801296 <memset>
      if (writeset)
  803d02:	85 f6                	test   %esi,%esi
  803d04:	74 18                	je     803d1e <lwip_select+0x12c>
        FD_ZERO(writeset);
  803d06:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803d0d:	00 
  803d0e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d15:	00 
  803d16:	89 34 24             	mov    %esi,(%esp)
  803d19:	e8 78 d5 ff ff       	call   801296 <memset>
      if (exceptset)
  803d1e:	85 db                	test   %ebx,%ebx
  803d20:	74 18                	je     803d3a <lwip_select+0x148>
        FD_ZERO(exceptset);
  803d22:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803d29:	00 
  803d2a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d31:	00 
  803d32:	89 1c 24             	mov    %ebx,(%esp)
  803d35:	e8 5c d5 ff ff       	call   801296 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  803d3a:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  803d41:	00 00 00 
  
      return 0;
  803d44:	e9 ca 01 00 00       	jmp    803f13 <lwip_select+0x321>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  803d49:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803d50:	e8 80 97 00 00       	call   80d4d5 <sys_sem_new>
  803d55:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  803d58:	a1 20 63 81 00       	mov    0x816320,%eax
  803d5d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  803d60:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  803d63:	a3 20 63 81 00       	mov    %eax,0x816320
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  803d68:	a1 28 63 81 00       	mov    0x816328,%eax
  803d6d:	89 04 24             	mov    %eax,(%esp)
  803d70:	e8 02 99 00 00       	call   80d677 <sys_sem_signal>
  803d75:	ba 00 00 00 00       	mov    $0x0,%edx
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  803d7a:	89 54 24 04          	mov    %edx,0x4(%esp)
  803d7e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  803d81:	89 04 24             	mov    %eax,(%esp)
  803d84:	e8 60 43 00 00       	call   8080e9 <sys_sem_wait_timeout>
  803d89:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  803d8c:	a1 28 63 81 00       	mov    0x816328,%eax
  803d91:	89 04 24             	mov    %eax,(%esp)
  803d94:	e8 c1 42 00 00       	call   80805a <sys_sem_wait>
    if (select_cb_list == &select_cb)
  803d99:	a1 20 63 81 00       	mov    0x816320,%eax
  803d9e:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  803da1:	39 c2                	cmp    %eax,%edx
  803da3:	75 1f                	jne    803dc4 <lwip_select+0x1d2>
      select_cb_list = select_cb.next;
  803da5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  803da8:	a3 20 63 81 00       	mov    %eax,0x816320
  803dad:	eb 26                	jmp    803dd5 <lwip_select+0x1e3>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  803daf:	8b 10                	mov    (%eax),%edx
  803db1:	39 d1                	cmp    %edx,%ecx
  803db3:	74 08                	je     803dbd <lwip_select+0x1cb>
  803db5:	89 d0                	mov    %edx,%eax
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  803db7:	85 c0                	test   %eax,%eax
  803db9:	75 f4                	jne    803daf <lwip_select+0x1bd>
  803dbb:	eb 18                	jmp    803dd5 <lwip_select+0x1e3>
        if (p_selcb->next == &select_cb) {
          p_selcb->next = select_cb.next;
  803dbd:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  803dc0:	89 10                	mov    %edx,(%eax)
          break;
  803dc2:	eb 11                	jmp    803dd5 <lwip_select+0x1e3>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  803dc4:	85 c0                	test   %eax,%eax
  803dc6:	74 0d                	je     803dd5 <lwip_select+0x1e3>
        if (p_selcb->next == &select_cb) {
  803dc8:	8b 10                	mov    (%eax),%edx
  803dca:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
  803dcd:	39 d1                	cmp    %edx,%ecx
  803dcf:	74 ec                	je     803dbd <lwip_select+0x1cb>
  803dd1:	89 d0                	mov    %edx,%eax
  803dd3:	eb e2                	jmp    803db7 <lwip_select+0x1c5>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  803dd5:	a1 28 63 81 00       	mov    0x816328,%eax
  803dda:	89 04 24             	mov    %eax,(%esp)
  803ddd:	e8 95 98 00 00       	call   80d677 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  803de2:	8b 45 d8             	mov    -0x28(%ebp),%eax
  803de5:	89 04 24             	mov    %eax,(%esp)
  803de8:	e8 26 92 00 00       	call   80d013 <sys_sem_free>
    if (i == 0)  {
  803ded:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  803df1:	75 63                	jne    803e56 <lwip_select+0x264>
      /* Timeout */
      if (readset)
  803df3:	85 ff                	test   %edi,%edi
  803df5:	74 18                	je     803e0f <lwip_select+0x21d>
        FD_ZERO(readset);
  803df7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803dfe:	00 
  803dff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e06:	00 
  803e07:	89 3c 24             	mov    %edi,(%esp)
  803e0a:	e8 87 d4 ff ff       	call   801296 <memset>
      if (writeset)
  803e0f:	85 f6                	test   %esi,%esi
  803e11:	74 18                	je     803e2b <lwip_select+0x239>
        FD_ZERO(writeset);
  803e13:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803e1a:	00 
  803e1b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e22:	00 
  803e23:	89 34 24             	mov    %esi,(%esp)
  803e26:	e8 6b d4 ff ff       	call   801296 <memset>
      if (exceptset)
  803e2b:	85 db                	test   %ebx,%ebx
  803e2d:	74 18                	je     803e47 <lwip_select+0x255>
        FD_ZERO(exceptset);
  803e2f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803e36:	00 
  803e37:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e3e:	00 
  803e3f:	89 1c 24             	mov    %ebx,(%esp)
  803e42:	e8 4f d4 ff ff       	call   801296 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  803e47:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  803e4e:	00 00 00 
  
      return 0;
  803e51:	e9 bd 00 00 00       	jmp    803f13 <lwip_select+0x321>
    }
    
    if (readset)
  803e56:	85 ff                	test   %edi,%edi
  803e58:	74 07                	je     803e61 <lwip_select+0x26f>
      lreadset = *readset;
  803e5a:	8b 07                	mov    (%edi),%eax
  803e5c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803e5f:	eb 1b                	jmp    803e7c <lwip_select+0x28a>
    else
      FD_ZERO(&lreadset);
  803e61:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803e68:	00 
  803e69:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e70:	00 
  803e71:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803e74:	89 04 24             	mov    %eax,(%esp)
  803e77:	e8 1a d4 ff ff       	call   801296 <memset>
    if (writeset)
  803e7c:	85 f6                	test   %esi,%esi
  803e7e:	74 07                	je     803e87 <lwip_select+0x295>
      lwriteset = *writeset;
  803e80:	8b 06                	mov    (%esi),%eax
  803e82:	89 45 e0             	mov    %eax,-0x20(%ebp)
  803e85:	eb 1b                	jmp    803ea2 <lwip_select+0x2b0>
    else
      FD_ZERO(&lwriteset);
  803e87:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803e8e:	00 
  803e8f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e96:	00 
  803e97:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803e9a:	89 04 24             	mov    %eax,(%esp)
  803e9d:	e8 f4 d3 ff ff       	call   801296 <memset>
    if (exceptset)
  803ea2:	85 db                	test   %ebx,%ebx
  803ea4:	74 07                	je     803ead <lwip_select+0x2bb>
      lexceptset = *exceptset;
  803ea6:	8b 03                	mov    (%ebx),%eax
  803ea8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  803eab:	eb 1b                	jmp    803ec8 <lwip_select+0x2d6>
    else
      FD_ZERO(&lexceptset);
  803ead:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803eb4:	00 
  803eb5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803ebc:	00 
  803ebd:	8d 45 dc             	lea    -0x24(%ebp),%eax
  803ec0:	89 04 24             	mov    %eax,(%esp)
  803ec3:	e8 ce d3 ff ff       	call   801296 <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  803ec8:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  803ecb:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  803ece:	8d 45 dc             	lea    -0x24(%ebp),%eax
  803ed1:	89 04 24             	mov    %eax,(%esp)
  803ed4:	8b 45 08             	mov    0x8(%ebp),%eax
  803ed7:	e8 86 f8 ff ff       	call   803762 <lwip_selscan>
  803edc:	89 45 b0             	mov    %eax,-0x50(%ebp)
  803edf:	eb 0d                	jmp    803eee <lwip_select+0x2fc>
  } else
    sys_sem_signal(selectsem);
  803ee1:	a1 28 63 81 00       	mov    0x816328,%eax
  803ee6:	89 04 24             	mov    %eax,(%esp)
  803ee9:	e8 89 97 00 00       	call   80d677 <sys_sem_signal>
  
  if (readset)
  803eee:	85 ff                	test   %edi,%edi
  803ef0:	74 05                	je     803ef7 <lwip_select+0x305>
    *readset = lreadset;
  803ef2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803ef5:	89 07                	mov    %eax,(%edi)
  if (writeset)
  803ef7:	85 f6                	test   %esi,%esi
  803ef9:	74 05                	je     803f00 <lwip_select+0x30e>
    *writeset = lwriteset;
  803efb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803efe:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  803f00:	85 db                	test   %ebx,%ebx
  803f02:	74 05                	je     803f09 <lwip_select+0x317>
    *exceptset = lexceptset;
  803f04:	8b 45 dc             	mov    -0x24(%ebp),%eax
  803f07:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  803f09:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  803f10:	00 00 00 
  
  return nready;
}
  803f13:	8b 45 b0             	mov    -0x50(%ebp),%eax
  803f16:	83 c4 5c             	add    $0x5c,%esp
  803f19:	5b                   	pop    %ebx
  803f1a:	5e                   	pop    %esi
  803f1b:	5f                   	pop    %edi
  803f1c:	5d                   	pop    %ebp
  803f1d:	c3                   	ret    
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  803f1e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803f25:	e8 ab 95 00 00       	call   80d4d5 <sys_sem_new>
  803f2a:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  803f2d:	a1 20 63 81 00       	mov    0x816320,%eax
  803f32:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  803f35:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  803f38:	a3 20 63 81 00       	mov    %eax,0x816320
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  803f3d:	a1 28 63 81 00       	mov    0x816328,%eax
  803f42:	89 04 24             	mov    %eax,(%esp)
  803f45:	e8 2d 97 00 00       	call   80d677 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  803f4a:	8b 45 18             	mov    0x18(%ebp),%eax
  803f4d:	8b 48 04             	mov    0x4(%eax),%ecx
  803f50:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  803f56:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  803f5b:	89 c8                	mov    %ecx,%eax
  803f5d:	f7 ea                	imul   %edx
  803f5f:	c1 fa 06             	sar    $0x6,%edx
  803f62:	c1 f9 1f             	sar    $0x1f,%ecx
  803f65:	29 ca                	sub    %ecx,%edx
  803f67:	8b 45 18             	mov    0x18(%ebp),%eax
  803f6a:	69 08 e8 03 00 00    	imul   $0x3e8,(%eax),%ecx
      if(msectimeout == 0)
  803f70:	01 ca                	add    %ecx,%edx
  803f72:	b8 01 00 00 00       	mov    $0x1,%eax
  803f77:	0f 44 d0             	cmove  %eax,%edx
  803f7a:	e9 fb fd ff ff       	jmp    803d7a <lwip_select+0x188>

00803f7f <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  803f7f:	55                   	push   %ebp
  803f80:	89 e5                	mov    %esp,%ebp
  803f82:	56                   	push   %esi
  803f83:	53                   	push   %ebx
  803f84:	83 ec 10             	sub    $0x10,%esp
  803f87:	8b 45 0c             	mov    0xc(%ebp),%eax
  803f8a:	8b 55 10             	mov    0x10(%ebp),%edx
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  803f8d:	83 f8 02             	cmp    $0x2,%eax
  803f90:	74 2f                	je     803fc1 <lwip_socket+0x42>
  803f92:	83 f8 03             	cmp    $0x3,%eax
  803f95:	74 0b                	je     803fa2 <lwip_socket+0x23>
  803f97:	83 f8 01             	cmp    $0x1,%eax
  803f9a:	75 70                	jne    80400c <lwip_socket+0x8d>
  803f9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803fa0:	eb 4a                	jmp    803fec <lwip_socket+0x6d>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  803fa2:	c7 44 24 08 36 3a 80 	movl   $0x803a36,0x8(%esp)
  803fa9:	00 
  803faa:	0f b6 d2             	movzbl %dl,%edx
  803fad:	89 54 24 04          	mov    %edx,0x4(%esp)
  803fb1:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  803fb8:	e8 8b a6 00 00       	call   80e648 <netconn_new_with_proto_and_callback>
  803fbd:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  803fbf:	eb 5c                	jmp    80401d <lwip_socket+0x9e>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  803fc1:	81 fa 88 00 00 00    	cmp    $0x88,%edx
  803fc7:	0f 94 c0             	sete   %al
  803fca:	0f b6 c0             	movzbl %al,%eax
  803fcd:	83 c0 20             	add    $0x20,%eax
  803fd0:	c7 44 24 08 36 3a 80 	movl   $0x803a36,0x8(%esp)
  803fd7:	00 
  803fd8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803fdf:	00 
  803fe0:	89 04 24             	mov    %eax,(%esp)
  803fe3:	e8 60 a6 00 00       	call   80e648 <netconn_new_with_proto_and_callback>
  803fe8:	89 c6                	mov    %eax,%esi
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  803fea:	eb 31                	jmp    80401d <lwip_socket+0x9e>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  803fec:	c7 44 24 08 36 3a 80 	movl   $0x803a36,0x8(%esp)
  803ff3:	00 
  803ff4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803ffb:	00 
  803ffc:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  804003:	e8 40 a6 00 00       	call   80e648 <netconn_new_with_proto_and_callback>
  804008:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  80400a:	eb 11                	jmp    80401d <lwip_socket+0x9e>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  80400c:	c7 05 20 c2 b3 00 16 	movl   $0x16,0xb3c220
  804013:	00 00 00 
  804016:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  80401b:	eb 44                	jmp    804061 <lwip_socket+0xe2>
  }

  if (!conn) {
  80401d:	85 f6                	test   %esi,%esi
  80401f:	75 11                	jne    804032 <lwip_socket+0xb3>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  804021:	c7 05 20 c2 b3 00 69 	movl   $0x69,0xb3c220
  804028:	00 00 00 
  80402b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  804030:	eb 2f                	jmp    804061 <lwip_socket+0xe2>
  }

  i = alloc_socket(conn);
  804032:	89 f0                	mov    %esi,%eax
  804034:	e8 54 f9 ff ff       	call   80398d <alloc_socket>
  804039:	89 c3                	mov    %eax,%ebx

  if (i == -1) {
  80403b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80403e:	75 14                	jne    804054 <lwip_socket+0xd5>
    netconn_delete(conn);
  804040:	89 34 24             	mov    %esi,(%esp)
  804043:	e8 c3 a5 00 00       	call   80e60b <netconn_delete>
    set_errno(ENFILE);
  804048:	c7 05 20 c2 b3 00 17 	movl   $0x17,0xb3c220
  80404f:	00 00 00 
    return -1;
  804052:	eb 0d                	jmp    804061 <lwip_socket+0xe2>
  }
  conn->socket = i;
  804054:	89 46 1c             	mov    %eax,0x1c(%esi)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  804057:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  80405e:	00 00 00 
  return i;
}
  804061:	89 d8                	mov    %ebx,%eax
  804063:	83 c4 10             	add    $0x10,%esp
  804066:	5b                   	pop    %ebx
  804067:	5e                   	pop    %esi
  804068:	5d                   	pop    %ebp
  804069:	c3                   	ret    

0080406a <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  80406a:	55                   	push   %ebp
  80406b:	89 e5                	mov    %esp,%ebp
  80406d:	83 ec 38             	sub    $0x38,%esp
  804070:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  804073:	89 75 f8             	mov    %esi,-0x8(%ebp)
  804076:	89 7d fc             	mov    %edi,-0x4(%ebp)
  804079:	8b 7d 08             	mov    0x8(%ebp),%edi
  80407c:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  80407f:	89 f8                	mov    %edi,%eax
  804081:	e8 aa ef ff ff       	call   803030 <get_socket>
  804086:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804088:	85 c0                	test   %eax,%eax
  80408a:	0f 84 80 00 00 00    	je     804110 <lwip_send+0xa6>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  804090:	8b 00                	mov    (%eax),%eax
  804092:	83 38 10             	cmpl   $0x10,(%eax)
  804095:	74 2e                	je     8040c5 <lwip_send+0x5b>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  804097:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80409e:	00 
  80409f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8040a6:	00 
  8040a7:	8b 45 14             	mov    0x14(%ebp),%eax
  8040aa:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8040ae:	89 74 24 08          	mov    %esi,0x8(%esp)
  8040b2:	8b 55 0c             	mov    0xc(%ebp),%edx
  8040b5:	89 54 24 04          	mov    %edx,0x4(%esp)
  8040b9:	89 3c 24             	mov    %edi,(%esp)
  8040bc:	e8 8c 00 00 00       	call   80414d <lwip_sendto>
  8040c1:	89 c6                	mov    %eax,%esi
  8040c3:	eb 50                	jmp    804115 <lwip_send+0xab>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  8040c5:	8b 55 14             	mov    0x14(%ebp),%edx
  8040c8:	83 e2 10             	and    $0x10,%edx
  8040cb:	83 fa 01             	cmp    $0x1,%edx
  8040ce:	19 d2                	sbb    %edx,%edx
  8040d0:	83 e2 fe             	and    $0xfffffffe,%edx
  8040d3:	83 c2 03             	add    $0x3,%edx
  8040d6:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8040da:	89 74 24 08          	mov    %esi,0x8(%esp)
  8040de:	8b 55 0c             	mov    0xc(%ebp),%edx
  8040e1:	89 54 24 04          	mov    %edx,0x4(%esp)
  8040e5:	89 04 24             	mov    %eax,(%esp)
  8040e8:	e8 09 a0 00 00       	call   80e0f6 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  8040ed:	0f be c8             	movsbl %al,%ecx
  8040f0:	f7 d9                	neg    %ecx
  8040f2:	ba 05 00 00 00       	mov    $0x5,%edx
  8040f7:	83 f9 0e             	cmp    $0xe,%ecx
  8040fa:	77 07                	ja     804103 <lwip_send+0x99>
  8040fc:	8b 14 8d 60 2a 81 00 	mov    0x812a60(,%ecx,4),%edx
  804103:	89 53 10             	mov    %edx,0x10(%ebx)
  804106:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  return (err==ERR_OK?size:-1);
  80410c:	84 c0                	test   %al,%al
  80410e:	74 05                	je     804115 <lwip_send+0xab>
  804110:	be ff ff ff ff       	mov    $0xffffffff,%esi
}
  804115:	89 f0                	mov    %esi,%eax
  804117:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80411a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80411d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  804120:	89 ec                	mov    %ebp,%esp
  804122:	5d                   	pop    %ebp
  804123:	c3                   	ret    

00804124 <lwip_write>:
  return i;
}

int
lwip_write(int s, const void *data, int size)
{
  804124:	55                   	push   %ebp
  804125:	89 e5                	mov    %esp,%ebp
  804127:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  80412a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804131:	00 
  804132:	8b 45 10             	mov    0x10(%ebp),%eax
  804135:	89 44 24 08          	mov    %eax,0x8(%esp)
  804139:	8b 45 0c             	mov    0xc(%ebp),%eax
  80413c:	89 44 24 04          	mov    %eax,0x4(%esp)
  804140:	8b 45 08             	mov    0x8(%ebp),%eax
  804143:	89 04 24             	mov    %eax,(%esp)
  804146:	e8 1f ff ff ff       	call   80406a <lwip_send>
}
  80414b:	c9                   	leave  
  80414c:	c3                   	ret    

0080414d <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  80414d:	55                   	push   %ebp
  80414e:	89 e5                	mov    %esp,%ebp
  804150:	57                   	push   %edi
  804151:	56                   	push   %esi
  804152:	53                   	push   %ebx
  804153:	83 ec 3c             	sub    $0x3c,%esp
  804156:	8b 7d 10             	mov    0x10(%ebp),%edi
  804159:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  80415c:	8b 45 08             	mov    0x8(%ebp),%eax
  80415f:	e8 cc ee ff ff       	call   803030 <get_socket>
  804164:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804166:	85 c0                	test   %eax,%eax
  804168:	0f 84 2e 01 00 00    	je     80429c <lwip_sendto+0x14f>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  80416e:	8b 00                	mov    (%eax),%eax
  804170:	83 38 10             	cmpl   $0x10,(%eax)
  804173:	75 24                	jne    804199 <lwip_sendto+0x4c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  804175:	8b 45 14             	mov    0x14(%ebp),%eax
  804178:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80417c:	89 7c 24 08          	mov    %edi,0x8(%esp)
  804180:	8b 45 0c             	mov    0xc(%ebp),%eax
  804183:	89 44 24 04          	mov    %eax,0x4(%esp)
  804187:	8b 45 08             	mov    0x8(%ebp),%eax
  80418a:	89 04 24             	mov    %eax,(%esp)
  80418d:	e8 d8 fe ff ff       	call   80406a <lwip_send>
  804192:	89 c7                	mov    %eax,%edi
  804194:	e9 08 01 00 00       	jmp    8042a1 <lwip_sendto+0x154>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  804199:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  80419f:	76 1c                	jbe    8041bd <lwip_sendto+0x70>
  8041a1:	c7 44 24 08 28 2a 81 	movl   $0x812a28,0x8(%esp)
  8041a8:	00 
  8041a9:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  8041b0:	00 
  8041b1:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  8041b8:	e8 57 c7 ff ff       	call   800914 <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8041bd:	85 f6                	test   %esi,%esi
  8041bf:	0f 95 c0             	setne  %al
  8041c2:	75 06                	jne    8041ca <lwip_sendto+0x7d>
  8041c4:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8041c8:	74 2a                	je     8041f4 <lwip_sendto+0xa7>
  8041ca:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  8041ce:	66 90                	xchg   %ax,%ax
  8041d0:	75 06                	jne    8041d8 <lwip_sendto+0x8b>
  8041d2:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8041d6:	74 1c                	je     8041f4 <lwip_sendto+0xa7>
  8041d8:	c7 44 24 08 a6 29 81 	movl   $0x8129a6,0x8(%esp)
  8041df:	00 
  8041e0:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  8041e7:	00 
  8041e8:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  8041ef:	e8 20 c7 ff ff       	call   800914 <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  8041f4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8041fb:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  804202:	84 c0                	test   %al,%al
  804204:	74 1e                	je     804224 <lwip_sendto+0xd7>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  804206:	8b 46 04             	mov    0x4(%esi),%eax
  804209:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  80420c:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  804210:	89 04 24             	mov    %eax,(%esp)
  804213:	e8 78 65 00 00       	call   80a790 <ntohs>
    buf.addr         = &remote_addr;
  804218:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80421b:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  80421e:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  804222:	eb 14                	jmp    804238 <lwip_sendto+0xeb>
  } else {
    remote_addr.addr = 0;
  804224:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  80422b:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  804232:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  804238:	0f b7 c7             	movzwl %di,%eax
  80423b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80423f:	8b 45 0c             	mov    0xc(%ebp),%eax
  804242:	89 44 24 04          	mov    %eax,0x4(%esp)
  804246:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  804249:	89 04 24             	mov    %eax,(%esp)
  80424c:	e8 9c 0e 00 00       	call   8050ed <netbuf_ref>
  804251:	0f be f0             	movsbl %al,%esi
  804254:	85 f6                	test   %esi,%esi
  804256:	75 14                	jne    80426c <lwip_sendto+0x11f>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  804258:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80425b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80425f:	8b 03                	mov    (%ebx),%eax
  804261:	89 04 24             	mov    %eax,(%esp)
  804264:	e8 0a 9f 00 00       	call   80e173 <netconn_send>
  804269:	0f be f0             	movsbl %al,%esi
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  80426c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80426f:	85 c0                	test   %eax,%eax
  804271:	74 08                	je     80427b <lwip_sendto+0x12e>
    pbuf_free(buf.p);
  804273:	89 04 24             	mov    %eax,(%esp)
  804276:	e8 12 37 00 00       	call   80798d <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  80427b:	89 f2                	mov    %esi,%edx
  80427d:	f7 da                	neg    %edx
  80427f:	b8 05 00 00 00       	mov    $0x5,%eax
  804284:	83 fa 0e             	cmp    $0xe,%edx
  804287:	77 07                	ja     804290 <lwip_sendto+0x143>
  804289:	8b 04 95 60 2a 81 00 	mov    0x812a60(,%edx,4),%eax
  804290:	89 43 10             	mov    %eax,0x10(%ebx)
  804293:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  return (err==ERR_OK?size:-1);
  804298:	85 f6                	test   %esi,%esi
  80429a:	74 05                	je     8042a1 <lwip_sendto+0x154>
  80429c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  8042a1:	89 f8                	mov    %edi,%eax
  8042a3:	83 c4 3c             	add    $0x3c,%esp
  8042a6:	5b                   	pop    %ebx
  8042a7:	5e                   	pop    %esi
  8042a8:	5f                   	pop    %edi
  8042a9:	5d                   	pop    %ebp
  8042aa:	c3                   	ret    

008042ab <lwip_recvfrom>:
}

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8042ab:	55                   	push   %ebp
  8042ac:	89 e5                	mov    %esp,%ebp
  8042ae:	57                   	push   %edi
  8042af:	56                   	push   %esi
  8042b0:	53                   	push   %ebx
  8042b1:	83 ec 5c             	sub    $0x5c,%esp
  8042b4:	8b 75 14             	mov    0x14(%ebp),%esi
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8042b7:	8b 45 08             	mov    0x8(%ebp),%eax
  8042ba:	e8 71 ed ff ff       	call   803030 <get_socket>
  8042bf:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8042c1:	66 c7 45 c6 00 00    	movw   $0x0,-0x3a(%ebp)
  8042c7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8042cc:	85 db                	test   %ebx,%ebx
  8042ce:	0f 84 0b 02 00 00    	je     8044df <lwip_recvfrom+0x234>
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8042d4:	89 f0                	mov    %esi,%eax
  8042d6:	83 e0 08             	and    $0x8,%eax
  8042d9:	89 45 b0             	mov    %eax,-0x50(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8042dc:	83 e6 01             	and    $0x1,%esi
  8042df:	89 75 b4             	mov    %esi,-0x4c(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  8042e2:	8b 73 04             	mov    0x4(%ebx),%esi
  8042e5:	85 f6                	test   %esi,%esi
  8042e7:	75 7d                	jne    804366 <lwip_recvfrom+0xbb>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8042e9:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  8042ed:	75 06                	jne    8042f5 <lwip_recvfrom+0x4a>
  8042ef:	f6 43 0f 08          	testb  $0x8,0xf(%ebx)
  8042f3:	74 22                	je     804317 <lwip_recvfrom+0x6c>
  8042f5:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8042fa:	75 1b                	jne    804317 <lwip_recvfrom+0x6c>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  8042fc:	c7 43 10 0b 00 00 00 	movl   $0xb,0x10(%ebx)
  804303:	c7 05 20 c2 b3 00 0b 	movl   $0xb,0xb3c220
  80430a:	00 00 00 
  80430d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
        return -1;
  804312:	e9 c8 01 00 00       	jmp    8044df <lwip_recvfrom+0x234>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  804317:	8b 03                	mov    (%ebx),%eax
  804319:	89 04 24             	mov    %eax,(%esp)
  80431c:	e8 38 a1 00 00       	call   80e459 <netconn_recv>
  804321:	89 c6                	mov    %eax,%esi
  804323:	89 43 04             	mov    %eax,0x4(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  804326:	85 c0                	test   %eax,%eax
  804328:	75 3c                	jne    804366 <lwip_recvfrom+0xbb>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  80432a:	8b 13                	mov    (%ebx),%edx
  80432c:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  804330:	74 0b                	je     80433d <lwip_recvfrom+0x92>
  804332:	b8 6e 00 00 00       	mov    $0x6e,%eax
  804337:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  80433b:	74 17                	je     804354 <lwip_recvfrom+0xa9>
  80433d:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  804341:	f7 da                	neg    %edx
  804343:	b8 05 00 00 00       	mov    $0x5,%eax
  804348:	83 fa 0e             	cmp    $0xe,%edx
  80434b:	77 07                	ja     804354 <lwip_recvfrom+0xa9>
  80434d:	8b 04 95 60 2a 81 00 	mov    0x812a60(,%edx,4),%eax
  804354:	89 43 10             	mov    %eax,0x10(%ebx)
  804357:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  80435c:	b8 00 00 00 00       	mov    $0x0,%eax
        return 0;
  804361:	e9 79 01 00 00       	jmp    8044df <lwip_recvfrom+0x234>
      }
    }

    buflen = netbuf_len(buf);
  804366:	8b 06                	mov    (%esi),%eax
  804368:	0f b7 78 08          	movzwl 0x8(%eax),%edi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  80436c:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  804370:	66 29 d7             	sub    %dx,%di

    if (len > buflen) {
  804373:	0f b7 cf             	movzwl %di,%ecx
  804376:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  804379:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  80437c:	0f 4e 7d 10          	cmovle 0x10(%ebp),%edi
      copylen = len;
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  804380:	0f b7 cf             	movzwl %di,%ecx
  804383:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  804386:	0f b7 d2             	movzwl %dx,%edx
  804389:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80438d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  804391:	0f b7 55 c6          	movzwl -0x3a(%ebp),%edx
  804395:	03 55 0c             	add    0xc(%ebp),%edx
  804398:	89 54 24 04          	mov    %edx,0x4(%esp)
  80439c:	89 04 24             	mov    %eax,(%esp)
  80439f:	e8 72 33 00 00       	call   807716 <pbuf_copy_partial>

    off += copylen;
  8043a4:	66 01 7d c6          	add    %di,-0x3a(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8043a8:	8b 03                	mov    (%ebx),%eax
  8043aa:	89 04 24             	mov    %eax,(%esp)
  8043ad:	e8 ce 9c 00 00       	call   80e080 <netconn_type>
  8043b2:	83 f8 10             	cmp    $0x10,%eax
  8043b5:	75 1f                	jne    8043d6 <lwip_recvfrom+0x12b>
      len -= copylen;
  8043b7:	8b 45 c0             	mov    -0x40(%ebp),%eax
  8043ba:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8043bd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8043c1:	7e 13                	jle    8043d6 <lwip_recvfrom+0x12b>
  8043c3:	8b 06                	mov    (%esi),%eax
  8043c5:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8043c9:	75 0b                	jne    8043d6 <lwip_recvfrom+0x12b>
  8043cb:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
  8043cf:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8043d4:	75 04                	jne    8043da <lwip_recvfrom+0x12f>
  8043d6:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8043da:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8043de:	75 39                	jne    804419 <lwip_recvfrom+0x16e>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8043e0:	8b 03                	mov    (%ebx),%eax
  8043e2:	83 38 10             	cmpl   $0x10,(%eax)
  8043e5:	75 13                	jne    8043fa <lwip_recvfrom+0x14f>
  8043e7:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8043ea:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8043ed:	85 c0                	test   %eax,%eax
  8043ef:	7e 09                	jle    8043fa <lwip_recvfrom+0x14f>
        sock->lastdata = buf;
  8043f1:	89 73 04             	mov    %esi,0x4(%ebx)
        sock->lastoffset += copylen;
  8043f4:	66 01 7b 08          	add    %di,0x8(%ebx)
    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8043f8:	eb 15                	jmp    80440f <lwip_recvfrom+0x164>
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
      } else {
        sock->lastdata = NULL;
  8043fa:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
        sock->lastoffset = 0;
  804401:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  804407:	89 34 24             	mov    %esi,(%esp)
  80440a:	e8 9f 0c 00 00       	call   8050ae <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  80440f:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
  804413:	0f 84 c9 fe ff ff    	je     8042e2 <lwip_recvfrom+0x37>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  804419:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  80441d:	0f 84 a7 00 00 00    	je     8044ca <lwip_recvfrom+0x21f>
  804423:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  804427:	0f 84 9d 00 00 00    	je     8044ca <lwip_recvfrom+0x21f>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  80442d:	8b 03                	mov    (%ebx),%eax
  80442f:	89 04 24             	mov    %eax,(%esp)
  804432:	e8 49 9c 00 00       	call   80e080 <netconn_type>
  804437:	83 f8 10             	cmp    $0x10,%eax
  80443a:	75 22                	jne    80445e <lwip_recvfrom+0x1b3>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  80443c:	8d 7d d8             	lea    -0x28(%ebp),%edi
      netconn_getaddr(sock->conn, addr, &port, 0);
  80443f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804446:	00 
  804447:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  80444a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80444e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  804452:	8b 03                	mov    (%ebx),%eax
  804454:	89 04 24             	mov    %eax,(%esp)
  804457:	e8 d7 9e 00 00       	call   80e333 <netconn_getaddr>
  80445c:	eb 0b                	jmp    804469 <lwip_recvfrom+0x1be>
    } else {
      addr = netbuf_fromaddr(buf);
  80445e:	8b 7e 08             	mov    0x8(%esi),%edi
      port = netbuf_fromport(buf);
  804461:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  804465:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  804469:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  804470:	00 
  804471:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804478:	00 
  804479:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80447c:	89 04 24             	mov    %eax,(%esp)
  80447f:	e8 12 ce ff ff       	call   801296 <memset>
    sin.sin_len = sizeof(sin);
  804484:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  804488:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  80448c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804490:	89 04 24             	mov    %eax,(%esp)
  804493:	e8 eb 62 00 00       	call   80a783 <htons>
  804498:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  80449c:	8b 07                	mov    (%edi),%eax
  80449e:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  8044a1:	8b 55 1c             	mov    0x1c(%ebp),%edx
  8044a4:	83 3a 10             	cmpl   $0x10,(%edx)
  8044a7:	76 06                	jbe    8044af <lwip_recvfrom+0x204>
      *fromlen = sizeof(sin);
  8044a9:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

    SMEMCPY(from, &sin, *fromlen);
  8044af:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  8044b2:	8b 01                	mov    (%ecx),%eax
  8044b4:	89 44 24 08          	mov    %eax,0x8(%esp)
  8044b8:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8044bb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8044bf:	8b 45 18             	mov    0x18(%ebp),%eax
  8044c2:	89 04 24             	mov    %eax,(%esp)
  8044c5:	e8 a7 ce ff ff       	call   801371 <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  8044ca:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8044d1:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8044d8:	00 00 00 
  return off;
  8044db:	0f b7 45 c6          	movzwl -0x3a(%ebp),%eax
}
  8044df:	83 c4 5c             	add    $0x5c,%esp
  8044e2:	5b                   	pop    %ebx
  8044e3:	5e                   	pop    %esi
  8044e4:	5f                   	pop    %edi
  8044e5:	5d                   	pop    %ebp
  8044e6:	c3                   	ret    

008044e7 <lwip_recv>:
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
}

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  8044e7:	55                   	push   %ebp
  8044e8:	89 e5                	mov    %esp,%ebp
  8044ea:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  8044ed:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8044f4:	00 
  8044f5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8044fc:	00 
  8044fd:	8b 45 14             	mov    0x14(%ebp),%eax
  804500:	89 44 24 0c          	mov    %eax,0xc(%esp)
  804504:	8b 45 10             	mov    0x10(%ebp),%eax
  804507:	89 44 24 08          	mov    %eax,0x8(%esp)
  80450b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80450e:	89 44 24 04          	mov    %eax,0x4(%esp)
  804512:	8b 45 08             	mov    0x8(%ebp),%eax
  804515:	89 04 24             	mov    %eax,(%esp)
  804518:	e8 8e fd ff ff       	call   8042ab <lwip_recvfrom>
}
  80451d:	c9                   	leave  
  80451e:	c3                   	ret    

0080451f <lwip_read>:
  return off;
}

int
lwip_read(int s, void *mem, int len)
{
  80451f:	55                   	push   %ebp
  804520:	89 e5                	mov    %esp,%ebp
  804522:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  804525:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80452c:	00 
  80452d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  804534:	00 
  804535:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80453c:	00 
  80453d:	8b 45 10             	mov    0x10(%ebp),%eax
  804540:	89 44 24 08          	mov    %eax,0x8(%esp)
  804544:	8b 45 0c             	mov    0xc(%ebp),%eax
  804547:	89 44 24 04          	mov    %eax,0x4(%esp)
  80454b:	8b 45 08             	mov    0x8(%ebp),%eax
  80454e:	89 04 24             	mov    %eax,(%esp)
  804551:	e8 55 fd ff ff       	call   8042ab <lwip_recvfrom>
}
  804556:	c9                   	leave  
  804557:	c3                   	ret    

00804558 <lwip_close>:
  return 0;
}

int
lwip_close(int s)
{
  804558:	55                   	push   %ebp
  804559:	89 e5                	mov    %esp,%ebp
  80455b:	53                   	push   %ebx
  80455c:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  80455f:	8b 45 08             	mov    0x8(%ebp),%eax
  804562:	e8 c9 ea ff ff       	call   803030 <get_socket>
  804567:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  804569:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80456e:	85 db                	test   %ebx,%ebx
  804570:	74 5c                	je     8045ce <lwip_close+0x76>
    return -1;
  }

  netconn_delete(sock->conn);
  804572:	8b 03                	mov    (%ebx),%eax
  804574:	89 04 24             	mov    %eax,(%esp)
  804577:	e8 8f a0 00 00       	call   80e60b <netconn_delete>

  sys_sem_wait(socksem);
  80457c:	a1 24 63 81 00       	mov    0x816324,%eax
  804581:	89 04 24             	mov    %eax,(%esp)
  804584:	e8 d1 3a 00 00       	call   80805a <sys_sem_wait>
  if (sock->lastdata) {
  804589:	8b 43 04             	mov    0x4(%ebx),%eax
  80458c:	85 c0                	test   %eax,%eax
  80458e:	74 08                	je     804598 <lwip_close+0x40>
    netbuf_delete(sock->lastdata);
  804590:	89 04 24             	mov    %eax,(%esp)
  804593:	e8 16 0b 00 00       	call   8050ae <netbuf_delete>
  }
  sock->lastdata   = NULL;
  804598:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  80459f:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  8045a5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  8045ab:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8045b2:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8045b9:	00 00 00 
  sys_sem_signal(socksem);
  8045bc:	a1 24 63 81 00       	mov    0x816324,%eax
  8045c1:	89 04 24             	mov    %eax,(%esp)
  8045c4:	e8 ae 90 00 00       	call   80d677 <sys_sem_signal>
  8045c9:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  8045ce:	83 c4 14             	add    $0x14,%esp
  8045d1:	5b                   	pop    %ebx
  8045d2:	5d                   	pop    %ebp
  8045d3:	c3                   	ret    

008045d4 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  8045d4:	55                   	push   %ebp
  8045d5:	89 e5                	mov    %esp,%ebp
  8045d7:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  8045da:	8b 45 08             	mov    0x8(%ebp),%eax
  8045dd:	89 04 24             	mov    %eax,(%esp)
  8045e0:	e8 73 ff ff ff       	call   804558 <lwip_close>
}
  8045e5:	c9                   	leave  
  8045e6:	c3                   	ret    

008045e7 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  8045e7:	55                   	push   %ebp
  8045e8:	89 e5                	mov    %esp,%ebp
  8045ea:	56                   	push   %esi
  8045eb:	53                   	push   %ebx
  8045ec:	83 ec 10             	sub    $0x10,%esp
  8045ef:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  8045f2:	8b 45 08             	mov    0x8(%ebp),%eax
  8045f5:	e8 36 ea ff ff       	call   803030 <get_socket>
  8045fa:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8045fc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804601:	85 db                	test   %ebx,%ebx
  804603:	74 69                	je     80466e <lwip_listen+0x87>
  804605:	85 f6                	test   %esi,%esi
  804607:	b8 00 00 00 00       	mov    $0x0,%eax
  80460c:	0f 48 f0             	cmovs  %eax,%esi
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  80460f:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  804615:	b0 ff                	mov    $0xff,%al
  804617:	0f 4f f0             	cmovg  %eax,%esi
  80461a:	81 e6 ff 00 00 00    	and    $0xff,%esi
  804620:	89 74 24 04          	mov    %esi,0x4(%esp)
  804624:	8b 03                	mov    (%ebx),%eax
  804626:	89 04 24             	mov    %eax,(%esp)
  804629:	e8 c5 9b 00 00       	call   80e1f3 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  80462e:	84 c0                	test   %al,%al
  804630:	74 26                	je     804658 <lwip_listen+0x71>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804632:	0f be c0             	movsbl %al,%eax
  804635:	f7 d8                	neg    %eax
  804637:	ba 05 00 00 00       	mov    $0x5,%edx
  80463c:	83 f8 0e             	cmp    $0xe,%eax
  80463f:	77 07                	ja     804648 <lwip_listen+0x61>
  804641:	8b 14 85 60 2a 81 00 	mov    0x812a60(,%eax,4),%edx
  804648:	89 53 10             	mov    %edx,0x10(%ebx)
  80464b:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  804651:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804656:	eb 16                	jmp    80466e <lwip_listen+0x87>
  }

  sock_set_errno(sock, 0);
  804658:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80465f:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  804666:	00 00 00 
  804669:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  80466e:	83 c4 10             	add    $0x10,%esp
  804671:	5b                   	pop    %ebx
  804672:	5e                   	pop    %esi
  804673:	5d                   	pop    %ebp
  804674:	c3                   	ret    

00804675 <lwip_connect>:
  return 0;
}

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804675:	55                   	push   %ebp
  804676:	89 e5                	mov    %esp,%ebp
  804678:	53                   	push   %ebx
  804679:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  80467c:	8b 45 08             	mov    0x8(%ebp),%eax
  80467f:	e8 ac e9 ff ff       	call   803030 <get_socket>
  804684:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804686:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80468b:	85 db                	test   %ebx,%ebx
  80468d:	0f 84 95 00 00 00    	je     804728 <lwip_connect+0xb3>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  804693:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  804697:	75 09                	jne    8046a2 <lwip_connect+0x2d>
  804699:	8b 45 0c             	mov    0xc(%ebp),%eax
  80469c:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  8046a0:	74 1c                	je     8046be <lwip_connect+0x49>
  8046a2:	c7 44 24 08 c3 29 81 	movl   $0x8129c3,0x8(%esp)
  8046a9:	00 
  8046aa:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  8046b1:	00 
  8046b2:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  8046b9:	e8 56 c2 ff ff       	call   800914 <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8046be:	8b 50 04             	mov    0x4(%eax),%edx
  8046c1:	89 55 f4             	mov    %edx,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8046c4:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  8046c8:	89 04 24             	mov    %eax,(%esp)
  8046cb:	e8 c0 60 00 00       	call   80a790 <ntohs>
  8046d0:	0f b7 c0             	movzwl %ax,%eax
  8046d3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8046d7:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8046da:	89 44 24 04          	mov    %eax,0x4(%esp)
  8046de:	8b 03                	mov    (%ebx),%eax
  8046e0:	89 04 24             	mov    %eax,(%esp)
  8046e3:	e8 9d 9b 00 00       	call   80e285 <netconn_connect>
  }

  if (err != ERR_OK) {
  8046e8:	84 c0                	test   %al,%al
  8046ea:	74 26                	je     804712 <lwip_connect+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8046ec:	0f be c0             	movsbl %al,%eax
  8046ef:	f7 d8                	neg    %eax
  8046f1:	ba 05 00 00 00       	mov    $0x5,%edx
  8046f6:	83 f8 0e             	cmp    $0xe,%eax
  8046f9:	77 07                	ja     804702 <lwip_connect+0x8d>
  8046fb:	8b 14 85 60 2a 81 00 	mov    0x812a60(,%eax,4),%edx
  804702:	89 53 10             	mov    %edx,0x10(%ebx)
  804705:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  80470b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804710:	eb 16                	jmp    804728 <lwip_connect+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  804712:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804719:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  804720:	00 00 00 
  804723:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804728:	83 c4 24             	add    $0x24,%esp
  80472b:	5b                   	pop    %ebx
  80472c:	5d                   	pop    %ebp
  80472d:	c3                   	ret    

0080472e <lwip_bind>:
  return newsock;
}

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80472e:	55                   	push   %ebp
  80472f:	89 e5                	mov    %esp,%ebp
  804731:	53                   	push   %ebx
  804732:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  804735:	8b 45 08             	mov    0x8(%ebp),%eax
  804738:	e8 f3 e8 ff ff       	call   803030 <get_socket>
  80473d:	89 c3                	mov    %eax,%ebx
  if (!sock)
  80473f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804744:	85 db                	test   %ebx,%ebx
  804746:	0f 84 95 00 00 00    	je     8047e1 <lwip_bind+0xb3>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80474c:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  804750:	75 09                	jne    80475b <lwip_bind+0x2d>
  804752:	8b 45 0c             	mov    0xc(%ebp),%eax
  804755:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  804759:	74 1c                	je     804777 <lwip_bind+0x49>
  80475b:	c7 44 24 08 e1 29 81 	movl   $0x8129e1,0x8(%esp)
  804762:	00 
  804763:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  80476a:	00 
  80476b:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  804772:	e8 9d c1 ff ff       	call   800914 <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  804777:	8b 50 04             	mov    0x4(%eax),%edx
  80477a:	89 55 f4             	mov    %edx,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  80477d:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  804781:	89 04 24             	mov    %eax,(%esp)
  804784:	e8 07 60 00 00       	call   80a790 <ntohs>
  804789:	0f b7 c0             	movzwl %ax,%eax
  80478c:	89 44 24 08          	mov    %eax,0x8(%esp)
  804790:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804793:	89 44 24 04          	mov    %eax,0x4(%esp)
  804797:	8b 03                	mov    (%ebx),%eax
  804799:	89 04 24             	mov    %eax,(%esp)
  80479c:	e8 3b 9b 00 00       	call   80e2dc <netconn_bind>

  if (err != ERR_OK) {
  8047a1:	84 c0                	test   %al,%al
  8047a3:	74 26                	je     8047cb <lwip_bind+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8047a5:	0f be c0             	movsbl %al,%eax
  8047a8:	f7 d8                	neg    %eax
  8047aa:	ba 05 00 00 00       	mov    $0x5,%edx
  8047af:	83 f8 0e             	cmp    $0xe,%eax
  8047b2:	77 07                	ja     8047bb <lwip_bind+0x8d>
  8047b4:	8b 14 85 60 2a 81 00 	mov    0x812a60(,%eax,4),%edx
  8047bb:	89 53 10             	mov    %edx,0x10(%ebx)
  8047be:	89 15 20 c2 b3 00    	mov    %edx,0xb3c220
  8047c4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  8047c9:	eb 16                	jmp    8047e1 <lwip_bind+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8047cb:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8047d2:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8047d9:	00 00 00 
  8047dc:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  8047e1:	83 c4 24             	add    $0x24,%esp
  8047e4:	5b                   	pop    %ebx
  8047e5:	5d                   	pop    %ebp
  8047e6:	c3                   	ret    

008047e7 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  8047e7:	55                   	push   %ebp
  8047e8:	89 e5                	mov    %esp,%ebp
  8047ea:	57                   	push   %edi
  8047eb:	56                   	push   %esi
  8047ec:	53                   	push   %ebx
  8047ed:	83 ec 4c             	sub    $0x4c,%esp
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  8047f0:	8b 45 08             	mov    0x8(%ebp),%eax
  8047f3:	e8 38 e8 ff ff       	call   803030 <get_socket>
  8047f8:	89 c7                	mov    %eax,%edi
  if (!sock)
  8047fa:	be ff ff ff ff       	mov    $0xffffffff,%esi
  8047ff:	85 c0                	test   %eax,%eax
  804801:	0f 84 ae 01 00 00    	je     8049b5 <lwip_accept+0x1ce>
    return -1;

  newconn = netconn_accept(sock->conn);
  804807:	8b 00                	mov    (%eax),%eax
  804809:	89 04 24             	mov    %eax,(%esp)
  80480c:	e8 be 9b 00 00       	call   80e3cf <netconn_accept>
  804811:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  804813:	85 c0                	test   %eax,%eax
  804815:	75 2b                	jne    804842 <lwip_accept+0x5b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  804817:	8b 07                	mov    (%edi),%eax
  804819:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  80481d:	f7 da                	neg    %edx
  80481f:	b8 05 00 00 00       	mov    $0x5,%eax
  804824:	83 fa 0e             	cmp    $0xe,%edx
  804827:	77 07                	ja     804830 <lwip_accept+0x49>
  804829:	8b 04 95 60 2a 81 00 	mov    0x812a60(,%edx,4),%eax
  804830:	89 47 10             	mov    %eax,0x10(%edi)
  804833:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  804838:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  80483d:	e9 73 01 00 00       	jmp    8049b5 <lwip_accept+0x1ce>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  804842:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804849:	00 
  80484a:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  80484d:	89 44 24 08          	mov    %eax,0x8(%esp)
  804851:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  804854:	89 44 24 04          	mov    %eax,0x4(%esp)
  804858:	89 1c 24             	mov    %ebx,(%esp)
  80485b:	e8 d3 9a 00 00       	call   80e333 <netconn_getaddr>
  804860:	89 c6                	mov    %eax,%esi
  if (err != ERR_OK) {
  804862:	84 c0                	test   %al,%al
  804864:	74 32                	je     804898 <lwip_accept+0xb1>
    netconn_delete(newconn);
  804866:	89 1c 24             	mov    %ebx,(%esp)
  804869:	e8 9d 9d 00 00       	call   80e60b <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  80486e:	89 f0                	mov    %esi,%eax
  804870:	0f be f0             	movsbl %al,%esi
  804873:	f7 de                	neg    %esi
  804875:	b8 05 00 00 00       	mov    $0x5,%eax
  80487a:	83 fe 0e             	cmp    $0xe,%esi
  80487d:	77 07                	ja     804886 <lwip_accept+0x9f>
  80487f:	8b 04 b5 60 2a 81 00 	mov    0x812a60(,%esi,4),%eax
  804886:	89 47 10             	mov    %eax,0x10(%edi)
  804889:	a3 20 c2 b3 00       	mov    %eax,0xb3c220
  80488e:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  804893:	e9 1d 01 00 00       	jmp    8049b5 <lwip_accept+0x1ce>
  }

  memset(&sin, 0, sizeof(sin));
  804898:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  80489f:	00 
  8048a0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8048a7:	00 
  8048a8:	8d 45 d0             	lea    -0x30(%ebp),%eax
  8048ab:	89 04 24             	mov    %eax,(%esp)
  8048ae:	e8 e3 c9 ff ff       	call   801296 <memset>
  sin.sin_len = sizeof(sin);
  8048b3:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  8048b7:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  8048bb:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8048bf:	89 04 24             	mov    %eax,(%esp)
  8048c2:	e8 bc 5e 00 00       	call   80a783 <htons>
  8048c7:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8048cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8048ce:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  8048d1:	8b 55 10             	mov    0x10(%ebp),%edx
  8048d4:	83 3a 10             	cmpl   $0x10,(%edx)
  8048d7:	76 06                	jbe    8048df <lwip_accept+0xf8>
    *addrlen = sizeof(sin);
  8048d9:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

  SMEMCPY(addr, &sin, *addrlen);
  8048df:	8b 55 10             	mov    0x10(%ebp),%edx
  8048e2:	8b 02                	mov    (%edx),%eax
  8048e4:	89 44 24 08          	mov    %eax,0x8(%esp)
  8048e8:	8d 45 d0             	lea    -0x30(%ebp),%eax
  8048eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8048ef:	8b 45 0c             	mov    0xc(%ebp),%eax
  8048f2:	89 04 24             	mov    %eax,(%esp)
  8048f5:	e8 77 ca ff ff       	call   801371 <memcpy>

  newsock = alloc_socket(newconn);
  8048fa:	89 d8                	mov    %ebx,%eax
  8048fc:	e8 8c f0 ff ff       	call   80398d <alloc_socket>
  804901:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  804903:	83 f8 ff             	cmp    $0xffffffff,%eax
  804906:	75 1e                	jne    804926 <lwip_accept+0x13f>
    netconn_delete(newconn);
  804908:	89 1c 24             	mov    %ebx,(%esp)
  80490b:	e8 fb 9c 00 00       	call   80e60b <netconn_delete>
    sock_set_errno(sock, ENFILE);
  804910:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  804917:	c7 05 20 c2 b3 00 17 	movl   $0x17,0xb3c220
  80491e:	00 00 00 
    return -1;
  804921:	e9 8f 00 00 00       	jmp    8049b5 <lwip_accept+0x1ce>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  804926:	83 fe 1f             	cmp    $0x1f,%esi
  804929:	76 1c                	jbe    804947 <lwip_accept+0x160>
  80492b:	c7 44 24 08 fc 29 81 	movl   $0x8129fc,0x8(%esp)
  804932:	00 
  804933:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  80493a:	00 
  80493b:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  804942:	e8 cd bf ff ff       	call   800914 <_panic>
  newconn->callback = event_callback;
  804947:	c7 43 2c 36 3a 80 00 	movl   $0x803a36,0x2c(%ebx)
  nsock = &sockets[newsock];
  80494e:	8d 04 80             	lea    (%eax,%eax,4),%eax
  804951:	8d 04 85 a0 60 81 00 	lea    0x8160a0(,%eax,4),%eax
  804958:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  80495b:	85 c0                	test   %eax,%eax
  80495d:	75 1c                	jne    80497b <lwip_accept+0x194>
  80495f:	c7 44 24 08 11 2a 81 	movl   $0x812a11,0x8(%esp)
  804966:	00 
  804967:	c7 44 24 04 28 01 00 	movl   $0x128,0x4(%esp)
  80496e:	00 
  80496f:	c7 04 24 81 29 81 00 	movl   $0x812981,(%esp)
  804976:	e8 99 bf ff ff       	call   800914 <_panic>

  sys_sem_wait(socksem);
  80497b:	a1 24 63 81 00       	mov    0x816324,%eax
  804980:	89 04 24             	mov    %eax,(%esp)
  804983:	e8 d2 36 00 00       	call   80805a <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  804988:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80498b:	f7 d0                	not    %eax
  80498d:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  804990:	66 01 42 0a          	add    %ax,0xa(%edx)
  newconn->socket = newsock;
  804994:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  804997:	a1 24 63 81 00       	mov    0x816324,%eax
  80499c:	89 04 24             	mov    %eax,(%esp)
  80499f:	e8 d3 8c 00 00       	call   80d677 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  8049a4:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8049ab:	c7 05 20 c2 b3 00 00 	movl   $0x0,0xb3c220
  8049b2:	00 00 00 
  return newsock;
}
  8049b5:	89 f0                	mov    %esi,%eax
  8049b7:	83 c4 4c             	add    $0x4c,%esp
  8049ba:	5b                   	pop    %ebx
  8049bb:	5e                   	pop    %esi
  8049bc:	5f                   	pop    %edi
  8049bd:	5d                   	pop    %ebp
  8049be:	c3                   	ret    
	...

008049c0 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8049c0:	55                   	push   %ebp
  8049c1:	89 e5                	mov    %esp,%ebp
  8049c3:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  8049c6:	8b 45 08             	mov    0x8(%ebp),%eax
  8049c9:	89 04 24             	mov    %eax,(%esp)
  8049cc:	e8 bc 2f 00 00       	call   80798d <pbuf_free>
}
  8049d1:	c9                   	leave  
  8049d2:	c3                   	ret    

008049d3 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  8049d3:	55                   	push   %ebp
  8049d4:	89 e5                	mov    %esp,%ebp
  8049d6:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  8049d9:	e8 62 08 00 00       	call   805240 <lwip_init>

  tcpip_init_done = initfunc;
  8049de:	8b 45 08             	mov    0x8(%ebp),%eax
  8049e1:	a3 2c 63 81 00       	mov    %eax,0x81632c
  tcpip_init_done_arg = arg;
  8049e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  8049e9:	a3 30 63 81 00       	mov    %eax,0x816330
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  8049ee:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8049f5:	e8 65 8b 00 00       	call   80d55f <sys_mbox_new>
  8049fa:	a3 3c 50 81 00       	mov    %eax,0x81503c
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8049ff:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  804a06:	00 
  804a07:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804a0e:	00 
  804a0f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804a16:	00 
  804a17:	c7 44 24 04 76 4a 80 	movl   $0x804a76,0x4(%esp)
  804a1e:	00 
  804a1f:	c7 04 24 9c 2a 81 00 	movl   $0x812a9c,(%esp)
  804a26:	e8 9f 88 00 00       	call   80d2ca <sys_thread_new>
}
  804a2b:	c9                   	leave  
  804a2c:	c3                   	ret    

00804a2d <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  804a2d:	55                   	push   %ebp
  804a2e:	89 e5                	mov    %esp,%ebp
  804a30:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  804a33:	83 3d 34 63 81 00 00 	cmpl   $0x0,0x816334
  804a3a:	75 38                	jne    804a74 <tcp_timer_needed+0x47>
  804a3c:	83 3d 0c f0 b3 00 00 	cmpl   $0x0,0xb3f00c
  804a43:	75 09                	jne    804a4e <tcp_timer_needed+0x21>
  804a45:	83 3d 20 f0 b3 00 00 	cmpl   $0x0,0xb3f020
  804a4c:	74 26                	je     804a74 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  804a4e:	c7 05 34 63 81 00 01 	movl   $0x1,0x816334
  804a55:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  804a58:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804a5f:	00 
  804a60:	c7 44 24 04 91 4e 80 	movl   $0x804e91,0x4(%esp)
  804a67:	00 
  804a68:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  804a6f:	e8 16 35 00 00       	call   807f8a <sys_timeout>
  }
}
  804a74:	c9                   	leave  
  804a75:	c3                   	ret    

00804a76 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  804a76:	55                   	push   %ebp
  804a77:	89 e5                	mov    %esp,%ebp
  804a79:	53                   	push   %ebx
  804a7a:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  804a7d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804a84:	00 
  804a85:	c7 44 24 04 6e 4c 80 	movl   $0x804c6e,0x4(%esp)
  804a8c:	00 
  804a8d:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  804a94:	e8 f1 34 00 00       	call   807f8a <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  804a99:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804aa0:	00 
  804aa1:	c7 44 24 04 45 4c 80 	movl   $0x804c45,0x4(%esp)
  804aa8:	00 
  804aa9:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  804ab0:	e8 d5 34 00 00       	call   807f8a <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  804ab5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804abc:	00 
  804abd:	c7 44 24 04 1c 4c 80 	movl   $0x804c1c,0x4(%esp)
  804ac4:	00 
  804ac5:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  804acc:	e8 b9 34 00 00       	call   807f8a <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  804ad1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804ad8:	00 
  804ad9:	c7 44 24 04 f3 4b 80 	movl   $0x804bf3,0x4(%esp)
  804ae0:	00 
  804ae1:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  804ae8:	e8 9d 34 00 00       	call   807f8a <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  804aed:	a1 2c 63 81 00       	mov    0x81632c,%eax
  804af2:	85 c0                	test   %eax,%eax
  804af4:	74 0b                	je     804b01 <tcpip_thread+0x8b>
    tcpip_init_done(tcpip_init_done_arg);
  804af6:	8b 15 30 63 81 00    	mov    0x816330,%edx
  804afc:	89 14 24             	mov    %edx,(%esp)
  804aff:	ff d0                	call   *%eax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  804b01:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  804b04:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804b08:	a1 3c 50 81 00       	mov    0x81503c,%eax
  804b0d:	89 04 24             	mov    %eax,(%esp)
  804b10:	e8 67 36 00 00       	call   80817c <sys_mbox_fetch>
    switch (msg->type) {
  804b15:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804b18:	8b 10                	mov    (%eax),%edx
  804b1a:	83 fa 01             	cmp    $0x1,%edx
  804b1d:	74 28                	je     804b47 <tcpip_thread+0xd1>
  804b1f:	83 fa 01             	cmp    $0x1,%edx
  804b22:	72 16                	jb     804b3a <tcpip_thread+0xc4>
  804b24:	83 fa 02             	cmp    $0x2,%edx
  804b27:	74 5f                	je     804b88 <tcpip_thread+0x112>
  804b29:	83 fa 03             	cmp    $0x3,%edx
  804b2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  804b30:	75 d2                	jne    804b04 <tcpip_thread+0x8e>
  804b32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  804b38:	eb 6f                	jmp    804ba9 <tcpip_thread+0x133>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  804b3a:	8b 40 08             	mov    0x8(%eax),%eax
  804b3d:	8d 50 04             	lea    0x4(%eax),%edx
  804b40:	89 14 24             	mov    %edx,(%esp)
  804b43:	ff 10                	call   *(%eax)
      break;
  804b45:	eb bd                	jmp    804b04 <tcpip_thread+0x8e>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  804b47:	8b 50 0c             	mov    0xc(%eax),%edx
  804b4a:	f6 42 2e 20          	testb  $0x20,0x2e(%edx)
  804b4e:	74 11                	je     804b61 <tcpip_thread+0xeb>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  804b50:	89 54 24 04          	mov    %edx,0x4(%esp)
  804b54:	8b 40 08             	mov    0x8(%eax),%eax
  804b57:	89 04 24             	mov    %eax,(%esp)
  804b5a:	e8 78 83 00 00       	call   80ced7 <ethernet_input>
  804b5f:	eb 0f                	jmp    804b70 <tcpip_thread+0xfa>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  804b61:	89 54 24 04          	mov    %edx,0x4(%esp)
  804b65:	8b 40 08             	mov    0x8(%eax),%eax
  804b68:	89 04 24             	mov    %eax,(%esp)
  804b6b:	e8 d4 4a 00 00       	call   809644 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  804b70:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804b73:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b77:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  804b7e:	e8 81 26 00 00       	call   807204 <memp_free>
      break;
  804b83:	e9 7c ff ff ff       	jmp    804b04 <tcpip_thread+0x8e>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  804b88:	8b 50 0c             	mov    0xc(%eax),%edx
  804b8b:	89 14 24             	mov    %edx,(%esp)
  804b8e:	ff 50 08             	call   *0x8(%eax)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  804b91:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804b94:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b98:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804b9f:	e8 60 26 00 00       	call   807204 <memp_free>
      break;
  804ba4:	e9 5b ff ff ff       	jmp    804b04 <tcpip_thread+0x8e>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  804ba9:	8b 50 08             	mov    0x8(%eax),%edx
  804bac:	83 fa ff             	cmp    $0xffffffff,%edx
  804baf:	74 18                	je     804bc9 <tcpip_thread+0x153>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  804bb1:	8b 48 10             	mov    0x10(%eax),%ecx
  804bb4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  804bb8:	8b 40 0c             	mov    0xc(%eax),%eax
  804bbb:	89 44 24 04          	mov    %eax,0x4(%esp)
  804bbf:	89 14 24             	mov    %edx,(%esp)
  804bc2:	e8 c3 33 00 00       	call   807f8a <sys_timeout>
  804bc7:	eb 12                	jmp    804bdb <tcpip_thread+0x165>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  804bc9:	8b 50 10             	mov    0x10(%eax),%edx
  804bcc:	89 54 24 04          	mov    %edx,0x4(%esp)
  804bd0:	8b 40 0c             	mov    0xc(%eax),%eax
  804bd3:	89 04 24             	mov    %eax,(%esp)
  804bd6:	e8 22 33 00 00       	call   807efd <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  804bdb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804bde:	89 44 24 04          	mov    %eax,0x4(%esp)
  804be2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804be9:	e8 16 26 00 00       	call   807204 <memp_free>
  804bee:	e9 11 ff ff ff       	jmp    804b04 <tcpip_thread+0x8e>

00804bf3 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  804bf3:	55                   	push   %ebp
  804bf4:	89 e5                	mov    %esp,%ebp
  804bf6:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  804bf9:	e8 f4 1e 00 00       	call   806af2 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  804bfe:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804c05:	00 
  804c06:	c7 44 24 04 f3 4b 80 	movl   $0x804bf3,0x4(%esp)
  804c0d:	00 
  804c0e:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  804c15:	e8 70 33 00 00       	call   807f8a <sys_timeout>
}
  804c1a:	c9                   	leave  
  804c1b:	c3                   	ret    

00804c1c <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  804c1c:	55                   	push   %ebp
  804c1d:	89 e5                	mov    %esp,%ebp
  804c1f:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  804c22:	e8 92 12 00 00       	call   805eb9 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  804c27:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804c2e:	00 
  804c2f:	c7 44 24 04 1c 4c 80 	movl   $0x804c1c,0x4(%esp)
  804c36:	00 
  804c37:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  804c3e:	e8 47 33 00 00       	call   807f8a <sys_timeout>
}
  804c43:	c9                   	leave  
  804c44:	c3                   	ret    

00804c45 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  804c45:	55                   	push   %ebp
  804c46:	89 e5                	mov    %esp,%ebp
  804c48:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  804c4b:	e8 59 7e 00 00       	call   80caa9 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  804c50:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804c57:	00 
  804c58:	c7 44 24 04 45 4c 80 	movl   $0x804c45,0x4(%esp)
  804c5f:	00 
  804c60:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  804c67:	e8 1e 33 00 00       	call   807f8a <sys_timeout>
}
  804c6c:	c9                   	leave  
  804c6d:	c3                   	ret    

00804c6e <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  804c6e:	55                   	push   %ebp
  804c6f:	89 e5                	mov    %esp,%ebp
  804c71:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  804c74:	e8 a8 50 00 00       	call   809d21 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  804c79:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804c80:	00 
  804c81:	c7 44 24 04 6e 4c 80 	movl   $0x804c6e,0x4(%esp)
  804c88:	00 
  804c89:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  804c90:	e8 f5 32 00 00       	call   807f8a <sys_timeout>
}
  804c95:	c9                   	leave  
  804c96:	c3                   	ret    

00804c97 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  804c97:	55                   	push   %ebp
  804c98:	89 e5                	mov    %esp,%ebp
  804c9a:	53                   	push   %ebx
  804c9b:	83 ec 34             	sub    $0x34,%esp
  804c9e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  804ca1:	8b 15 3c 50 81 00    	mov    0x81503c,%edx
  804ca7:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804cac:	83 fa ff             	cmp    $0xffffffff,%edx
  804caf:	74 34                	je     804ce5 <tcpip_apimsg+0x4e>
    msg.type = TCPIP_MSG_API;
  804cb1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  804cb8:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  804cbb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  804cbe:	89 44 24 04          	mov    %eax,0x4(%esp)
  804cc2:	89 14 24             	mov    %edx,(%esp)
  804cc5:	e8 2b 8c 00 00       	call   80d8f5 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  804cca:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804cd1:	00 
  804cd2:	8b 43 04             	mov    0x4(%ebx),%eax
  804cd5:	8b 40 10             	mov    0x10(%eax),%eax
  804cd8:	89 04 24             	mov    %eax,(%esp)
  804cdb:	e8 a6 86 00 00       	call   80d386 <sys_arch_sem_wait>
  804ce0:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  804ce5:	83 c4 34             	add    $0x34,%esp
  804ce8:	5b                   	pop    %ebx
  804ce9:	5d                   	pop    %ebp
  804cea:	c3                   	ret    

00804ceb <tcpip_timeout>:
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  804ceb:	55                   	push   %ebp
  804cec:	89 e5                	mov    %esp,%ebp
  804cee:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  804cf1:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804cf6:	83 3d 3c 50 81 00 ff 	cmpl   $0xffffffff,0x81503c
  804cfd:	74 45                	je     804d44 <tcpip_timeout+0x59>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  804cff:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804d06:	e8 3d 25 00 00       	call   807248 <memp_malloc>
  804d0b:	89 c2                	mov    %eax,%edx
    if (msg == NULL) {
  804d0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804d12:	85 d2                	test   %edx,%edx
  804d14:	74 2e                	je     804d44 <tcpip_timeout+0x59>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  804d16:	c7 02 03 00 00 00    	movl   $0x3,(%edx)
    msg->msg.tmo.msecs = msecs;
  804d1c:	8b 45 08             	mov    0x8(%ebp),%eax
  804d1f:	89 42 08             	mov    %eax,0x8(%edx)
    msg->msg.tmo.h = h;
  804d22:	8b 45 0c             	mov    0xc(%ebp),%eax
  804d25:	89 42 0c             	mov    %eax,0xc(%edx)
    msg->msg.tmo.arg = arg;
  804d28:	8b 45 10             	mov    0x10(%ebp),%eax
  804d2b:	89 42 10             	mov    %eax,0x10(%edx)
    sys_mbox_post(mbox, msg);
  804d2e:	89 54 24 04          	mov    %edx,0x4(%esp)
  804d32:	a1 3c 50 81 00       	mov    0x81503c,%eax
  804d37:	89 04 24             	mov    %eax,(%esp)
  804d3a:	e8 b6 8b 00 00       	call   80d8f5 <sys_mbox_post>
  804d3f:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  804d44:	c9                   	leave  
  804d45:	c3                   	ret    

00804d46 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  804d46:	55                   	push   %ebp
  804d47:	89 e5                	mov    %esp,%ebp
  804d49:	83 ec 18             	sub    $0x18,%esp
  804d4c:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  804d4f:	89 75 fc             	mov    %esi,-0x4(%ebp)
  804d52:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  804d56:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804d5b:	83 3d 3c 50 81 00 ff 	cmpl   $0xffffffff,0x81503c
  804d62:	74 6f                	je     804dd3 <tcpip_callback_with_block+0x8d>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  804d64:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804d6b:	e8 d8 24 00 00       	call   807248 <memp_malloc>
  804d70:	89 c6                	mov    %eax,%esi
    if (msg == NULL) {
  804d72:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804d77:	85 f6                	test   %esi,%esi
  804d79:	74 58                	je     804dd3 <tcpip_callback_with_block+0x8d>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  804d7b:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
    msg->msg.cb.f = f;
  804d81:	8b 45 08             	mov    0x8(%ebp),%eax
  804d84:	89 46 08             	mov    %eax,0x8(%esi)
    msg->msg.cb.ctx = ctx;
  804d87:	8b 45 0c             	mov    0xc(%ebp),%eax
  804d8a:	89 46 0c             	mov    %eax,0xc(%esi)
    if (block) {
  804d8d:	84 db                	test   %bl,%bl
  804d8f:	74 18                	je     804da9 <tcpip_callback_with_block+0x63>
      sys_mbox_post(mbox, msg);
  804d91:	89 74 24 04          	mov    %esi,0x4(%esp)
  804d95:	a1 3c 50 81 00       	mov    0x81503c,%eax
  804d9a:	89 04 24             	mov    %eax,(%esp)
  804d9d:	e8 53 8b 00 00       	call   80d8f5 <sys_mbox_post>
  804da2:	b8 00 00 00 00       	mov    $0x0,%eax
  804da7:	eb 2a                	jmp    804dd3 <tcpip_callback_with_block+0x8d>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  804da9:	89 74 24 04          	mov    %esi,0x4(%esp)
  804dad:	a1 3c 50 81 00       	mov    0x81503c,%eax
  804db2:	89 04 24             	mov    %eax,(%esp)
  804db5:	e8 6d 8a 00 00       	call   80d827 <sys_mbox_trypost>
  804dba:	84 c0                	test   %al,%al
  804dbc:	74 15                	je     804dd3 <tcpip_callback_with_block+0x8d>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  804dbe:	89 74 24 04          	mov    %esi,0x4(%esp)
  804dc2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  804dc9:	e8 36 24 00 00       	call   807204 <memp_free>
  804dce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  804dd3:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  804dd6:	8b 75 fc             	mov    -0x4(%ebp),%esi
  804dd9:	89 ec                	mov    %ebp,%esp
  804ddb:	5d                   	pop    %ebp
  804ddc:	c3                   	ret    

00804ddd <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  804ddd:	55                   	push   %ebp
  804dde:	89 e5                	mov    %esp,%ebp
  804de0:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  804de3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804dea:	00 
  804deb:	8b 45 08             	mov    0x8(%ebp),%eax
  804dee:	89 44 24 04          	mov    %eax,0x4(%esp)
  804df2:	c7 04 24 85 6f 80 00 	movl   $0x806f85,(%esp)
  804df9:	e8 48 ff ff ff       	call   804d46 <tcpip_callback_with_block>
}
  804dfe:	c9                   	leave  
  804dff:	c3                   	ret    

00804e00 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  804e00:	55                   	push   %ebp
  804e01:	89 e5                	mov    %esp,%ebp
  804e03:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  804e06:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804e0d:	00 
  804e0e:	8b 45 08             	mov    0x8(%ebp),%eax
  804e11:	89 44 24 04          	mov    %eax,0x4(%esp)
  804e15:	c7 04 24 c0 49 80 00 	movl   $0x8049c0,(%esp)
  804e1c:	e8 25 ff ff ff       	call   804d46 <tcpip_callback_with_block>
}
  804e21:	c9                   	leave  
  804e22:	c3                   	ret    

00804e23 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  804e23:	55                   	push   %ebp
  804e24:	89 e5                	mov    %esp,%ebp
  804e26:	53                   	push   %ebx
  804e27:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  804e2a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  804e2f:	83 3d 3c 50 81 00 ff 	cmpl   $0xffffffff,0x81503c
  804e36:	74 53                	je     804e8b <tcpip_input+0x68>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  804e38:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  804e3f:	e8 04 24 00 00       	call   807248 <memp_malloc>
  804e44:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  804e46:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804e4b:	85 db                	test   %ebx,%ebx
  804e4d:	74 3c                	je     804e8b <tcpip_input+0x68>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  804e4f:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
    msg->msg.inp.p = p;
  804e55:	8b 45 08             	mov    0x8(%ebp),%eax
  804e58:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  804e5b:	8b 45 0c             	mov    0xc(%ebp),%eax
  804e5e:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  804e61:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804e65:	a1 3c 50 81 00       	mov    0x81503c,%eax
  804e6a:	89 04 24             	mov    %eax,(%esp)
  804e6d:	e8 b5 89 00 00       	call   80d827 <sys_mbox_trypost>
  804e72:	84 c0                	test   %al,%al
  804e74:	74 15                	je     804e8b <tcpip_input+0x68>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  804e76:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804e7a:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  804e81:	e8 7e 23 00 00       	call   807204 <memp_free>
  804e86:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  804e8b:	83 c4 14             	add    $0x14,%esp
  804e8e:	5b                   	pop    %ebx
  804e8f:	5d                   	pop    %ebp
  804e90:	c3                   	ret    

00804e91 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  804e91:	55                   	push   %ebp
  804e92:	89 e5                	mov    %esp,%ebp
  804e94:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  804e97:	e8 2a 43 00 00       	call   8091c6 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  804e9c:	83 3d 0c f0 b3 00 00 	cmpl   $0x0,0xb3f00c
  804ea3:	75 09                	jne    804eae <tcpip_tcp_timer+0x1d>
  804ea5:	83 3d 20 f0 b3 00 00 	cmpl   $0x0,0xb3f020
  804eac:	74 1e                	je     804ecc <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  804eae:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804eb5:	00 
  804eb6:	c7 44 24 04 91 4e 80 	movl   $0x804e91,0x4(%esp)
  804ebd:	00 
  804ebe:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  804ec5:	e8 c0 30 00 00       	call   807f8a <sys_timeout>
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  804eca:	eb 0a                	jmp    804ed6 <tcpip_tcp_timer+0x45>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  804ecc:	c7 05 34 63 81 00 00 	movl   $0x0,0x816334
  804ed3:	00 00 00 
  }
}
  804ed6:	c9                   	leave  
  804ed7:	c3                   	ret    

00804ed8 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  804ed8:	55                   	push   %ebp
  804ed9:	89 e5                	mov    %esp,%ebp
  804edb:	83 ec 18             	sub    $0x18,%esp
  804ede:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  804ee1:	85 c0                	test   %eax,%eax
  804ee3:	75 1c                	jne    804f01 <netbuf_first+0x29>
  804ee5:	c7 44 24 08 a9 2a 81 	movl   $0x812aa9,0x8(%esp)
  804eec:	00 
  804eed:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  804ef4:	00 
  804ef5:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  804efc:	e8 13 ba ff ff       	call   800914 <_panic>
  buf->ptr = buf->p;
  804f01:	8b 10                	mov    (%eax),%edx
  804f03:	89 50 04             	mov    %edx,0x4(%eax)
}
  804f06:	c9                   	leave  
  804f07:	c3                   	ret    

00804f08 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  804f08:	55                   	push   %ebp
  804f09:	89 e5                	mov    %esp,%ebp
  804f0b:	83 ec 18             	sub    $0x18,%esp
  804f0e:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  804f11:	85 d2                	test   %edx,%edx
  804f13:	75 1c                	jne    804f31 <netbuf_next+0x29>
  804f15:	c7 44 24 08 a9 2a 81 	movl   $0x812aa9,0x8(%esp)
  804f1c:	00 
  804f1d:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  804f24:	00 
  804f25:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  804f2c:	e8 e3 b9 ff ff       	call   800914 <_panic>
  if (buf->ptr->next == NULL) {
  804f31:	8b 42 04             	mov    0x4(%edx),%eax
  804f34:	8b 08                	mov    (%eax),%ecx
  804f36:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804f3b:	85 c9                	test   %ecx,%ecx
  804f3d:	74 09                	je     804f48 <netbuf_next+0x40>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  804f3f:	89 4a 04             	mov    %ecx,0x4(%edx)
  804f42:	83 39 00             	cmpl   $0x0,(%ecx)
  804f45:	0f 94 c0             	sete   %al
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  804f48:	c9                   	leave  
  804f49:	c3                   	ret    

00804f4a <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  804f4a:	55                   	push   %ebp
  804f4b:	89 e5                	mov    %esp,%ebp
  804f4d:	56                   	push   %esi
  804f4e:	53                   	push   %ebx
  804f4f:	83 ec 10             	sub    $0x10,%esp
  804f52:	8b 55 08             	mov    0x8(%ebp),%edx
  804f55:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  804f58:	8b 4d 10             	mov    0x10(%ebp),%ecx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  804f5b:	85 d2                	test   %edx,%edx
  804f5d:	75 1c                	jne    804f7b <netbuf_data+0x31>
  804f5f:	c7 44 24 08 d8 2a 81 	movl   $0x812ad8,0x8(%esp)
  804f66:	00 
  804f67:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  804f6e:	00 
  804f6f:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  804f76:	e8 99 b9 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  804f7b:	85 db                	test   %ebx,%ebx
  804f7d:	75 1c                	jne    804f9b <netbuf_data+0x51>
  804f7f:	c7 44 24 08 f1 2a 81 	movl   $0x812af1,0x8(%esp)
  804f86:	00 
  804f87:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  804f8e:	00 
  804f8f:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  804f96:	e8 79 b9 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  804f9b:	85 c9                	test   %ecx,%ecx
  804f9d:	75 1c                	jne    804fbb <netbuf_data+0x71>
  804f9f:	c7 44 24 08 0e 2b 81 	movl   $0x812b0e,0x8(%esp)
  804fa6:	00 
  804fa7:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  804fae:	00 
  804faf:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  804fb6:	e8 59 b9 ff ff       	call   800914 <_panic>

  if (buf->ptr == NULL) {
  804fbb:	8b 72 04             	mov    0x4(%edx),%esi
  804fbe:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  804fc3:	85 f6                	test   %esi,%esi
  804fc5:	74 14                	je     804fdb <netbuf_data+0x91>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  804fc7:	8b 46 04             	mov    0x4(%esi),%eax
  804fca:	89 03                	mov    %eax,(%ebx)
  *len = buf->ptr->len;
  804fcc:	8b 42 04             	mov    0x4(%edx),%eax
  804fcf:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  804fd3:	66 89 01             	mov    %ax,(%ecx)
  804fd6:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  804fdb:	83 c4 10             	add    $0x10,%esp
  804fde:	5b                   	pop    %ebx
  804fdf:	5e                   	pop    %esi
  804fe0:	5d                   	pop    %ebp
  804fe1:	c3                   	ret    

00804fe2 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  804fe2:	55                   	push   %ebp
  804fe3:	89 e5                	mov    %esp,%ebp
  804fe5:	83 ec 18             	sub    $0x18,%esp
  804fe8:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  804feb:	89 75 fc             	mov    %esi,-0x4(%ebp)
  804fee:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804ff1:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  804ff4:	85 db                	test   %ebx,%ebx
  804ff6:	75 1c                	jne    805014 <netbuf_chain+0x32>
  804ff8:	c7 44 24 08 27 2b 81 	movl   $0x812b27,0x8(%esp)
  804fff:	00 
  805000:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  805007:	00 
  805008:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  80500f:	e8 00 b9 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  805014:	85 f6                	test   %esi,%esi
  805016:	75 1c                	jne    805034 <netbuf_chain+0x52>
  805018:	c7 44 24 08 40 2b 81 	movl   $0x812b40,0x8(%esp)
  80501f:	00 
  805020:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  805027:	00 
  805028:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  80502f:	e8 e0 b8 ff ff       	call   800914 <_panic>
  pbuf_chain(head->p, tail->p);
  805034:	8b 06                	mov    (%esi),%eax
  805036:	89 44 24 04          	mov    %eax,0x4(%esp)
  80503a:	8b 03                	mov    (%ebx),%eax
  80503c:	89 04 24             	mov    %eax,(%esp)
  80503f:	e8 b8 25 00 00       	call   8075fc <pbuf_chain>
  head->ptr = head->p;
  805044:	8b 03                	mov    (%ebx),%eax
  805046:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  805049:	89 74 24 04          	mov    %esi,0x4(%esp)
  80504d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  805054:	e8 ab 21 00 00       	call   807204 <memp_free>
}
  805059:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80505c:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80505f:	89 ec                	mov    %ebp,%esp
  805061:	5d                   	pop    %ebp
  805062:	c3                   	ret    

00805063 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  805063:	55                   	push   %ebp
  805064:	89 e5                	mov    %esp,%ebp
  805066:	53                   	push   %ebx
  805067:	83 ec 14             	sub    $0x14,%esp
  80506a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80506d:	85 db                	test   %ebx,%ebx
  80506f:	75 1c                	jne    80508d <netbuf_free+0x2a>
  805071:	c7 44 24 08 a9 2a 81 	movl   $0x812aa9,0x8(%esp)
  805078:	00 
  805079:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  805080:	00 
  805081:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  805088:	e8 87 b8 ff ff       	call   800914 <_panic>
  if (buf->p != NULL) {
  80508d:	8b 03                	mov    (%ebx),%eax
  80508f:	85 c0                	test   %eax,%eax
  805091:	74 08                	je     80509b <netbuf_free+0x38>
    pbuf_free(buf->p);
  805093:	89 04 24             	mov    %eax,(%esp)
  805096:	e8 f2 28 00 00       	call   80798d <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  80509b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8050a2:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  8050a8:	83 c4 14             	add    $0x14,%esp
  8050ab:	5b                   	pop    %ebx
  8050ac:	5d                   	pop    %ebp
  8050ad:	c3                   	ret    

008050ae <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  8050ae:	55                   	push   %ebp
  8050af:	89 e5                	mov    %esp,%ebp
  8050b1:	53                   	push   %ebx
  8050b2:	83 ec 14             	sub    $0x14,%esp
  8050b5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  8050b8:	85 db                	test   %ebx,%ebx
  8050ba:	74 2b                	je     8050e7 <netbuf_delete+0x39>
    if (buf->p != NULL) {
  8050bc:	8b 03                	mov    (%ebx),%eax
  8050be:	85 c0                	test   %eax,%eax
  8050c0:	74 15                	je     8050d7 <netbuf_delete+0x29>
      pbuf_free(buf->p);
  8050c2:	89 04 24             	mov    %eax,(%esp)
  8050c5:	e8 c3 28 00 00       	call   80798d <pbuf_free>
      buf->p = buf->ptr = NULL;
  8050ca:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8050d1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  8050d7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8050db:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8050e2:	e8 1d 21 00 00       	call   807204 <memp_free>
  }
}
  8050e7:	83 c4 14             	add    $0x14,%esp
  8050ea:	5b                   	pop    %ebx
  8050eb:	5d                   	pop    %ebp
  8050ec:	c3                   	ret    

008050ed <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8050ed:	55                   	push   %ebp
  8050ee:	89 e5                	mov    %esp,%ebp
  8050f0:	56                   	push   %esi
  8050f1:	53                   	push   %ebx
  8050f2:	83 ec 10             	sub    $0x10,%esp
  8050f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8050f8:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8050fc:	85 db                	test   %ebx,%ebx
  8050fe:	75 1c                	jne    80511c <netbuf_ref+0x2f>
  805100:	c7 44 24 08 5b 2b 81 	movl   $0x812b5b,0x8(%esp)
  805107:	00 
  805108:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80510f:	00 
  805110:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  805117:	e8 f8 b7 ff ff       	call   800914 <_panic>
  if (buf->p != NULL) {
  80511c:	8b 03                	mov    (%ebx),%eax
  80511e:	85 c0                	test   %eax,%eax
  805120:	74 08                	je     80512a <netbuf_ref+0x3d>
    pbuf_free(buf->p);
  805122:	89 04 24             	mov    %eax,(%esp)
  805125:	e8 63 28 00 00       	call   80798d <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  80512a:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  805131:	00 
  805132:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805139:	00 
  80513a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805141:	e8 03 2b 00 00       	call   807c49 <pbuf_alloc>
  805146:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  805148:	85 c0                	test   %eax,%eax
  80514a:	75 0e                	jne    80515a <netbuf_ref+0x6d>
    buf->ptr = NULL;
  80514c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  805153:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  805158:	eb 1a                	jmp    805174 <netbuf_ref+0x87>
  }
  buf->p->payload = (void*)dataptr;
  80515a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80515d:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  805160:	8b 03                	mov    (%ebx),%eax
  805162:	66 89 70 08          	mov    %si,0x8(%eax)
  805166:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  80516a:	8b 03                	mov    (%ebx),%eax
  80516c:	89 43 04             	mov    %eax,0x4(%ebx)
  80516f:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  805174:	83 c4 10             	add    $0x10,%esp
  805177:	5b                   	pop    %ebx
  805178:	5e                   	pop    %esi
  805179:	5d                   	pop    %ebp
  80517a:	c3                   	ret    

0080517b <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  80517b:	55                   	push   %ebp
  80517c:	89 e5                	mov    %esp,%ebp
  80517e:	56                   	push   %esi
  80517f:	53                   	push   %ebx
  805180:	83 ec 10             	sub    $0x10,%esp
  805183:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805186:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80518a:	85 db                	test   %ebx,%ebx
  80518c:	75 1c                	jne    8051aa <netbuf_alloc+0x2f>
  80518e:	c7 44 24 08 73 2b 81 	movl   $0x812b73,0x8(%esp)
  805195:	00 
  805196:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  80519d:	00 
  80519e:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  8051a5:	e8 6a b7 ff ff       	call   800914 <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  8051aa:	8b 03                	mov    (%ebx),%eax
  8051ac:	85 c0                	test   %eax,%eax
  8051ae:	74 08                	je     8051b8 <netbuf_alloc+0x3d>
    pbuf_free(buf->p);
  8051b0:	89 04 24             	mov    %eax,(%esp)
  8051b3:	e8 d5 27 00 00       	call   80798d <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8051b8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8051bf:	00 
  8051c0:	0f b7 c6             	movzwl %si,%eax
  8051c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8051c7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8051ce:	e8 76 2a 00 00       	call   807c49 <pbuf_alloc>
  8051d3:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8051d5:	ba 00 00 00 00       	mov    $0x0,%edx
  8051da:	85 c0                	test   %eax,%eax
  8051dc:	74 28                	je     805206 <netbuf_alloc+0x8b>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8051de:	66 3b 70 0a          	cmp    0xa(%eax),%si
  8051e2:	76 1c                	jbe    805200 <netbuf_alloc+0x85>
  8051e4:	c7 44 24 08 90 2b 81 	movl   $0x812b90,0x8(%esp)
  8051eb:	00 
  8051ec:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  8051f3:	00 
  8051f4:	c7 04 24 c2 2a 81 00 	movl   $0x812ac2,(%esp)
  8051fb:	e8 14 b7 ff ff       	call   800914 <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  805200:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  805203:	8b 50 04             	mov    0x4(%eax),%edx
}
  805206:	89 d0                	mov    %edx,%eax
  805208:	83 c4 10             	add    $0x10,%esp
  80520b:	5b                   	pop    %ebx
  80520c:	5e                   	pop    %esi
  80520d:	5d                   	pop    %ebp
  80520e:	c3                   	ret    

0080520f <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  80520f:	55                   	push   %ebp
  805210:	89 e5                	mov    %esp,%ebp
  805212:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  805215:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80521c:	e8 27 20 00 00       	call   807248 <memp_malloc>
  if (buf != NULL) {
  805221:	85 c0                	test   %eax,%eax
  805223:	74 14                	je     805239 <netbuf_new+0x2a>
    buf->p = NULL;
  805225:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  80522b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  805232:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  805239:	c9                   	leave  
  80523a:	c3                   	ret    
  80523b:	00 00                	add    %al,(%eax)
  80523d:	00 00                	add    %al,(%eax)
	...

00805240 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  805240:	55                   	push   %ebp
  805241:	89 e5                	mov    %esp,%ebp
  805243:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  805246:	e8 35 7d 00 00       	call   80cf80 <sys_init>
  mem_init();
  80524b:	e8 d3 1e 00 00       	call   807123 <mem_init>
  memp_init();
  805250:	e8 2b 1f 00 00       	call   807180 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  805255:	e8 6e e9 ff ff       	call   803bc8 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  80525a:	c9                   	leave  
  80525b:	c3                   	ret    
  80525c:	00 00                	add    %al,(%eax)
	...

00805260 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  805260:	55                   	push   %ebp
  805261:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  805263:	38 10                	cmp    %dl,(%eax)
  805265:	74 06                	je     80526d <dhcp_set_state+0xd>
    dhcp->state = new_state;
  805267:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  805269:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  80526d:	5d                   	pop    %ebp
  80526e:	c3                   	ret    

0080526f <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80526f:	55                   	push   %ebp
  805270:	89 e5                	mov    %esp,%ebp
  805272:	57                   	push   %edi
  805273:	56                   	push   %esi
  805274:	53                   	push   %ebx
  805275:	83 ec 08             	sub    $0x8,%esp
  805278:	88 55 f3             	mov    %dl,-0xd(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80527b:	8b 70 14             	mov    0x14(%eax),%esi
  80527e:	85 f6                	test   %esi,%esi
  805280:	0f 84 e6 00 00 00    	je     80536c <dhcp_get_option_ptr+0xfd>
  805286:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  80528a:	66 85 ff             	test   %di,%di
  80528d:	0f 84 d9 00 00 00    	je     80536c <dhcp_get_option_ptr+0xfd>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  805293:	0f b6 0e             	movzbl (%esi),%ecx
  805296:	80 f9 ff             	cmp    $0xff,%cl
  805299:	0f 84 cd 00 00 00    	je     80536c <dhcp_get_option_ptr+0xfd>
  80529f:	89 f3                	mov    %esi,%ebx
  8052a1:	c6 45 f2 00          	movb   $0x0,-0xe(%ebp)
  8052a5:	ba 00 00 00 00       	mov    $0x0,%edx
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  8052aa:	80 f9 34             	cmp    $0x34,%cl
  8052ad:	75 12                	jne    8052c1 <dhcp_get_option_ptr+0x52>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  8052af:	8d 4a 02             	lea    0x2(%edx),%ecx
        overload = options[offset++];
  8052b2:	0f b7 c9             	movzwl %cx,%ecx
  8052b5:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  8052b9:	88 4d f2             	mov    %cl,-0xe(%ebp)
  8052bc:	83 c2 03             	add    $0x3,%edx
  8052bf:	eb 17                	jmp    8052d8 <dhcp_get_option_ptr+0x69>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  8052c1:	3a 4d f3             	cmp    -0xd(%ebp),%cl
  8052c4:	0f 84 a7 00 00 00    	je     805371 <dhcp_get_option_ptr+0x102>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  8052ca:	8d 4a 01             	lea    0x1(%edx),%ecx
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  8052cd:	0f b7 c9             	movzwl %cx,%ecx
  8052d0:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  8052d4:	8d 54 0a 02          	lea    0x2(%edx,%ecx,1),%edx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8052d8:	66 39 d7             	cmp    %dx,%di
  8052db:	76 0e                	jbe    8052eb <dhcp_get_option_ptr+0x7c>
  8052dd:	0f b7 da             	movzwl %dx,%ebx
  8052e0:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  8052e3:	0f b6 0b             	movzbl (%ebx),%ecx
  8052e6:	80 f9 ff             	cmp    $0xff,%cl
  8052e9:	75 bf                	jne    8052aa <dhcp_get_option_ptr+0x3b>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  8052eb:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
  8052ef:	74 7b                	je     80536c <dhcp_get_option_ptr+0xfd>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  8052f1:	80 7d f2 01          	cmpb   $0x1,-0xe(%ebp)
  8052f5:	75 0d                	jne    805304 <dhcp_get_option_ptr+0x95>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  8052f7:	8b 58 10             	mov    0x10(%eax),%ebx
  8052fa:	83 c3 6c             	add    $0x6c,%ebx
  8052fd:	b9 80 00 00 00       	mov    $0x80,%ecx
  805302:	eb 1e                	jmp    805322 <dhcp_get_option_ptr+0xb3>
        field_len = DHCP_FILE_LEN;
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  805304:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  805308:	75 0d                	jne    805317 <dhcp_get_option_ptr+0xa8>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  80530a:	8b 58 10             	mov    0x10(%eax),%ebx
  80530d:	83 c3 2c             	add    $0x2c,%ebx
  805310:	b9 40 00 00 00       	mov    $0x40,%ecx
  805315:	eb 0b                	jmp    805322 <dhcp_get_option_ptr+0xb3>
        field_len = DHCP_SNAME_LEN;
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  805317:	8b 58 10             	mov    0x10(%eax),%ebx
  80531a:	83 c3 2c             	add    $0x2c,%ebx
  80531d:	b9 c0 00 00 00       	mov    $0xc0,%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  805322:	0f b6 13             	movzbl (%ebx),%edx
  805325:	80 fa ff             	cmp    $0xff,%dl
  805328:	74 42                	je     80536c <dhcp_get_option_ptr+0xfd>
        if (options[offset] == option_type) {
  80532a:	b8 00 00 00 00       	mov    $0x0,%eax
  80532f:	38 55 f3             	cmp    %dl,-0xd(%ebp)
  805332:	75 0e                	jne    805342 <dhcp_get_option_ptr+0xd3>
  805334:	eb 3b                	jmp    805371 <dhcp_get_option_ptr+0x102>
  805336:	89 f9                	mov    %edi,%ecx
  805338:	38 d1                	cmp    %dl,%cl
  80533a:	75 0e                	jne    80534a <dhcp_get_option_ptr+0xdb>
  80533c:	89 f3                	mov    %esi,%ebx
  80533e:	66 90                	xchg   %ax,%ax
  805340:	eb 2f                	jmp    805371 <dhcp_get_option_ptr+0x102>
  805342:	66 89 4d ee          	mov    %cx,-0x12(%ebp)
  805346:	0f b6 7d f3          	movzbl -0xd(%ebp),%edi
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80534a:	8d 50 01             	lea    0x1(%eax),%edx
          offset += 1 + options[offset];
  80534d:	0f b7 d2             	movzwl %dx,%edx
  805350:	0f b6 14 13          	movzbl (%ebx,%edx,1),%edx
  805354:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  805358:	66 39 45 ee          	cmp    %ax,-0x12(%ebp)
  80535c:	76 0e                	jbe    80536c <dhcp_get_option_ptr+0xfd>
  80535e:	0f b7 f0             	movzwl %ax,%esi
  805361:	8d 34 33             	lea    (%ebx,%esi,1),%esi
  805364:	0f b6 16             	movzbl (%esi),%edx
  805367:	80 fa ff             	cmp    $0xff,%dl
  80536a:	75 ca                	jne    805336 <dhcp_get_option_ptr+0xc7>
  80536c:	bb 00 00 00 00       	mov    $0x0,%ebx
        }
      }
    }
  }
  return NULL;
}
  805371:	89 d8                	mov    %ebx,%eax
  805373:	83 c4 08             	add    $0x8,%esp
  805376:	5b                   	pop    %ebx
  805377:	5e                   	pop    %esi
  805378:	5f                   	pop    %edi
  805379:	5d                   	pop    %ebp
  80537a:	c3                   	ret    

0080537b <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80537b:	55                   	push   %ebp
  80537c:	89 e5                	mov    %esp,%ebp
  80537e:	0f b6 00             	movzbl (%eax),%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
}
  805381:	5d                   	pop    %ebp
  805382:	c3                   	ret    

00805383 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  805383:	55                   	push   %ebp
  805384:	89 e5                	mov    %esp,%ebp
  805386:	53                   	push   %ebx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  805387:	0f b6 10             	movzbl (%eax),%edx
  80538a:	c1 e2 18             	shl    $0x18,%edx
  value |= (u32_t)(*ptr++) << 16;
  80538d:	0f b6 58 01          	movzbl 0x1(%eax),%ebx
  805391:	c1 e3 10             	shl    $0x10,%ebx
  805394:	09 d3                	or     %edx,%ebx
  805396:	8d 50 02             	lea    0x2(%eax),%edx
  value |= (u32_t)(*ptr++) << 8;
  805399:	0f b6 0a             	movzbl (%edx),%ecx
  80539c:	c1 e1 08             	shl    $0x8,%ecx
  80539f:	89 d8                	mov    %ebx,%eax
  8053a1:	09 c8                	or     %ecx,%eax
  8053a3:	0f b6 52 01          	movzbl 0x1(%edx),%edx
  8053a7:	09 d0                	or     %edx,%eax
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  8053a9:	5b                   	pop    %ebx
  8053aa:	5d                   	pop    %ebp
  8053ab:	c3                   	ret    

008053ac <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  8053ac:	55                   	push   %ebp
  8053ad:	89 e5                	mov    %esp,%ebp
  8053af:	83 ec 28             	sub    $0x28,%esp
  8053b2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8053b5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8053b8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  8053bb:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  8053bf:	0f b7 fb             	movzwl %bx,%edi
  8053c2:	0f b6 f1             	movzbl %cl,%esi
  8053c5:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  8053c9:	83 fe 44             	cmp    $0x44,%esi
  8053cc:	76 1c                	jbe    8053ea <dhcp_option+0x3e>
  8053ce:	c7 44 24 08 b4 2b 81 	movl   $0x812bb4,0x8(%esp)
  8053d5:	00 
  8053d6:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  8053dd:	00 
  8053de:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8053e5:	e8 2a b5 ff ff       	call   800914 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8053ea:	8b 78 20             	mov    0x20(%eax),%edi
  8053ed:	0f b7 f3             	movzwl %bx,%esi
  8053f0:	88 94 37 f0 00 00 00 	mov    %dl,0xf0(%edi,%esi,1)
  8053f7:	8d 53 01             	lea    0x1(%ebx),%edx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8053fa:	8b 70 20             	mov    0x20(%eax),%esi
  8053fd:	0f b7 d2             	movzwl %dx,%edx
  805400:	88 8c 16 f0 00 00 00 	mov    %cl,0xf0(%esi,%edx,1)
  805407:	83 c3 02             	add    $0x2,%ebx
  80540a:	66 89 58 24          	mov    %bx,0x24(%eax)
}
  80540e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805411:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805414:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805417:	89 ec                	mov    %ebp,%esp
  805419:	5d                   	pop    %ebp
  80541a:	c3                   	ret    

0080541b <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  80541b:	55                   	push   %ebp
  80541c:	89 e5                	mov    %esp,%ebp
  80541e:	83 ec 18             	sub    $0x18,%esp
  805421:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  805424:	89 75 fc             	mov    %esi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  805427:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  80542b:	66 83 f9 43          	cmp    $0x43,%cx
  80542f:	76 1c                	jbe    80544d <dhcp_option_byte+0x32>
  805431:	c7 44 24 08 fc 2b 81 	movl   $0x812bfc,0x8(%esp)
  805438:	00 
  805439:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  805440:	00 
  805441:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  805448:	e8 c7 b4 ff ff       	call   800914 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80544d:	8b 70 20             	mov    0x20(%eax),%esi
  805450:	0f b7 d9             	movzwl %cx,%ebx
  805453:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  80545a:	83 c1 01             	add    $0x1,%ecx
  80545d:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805461:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  805464:	8b 75 fc             	mov    -0x4(%ebp),%esi
  805467:	89 ec                	mov    %ebp,%esp
  805469:	5d                   	pop    %ebp
  80546a:	c3                   	ret    

0080546b <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  80546b:	55                   	push   %ebp
  80546c:	89 e5                	mov    %esp,%ebp
  80546e:	53                   	push   %ebx
  80546f:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  805472:	85 c0                	test   %eax,%eax
  805474:	75 1c                	jne    805492 <dhcp_option_trailer+0x27>
  805476:	c7 44 24 08 38 2c 81 	movl   $0x812c38,0x8(%esp)
  80547d:	00 
  80547e:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  805485:	00 
  805486:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80548d:	e8 82 b4 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  805492:	8b 48 20             	mov    0x20(%eax),%ecx
  805495:	85 c9                	test   %ecx,%ecx
  805497:	75 1c                	jne    8054b5 <dhcp_option_trailer+0x4a>
  805499:	c7 44 24 08 5c 2c 81 	movl   $0x812c5c,0x8(%esp)
  8054a0:	00 
  8054a1:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  8054a8:	00 
  8054a9:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8054b0:	e8 5f b4 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8054b5:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8054b9:	66 83 fa 43          	cmp    $0x43,%dx
  8054bd:	76 1c                	jbe    8054db <dhcp_option_trailer+0x70>
  8054bf:	c7 44 24 08 88 2c 81 	movl   $0x812c88,0x8(%esp)
  8054c6:	00 
  8054c7:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  8054ce:	00 
  8054cf:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8054d6:	e8 39 b4 ff ff       	call   800914 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  8054db:	0f b7 da             	movzwl %dx,%ebx
  8054de:	c6 84 19 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%ebx,1)
  8054e5:	ff 
  8054e6:	83 c2 01             	add    $0x1,%edx
  8054e9:	66 89 50 24          	mov    %dx,0x24(%eax)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  8054ed:	eb 31                	jmp    805520 <dhcp_option_trailer+0xb5>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8054ef:	c7 44 24 08 88 2c 81 	movl   $0x812c88,0x8(%esp)
  8054f6:	00 
  8054f7:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  8054fe:	00 
  8054ff:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  805506:	e8 09 b4 ff ff       	call   800914 <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  80550b:	8b 58 20             	mov    0x20(%eax),%ebx
  80550e:	0f b7 ca             	movzwl %dx,%ecx
  805511:	c6 84 0b f0 00 00 00 	movb   $0x0,0xf0(%ebx,%ecx,1)
  805518:	00 
  805519:	83 c2 01             	add    $0x1,%edx
  80551c:	66 89 50 24          	mov    %dx,0x24(%eax)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  805520:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  805524:	66 83 fa 43          	cmp    $0x43,%dx
  805528:	76 e1                	jbe    80550b <dhcp_option_trailer+0xa0>
  80552a:	f6 c2 03             	test   $0x3,%dl
  80552d:	75 c0                	jne    8054ef <dhcp_option_trailer+0x84>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  80552f:	83 c4 14             	add    $0x14,%esp
  805532:	5b                   	pop    %ebx
  805533:	5d                   	pop    %ebp
  805534:	c3                   	ret    

00805535 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  805535:	55                   	push   %ebp
  805536:	89 e5                	mov    %esp,%ebp
  805538:	83 ec 48             	sub    $0x48,%esp
  80553b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80553e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805541:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  805544:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  805548:	0f b7 d9             	movzwl %cx,%ebx
  80554b:	83 c3 02             	add    $0x2,%ebx
  80554e:	83 fb 44             	cmp    $0x44,%ebx
  805551:	76 1c                	jbe    80556f <dhcp_option_short+0x3a>
  805553:	c7 44 24 08 c8 2c 81 	movl   $0x812cc8,0x8(%esp)
  80555a:	00 
  80555b:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  805562:	00 
  805563:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80556a:	e8 a5 b3 ff ff       	call   800914 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80556f:	0f b7 d9             	movzwl %cx,%ebx
  805572:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805575:	89 d6                	mov    %edx,%esi
  805577:	66 c1 ee 08          	shr    $0x8,%si
  80557b:	66 89 75 d6          	mov    %si,-0x2a(%ebp)
  80557f:	0f b6 5d d6          	movzbl -0x2a(%ebp),%ebx
  805583:	8b 78 20             	mov    0x20(%eax),%edi
  805586:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805589:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805590:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  805593:	8b 70 20             	mov    0x20(%eax),%esi
  805596:	0f b7 db             	movzwl %bx,%ebx
  805599:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  8055a0:	83 c1 02             	add    $0x2,%ecx
  8055a3:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  8055a7:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8055aa:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8055ad:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8055b0:	89 ec                	mov    %ebp,%esp
  8055b2:	5d                   	pop    %ebp
  8055b3:	c3                   	ret    

008055b4 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  8055b4:	55                   	push   %ebp
  8055b5:	89 e5                	mov    %esp,%ebp
  8055b7:	83 ec 48             	sub    $0x48,%esp
  8055ba:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8055bd:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8055c0:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  8055c3:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8055c7:	0f b7 d9             	movzwl %cx,%ebx
  8055ca:	83 c3 04             	add    $0x4,%ebx
  8055cd:	83 fb 44             	cmp    $0x44,%ebx
  8055d0:	76 1c                	jbe    8055ee <dhcp_option_long+0x3a>
  8055d2:	c7 44 24 08 0c 2d 81 	movl   $0x812d0c,0x8(%esp)
  8055d9:	00 
  8055da:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  8055e1:	00 
  8055e2:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8055e9:	e8 26 b3 ff ff       	call   800914 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  8055ee:	0f b7 d9             	movzwl %cx,%ebx
  8055f1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  8055f4:	89 d6                	mov    %edx,%esi
  8055f6:	c1 ee 18             	shr    $0x18,%esi
  8055f9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  8055fc:	0f b6 5d d4          	movzbl -0x2c(%ebp),%ebx
  805600:	8b 78 20             	mov    0x20(%eax),%edi
  805603:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805606:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  80560d:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  805610:	0f b7 db             	movzwl %bx,%ebx
  805613:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805616:	89 d3                	mov    %edx,%ebx
  805618:	c1 eb 10             	shr    $0x10,%ebx
  80561b:	8b 78 20             	mov    0x20(%eax),%edi
  80561e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805621:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805628:	8d 59 02             	lea    0x2(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  80562b:	0f b7 db             	movzwl %bx,%ebx
  80562e:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805631:	0f b6 de             	movzbl %dh,%ebx
  805634:	8b 78 20             	mov    0x20(%eax),%edi
  805637:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80563a:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805641:	8d 59 03             	lea    0x3(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  805644:	8b 70 20             	mov    0x20(%eax),%esi
  805647:	0f b7 db             	movzwl %bx,%ebx
  80564a:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  805651:	83 c1 04             	add    $0x4,%ecx
  805654:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805658:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80565b:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80565e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805661:	89 ec                	mov    %ebp,%esp
  805663:	5d                   	pop    %ebp
  805664:	c3                   	ret    

00805665 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  805665:	55                   	push   %ebp
  805666:	89 e5                	mov    %esp,%ebp
  805668:	53                   	push   %ebx
  805669:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80566c:	85 c0                	test   %eax,%eax
  80566e:	75 1c                	jne    80568c <dhcp_delete_request+0x27>
  805670:	c7 44 24 08 4c 2d 81 	movl   $0x812d4c,0x8(%esp)
  805677:	00 
  805678:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  80567f:	00 
  805680:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  805687:	e8 88 b2 ff ff       	call   800914 <_panic>
  dhcp = netif->dhcp;
  80568c:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  80568f:	85 db                	test   %ebx,%ebx
  805691:	75 1c                	jne    8056af <dhcp_delete_request+0x4a>
  805693:	c7 44 24 08 70 2d 81 	movl   $0x812d70,0x8(%esp)
  80569a:	00 
  80569b:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  8056a2:	00 
  8056a3:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8056aa:	e8 65 b2 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  8056af:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8056b2:	85 c0                	test   %eax,%eax
  8056b4:	75 1c                	jne    8056d2 <dhcp_delete_request+0x6d>
  8056b6:	c7 44 24 08 94 2d 81 	movl   $0x812d94,0x8(%esp)
  8056bd:	00 
  8056be:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  8056c5:	00 
  8056c6:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8056cd:	e8 42 b2 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  8056d2:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  8056d6:	75 1c                	jne    8056f4 <dhcp_delete_request+0x8f>
  8056d8:	c7 44 24 08 c0 2d 81 	movl   $0x812dc0,0x8(%esp)
  8056df:	00 
  8056e0:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  8056e7:	00 
  8056e8:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8056ef:	e8 20 b2 ff ff       	call   800914 <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  8056f4:	89 04 24             	mov    %eax,(%esp)
  8056f7:	e8 91 22 00 00       	call   80798d <pbuf_free>
  }
  dhcp->p_out = NULL;
  8056fc:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  805703:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  80570a:	83 c4 14             	add    $0x14,%esp
  80570d:	5b                   	pop    %ebx
  80570e:	5d                   	pop    %ebp
  80570f:	c3                   	ret    

00805710 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  805710:	55                   	push   %ebp
  805711:	89 e5                	mov    %esp,%ebp
  805713:	53                   	push   %ebx
  805714:	83 ec 14             	sub    $0x14,%esp
  805717:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  805719:	8b 40 10             	mov    0x10(%eax),%eax
  80571c:	85 c0                	test   %eax,%eax
  80571e:	74 0f                	je     80572f <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  805720:	89 04 24             	mov    %eax,(%esp)
  805723:	e8 5d 18 00 00       	call   806f85 <mem_free>
    dhcp->msg_in = NULL;
  805728:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  80572f:	8b 43 14             	mov    0x14(%ebx),%eax
  805732:	85 c0                	test   %eax,%eax
  805734:	74 15                	je     80574b <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  805736:	89 04 24             	mov    %eax,(%esp)
  805739:	e8 47 18 00 00       	call   806f85 <mem_free>
    dhcp->options_in = NULL;
  80573e:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  805745:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  80574b:	83 c4 14             	add    $0x14,%esp
  80574e:	5b                   	pop    %ebx
  80574f:	5d                   	pop    %ebp
  805750:	c3                   	ret    

00805751 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  805751:	55                   	push   %ebp
  805752:	89 e5                	mov    %esp,%ebp
  805754:	56                   	push   %esi
  805755:	53                   	push   %ebx
  805756:	83 ec 10             	sub    $0x10,%esp
  805759:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  80575c:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  80575f:	85 f6                	test   %esi,%esi
  805761:	75 1c                	jne    80577f <dhcp_stop+0x2e>
  805763:	c7 44 24 08 17 2f 81 	movl   $0x812f17,0x8(%esp)
  80576a:	00 
  80576b:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  805772:	00 
  805773:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80577a:	e8 95 b1 ff ff       	call   800914 <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80577f:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  805783:	85 db                	test   %ebx,%ebx
  805785:	74 42                	je     8057c9 <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  805787:	8b 43 08             	mov    0x8(%ebx),%eax
  80578a:	85 c0                	test   %eax,%eax
  80578c:	74 0f                	je     80579d <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  80578e:	89 04 24             	mov    %eax,(%esp)
  805791:	e8 e6 63 00 00       	call   80bb7c <udp_remove>
      dhcp->pcb = NULL;
  805796:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  80579d:	8b 43 0c             	mov    0xc(%ebx),%eax
  8057a0:	85 c0                	test   %eax,%eax
  8057a2:	74 0f                	je     8057b3 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  8057a4:	89 04 24             	mov    %eax,(%esp)
  8057a7:	e8 e1 21 00 00       	call   80798d <pbuf_free>
      dhcp->p = NULL;
  8057ac:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  8057b3:	89 d8                	mov    %ebx,%eax
  8057b5:	e8 56 ff ff ff       	call   805710 <dhcp_free_reply>
    mem_free((void *)dhcp);
  8057ba:	89 1c 24             	mov    %ebx,(%esp)
  8057bd:	e8 c3 17 00 00       	call   806f85 <mem_free>
    netif->dhcp = NULL;
  8057c2:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  8057c9:	83 c4 10             	add    $0x10,%esp
  8057cc:	5b                   	pop    %ebx
  8057cd:	5e                   	pop    %esi
  8057ce:	5d                   	pop    %ebp
  8057cf:	c3                   	ret    

008057d0 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  8057d0:	55                   	push   %ebp
  8057d1:	89 e5                	mov    %esp,%ebp
  8057d3:	57                   	push   %edi
  8057d4:	56                   	push   %esi
  8057d5:	53                   	push   %ebx
  8057d6:	83 ec 2c             	sub    $0x2c,%esp
  8057d9:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  8057db:	85 c0                	test   %eax,%eax
  8057dd:	75 1c                	jne    8057fb <dhcp_create_request+0x2b>
  8057df:	c7 44 24 08 ec 2d 81 	movl   $0x812dec,0x8(%esp)
  8057e6:	00 
  8057e7:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  8057ee:	00 
  8057ef:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8057f6:	e8 19 b1 ff ff       	call   800914 <_panic>
  dhcp = netif->dhcp;
  8057fb:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  8057fe:	85 db                	test   %ebx,%ebx
  805800:	75 1c                	jne    80581e <dhcp_create_request+0x4e>
  805802:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  805809:	00 
  80580a:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  805811:	00 
  805812:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  805819:	e8 f6 b0 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80581e:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  805822:	74 1c                	je     805840 <dhcp_create_request+0x70>
  805824:	c7 44 24 08 34 2e 81 	movl   $0x812e34,0x8(%esp)
  80582b:	00 
  80582c:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  805833:	00 
  805834:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80583b:	e8 d4 b0 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  805840:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  805844:	74 1c                	je     805862 <dhcp_create_request+0x92>
  805846:	c7 44 24 08 60 2e 81 	movl   $0x812e60,0x8(%esp)
  80584d:	00 
  80584e:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  805855:	00 
  805856:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80585d:	e8 b2 b0 ff ff       	call   800914 <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  805862:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805869:	00 
  80586a:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  805871:	00 
  805872:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805879:	e8 cb 23 00 00       	call   807c49 <pbuf_alloc>
  80587e:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  805881:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  805886:	85 c0                	test   %eax,%eax
  805888:	0f 84 2d 01 00 00    	je     8059bb <dhcp_create_request+0x1eb>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80588e:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  805894:	77 1c                	ja     8058b2 <dhcp_create_request+0xe2>
  805896:	c7 44 24 08 8c 2e 81 	movl   $0x812e8c,0x8(%esp)
  80589d:	00 
  80589e:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  8058a5:	00 
  8058a6:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8058ad:	e8 62 b0 ff ff       	call   800914 <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  8058b2:	8b 15 40 50 81 00    	mov    0x815040,%edx
  8058b8:	89 53 04             	mov    %edx,0x4(%ebx)
  8058bb:	83 c2 01             	add    $0x1,%edx
  8058be:	89 15 40 50 81 00    	mov    %edx,0x815040
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  8058c4:	8b 40 04             	mov    0x4(%eax),%eax
  8058c7:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  8058ca:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  8058cd:	8b 43 20             	mov    0x20(%ebx),%eax
  8058d0:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  8058d4:	8b 43 20             	mov    0x20(%ebx),%eax
  8058d7:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  8058db:	8b 43 20             	mov    0x20(%ebx),%eax
  8058de:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  8058e2:	8b 73 20             	mov    0x20(%ebx),%esi
  8058e5:	8b 43 04             	mov    0x4(%ebx),%eax
  8058e8:	89 04 24             	mov    %eax,(%esp)
  8058eb:	e8 b4 4e 00 00       	call   80a7a4 <htonl>
  8058f0:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  8058f3:	8b 43 20             	mov    0x20(%ebx),%eax
  8058f6:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  8058fc:	8b 43 20             	mov    0x20(%ebx),%eax
  8058ff:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  805905:	8b 43 20             	mov    0x20(%ebx),%eax
  805908:	8b 57 04             	mov    0x4(%edi),%edx
  80590b:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  80590e:	8b 43 20             	mov    0x20(%ebx),%eax
  805911:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  805918:	8b 43 20             	mov    0x20(%ebx),%eax
  80591b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  805922:	8b 43 20             	mov    0x20(%ebx),%eax
  805925:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  80592c:	b8 00 00 00 00       	mov    $0x0,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  805931:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805934:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  805937:	8b 5a 20             	mov    0x20(%edx),%ebx
  80593a:	89 c1                	mov    %eax,%ecx
  80593c:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  805940:	ba 00 00 00 00       	mov    $0x0,%edx
  805945:	66 39 c6             	cmp    %ax,%si
  805948:	76 05                	jbe    80594f <dhcp_create_request+0x17f>
  80594a:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  80594f:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  805953:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  805956:	83 f8 10             	cmp    $0x10,%eax
  805959:	75 d9                	jne    805934 <dhcp_create_request+0x164>
  80595b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80595e:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  805960:	8b 53 20             	mov    0x20(%ebx),%edx
  805963:	c6 44 10 2c 00       	movb   $0x0,0x2c(%eax,%edx,1)
  805968:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80596b:	83 f8 40             	cmp    $0x40,%eax
  80596e:	75 f0                	jne    805960 <dhcp_create_request+0x190>
  805970:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  805972:	8b 53 20             	mov    0x20(%ebx),%edx
  805975:	c6 44 10 6c 00       	movb   $0x0,0x6c(%eax,%edx,1)
  80597a:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80597d:	3d 80 00 00 00       	cmp    $0x80,%eax
  805982:	75 ee                	jne    805972 <dhcp_create_request+0x1a2>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  805984:	8b 73 20             	mov    0x20(%ebx),%esi
  805987:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  80598e:	e8 11 4e 00 00       	call   80a7a4 <htonl>
  805993:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  805999:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  80599f:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  8059a4:	8b 53 20             	mov    0x20(%ebx),%edx
  8059a7:	88 84 10 f0 00 00 00 	mov    %al,0xf0(%eax,%edx,1)
  8059ae:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  8059b1:	83 f8 44             	cmp    $0x44,%eax
  8059b4:	75 ee                	jne    8059a4 <dhcp_create_request+0x1d4>
  8059b6:	ba 00 00 00 00       	mov    $0x0,%edx
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  8059bb:	89 d0                	mov    %edx,%eax
  8059bd:	83 c4 2c             	add    $0x2c,%esp
  8059c0:	5b                   	pop    %ebx
  8059c1:	5e                   	pop    %esi
  8059c2:	5f                   	pop    %edi
  8059c3:	5d                   	pop    %ebp
  8059c4:	c3                   	ret    

008059c5 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  8059c5:	55                   	push   %ebp
  8059c6:	89 e5                	mov    %esp,%ebp
  8059c8:	57                   	push   %edi
  8059c9:	56                   	push   %esi
  8059ca:	53                   	push   %ebx
  8059cb:	83 ec 3c             	sub    $0x3c,%esp
  8059ce:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  8059d1:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  8059d4:	ba 0d 00 00 00       	mov    $0xd,%edx
  8059d9:	89 d8                	mov    %ebx,%eax
  8059db:	e8 80 f8 ff ff       	call   805260 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  8059e0:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  8059e7:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  8059ee:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  8059f5:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  8059fc:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  805a03:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  805a0a:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  805a11:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  805a18:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805a1f:	89 f0                	mov    %esi,%eax
  805a21:	e8 aa fd ff ff       	call   8057d0 <dhcp_create_request>
  805a26:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  805a28:	84 c0                	test   %al,%al
  805a2a:	0f 85 87 00 00 00    	jne    805ab7 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805a30:	b9 01 00 00 00       	mov    $0x1,%ecx
  805a35:	ba 35 00 00 00       	mov    $0x35,%edx
  805a3a:	89 d8                	mov    %ebx,%eax
  805a3c:	e8 6b f9 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  805a41:	ba 07 00 00 00       	mov    $0x7,%edx
  805a46:	89 d8                	mov    %ebx,%eax
  805a48:	e8 ce f9 ff ff       	call   80541b <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  805a4d:	89 d8                	mov    %ebx,%eax
  805a4f:	e8 17 fa ff ff       	call   80546b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805a54:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805a58:	66 05 f0 00          	add    $0xf0,%ax
  805a5c:	0f b7 c0             	movzwl %ax,%eax
  805a5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  805a63:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805a66:	89 04 24             	mov    %eax,(%esp)
  805a69:	e8 ab 20 00 00       	call   807b19 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  805a6e:	8d 43 2c             	lea    0x2c(%ebx),%eax
  805a71:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805a74:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805a7b:	00 
  805a7c:	89 44 24 04          	mov    %eax,0x4(%esp)
  805a80:	8b 43 08             	mov    0x8(%ebx),%eax
  805a83:	89 04 24             	mov    %eax,(%esp)
  805a86:	e8 03 62 00 00       	call   80bc8e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  805a8b:	89 74 24 10          	mov    %esi,0x10(%esp)
  805a8f:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805a96:	00 
  805a97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805a9a:	89 44 24 08          	mov    %eax,0x8(%esp)
  805a9e:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805aa1:	89 44 24 04          	mov    %eax,0x4(%esp)
  805aa5:	8b 43 08             	mov    0x8(%ebx),%eax
  805aa8:	89 04 24             	mov    %eax,(%esp)
  805aab:	e8 60 62 00 00       	call   80bd10 <udp_sendto_if>
    dhcp_delete_request(netif);
  805ab0:	89 f0                	mov    %esi,%eax
  805ab2:	e8 ae fb ff ff       	call   805665 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805ab7:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  805abb:	83 c1 01             	add    $0x1,%ecx
  805abe:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  805ac1:	ba 10 27 00 00       	mov    $0x2710,%edx
  805ac6:	80 f9 09             	cmp    $0x9,%cl
  805ac9:	77 08                	ja     805ad3 <dhcp_release+0x10e>
  805acb:	0f b6 c9             	movzbl %cl,%ecx
  805ace:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805ad3:	0f b7 d2             	movzwl %dx,%edx
  805ad6:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805adc:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  805ae1:	89 d0                	mov    %edx,%eax
  805ae3:	f7 e9                	imul   %ecx
  805ae5:	c1 fa 05             	sar    $0x5,%edx
  805ae8:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  805aec:	89 34 24             	mov    %esi,(%esp)
  805aef:	e8 94 18 00 00       	call   807388 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  805af4:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  805afb:	00 
  805afc:	89 34 24             	mov    %esi,(%esp)
  805aff:	e8 e0 18 00 00       	call   8073e4 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  805b04:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  805b0b:	00 
  805b0c:	89 34 24             	mov    %esi,(%esp)
  805b0f:	e8 db 17 00 00       	call   8072ef <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  805b14:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  805b1b:	00 
  805b1c:	89 34 24             	mov    %esi,(%esp)
  805b1f:	e8 e4 17 00 00       	call   807308 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  805b24:	89 f8                	mov    %edi,%eax
  805b26:	83 c4 3c             	add    $0x3c,%esp
  805b29:	5b                   	pop    %ebx
  805b2a:	5e                   	pop    %esi
  805b2b:	5f                   	pop    %edi
  805b2c:	5d                   	pop    %ebp
  805b2d:	c3                   	ret    

00805b2e <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  805b2e:	55                   	push   %ebp
  805b2f:	89 e5                	mov    %esp,%ebp
  805b31:	83 ec 48             	sub    $0x48,%esp
  805b34:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805b37:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805b3a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  805b3d:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  805b40:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  805b43:	ba 05 00 00 00       	mov    $0x5,%edx
  805b48:	89 d8                	mov    %ebx,%eax
  805b4a:	e8 11 f7 ff ff       	call   805260 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805b4f:	89 f8                	mov    %edi,%eax
  805b51:	e8 7a fc ff ff       	call   8057d0 <dhcp_create_request>
  805b56:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  805b58:	84 c0                	test   %al,%al
  805b5a:	0f 85 a4 00 00 00    	jne    805c04 <dhcp_renew+0xd6>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805b60:	b9 01 00 00 00       	mov    $0x1,%ecx
  805b65:	ba 35 00 00 00       	mov    $0x35,%edx
  805b6a:	89 d8                	mov    %ebx,%eax
  805b6c:	e8 3b f8 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  805b71:	ba 03 00 00 00       	mov    $0x3,%edx
  805b76:	89 d8                	mov    %ebx,%eax
  805b78:	e8 9e f8 ff ff       	call   80541b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805b7d:	b9 02 00 00 00       	mov    $0x2,%ecx
  805b82:	ba 39 00 00 00       	mov    $0x39,%edx
  805b87:	89 d8                	mov    %ebx,%eax
  805b89:	e8 1e f8 ff ff       	call   8053ac <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  805b8e:	ba 40 02 00 00       	mov    $0x240,%edx
  805b93:	89 d8                	mov    %ebx,%eax
  805b95:	e8 9b f9 ff ff       	call   805535 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  805b9a:	89 d8                	mov    %ebx,%eax
  805b9c:	e8 ca f8 ff ff       	call   80546b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805ba1:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805ba5:	66 05 f0 00          	add    $0xf0,%ax
  805ba9:	0f b7 c0             	movzwl %ax,%eax
  805bac:	89 44 24 04          	mov    %eax,0x4(%esp)
  805bb0:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805bb3:	89 04 24             	mov    %eax,(%esp)
  805bb6:	e8 5e 1f 00 00       	call   807b19 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  805bbb:	8d 43 2c             	lea    0x2c(%ebx),%eax
  805bbe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805bc1:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805bc8:	00 
  805bc9:	89 44 24 04          	mov    %eax,0x4(%esp)
  805bcd:	8b 43 08             	mov    0x8(%ebx),%eax
  805bd0:	89 04 24             	mov    %eax,(%esp)
  805bd3:	e8 b6 60 00 00       	call   80bc8e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  805bd8:	89 7c 24 10          	mov    %edi,0x10(%esp)
  805bdc:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805be3:	00 
  805be4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805be7:	89 44 24 08          	mov    %eax,0x8(%esp)
  805beb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805bee:	89 44 24 04          	mov    %eax,0x4(%esp)
  805bf2:	8b 43 08             	mov    0x8(%ebx),%eax
  805bf5:	89 04 24             	mov    %eax,(%esp)
  805bf8:	e8 13 61 00 00       	call   80bd10 <udp_sendto_if>
    dhcp_delete_request(netif);
  805bfd:	89 f8                	mov    %edi,%eax
  805bff:	e8 61 fa ff ff       	call   805665 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805c04:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  805c08:	83 c1 01             	add    $0x1,%ecx
  805c0b:	88 4b 01             	mov    %cl,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  805c0e:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  805c13:	80 f9 09             	cmp    $0x9,%cl
  805c16:	77 08                	ja     805c20 <dhcp_renew+0xf2>
  805c18:	0f b6 c9             	movzbl %cl,%ecx
  805c1b:	66 69 d1 d0 07       	imul   $0x7d0,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805c20:	0f b7 d2             	movzwl %dx,%edx
  805c23:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805c29:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  805c2e:	89 d0                	mov    %edx,%eax
  805c30:	f7 e9                	imul   %ecx
  805c32:	c1 fa 05             	sar    $0x5,%edx
  805c35:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  805c39:	89 f0                	mov    %esi,%eax
  805c3b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805c3e:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805c41:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805c44:	89 ec                	mov    %ebp,%esp
  805c46:	5d                   	pop    %ebp
  805c47:	c3                   	ret    

00805c48 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  805c48:	55                   	push   %ebp
  805c49:	89 e5                	mov    %esp,%ebp
  805c4b:	57                   	push   %edi
  805c4c:	56                   	push   %esi
  805c4d:	53                   	push   %ebx
  805c4e:	83 ec 2c             	sub    $0x2c,%esp
  805c51:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  805c53:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  805c56:	a1 e4 37 81 00       	mov    0x8137e4,%eax
  805c5b:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805c5e:	89 f8                	mov    %edi,%eax
  805c60:	e8 6b fb ff ff       	call   8057d0 <dhcp_create_request>
  805c65:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  805c67:	84 c0                	test   %al,%al
  805c69:	0f 85 f0 00 00 00    	jne    805d5f <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805c6f:	b9 01 00 00 00       	mov    $0x1,%ecx
  805c74:	ba 35 00 00 00       	mov    $0x35,%edx
  805c79:	89 d8                	mov    %ebx,%eax
  805c7b:	e8 2c f7 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  805c80:	ba 01 00 00 00       	mov    $0x1,%edx
  805c85:	89 d8                	mov    %ebx,%eax
  805c87:	e8 8f f7 ff ff       	call   80541b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805c8c:	b9 02 00 00 00       	mov    $0x2,%ecx
  805c91:	ba 39 00 00 00       	mov    $0x39,%edx
  805c96:	89 d8                	mov    %ebx,%eax
  805c98:	e8 0f f7 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_short(dhcp, 576);
  805c9d:	ba 40 02 00 00       	mov    $0x240,%edx
  805ca2:	89 d8                	mov    %ebx,%eax
  805ca4:	e8 8c f8 ff ff       	call   805535 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  805ca9:	b9 04 00 00 00       	mov    $0x4,%ecx
  805cae:	ba 37 00 00 00       	mov    $0x37,%edx
  805cb3:	89 d8                	mov    %ebx,%eax
  805cb5:	e8 f2 f6 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  805cba:	ba 01 00 00 00       	mov    $0x1,%edx
  805cbf:	89 d8                	mov    %ebx,%eax
  805cc1:	e8 55 f7 ff ff       	call   80541b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  805cc6:	ba 03 00 00 00       	mov    $0x3,%edx
  805ccb:	89 d8                	mov    %ebx,%eax
  805ccd:	e8 49 f7 ff ff       	call   80541b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  805cd2:	ba 1c 00 00 00       	mov    $0x1c,%edx
  805cd7:	89 d8                	mov    %ebx,%eax
  805cd9:	e8 3d f7 ff ff       	call   80541b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  805cde:	ba 06 00 00 00       	mov    $0x6,%edx
  805ce3:	89 d8                	mov    %ebx,%eax
  805ce5:	e8 31 f7 ff ff       	call   80541b <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  805cea:	89 d8                	mov    %ebx,%eax
  805cec:	e8 7a f7 ff ff       	call   80546b <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805cf1:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805cf5:	66 05 f0 00          	add    $0xf0,%ax
  805cf9:	0f b7 c0             	movzwl %ax,%eax
  805cfc:	89 44 24 04          	mov    %eax,0x4(%esp)
  805d00:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805d03:	89 04 24             	mov    %eax,(%esp)
  805d06:	e8 0e 1e 00 00       	call   807b19 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  805d0b:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805d12:	00 
  805d13:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  805d1a:	00 
  805d1b:	8b 43 08             	mov    0x8(%ebx),%eax
  805d1e:	89 04 24             	mov    %eax,(%esp)
  805d21:	e8 68 5f 00 00       	call   80bc8e <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  805d26:	89 7c 24 10          	mov    %edi,0x10(%esp)
  805d2a:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805d31:	00 
  805d32:	c7 44 24 08 e8 37 81 	movl   $0x8137e8,0x8(%esp)
  805d39:	00 
  805d3a:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805d3d:	89 44 24 04          	mov    %eax,0x4(%esp)
  805d41:	8b 43 08             	mov    0x8(%ebx),%eax
  805d44:	89 04 24             	mov    %eax,(%esp)
  805d47:	e8 c4 5f 00 00       	call   80bd10 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  805d4c:	89 f8                	mov    %edi,%eax
  805d4e:	e8 12 f9 ff ff       	call   805665 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  805d53:	ba 06 00 00 00       	mov    $0x6,%edx
  805d58:	89 d8                	mov    %ebx,%eax
  805d5a:	e8 01 f5 ff ff       	call   805260 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805d5f:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  805d63:	83 c1 01             	add    $0x1,%ecx
  805d66:	88 4b 01             	mov    %cl,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  805d69:	ba 10 27 00 00       	mov    $0x2710,%edx
  805d6e:	80 f9 03             	cmp    $0x3,%cl
  805d71:	77 0b                	ja     805d7e <dhcp_discover+0x136>
  805d73:	0f b6 d1             	movzbl %cl,%edx
  805d76:	83 c2 01             	add    $0x1,%edx
  805d79:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805d7e:	0f b7 d2             	movzwl %dx,%edx
  805d81:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805d87:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  805d8c:	89 d0                	mov    %edx,%eax
  805d8e:	f7 e9                	imul   %ecx
  805d90:	c1 fa 05             	sar    $0x5,%edx
  805d93:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  805d97:	89 f0                	mov    %esi,%eax
  805d99:	83 c4 2c             	add    $0x2c,%esp
  805d9c:	5b                   	pop    %ebx
  805d9d:	5e                   	pop    %esi
  805d9e:	5f                   	pop    %edi
  805d9f:	5d                   	pop    %ebp
  805da0:	c3                   	ret    

00805da1 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  805da1:	55                   	push   %ebp
  805da2:	89 e5                	mov    %esp,%ebp
  805da4:	83 ec 38             	sub    $0x38,%esp
  805da7:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805daa:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805dad:	89 7d fc             	mov    %edi,-0x4(%ebp)
  805db0:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  805db2:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  805db5:	ba 04 00 00 00       	mov    $0x4,%edx
  805dba:	89 d8                	mov    %ebx,%eax
  805dbc:	e8 9f f4 ff ff       	call   805260 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805dc1:	89 f8                	mov    %edi,%eax
  805dc3:	e8 08 fa ff ff       	call   8057d0 <dhcp_create_request>
  805dc8:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  805dca:	84 c0                	test   %al,%al
  805dcc:	0f 85 a3 00 00 00    	jne    805e75 <dhcp_rebind+0xd4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805dd2:	b9 01 00 00 00       	mov    $0x1,%ecx
  805dd7:	ba 35 00 00 00       	mov    $0x35,%edx
  805ddc:	89 d8                	mov    %ebx,%eax
  805dde:	e8 c9 f5 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  805de3:	ba 03 00 00 00       	mov    $0x3,%edx
  805de8:	89 d8                	mov    %ebx,%eax
  805dea:	e8 2c f6 ff ff       	call   80541b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805def:	b9 02 00 00 00       	mov    $0x2,%ecx
  805df4:	ba 39 00 00 00       	mov    $0x39,%edx
  805df9:	89 d8                	mov    %ebx,%eax
  805dfb:	e8 ac f5 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_short(dhcp, 576);
  805e00:	ba 40 02 00 00       	mov    $0x240,%edx
  805e05:	89 d8                	mov    %ebx,%eax
  805e07:	e8 29 f7 ff ff       	call   805535 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  805e0c:	89 d8                	mov    %ebx,%eax
  805e0e:	e8 58 f6 ff ff       	call   80546b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  805e13:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  805e17:	66 05 f0 00          	add    $0xf0,%ax
  805e1b:	0f b7 c0             	movzwl %ax,%eax
  805e1e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805e22:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805e25:	89 04 24             	mov    %eax,(%esp)
  805e28:	e8 ec 1c 00 00       	call   807b19 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  805e2d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  805e34:	00 
  805e35:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  805e3c:	00 
  805e3d:	8b 43 08             	mov    0x8(%ebx),%eax
  805e40:	89 04 24             	mov    %eax,(%esp)
  805e43:	e8 46 5e 00 00       	call   80bc8e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  805e48:	89 7c 24 10          	mov    %edi,0x10(%esp)
  805e4c:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  805e53:	00 
  805e54:	c7 44 24 08 e8 37 81 	movl   $0x8137e8,0x8(%esp)
  805e5b:	00 
  805e5c:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805e5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  805e63:	8b 43 08             	mov    0x8(%ebx),%eax
  805e66:	89 04 24             	mov    %eax,(%esp)
  805e69:	e8 a2 5e 00 00       	call   80bd10 <udp_sendto_if>
    dhcp_delete_request(netif);
  805e6e:	89 f8                	mov    %edi,%eax
  805e70:	e8 f0 f7 ff ff       	call   805665 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  805e75:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  805e79:	83 c1 01             	add    $0x1,%ecx
  805e7c:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  805e7f:	ba 10 27 00 00       	mov    $0x2710,%edx
  805e84:	80 f9 09             	cmp    $0x9,%cl
  805e87:	77 08                	ja     805e91 <dhcp_rebind+0xf0>
  805e89:	0f b6 c9             	movzbl %cl,%ecx
  805e8c:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  805e91:	0f b7 d2             	movzwl %dx,%edx
  805e94:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  805e9a:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  805e9f:	89 d0                	mov    %edx,%eax
  805ea1:	f7 e9                	imul   %ecx
  805ea3:	c1 fa 05             	sar    $0x5,%edx
  805ea6:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  805eaa:	89 f0                	mov    %esi,%eax
  805eac:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805eaf:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805eb2:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805eb5:	89 ec                	mov    %ebp,%esp
  805eb7:	5d                   	pop    %ebp
  805eb8:	c3                   	ret    

00805eb9 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  805eb9:	55                   	push   %ebp
  805eba:	89 e5                	mov    %esp,%ebp
  805ebc:	53                   	push   %ebx
  805ebd:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  805ec0:	8b 1d 04 f0 b3 00    	mov    0xb3f004,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  805ec6:	85 db                	test   %ebx,%ebx
  805ec8:	74 67                	je     805f31 <dhcp_coarse_tmr+0x78>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  805eca:	8b 43 20             	mov    0x20(%ebx),%eax
  805ecd:	85 c0                	test   %eax,%eax
  805ecf:	74 5a                	je     805f2b <dhcp_coarse_tmr+0x72>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  805ed1:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  805ed5:	8d 4a ff             	lea    -0x1(%edx),%ecx
  805ed8:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  805edc:	66 83 fa 01          	cmp    $0x1,%dx
  805ee0:	75 1b                	jne    805efd <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  805ee2:	8b 43 20             	mov    0x20(%ebx),%eax
  805ee5:	0f b6 00             	movzbl (%eax),%eax
  805ee8:	3c 01                	cmp    $0x1,%al
  805eea:	74 08                	je     805ef4 <dhcp_coarse_tmr+0x3b>
  805eec:	3c 0a                	cmp    $0xa,%al
  805eee:	74 04                	je     805ef4 <dhcp_coarse_tmr+0x3b>
  805ef0:	3c 05                	cmp    $0x5,%al
  805ef2:	75 37                	jne    805f2b <dhcp_coarse_tmr+0x72>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  805ef4:	89 d8                	mov    %ebx,%eax
  805ef6:	e8 a6 fe ff ff       	call   805da1 <dhcp_rebind>
  805efb:	eb 2e                	jmp    805f2b <dhcp_coarse_tmr+0x72>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  805efd:	8b 53 20             	mov    0x20(%ebx),%edx
  805f00:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  805f04:	8d 48 ff             	lea    -0x1(%eax),%ecx
  805f07:	66 89 4a 28          	mov    %cx,0x28(%edx)
  805f0b:	66 83 f8 01          	cmp    $0x1,%ax
  805f0f:	75 1a                	jne    805f2b <dhcp_coarse_tmr+0x72>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  805f11:	8b 43 20             	mov    0x20(%ebx),%eax
  805f14:	0f b6 00             	movzbl (%eax),%eax
  805f17:	3c 01                	cmp    $0x1,%al
  805f19:	74 08                	je     805f23 <dhcp_coarse_tmr+0x6a>
  805f1b:	3c 0a                	cmp    $0xa,%al
  805f1d:	74 04                	je     805f23 <dhcp_coarse_tmr+0x6a>
  805f1f:	3c 05                	cmp    $0x5,%al
  805f21:	75 08                	jne    805f2b <dhcp_coarse_tmr+0x72>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  805f23:	89 1c 24             	mov    %ebx,(%esp)
  805f26:	e8 03 fc ff ff       	call   805b2e <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  805f2b:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  805f2d:	85 db                	test   %ebx,%ebx
  805f2f:	75 99                	jne    805eca <dhcp_coarse_tmr+0x11>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  805f31:	83 c4 14             	add    $0x14,%esp
  805f34:	5b                   	pop    %ebx
  805f35:	5d                   	pop    %ebp
  805f36:	c3                   	ret    

00805f37 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  805f37:	55                   	push   %ebp
  805f38:	89 e5                	mov    %esp,%ebp
  805f3a:	83 ec 28             	sub    $0x28,%esp
  805f3d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  805f40:	89 75 fc             	mov    %esi,-0x4(%ebp)
  805f43:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  805f46:	85 f6                	test   %esi,%esi
  805f48:	75 1c                	jne    805f66 <dhcp_arp_reply+0x2f>
  805f4a:	c7 44 24 08 3b 2f 81 	movl   $0x812f3b,0x8(%esp)
  805f51:	00 
  805f52:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  805f59:	00 
  805f5a:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  805f61:	e8 ae a9 ff ff       	call   800914 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  805f66:	8b 5e 20             	mov    0x20(%esi),%ebx
  805f69:	85 db                	test   %ebx,%ebx
  805f6b:	0f 84 04 01 00 00    	je     806075 <dhcp_arp_reply+0x13e>
  805f71:	80 3b 08             	cmpb   $0x8,(%ebx)
  805f74:	0f 85 fb 00 00 00    	jne    806075 <dhcp_arp_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  805f7a:	8b 45 0c             	mov    0xc(%ebp),%eax
  805f7d:	8b 00                	mov    (%eax),%eax
  805f7f:	3b 43 30             	cmp    0x30(%ebx),%eax
  805f82:	0f 85 ed 00 00 00    	jne    806075 <dhcp_arp_reply+0x13e>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  805f88:	ba 0c 00 00 00       	mov    $0xc,%edx
  805f8d:	89 d8                	mov    %ebx,%eax
  805f8f:	e8 cc f2 ff ff       	call   805260 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805f94:	89 f0                	mov    %esi,%eax
  805f96:	e8 35 f8 ff ff       	call   8057d0 <dhcp_create_request>
  if (result == ERR_OK) {
  805f9b:	84 c0                	test   %al,%al
  805f9d:	0f 85 c8 00 00 00    	jne    80606b <dhcp_arp_reply+0x134>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  805fa3:	b9 01 00 00 00       	mov    $0x1,%ecx
  805fa8:	ba 35 00 00 00       	mov    $0x35,%edx
  805fad:	89 d8                	mov    %ebx,%eax
  805faf:	e8 f8 f3 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  805fb4:	ba 04 00 00 00       	mov    $0x4,%edx
  805fb9:	89 d8                	mov    %ebx,%eax
  805fbb:	e8 5b f4 ff ff       	call   80541b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  805fc0:	b9 02 00 00 00       	mov    $0x2,%ecx
  805fc5:	ba 39 00 00 00       	mov    $0x39,%edx
  805fca:	89 d8                	mov    %ebx,%eax
  805fcc:	e8 db f3 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_short(dhcp, 576);
  805fd1:	ba 40 02 00 00       	mov    $0x240,%edx
  805fd6:	89 d8                	mov    %ebx,%eax
  805fd8:	e8 58 f5 ff ff       	call   805535 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  805fdd:	b9 04 00 00 00       	mov    $0x4,%ecx
  805fe2:	ba 32 00 00 00       	mov    $0x32,%edx
  805fe7:	89 d8                	mov    %ebx,%eax
  805fe9:	e8 be f3 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  805fee:	8b 43 30             	mov    0x30(%ebx),%eax
  805ff1:	89 04 24             	mov    %eax,(%esp)
  805ff4:	e8 cc 49 00 00       	call   80a9c5 <ntohl>
  805ff9:	89 c2                	mov    %eax,%edx
  805ffb:	89 d8                	mov    %ebx,%eax
  805ffd:	e8 b2 f5 ff ff       	call   8055b4 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  806002:	89 d8                	mov    %ebx,%eax
  806004:	e8 62 f4 ff ff       	call   80546b <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806009:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80600d:	66 05 f0 00          	add    $0xf0,%ax
  806011:	0f b7 c0             	movzwl %ax,%eax
  806014:	89 44 24 04          	mov    %eax,0x4(%esp)
  806018:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80601b:	89 04 24             	mov    %eax,(%esp)
  80601e:	e8 f6 1a 00 00       	call   807b19 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806023:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80602a:	00 
  80602b:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  806032:	00 
  806033:	8b 43 08             	mov    0x8(%ebx),%eax
  806036:	89 04 24             	mov    %eax,(%esp)
  806039:	e8 50 5c 00 00       	call   80bc8e <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80603e:	89 74 24 10          	mov    %esi,0x10(%esp)
  806042:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806049:	00 
  80604a:	c7 44 24 08 e8 37 81 	movl   $0x8137e8,0x8(%esp)
  806051:	00 
  806052:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806055:	89 44 24 04          	mov    %eax,0x4(%esp)
  806059:	8b 43 08             	mov    0x8(%ebx),%eax
  80605c:	89 04 24             	mov    %eax,(%esp)
  80605f:	e8 ac 5c 00 00       	call   80bd10 <udp_sendto_if>
    dhcp_delete_request(netif);
  806064:	89 f0                	mov    %esi,%eax
  806066:	e8 fa f5 ff ff       	call   805665 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80606b:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80606f:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  806075:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  806078:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80607b:	89 ec                	mov    %ebp,%esp
  80607d:	5d                   	pop    %ebp
  80607e:	c3                   	ret    

0080607f <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  80607f:	55                   	push   %ebp
  806080:	89 e5                	mov    %esp,%ebp
  806082:	57                   	push   %edi
  806083:	56                   	push   %esi
  806084:	53                   	push   %ebx
  806085:	83 ec 2c             	sub    $0x2c,%esp
  806088:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80608a:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80608d:	e8 3e f7 ff ff       	call   8057d0 <dhcp_create_request>
  806092:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  806094:	84 c0                	test   %al,%al
  806096:	0f 85 3a 01 00 00    	jne    8061d6 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80609c:	b9 01 00 00 00       	mov    $0x1,%ecx
  8060a1:	ba 35 00 00 00       	mov    $0x35,%edx
  8060a6:	89 d8                	mov    %ebx,%eax
  8060a8:	e8 ff f2 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8060ad:	ba 03 00 00 00       	mov    $0x3,%edx
  8060b2:	89 d8                	mov    %ebx,%eax
  8060b4:	e8 62 f3 ff ff       	call   80541b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8060b9:	b9 02 00 00 00       	mov    $0x2,%ecx
  8060be:	ba 39 00 00 00       	mov    $0x39,%edx
  8060c3:	89 d8                	mov    %ebx,%eax
  8060c5:	e8 e2 f2 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8060ca:	ba 40 02 00 00       	mov    $0x240,%edx
  8060cf:	89 d8                	mov    %ebx,%eax
  8060d1:	e8 5f f4 ff ff       	call   805535 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8060d6:	b9 04 00 00 00       	mov    $0x4,%ecx
  8060db:	ba 32 00 00 00       	mov    $0x32,%edx
  8060e0:	89 d8                	mov    %ebx,%eax
  8060e2:	e8 c5 f2 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8060e7:	8b 43 30             	mov    0x30(%ebx),%eax
  8060ea:	89 04 24             	mov    %eax,(%esp)
  8060ed:	e8 d3 48 00 00       	call   80a9c5 <ntohl>
  8060f2:	89 c2                	mov    %eax,%edx
  8060f4:	89 d8                	mov    %ebx,%eax
  8060f6:	e8 b9 f4 ff ff       	call   8055b4 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8060fb:	b9 04 00 00 00       	mov    $0x4,%ecx
  806100:	ba 36 00 00 00       	mov    $0x36,%edx
  806105:	89 d8                	mov    %ebx,%eax
  806107:	e8 a0 f2 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  80610c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80610f:	89 04 24             	mov    %eax,(%esp)
  806112:	e8 ae 48 00 00       	call   80a9c5 <ntohl>
  806117:	89 c2                	mov    %eax,%edx
  806119:	89 d8                	mov    %ebx,%eax
  80611b:	e8 94 f4 ff ff       	call   8055b4 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  806120:	b9 04 00 00 00       	mov    $0x4,%ecx
  806125:	ba 37 00 00 00       	mov    $0x37,%edx
  80612a:	89 d8                	mov    %ebx,%eax
  80612c:	e8 7b f2 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  806131:	ba 01 00 00 00       	mov    $0x1,%edx
  806136:	89 d8                	mov    %ebx,%eax
  806138:	e8 de f2 ff ff       	call   80541b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80613d:	ba 03 00 00 00       	mov    $0x3,%edx
  806142:	89 d8                	mov    %ebx,%eax
  806144:	e8 d2 f2 ff ff       	call   80541b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  806149:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80614e:	89 d8                	mov    %ebx,%eax
  806150:	e8 c6 f2 ff ff       	call   80541b <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  806155:	ba 06 00 00 00       	mov    $0x6,%edx
  80615a:	89 d8                	mov    %ebx,%eax
  80615c:	e8 ba f2 ff ff       	call   80541b <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  806161:	89 d8                	mov    %ebx,%eax
  806163:	e8 03 f3 ff ff       	call   80546b <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806168:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80616c:	66 05 f0 00          	add    $0xf0,%ax
  806170:	0f b7 c0             	movzwl %ax,%eax
  806173:	89 44 24 04          	mov    %eax,0x4(%esp)
  806177:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80617a:	89 04 24             	mov    %eax,(%esp)
  80617d:	e8 97 19 00 00       	call   807b19 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806182:	89 7c 24 10          	mov    %edi,0x10(%esp)
  806186:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80618d:	00 
  80618e:	c7 44 24 08 e8 37 81 	movl   $0x8137e8,0x8(%esp)
  806195:	00 
  806196:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806199:	89 44 24 04          	mov    %eax,0x4(%esp)
  80619d:	8b 43 08             	mov    0x8(%ebx),%eax
  8061a0:	89 04 24             	mov    %eax,(%esp)
  8061a3:	e8 68 5b 00 00       	call   80bd10 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8061a8:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8061af:	00 
  8061b0:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  8061b7:	00 
  8061b8:	8b 43 08             	mov    0x8(%ebx),%eax
  8061bb:	89 04 24             	mov    %eax,(%esp)
  8061be:	e8 cb 5a 00 00       	call   80bc8e <udp_connect>
    dhcp_delete_request(netif);
  8061c3:	89 f8                	mov    %edi,%eax
  8061c5:	e8 9b f4 ff ff       	call   805665 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8061ca:	ba 01 00 00 00       	mov    $0x1,%edx
  8061cf:	89 d8                	mov    %ebx,%eax
  8061d1:	e8 8a f0 ff ff       	call   805260 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8061d6:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  8061da:	83 c1 01             	add    $0x1,%ecx
  8061dd:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8061e0:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  8061e5:	80 f9 03             	cmp    $0x3,%cl
  8061e8:	77 08                	ja     8061f2 <dhcp_select+0x173>
  8061ea:	0f b6 c9             	movzbl %cl,%ecx
  8061ed:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8061f2:	0f b7 d2             	movzwl %dx,%edx
  8061f5:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8061fb:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  806200:	89 d0                	mov    %edx,%eax
  806202:	f7 e9                	imul   %ecx
  806204:	c1 fa 05             	sar    $0x5,%edx
  806207:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  80620b:	89 f0                	mov    %esi,%eax
  80620d:	83 c4 2c             	add    $0x2c,%esp
  806210:	5b                   	pop    %ebx
  806211:	5e                   	pop    %esi
  806212:	5f                   	pop    %edi
  806213:	5d                   	pop    %ebp
  806214:	c3                   	ret    

00806215 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  806215:	55                   	push   %ebp
  806216:	89 e5                	mov    %esp,%ebp
  806218:	83 ec 38             	sub    $0x38,%esp
  80621b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80621e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806221:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806224:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  806227:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  80622a:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  806231:	e8 ba 09 00 00       	call   806bf0 <mem_malloc>
  806236:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  806238:	85 c0                	test   %eax,%eax
  80623a:	0f 84 40 01 00 00    	je     806380 <dhcp_inform+0x16b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  806240:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  806243:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  80624a:	00 
  80624b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806252:	00 
  806253:	89 04 24             	mov    %eax,(%esp)
  806256:	e8 3b b0 ff ff       	call   801296 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  80625b:	e8 df 58 00 00       	call   80bb3f <udp_new>
  806260:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  806263:	85 c0                	test   %eax,%eax
  806265:	75 0e                	jne    806275 <dhcp_inform+0x60>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  806267:	89 1c 24             	mov    %ebx,(%esp)
  80626a:	e8 16 0d 00 00       	call   806f85 <mem_free>
    return;
  80626f:	90                   	nop
  806270:	e9 0b 01 00 00       	jmp    806380 <dhcp_inform+0x16b>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  806275:	89 f0                	mov    %esi,%eax
  806277:	e8 54 f5 ff ff       	call   8057d0 <dhcp_create_request>
  if (result == ERR_OK) {
  80627c:	84 c0                	test   %al,%al
  80627e:	66 90                	xchg   %ax,%ax
  806280:	0f 85 d9 00 00 00    	jne    80635f <dhcp_inform+0x14a>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  806286:	b9 01 00 00 00       	mov    $0x1,%ecx
  80628b:	ba 35 00 00 00       	mov    $0x35,%edx
  806290:	89 d8                	mov    %ebx,%eax
  806292:	e8 15 f1 ff ff       	call   8053ac <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  806297:	ba 08 00 00 00       	mov    $0x8,%edx
  80629c:	89 d8                	mov    %ebx,%eax
  80629e:	e8 78 f1 ff ff       	call   80541b <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8062a3:	b9 02 00 00 00       	mov    $0x2,%ecx
  8062a8:	ba 39 00 00 00       	mov    $0x39,%edx
  8062ad:	89 d8                	mov    %ebx,%eax
  8062af:	e8 f8 f0 ff ff       	call   8053ac <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  8062b4:	ba 40 02 00 00       	mov    $0x240,%edx
  8062b9:	89 d8                	mov    %ebx,%eax
  8062bb:	e8 75 f2 ff ff       	call   805535 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  8062c0:	89 d8                	mov    %ebx,%eax
  8062c2:	e8 a4 f1 ff ff       	call   80546b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8062c7:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8062cb:	66 05 f0 00          	add    $0xf0,%ax
  8062cf:	0f b7 c0             	movzwl %ax,%eax
  8062d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8062d6:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8062d9:	89 04 24             	mov    %eax,(%esp)
  8062dc:	e8 38 18 00 00       	call   807b19 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  8062e1:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  8062e8:	00 
  8062e9:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  8062f0:	00 
  8062f1:	8b 43 08             	mov    0x8(%ebx),%eax
  8062f4:	89 04 24             	mov    %eax,(%esp)
  8062f7:	e8 cc 58 00 00       	call   80bbc8 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  8062fc:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806303:	00 
  806304:	c7 44 24 04 e8 37 81 	movl   $0x8137e8,0x4(%esp)
  80630b:	00 
  80630c:	8b 43 08             	mov    0x8(%ebx),%eax
  80630f:	89 04 24             	mov    %eax,(%esp)
  806312:	e8 77 59 00 00       	call   80bc8e <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806317:	89 74 24 10          	mov    %esi,0x10(%esp)
  80631b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806322:	00 
  806323:	c7 44 24 08 e8 37 81 	movl   $0x8137e8,0x8(%esp)
  80632a:	00 
  80632b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80632e:	89 44 24 04          	mov    %eax,0x4(%esp)
  806332:	8b 43 08             	mov    0x8(%ebx),%eax
  806335:	89 04 24             	mov    %eax,(%esp)
  806338:	e8 d3 59 00 00       	call   80bd10 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80633d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806344:	00 
  806345:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  80634c:	00 
  80634d:	8b 43 08             	mov    0x8(%ebx),%eax
  806350:	89 04 24             	mov    %eax,(%esp)
  806353:	e8 36 59 00 00       	call   80bc8e <udp_connect>
    dhcp_delete_request(netif);
  806358:	89 f0                	mov    %esi,%eax
  80635a:	e8 06 f3 ff ff       	call   805665 <dhcp_delete_request>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  80635f:	8b 43 08             	mov    0x8(%ebx),%eax
  806362:	85 c0                	test   %eax,%eax
  806364:	74 08                	je     80636e <dhcp_inform+0x159>
      udp_remove(dhcp->pcb);
  806366:	89 04 24             	mov    %eax,(%esp)
  806369:	e8 0e 58 00 00       	call   80bb7c <udp_remove>
    }
    dhcp->pcb = NULL;
  80636e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  806375:	89 1c 24             	mov    %ebx,(%esp)
  806378:	e8 08 0c 00 00       	call   806f85 <mem_free>
    netif->dhcp = old_dhcp;
  80637d:	89 7e 20             	mov    %edi,0x20(%esi)
  }
}
  806380:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  806383:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806386:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806389:	89 ec                	mov    %ebp,%esp
  80638b:	5d                   	pop    %ebp
  80638c:	c3                   	ret    

0080638d <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  80638d:	55                   	push   %ebp
  80638e:	89 e5                	mov    %esp,%ebp
  806390:	56                   	push   %esi
  806391:	53                   	push   %ebx
  806392:	83 ec 10             	sub    $0x10,%esp
  806395:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  806398:	85 f6                	test   %esi,%esi
  80639a:	75 1c                	jne    8063b8 <dhcp_start+0x2b>
  80639c:	c7 44 24 08 3b 2f 81 	movl   $0x812f3b,0x8(%esp)
  8063a3:	00 
  8063a4:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  8063ab:	00 
  8063ac:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8063b3:	e8 5c a5 ff ff       	call   800914 <_panic>
  dhcp = netif->dhcp;
  8063b8:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  8063bb:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  8063bf:	85 db                	test   %ebx,%ebx
  8063c1:	75 1e                	jne    8063e1 <dhcp_start+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  8063c3:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  8063ca:	e8 21 08 00 00       	call   806bf0 <mem_malloc>
  8063cf:	89 c3                	mov    %eax,%ebx
    if (dhcp == NULL) {
  8063d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8063d6:	85 db                	test   %ebx,%ebx
  8063d8:	0f 84 a5 00 00 00    	je     806483 <dhcp_start+0xf6>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  8063de:	89 5e 20             	mov    %ebx,0x20(%esi)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  8063e1:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  8063e8:	00 
  8063e9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8063f0:	00 
  8063f1:	89 1c 24             	mov    %ebx,(%esp)
  8063f4:	e8 9d ae ff ff       	call   801296 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  8063f9:	e8 41 57 00 00       	call   80bb3f <udp_new>
  8063fe:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  806401:	85 c0                	test   %eax,%eax
  806403:	75 16                	jne    80641b <dhcp_start+0x8e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  806405:	89 1c 24             	mov    %ebx,(%esp)
  806408:	e8 78 0b 00 00       	call   806f85 <mem_free>
    netif->dhcp = dhcp = NULL;
  80640d:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  806414:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  806419:	eb 68                	jmp    806483 <dhcp_start+0xf6>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80641b:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  806422:	00 
  806423:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  80642a:	00 
  80642b:	89 04 24             	mov    %eax,(%esp)
  80642e:	e8 95 57 00 00       	call   80bbc8 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806433:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80643a:	00 
  80643b:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  806442:	00 
  806443:	8b 43 08             	mov    0x8(%ebx),%eax
  806446:	89 04 24             	mov    %eax,(%esp)
  806449:	e8 40 58 00 00       	call   80bc8e <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  80644e:	89 74 24 08          	mov    %esi,0x8(%esp)
  806452:	c7 44 24 04 62 66 80 	movl   $0x806662,0x4(%esp)
  806459:	00 
  80645a:	8b 43 08             	mov    0x8(%ebx),%eax
  80645d:	89 04 24             	mov    %eax,(%esp)
  806460:	e8 c6 56 00 00       	call   80bb2b <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  806465:	89 f0                	mov    %esi,%eax
  806467:	e8 dc f7 ff ff       	call   805c48 <dhcp_discover>
  if (result != ERR_OK) {
  80646c:	84 c0                	test   %al,%al
  80646e:	74 0f                	je     80647f <dhcp_start+0xf2>
    /* free resources allocated above */
    dhcp_stop(netif);
  806470:	89 34 24             	mov    %esi,(%esp)
  806473:	e8 d9 f2 ff ff       	call   805751 <dhcp_stop>
  806478:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80647d:	eb 04                	jmp    806483 <dhcp_start+0xf6>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  80647f:	80 4e 2e 08          	orb    $0x8,0x2e(%esi)
  return result;
}
  806483:	83 c4 10             	add    $0x10,%esp
  806486:	5b                   	pop    %ebx
  806487:	5e                   	pop    %esi
  806488:	5d                   	pop    %ebp
  806489:	c3                   	ret    

0080648a <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  80648a:	55                   	push   %ebp
  80648b:	89 e5                	mov    %esp,%ebp
  80648d:	53                   	push   %ebx
  80648e:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  806491:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  806494:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80649b:	00 
  80649c:	8d 53 30             	lea    0x30(%ebx),%edx
  80649f:	89 54 24 04          	mov    %edx,0x4(%esp)
  8064a3:	89 04 24             	mov    %eax,(%esp)
  8064a6:	e8 9c 62 00 00       	call   80c747 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  8064ab:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8064af:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  8064b5:	ba 08 00 00 00       	mov    $0x8,%edx
  8064ba:	89 d8                	mov    %ebx,%eax
  8064bc:	e8 9f ed ff ff       	call   805260 <dhcp_set_state>
}
  8064c1:	83 c4 14             	add    $0x14,%esp
  8064c4:	5b                   	pop    %ebx
  8064c5:	5d                   	pop    %ebp
  8064c6:	c3                   	ret    

008064c7 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  8064c7:	55                   	push   %ebp
  8064c8:	89 e5                	mov    %esp,%ebp
  8064ca:	57                   	push   %edi
  8064cb:	56                   	push   %esi
  8064cc:	53                   	push   %ebx
  8064cd:	83 ec 2c             	sub    $0x2c,%esp
  8064d0:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  8064d2:	85 c0                	test   %eax,%eax
  8064d4:	75 1c                	jne    8064f2 <dhcp_bind+0x2b>
  8064d6:	c7 44 24 08 30 2f 81 	movl   $0x812f30,0x8(%esp)
  8064dd:	00 
  8064de:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  8064e5:	00 
  8064e6:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8064ed:	e8 22 a4 ff ff       	call   800914 <_panic>
  dhcp = netif->dhcp;
  8064f2:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  8064f5:	85 db                	test   %ebx,%ebx
  8064f7:	75 1c                	jne    806515 <dhcp_bind+0x4e>
  8064f9:	c7 44 24 08 49 2f 81 	movl   $0x812f49,0x8(%esp)
  806500:	00 
  806501:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  806508:	00 
  806509:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  806510:	e8 ff a3 ff ff       	call   800914 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  806515:	8b 53 50             	mov    0x50(%ebx),%edx
  806518:	83 fa ff             	cmp    $0xffffffff,%edx
  80651b:	74 2c                	je     806549 <dhcp_bind+0x82>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  80651d:	83 c2 1e             	add    $0x1e,%edx
  806520:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  806525:	89 d0                	mov    %edx,%eax
  806527:	f7 e1                	mul    %ecx
  806529:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  80652c:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  806532:	b8 ff ff 00 00       	mov    $0xffff,%eax
  806537:	0f 47 d0             	cmova  %eax,%edx
    if (dhcp->t1_timeout == 0) {
      dhcp->t1_timeout = 1;
  80653a:	66 85 d2             	test   %dx,%dx
  80653d:	b8 01 00 00 00       	mov    $0x1,%eax
  806542:	0f 44 d0             	cmove  %eax,%edx
  806545:	66 89 53 28          	mov    %dx,0x28(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  806549:	8b 53 54             	mov    0x54(%ebx),%edx
  80654c:	83 fa ff             	cmp    $0xffffffff,%edx
  80654f:	74 2c                	je     80657d <dhcp_bind+0xb6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  806551:	83 c2 1e             	add    $0x1e,%edx
  806554:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  806559:	89 d0                	mov    %edx,%eax
  80655b:	f7 e1                	mul    %ecx
  80655d:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  806560:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  806566:	b8 ff ff 00 00       	mov    $0xffff,%eax
  80656b:	0f 47 d0             	cmova  %eax,%edx
    if (dhcp->t2_timeout == 0) {
      dhcp->t2_timeout = 1;
  80656e:	66 85 d2             	test   %dx,%dx
  806571:	b8 01 00 00 00       	mov    $0x1,%eax
  806576:	0f 44 d0             	cmove  %eax,%edx
  806579:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80657d:	83 fb cc             	cmp    $0xffffffcc,%ebx
  806580:	0f 84 c5 00 00 00    	je     80664b <dhcp_bind+0x184>
  806586:	8b 43 34             	mov    0x34(%ebx),%eax
  806589:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  80658c:	85 c0                	test   %eax,%eax
  80658e:	75 49                	jne    8065d9 <dhcp_bind+0x112>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  806590:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  806597:	e8 29 44 00 00       	call   80a9c5 <ntohl>
  80659c:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  80659f:	84 c0                	test   %al,%al
  8065a1:	78 11                	js     8065b4 <dhcp_bind+0xed>
      sn_mask.addr = htonl(0xff000000);
  8065a3:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  8065aa:	e8 f5 41 00 00       	call   80a7a4 <htonl>
  8065af:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8065b2:	eb 25                	jmp    8065d9 <dhcp_bind+0x112>
    } else if (first_octet >= 192) {
  8065b4:	3c bf                	cmp    $0xbf,%al
  8065b6:	76 12                	jbe    8065ca <dhcp_bind+0x103>
      sn_mask.addr = htonl(0xffffff00);
  8065b8:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  8065bf:	90                   	nop
  8065c0:	e8 df 41 00 00       	call   80a7a4 <htonl>
  8065c5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8065c8:	eb 0f                	jmp    8065d9 <dhcp_bind+0x112>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  8065ca:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  8065d1:	e8 ce 41 00 00       	call   80a7a4 <htonl>
  8065d6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  8065d9:	83 fb c8             	cmp    $0xffffffc8,%ebx
  8065dc:	74 79                	je     806657 <dhcp_bind+0x190>
  8065de:	8b 43 38             	mov    0x38(%ebx),%eax
  8065e1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  8065e4:	85 c0                	test   %eax,%eax
  8065e6:	75 1a                	jne    806602 <dhcp_bind+0x13b>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  8065e8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8065eb:	23 7b 30             	and    0x30(%ebx),%edi
  8065ee:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  8065f1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8065f8:	e8 a7 41 00 00       	call   80a7a4 <htonl>
  8065fd:	09 c7                	or     %eax,%edi
  8065ff:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  806602:	8d 43 30             	lea    0x30(%ebx),%eax
  806605:	89 44 24 04          	mov    %eax,0x4(%esp)
  806609:	89 34 24             	mov    %esi,(%esp)
  80660c:	e8 d3 0d 00 00       	call   8073e4 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  806611:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  806614:	89 44 24 04          	mov    %eax,0x4(%esp)
  806618:	89 34 24             	mov    %esi,(%esp)
  80661b:	e8 e8 0c 00 00       	call   807308 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  806620:	8d 45 e0             	lea    -0x20(%ebp),%eax
  806623:	89 44 24 04          	mov    %eax,0x4(%esp)
  806627:	89 34 24             	mov    %esi,(%esp)
  80662a:	e8 c0 0c 00 00       	call   8072ef <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  80662f:	89 34 24             	mov    %esi,(%esp)
  806632:	e8 77 0d 00 00       	call   8073ae <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  806637:	ba 0a 00 00 00       	mov    $0xa,%edx
  80663c:	89 d8                	mov    %ebx,%eax
  80663e:	e8 1d ec ff ff       	call   805260 <dhcp_set_state>
}
  806643:	83 c4 2c             	add    $0x2c,%esp
  806646:	5b                   	pop    %ebx
  806647:	5e                   	pop    %esi
  806648:	5f                   	pop    %edi
  806649:	5d                   	pop    %ebp
  80664a:	c3                   	ret    
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  80664b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  806652:	e9 39 ff ff ff       	jmp    806590 <dhcp_bind+0xc9>
    } else {
      sn_mask.addr = htonl(0xffff0000);
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  806657:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80665e:	66 90                	xchg   %ax,%ax
  806660:	eb 86                	jmp    8065e8 <dhcp_bind+0x121>

00806662 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  806662:	55                   	push   %ebp
  806663:	89 e5                	mov    %esp,%ebp
  806665:	57                   	push   %edi
  806666:	56                   	push   %esi
  806667:	53                   	push   %ebx
  806668:	83 ec 2c             	sub    $0x2c,%esp
  struct netif *netif = (struct netif *)arg;
  80666b:	8b 45 08             	mov    0x8(%ebp),%eax
  80666e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  struct dhcp *dhcp = netif->dhcp;
  806671:	8b 50 20             	mov    0x20(%eax),%edx
  806674:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  806677:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80667a:	8b 71 04             	mov    0x4(%ecx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  80667d:	89 4a 0c             	mov    %ecx,0xc(%edx)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  806680:	80 3e 02             	cmpb   $0x2,(%esi)
  806683:	0f 85 33 04 00 00    	jne    806abc <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  806689:	0f b6 78 24          	movzbl 0x24(%eax),%edi
  80668d:	89 fb                	mov    %edi,%ebx
  80668f:	84 db                	test   %bl,%bl
  806691:	74 35                	je     8066c8 <dhcp_recv+0x66>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  806693:	0f b6 48 25          	movzbl 0x25(%eax),%ecx
  806697:	89 c2                	mov    %eax,%edx
  806699:	b8 00 00 00 00       	mov    $0x0,%eax
  80669e:	3a 4e 1c             	cmp    0x1c(%esi),%cl
  8066a1:	74 1c                	je     8066bf <dhcp_recv+0x5d>
  8066a3:	e9 14 04 00 00       	jmp    806abc <dhcp_recv+0x45a>
  8066a8:	0f b6 5a 26          	movzbl 0x26(%edx),%ebx
  8066ac:	0f b6 4c 06 1d       	movzbl 0x1d(%esi,%eax,1),%ecx
  8066b1:	83 c0 01             	add    $0x1,%eax
  8066b4:	83 c2 01             	add    $0x1,%edx
  8066b7:	38 cb                	cmp    %cl,%bl
  8066b9:	0f 85 fd 03 00 00    	jne    806abc <dhcp_recv+0x45a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  8066bf:	8d 48 01             	lea    0x1(%eax),%ecx
  8066c2:	89 fb                	mov    %edi,%ebx
  8066c4:	38 cb                	cmp    %cl,%bl
  8066c6:	77 e0                	ja     8066a8 <dhcp_recv+0x46>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  8066c8:	8b 46 04             	mov    0x4(%esi),%eax
  8066cb:	89 04 24             	mov    %eax,(%esp)
  8066ce:	e8 f2 42 00 00       	call   80a9c5 <ntohl>
  8066d3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8066d6:	3b 42 04             	cmp    0x4(%edx),%eax
  8066d9:	0f 85 dd 03 00 00    	jne    806abc <dhcp_recv+0x45a>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  8066df:	85 d2                	test   %edx,%edx
  8066e1:	75 1c                	jne    8066ff <dhcp_recv+0x9d>
  8066e3:	c7 44 24 08 54 2f 81 	movl   $0x812f54,0x8(%esp)
  8066ea:	00 
  8066eb:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  8066f2:	00 
  8066f3:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8066fa:	e8 15 a2 ff ff       	call   800914 <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8066ff:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806702:	83 79 0c 00          	cmpl   $0x0,0xc(%ecx)
  806706:	75 1c                	jne    806724 <dhcp_recv+0xc2>
  806708:	c7 44 24 08 61 2f 81 	movl   $0x812f61,0x8(%esp)
  80670f:	00 
  806710:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  806717:	00 
  806718:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  80671f:	e8 f0 a1 ff ff       	call   800914 <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  806724:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806727:	e8 e4 ef ff ff       	call   805710 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  80672c:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80672f:	8b 43 0c             	mov    0xc(%ebx),%eax
  806732:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  806736:	66 3d f0 00          	cmp    $0xf0,%ax
  80673a:	76 1e                	jbe    80675a <dhcp_recv+0xf8>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80673c:	66 2d f0 00          	sub    $0xf0,%ax
  806740:	66 89 43 18          	mov    %ax,0x18(%ebx)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  806744:	0f b7 c0             	movzwl %ax,%eax
  806747:	89 04 24             	mov    %eax,(%esp)
  80674a:	e8 a1 04 00 00       	call   806bf0 <mem_malloc>
  80674f:	89 43 14             	mov    %eax,0x14(%ebx)
    if (dhcp->options_in == NULL) {
  806752:	85 c0                	test   %eax,%eax
  806754:	0f 84 62 03 00 00    	je     806abc <dhcp_recv+0x45a>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80675a:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  806761:	e8 8a 04 00 00       	call   806bf0 <mem_malloc>
  806766:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806769:	89 42 10             	mov    %eax,0x10(%edx)
  if (dhcp->msg_in == NULL) {
  80676c:	85 c0                	test   %eax,%eax
  80676e:	75 1a                	jne    80678a <dhcp_recv+0x128>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  806770:	8b 42 14             	mov    0x14(%edx),%eax
  806773:	89 04 24             	mov    %eax,(%esp)
  806776:	e8 0a 08 00 00       	call   806f85 <mem_free>
    dhcp->options_in = NULL;
  80677b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80677e:	c7 41 14 00 00 00 00 	movl   $0x0,0x14(%ecx)
  806785:	e9 32 03 00 00       	jmp    806abc <dhcp_recv+0x45a>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80678a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  806791:	00 
  806792:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  806799:	00 
  80679a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80679e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8067a1:	8b 43 0c             	mov    0xc(%ebx),%eax
  8067a4:	89 04 24             	mov    %eax,(%esp)
  8067a7:	e8 6a 0f 00 00       	call   807716 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8067ac:	66 3d f0 00          	cmp    $0xf0,%ax
  8067b0:	74 1c                	je     8067ce <dhcp_recv+0x16c>
  8067b2:	c7 44 24 08 d0 2e 81 	movl   $0x812ed0,0x8(%esp)
  8067b9:	00 
  8067ba:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  8067c1:	00 
  8067c2:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  8067c9:	e8 46 a1 ff ff       	call   800914 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  8067ce:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8067d1:	8b 42 14             	mov    0x14(%edx),%eax
  8067d4:	85 c0                	test   %eax,%eax
  8067d6:	0f 84 fd 02 00 00    	je     806ad9 <dhcp_recv+0x477>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8067dc:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  8067e3:	00 
  8067e4:	89 d1                	mov    %edx,%ecx
  8067e6:	0f b7 52 18          	movzwl 0x18(%edx),%edx
  8067ea:	89 54 24 08          	mov    %edx,0x8(%esp)
  8067ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  8067f2:	8b 41 0c             	mov    0xc(%ecx),%eax
  8067f5:	89 04 24             	mov    %eax,(%esp)
  8067f8:	e8 19 0f 00 00       	call   807716 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8067fd:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806800:	66 3b 43 18          	cmp    0x18(%ebx),%ax
  806804:	0f 84 cf 02 00 00    	je     806ad9 <dhcp_recv+0x477>
  80680a:	c7 44 24 08 71 2f 81 	movl   $0x812f71,0x8(%esp)
  806811:	00 
  806812:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  806819:	00 
  80681a:	c7 04 24 02 2f 81 00 	movl   $0x812f02,(%esp)
  806821:	e8 ee a0 ff ff       	call   800914 <_panic>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  806826:	83 c0 02             	add    $0x2,%eax
  806829:	e8 4d eb ff ff       	call   80537b <dhcp_get_option_byte>
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  80682e:	3c 05                	cmp    $0x5,%al
  806830:	0f 85 a5 01 00 00    	jne    8069db <dhcp_recv+0x379>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  806836:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806839:	0f b6 02             	movzbl (%edx),%eax
  80683c:	3c 01                	cmp    $0x1,%al
  80683e:	0f 85 76 01 00 00    	jne    8069ba <dhcp_recv+0x358>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806844:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806847:	8b 59 20             	mov    0x20(%ecx),%ebx
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  80684a:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  dhcp->offered_gw_addr.addr = 0;
  806851:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_bc_addr.addr = 0;
  806858:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  80685f:	ba 33 00 00 00       	mov    $0x33,%edx
  806864:	89 d8                	mov    %ebx,%eax
  806866:	e8 04 ea ff ff       	call   80526f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  80686b:	85 c0                	test   %eax,%eax
  80686d:	74 0b                	je     80687a <dhcp_recv+0x218>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  80686f:	83 c0 02             	add    $0x2,%eax
  806872:	e8 0c eb ff ff       	call   805383 <dhcp_get_option_long>
  806877:	89 43 4c             	mov    %eax,0x4c(%ebx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  80687a:	ba 3a 00 00 00       	mov    $0x3a,%edx
  80687f:	89 d8                	mov    %ebx,%eax
  806881:	e8 e9 e9 ff ff       	call   80526f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806886:	85 c0                	test   %eax,%eax
  806888:	74 0d                	je     806897 <dhcp_recv+0x235>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  80688a:	83 c0 02             	add    $0x2,%eax
  80688d:	e8 f1 ea ff ff       	call   805383 <dhcp_get_option_long>
  806892:	89 43 50             	mov    %eax,0x50(%ebx)
  806895:	eb 08                	jmp    80689f <dhcp_recv+0x23d>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  806897:	8b 43 4c             	mov    0x4c(%ebx),%eax
  80689a:	d1 e8                	shr    %eax
  80689c:	89 43 50             	mov    %eax,0x50(%ebx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  80689f:	ba 3b 00 00 00       	mov    $0x3b,%edx
  8068a4:	89 d8                	mov    %ebx,%eax
  8068a6:	e8 c4 e9 ff ff       	call   80526f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  8068ab:	85 c0                	test   %eax,%eax
  8068ad:	74 0d                	je     8068bc <dhcp_recv+0x25a>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  8068af:	83 c0 02             	add    $0x2,%eax
  8068b2:	e8 cc ea ff ff       	call   805383 <dhcp_get_option_long>
  8068b7:	89 43 54             	mov    %eax,0x54(%ebx)
  8068ba:	eb 06                	jmp    8068c2 <dhcp_recv+0x260>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  8068bc:	8b 43 4c             	mov    0x4c(%ebx),%eax
  8068bf:	89 43 54             	mov    %eax,0x54(%ebx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  8068c2:	8b 53 10             	mov    0x10(%ebx),%edx
  8068c5:	b8 00 00 00 00       	mov    $0x0,%eax
  8068ca:	83 fa f0             	cmp    $0xfffffff0,%edx
  8068cd:	74 03                	je     8068d2 <dhcp_recv+0x270>
  8068cf:	8b 42 10             	mov    0x10(%edx),%eax
  8068d2:	89 43 30             	mov    %eax,0x30(%ebx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  8068d5:	ba 01 00 00 00       	mov    $0x1,%edx
  8068da:	89 d8                	mov    %ebx,%eax
  8068dc:	e8 8e e9 ff ff       	call   80526f <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  8068e1:	85 c0                	test   %eax,%eax
  8068e3:	74 13                	je     8068f8 <dhcp_recv+0x296>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  8068e5:	83 c0 02             	add    $0x2,%eax
  8068e8:	e8 96 ea ff ff       	call   805383 <dhcp_get_option_long>
  8068ed:	89 04 24             	mov    %eax,(%esp)
  8068f0:	e8 af 3e 00 00       	call   80a7a4 <htonl>
  8068f5:	89 43 34             	mov    %eax,0x34(%ebx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  8068f8:	ba 03 00 00 00       	mov    $0x3,%edx
  8068fd:	89 d8                	mov    %ebx,%eax
  8068ff:	e8 6b e9 ff ff       	call   80526f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806904:	85 c0                	test   %eax,%eax
  806906:	74 13                	je     80691b <dhcp_recv+0x2b9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806908:	83 c0 02             	add    $0x2,%eax
  80690b:	e8 73 ea ff ff       	call   805383 <dhcp_get_option_long>
  806910:	89 04 24             	mov    %eax,(%esp)
  806913:	e8 8c 3e 00 00       	call   80a7a4 <htonl>
  806918:	89 43 38             	mov    %eax,0x38(%ebx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  80691b:	ba 1c 00 00 00       	mov    $0x1c,%edx
  806920:	89 d8                	mov    %ebx,%eax
  806922:	e8 48 e9 ff ff       	call   80526f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806927:	85 c0                	test   %eax,%eax
  806929:	74 13                	je     80693e <dhcp_recv+0x2dc>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80692b:	83 c0 02             	add    $0x2,%eax
  80692e:	e8 50 ea ff ff       	call   805383 <dhcp_get_option_long>
  806933:	89 04 24             	mov    %eax,(%esp)
  806936:	e8 69 3e 00 00       	call   80a7a4 <htonl>
  80693b:	89 43 3c             	mov    %eax,0x3c(%ebx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  80693e:	ba 06 00 00 00       	mov    $0x6,%edx
  806943:	89 d8                	mov    %ebx,%eax
  806945:	e8 25 e9 ff ff       	call   80526f <dhcp_get_option_ptr>
  80694a:	89 c6                	mov    %eax,%esi
  if (option_ptr != NULL) {
  80694c:	85 c0                	test   %eax,%eax
  80694e:	74 54                	je     8069a4 <dhcp_recv+0x342>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  806950:	8d 40 01             	lea    0x1(%eax),%eax
  806953:	e8 23 ea ff ff       	call   80537b <dhcp_get_option_byte>
  806958:	c0 e8 02             	shr    $0x2,%al
  80695b:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  80695e:	83 f8 03             	cmp    $0x3,%eax
  806961:	ba 02 00 00 00       	mov    $0x2,%edx
  806966:	0f 43 c2             	cmovae %edx,%eax
  806969:	89 43 40             	mov    %eax,0x40(%ebx)
  80696c:	bf 00 00 00 00       	mov    $0x0,%edi
  806971:	89 f8                	mov    %edi,%eax
  806973:	89 f7                	mov    %esi,%edi
  806975:	89 de                	mov    %ebx,%esi
  806977:	89 c3                	mov    %eax,%ebx
  806979:	eb 21                	jmp    80699c <dhcp_recv+0x33a>
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  80697b:	0f b6 c3             	movzbl %bl,%eax
  80697e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806981:	8d 44 87 02          	lea    0x2(%edi,%eax,4),%eax
  806985:	e8 f9 e9 ff ff       	call   805383 <dhcp_get_option_long>
  80698a:	89 04 24             	mov    %eax,(%esp)
  80698d:	e8 12 3e 00 00       	call   80a7a4 <htonl>
  806992:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806995:	89 44 96 44          	mov    %eax,0x44(%esi,%edx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  806999:	83 c3 01             	add    $0x1,%ebx
  80699c:	0f b6 c3             	movzbl %bl,%eax
  80699f:	3b 46 40             	cmp    0x40(%esi),%eax
  8069a2:	72 d7                	jb     80697b <dhcp_recv+0x319>
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  8069a4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8069a7:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  8069ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8069b0:	e8 d5 fa ff ff       	call   80648a <dhcp_check>
  8069b5:	e9 02 01 00 00       	jmp    806abc <dhcp_recv+0x45a>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  8069ba:	83 e8 03             	sub    $0x3,%eax
  8069bd:	3c 02                	cmp    $0x2,%al
  8069bf:	0f 87 f7 00 00 00    	ja     806abc <dhcp_recv+0x45a>
      dhcp->request_timeout = 0;
  8069c5:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8069c8:	66 c7 43 26 00 00    	movw   $0x0,0x26(%ebx)
      dhcp_bind(netif);
  8069ce:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8069d1:	e8 f1 fa ff ff       	call   8064c7 <dhcp_bind>
  8069d6:	e9 e1 00 00 00       	jmp    806abc <dhcp_recv+0x45a>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  8069db:	3c 06                	cmp    $0x6,%al
  8069dd:	0f 85 80 00 00 00    	jne    806a63 <dhcp_recv+0x401>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  8069e3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8069e6:	0f b6 02             	movzbl (%edx),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  8069e9:	3c 03                	cmp    $0x3,%al
  8069eb:	74 10                	je     8069fd <dhcp_recv+0x39b>
  8069ed:	3c 01                	cmp    $0x1,%al
  8069ef:	74 0c                	je     8069fd <dhcp_recv+0x39b>
  8069f1:	3c 04                	cmp    $0x4,%al
  8069f3:	74 08                	je     8069fd <dhcp_recv+0x39b>
  8069f5:	3c 05                	cmp    $0x5,%al
  8069f7:	0f 85 bf 00 00 00    	jne    806abc <dhcp_recv+0x45a>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  8069fd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806a00:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806a06:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806a09:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  806a0c:	89 04 24             	mov    %eax,(%esp)
  806a0f:	e8 74 09 00 00       	call   807388 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  806a14:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  806a1b:	00 
  806a1c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806a1f:	89 14 24             	mov    %edx,(%esp)
  806a22:	e8 bd 09 00 00       	call   8073e4 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  806a27:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  806a2e:	00 
  806a2f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806a32:	89 0c 24             	mov    %ecx,(%esp)
  806a35:	e8 b5 08 00 00       	call   8072ef <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  806a3a:	c7 44 24 04 e4 37 81 	movl   $0x8137e4,0x4(%esp)
  806a41:	00 
  806a42:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806a45:	89 04 24             	mov    %eax,(%esp)
  806a48:	e8 bb 08 00 00       	call   807308 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  806a4d:	ba 0c 00 00 00       	mov    $0xc,%edx
  806a52:	89 d8                	mov    %ebx,%eax
  806a54:	e8 07 e8 ff ff       	call   805260 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  806a59:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806a5c:	e8 e7 f1 ff ff       	call   805c48 <dhcp_discover>
  806a61:	eb 59                	jmp    806abc <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  806a63:	3c 02                	cmp    $0x2,%al
  806a65:	75 55                	jne    806abc <dhcp_recv+0x45a>
  806a67:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806a6a:	80 3a 06             	cmpb   $0x6,(%edx)
  806a6d:	8d 76 00             	lea    0x0(%esi),%esi
  806a70:	75 4a                	jne    806abc <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  806a72:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806a78:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806a7b:	8b 59 20             	mov    0x20(%ecx),%ebx
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  806a7e:	ba 36 00 00 00       	mov    $0x36,%edx
  806a83:	89 d8                	mov    %ebx,%eax
  806a85:	e8 e5 e7 ff ff       	call   80526f <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  806a8a:	85 c0                	test   %eax,%eax
  806a8c:	74 2e                	je     806abc <dhcp_recv+0x45a>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806a8e:	83 c0 02             	add    $0x2,%eax
  806a91:	e8 ed e8 ff ff       	call   805383 <dhcp_get_option_long>
  806a96:	89 04 24             	mov    %eax,(%esp)
  806a99:	e8 06 3d 00 00       	call   80a7a4 <htonl>
  806a9e:	89 43 2c             	mov    %eax,0x2c(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  806aa1:	8b 53 10             	mov    0x10(%ebx),%edx
  806aa4:	b8 00 00 00 00       	mov    $0x0,%eax
  806aa9:	83 fa f0             	cmp    $0xfffffff0,%edx
  806aac:	74 03                	je     806ab1 <dhcp_recv+0x44f>
  806aae:	8b 42 10             	mov    0x10(%edx),%eax
  806ab1:	89 43 30             	mov    %eax,0x30(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  806ab4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806ab7:	e8 c3 f5 ff ff       	call   80607f <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  806abc:	8b 5d 10             	mov    0x10(%ebp),%ebx
  806abf:	89 1c 24             	mov    %ebx,(%esp)
  806ac2:	e8 c6 0e 00 00       	call   80798d <pbuf_free>
  dhcp->p = NULL;
  806ac7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806aca:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
  806ad1:	83 c4 2c             	add    $0x2c,%esp
  806ad4:	5b                   	pop    %ebx
  806ad5:	5e                   	pop    %esi
  806ad6:	5f                   	pop    %edi
  806ad7:	5d                   	pop    %ebp
  806ad8:	c3                   	ret    
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  806ad9:	ba 35 00 00 00       	mov    $0x35,%edx
  806ade:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806ae1:	e8 89 e7 ff ff       	call   80526f <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  806ae6:	85 c0                	test   %eax,%eax
  806ae8:	0f 85 38 fd ff ff    	jne    806826 <dhcp_recv+0x1c4>
  806aee:	66 90                	xchg   %ax,%ax
  806af0:	eb ca                	jmp    806abc <dhcp_recv+0x45a>

00806af2 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  806af2:	55                   	push   %ebp
  806af3:	89 e5                	mov    %esp,%ebp
  806af5:	53                   	push   %ebx
  806af6:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  806af9:	8b 1d 04 f0 b3 00    	mov    0xb3f004,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  806aff:	85 db                	test   %ebx,%ebx
  806b01:	0f 84 dd 00 00 00    	je     806be4 <dhcp_fine_tmr+0xf2>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  806b07:	8b 43 20             	mov    0x20(%ebx),%eax
  806b0a:	85 c0                	test   %eax,%eax
  806b0c:	0f 84 c8 00 00 00    	je     806bda <dhcp_fine_tmr+0xe8>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  806b12:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  806b16:	66 83 fa 01          	cmp    $0x1,%dx
  806b1a:	76 0c                	jbe    806b28 <dhcp_fine_tmr+0x36>
        netif->dhcp->request_timeout--;
  806b1c:	83 ea 01             	sub    $0x1,%edx
  806b1f:	66 89 50 26          	mov    %dx,0x26(%eax)
  806b23:	e9 b2 00 00 00       	jmp    806bda <dhcp_fine_tmr+0xe8>
      }
      else if (netif->dhcp->request_timeout == 1) {
  806b28:	66 83 fa 01          	cmp    $0x1,%dx
  806b2c:	0f 85 a8 00 00 00    	jne    806bda <dhcp_fine_tmr+0xe8>
        netif->dhcp->request_timeout--;
  806b32:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806b38:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  806b3b:	0f b6 02             	movzbl (%edx),%eax
  806b3e:	3c 0c                	cmp    $0xc,%al
  806b40:	74 04                	je     806b46 <dhcp_fine_tmr+0x54>
  806b42:	3c 06                	cmp    $0x6,%al
  806b44:	75 0f                	jne    806b55 <dhcp_fine_tmr+0x63>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  806b46:	89 d8                	mov    %ebx,%eax
  806b48:	e8 fb f0 ff ff       	call   805c48 <dhcp_discover>
  806b4d:	8d 76 00             	lea    0x0(%esi),%esi
  806b50:	e9 85 00 00 00       	jmp    806bda <dhcp_fine_tmr+0xe8>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  806b55:	3c 01                	cmp    $0x1,%al
  806b57:	75 23                	jne    806b7c <dhcp_fine_tmr+0x8a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  806b59:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  806b5d:	8d 76 00             	lea    0x0(%esi),%esi
  806b60:	77 09                	ja     806b6b <dhcp_fine_tmr+0x79>
      dhcp_select(netif);
  806b62:	89 d8                	mov    %ebx,%eax
  806b64:	e8 16 f5 ff ff       	call   80607f <dhcp_select>
  806b69:	eb 6f                	jmp    806bda <dhcp_fine_tmr+0xe8>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  806b6b:	89 1c 24             	mov    %ebx,(%esp)
  806b6e:	e8 52 ee ff ff       	call   8059c5 <dhcp_release>
      dhcp_discover(netif);
  806b73:	89 d8                	mov    %ebx,%eax
  806b75:	e8 ce f0 ff ff       	call   805c48 <dhcp_discover>
  806b7a:	eb 5e                	jmp    806bda <dhcp_fine_tmr+0xe8>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  806b7c:	3c 08                	cmp    $0x8,%al
  806b7e:	66 90                	xchg   %ax,%ax
  806b80:	75 20                	jne    806ba2 <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  806b82:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  806b86:	66 90                	xchg   %ax,%ax
  806b88:	77 0d                	ja     806b97 <dhcp_fine_tmr+0xa5>
      dhcp_check(netif);
  806b8a:	89 d8                	mov    %ebx,%eax
  806b8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  806b90:	e8 f5 f8 ff ff       	call   80648a <dhcp_check>
  806b95:	eb 43                	jmp    806bda <dhcp_fine_tmr+0xe8>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  806b97:	89 d8                	mov    %ebx,%eax
  806b99:	e8 29 f9 ff ff       	call   8064c7 <dhcp_bind>
  806b9e:	66 90                	xchg   %ax,%ax
  806ba0:	eb 38                	jmp    806bda <dhcp_fine_tmr+0xe8>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  806ba2:	3c 05                	cmp    $0x5,%al
  806ba4:	75 11                	jne    806bb7 <dhcp_fine_tmr+0xc5>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  806ba6:	89 1c 24             	mov    %ebx,(%esp)
  806ba9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  806bb0:	e8 79 ef ff ff       	call   805b2e <dhcp_renew>
  806bb5:	eb 23                	jmp    806bda <dhcp_fine_tmr+0xe8>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  806bb7:	3c 04                	cmp    $0x4,%al
  806bb9:	75 1f                	jne    806bda <dhcp_fine_tmr+0xe8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  806bbb:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  806bbf:	90                   	nop
  806bc0:	77 09                	ja     806bcb <dhcp_fine_tmr+0xd9>
      dhcp_rebind(netif);
  806bc2:	89 d8                	mov    %ebx,%eax
  806bc4:	e8 d8 f1 ff ff       	call   805da1 <dhcp_rebind>
  806bc9:	eb 0f                	jmp    806bda <dhcp_fine_tmr+0xe8>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  806bcb:	89 1c 24             	mov    %ebx,(%esp)
  806bce:	e8 f2 ed ff ff       	call   8059c5 <dhcp_release>
      dhcp_discover(netif);
  806bd3:	89 d8                	mov    %ebx,%eax
  806bd5:	e8 6e f0 ff ff       	call   805c48 <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  806bda:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  806bdc:	85 db                	test   %ebx,%ebx
  806bde:	0f 85 23 ff ff ff    	jne    806b07 <dhcp_fine_tmr+0x15>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  806be4:	83 c4 14             	add    $0x14,%esp
  806be7:	5b                   	pop    %ebx
  806be8:	5d                   	pop    %ebp
  806be9:	c3                   	ret    
  806bea:	00 00                	add    %al,(%eax)
  806bec:	00 00                	add    %al,(%eax)
	...

00806bf0 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  806bf0:	55                   	push   %ebp
  806bf1:	89 e5                	mov    %esp,%ebp
  806bf3:	83 ec 38             	sub    $0x38,%esp
  806bf6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806bf9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806bfc:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806bff:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  806c02:	85 c0                	test   %eax,%eax
  806c04:	0f 84 be 01 00 00    	je     806dc8 <mem_malloc+0x1d8>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  806c0a:	83 c0 03             	add    $0x3,%eax
  806c0d:	83 e0 fc             	and    $0xfffffffc,%eax
  806c10:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(size < MIN_SIZE_ALIGNED) {
  806c13:	83 f8 0b             	cmp    $0xb,%eax
  806c16:	77 09                	ja     806c21 <mem_malloc+0x31>
  806c18:	c7 45 e4 0c 00 00 00 	movl   $0xc,-0x1c(%ebp)
  806c1f:	eb 0d                	jmp    806c2e <mem_malloc+0x3e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  806c21:	81 7d e4 00 00 22 00 	cmpl   $0x220000,-0x1c(%ebp)
  806c28:	0f 87 9a 01 00 00    	ja     806dc8 <mem_malloc+0x1d8>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  806c2e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806c35:	00 
  806c36:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806c3b:	89 04 24             	mov    %eax,(%esp)
  806c3e:	e8 43 67 00 00       	call   80d386 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  806c43:	a1 64 63 a3 00       	mov    0xa36364,%eax
  806c48:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806c4b:	8b 15 5c 63 a3 00    	mov    0xa3635c,%edx
  806c51:	29 d0                	sub    %edx,%eax
  806c53:	b9 00 00 22 00       	mov    $0x220000,%ecx
  806c58:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
  806c5b:	39 c8                	cmp    %ecx,%eax
  806c5d:	0f 83 51 01 00 00    	jae    806db4 <mem_malloc+0x1c4>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  806c63:	89 55 e0             	mov    %edx,-0x20(%ebp)
  806c66:	8b 75 e0             	mov    -0x20(%ebp),%esi
  806c69:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  806c6c:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  806c70:	0f 85 34 01 00 00    	jne    806daa <mem_malloc+0x1ba>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  806c76:	8b 3b                	mov    (%ebx),%edi
  806c78:	83 ef 0c             	sub    $0xc,%edi
  806c7b:	29 c7                	sub    %eax,%edi
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  806c7d:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  806c80:	0f 87 24 01 00 00    	ja     806daa <mem_malloc+0x1ba>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  806c86:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806c89:	83 c2 18             	add    $0x18,%edx
  806c8c:	39 d7                	cmp    %edx,%edi
  806c8e:	72 2a                	jb     806cba <mem_malloc+0xca>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  806c90:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806c93:	8d 4c 02 0c          	lea    0xc(%edx,%eax,1),%ecx
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  806c97:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  806c9a:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  806c9e:	8b 3b                	mov    (%ebx),%edi
  806ca0:	89 3a                	mov    %edi,(%edx)
          mem2->prev = ptr;
  806ca2:	89 42 04             	mov    %eax,0x4(%edx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  806ca5:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  806ca7:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  806cab:	8b 02                	mov    (%edx),%eax
  806cad:	3d 00 00 22 00       	cmp    $0x220000,%eax
  806cb2:	74 0a                	je     806cbe <mem_malloc+0xce>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  806cb4:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  806cb8:	eb 04                	jmp    806cbe <mem_malloc+0xce>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  806cba:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  806cbe:	39 5d dc             	cmp    %ebx,-0x24(%ebp)
  806cc1:	75 67                	jne    806d2a <mem_malloc+0x13a>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  806cc3:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  806cc6:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  806cca:	84 c0                	test   %al,%al
  806ccc:	74 31                	je     806cff <mem_malloc+0x10f>
  806cce:	8b 15 60 63 a3 00    	mov    0xa36360,%edx
  806cd4:	39 d1                	cmp    %edx,%ecx
  806cd6:	74 52                	je     806d2a <mem_malloc+0x13a>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  806cd8:	8b 09                	mov    (%ecx),%ecx
  806cda:	8d 0c 0e             	lea    (%esi,%ecx,1),%ecx
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  806cdd:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  806ce1:	84 c0                	test   %al,%al
  806ce3:	75 0b                	jne    806cf0 <mem_malloc+0x100>
  806ce5:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  806ce8:	89 0d 64 63 a3 00    	mov    %ecx,0xa36364
  806cee:	eb 0f                	jmp    806cff <mem_malloc+0x10f>
  806cf0:	39 d1                	cmp    %edx,%ecx
  806cf2:	75 e4                	jne    806cd8 <mem_malloc+0xe8>
  806cf4:	89 4d dc             	mov    %ecx,-0x24(%ebp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
  806cf7:	89 0d 64 63 a3 00    	mov    %ecx,0xa36364
  806cfd:	eb 2b                	jmp    806d2a <mem_malloc+0x13a>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  806cff:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806d02:	3b 15 60 63 a3 00    	cmp    0xa36360,%edx
  806d08:	74 20                	je     806d2a <mem_malloc+0x13a>
  806d0a:	84 c0                	test   %al,%al
  806d0c:	74 1c                	je     806d2a <mem_malloc+0x13a>
  806d0e:	c7 44 24 08 8d 2f 81 	movl   $0x812f8d,0x8(%esp)
  806d15:	00 
  806d16:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
  806d1d:	00 
  806d1e:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806d25:	e8 ea 9b ff ff       	call   800914 <_panic>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  806d2a:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806d2f:	89 04 24             	mov    %eax,(%esp)
  806d32:	e8 40 69 00 00       	call   80d677 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  806d37:	89 d8                	mov    %ebx,%eax
  806d39:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806d3c:	8d 54 19 0c          	lea    0xc(%ecx,%ebx,1),%edx
  806d40:	3b 15 60 63 a3 00    	cmp    0xa36360,%edx
  806d46:	76 1c                	jbe    806d64 <mem_malloc+0x174>
  806d48:	c7 44 24 08 30 30 81 	movl   $0x813030,0x8(%esp)
  806d4f:	00 
  806d50:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  806d57:	00 
  806d58:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806d5f:	e8 b0 9b ff ff       	call   800914 <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  806d64:	f6 c3 03             	test   $0x3,%bl
  806d67:	74 1c                	je     806d85 <mem_malloc+0x195>
  806d69:	c7 44 24 08 60 30 81 	movl   $0x813060,0x8(%esp)
  806d70:	00 
  806d71:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  806d78:	00 
  806d79:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806d80:	e8 8f 9b ff ff       	call   800914 <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  806d85:	a8 03                	test   $0x3,%al
  806d87:	74 1c                	je     806da5 <mem_malloc+0x1b5>
  806d89:	c7 44 24 08 90 30 81 	movl   $0x813090,0x8(%esp)
  806d90:	00 
  806d91:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  806d98:	00 
  806d99:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806da0:	e8 6f 9b ff ff       	call   800914 <_panic>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  806da5:	8d 43 0c             	lea    0xc(%ebx),%eax
  806da8:	eb 23                	jmp    806dcd <mem_malloc+0x1dd>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  806daa:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  806dac:	39 c1                	cmp    %eax,%ecx
  806dae:	0f 87 b2 fe ff ff    	ja     806c66 <mem_malloc+0x76>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  806db4:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806db9:	89 04 24             	mov    %eax,(%esp)
  806dbc:	e8 b6 68 00 00       	call   80d677 <sys_sem_signal>
  806dc1:	b8 00 00 00 00       	mov    $0x0,%eax
  return NULL;
  806dc6:	eb 05                	jmp    806dcd <mem_malloc+0x1dd>
  806dc8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806dcd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  806dd0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806dd3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806dd6:	89 ec                	mov    %ebp,%esp
  806dd8:	5d                   	pop    %ebp
  806dd9:	c3                   	ret    

00806dda <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  806dda:	55                   	push   %ebp
  806ddb:	89 e5                	mov    %esp,%ebp
  806ddd:	83 ec 18             	sub    $0x18,%esp
  806de0:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  806de3:	89 75 fc             	mov    %esi,-0x4(%ebp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  806de6:	8b 75 0c             	mov    0xc(%ebp),%esi
  806de9:	0f af 75 08          	imul   0x8(%ebp),%esi
  806ded:	89 34 24             	mov    %esi,(%esp)
  806df0:	e8 fb fd ff ff       	call   806bf0 <mem_malloc>
  806df5:	89 c3                	mov    %eax,%ebx
  if (p) {
  806df7:	85 c0                	test   %eax,%eax
  806df9:	74 14                	je     806e0f <mem_calloc+0x35>
    /* zero the memory */
    memset(p, 0, count * size);
  806dfb:	89 74 24 08          	mov    %esi,0x8(%esp)
  806dff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806e06:	00 
  806e07:	89 04 24             	mov    %eax,(%esp)
  806e0a:	e8 87 a4 ff ff       	call   801296 <memset>
  }
  return p;
}
  806e0f:	89 d8                	mov    %ebx,%eax
  806e11:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  806e14:	8b 75 fc             	mov    -0x4(%ebp),%esi
  806e17:	89 ec                	mov    %ebp,%esp
  806e19:	5d                   	pop    %ebp
  806e1a:	c3                   	ret    

00806e1b <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  806e1b:	55                   	push   %ebp
  806e1c:	89 e5                	mov    %esp,%ebp
  806e1e:	83 ec 38             	sub    $0x38,%esp
  806e21:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806e24:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806e27:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806e2a:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  806e2d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  806e30:	83 c3 03             	add    $0x3,%ebx
  806e33:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  806e36:	83 fb 0b             	cmp    $0xb,%ebx
  806e39:	77 07                	ja     806e42 <mem_realloc+0x27>
  806e3b:	bb 0c 00 00 00       	mov    $0xc,%ebx
  806e40:	eb 13                	jmp    806e55 <mem_realloc+0x3a>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  806e42:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  806e48:	76 0b                	jbe    806e55 <mem_realloc+0x3a>
  806e4a:	be 00 00 00 00       	mov    $0x0,%esi
  806e4f:	90                   	nop
  806e50:	e9 21 01 00 00       	jmp    806f76 <mem_realloc+0x15b>
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  806e55:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  806e5a:	39 c6                	cmp    %eax,%esi
  806e5c:	72 08                	jb     806e66 <mem_realloc+0x4b>
  806e5e:	3b 35 60 63 a3 00    	cmp    0xa36360,%esi
  806e64:	72 1c                	jb     806e82 <mem_realloc+0x67>
  806e66:	c7 44 24 08 ba 2f 81 	movl   $0x812fba,0x8(%esp)
  806e6d:	00 
  806e6e:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  806e75:	00 
  806e76:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806e7d:	e8 92 9a ff ff       	call   800914 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  806e82:	8d 7e f4             	lea    -0xc(%esi),%edi
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  806e85:	89 fa                	mov    %edi,%edx
  806e87:	29 c2                	sub    %eax,%edx
  806e89:	89 55 e0             	mov    %edx,-0x20(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  806e8c:	8b 07                	mov    (%edi),%eax
  806e8e:	83 e8 0c             	sub    $0xc,%eax
  806e91:	29 d0                	sub    %edx,%eax
  806e93:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  806e96:	39 d8                	cmp    %ebx,%eax
  806e98:	73 1c                	jae    806eb6 <mem_realloc+0x9b>
  806e9a:	c7 44 24 08 b4 30 81 	movl   $0x8130b4,0x8(%esp)
  806ea1:	00 
  806ea2:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  806ea9:	00 
  806eaa:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806eb1:	e8 5e 9a ff ff       	call   800914 <_panic>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  806eb6:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
  806eb9:	0f 84 b7 00 00 00    	je     806f76 <mem_realloc+0x15b>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  806ebf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806ec6:	00 
  806ec7:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806ecc:	89 04 24             	mov    %eax,(%esp)
  806ecf:	e8 b2 64 00 00       	call   80d386 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  806ed4:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  806ed9:	89 c2                	mov    %eax,%edx
  806edb:	03 17                	add    (%edi),%edx
  if(mem2->used == 0) {
  806edd:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  806ee1:	75 41                	jne    806f24 <mem_realloc+0x109>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  806ee3:	8b 0a                	mov    (%edx),%ecx
  806ee5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  806ee8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806eeb:	8d 5c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ebx
    if (lfree == mem2) {
  806eef:	39 15 64 63 a3 00    	cmp    %edx,0xa36364
  806ef5:	75 09                	jne    806f00 <mem_realloc+0xe5>
      lfree = (struct mem *)&ram[ptr2];
  806ef7:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  806efa:	89 15 64 63 a3 00    	mov    %edx,0xa36364
    }
    mem2 = (struct mem *)&ram[ptr2];
  806f00:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  806f03:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  806f07:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806f0a:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  806f0c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806f0f:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  806f12:	89 1f                	mov    %ebx,(%edi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  806f14:	8b 12                	mov    (%edx),%edx
  806f16:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  806f1c:	74 4b                	je     806f69 <mem_realloc+0x14e>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  806f1e:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
  806f22:	eb 45                	jmp    806f69 <mem_realloc+0x14e>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  806f24:	8d 53 18             	lea    0x18(%ebx),%edx
  806f27:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  806f2a:	72 3d                	jb     806f69 <mem_realloc+0x14e>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  806f2c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806f2f:	8d 5c 13 0c          	lea    0xc(%ebx,%edx,1),%ebx
    mem2 = (struct mem *)&ram[ptr2];
  806f33:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    if (mem2 < lfree) {
      lfree = mem2;
  806f36:	3b 15 64 63 a3 00    	cmp    0xa36364,%edx
  806f3c:	8b 0d 64 63 a3 00    	mov    0xa36364,%ecx
  806f42:	0f 42 ca             	cmovb  %edx,%ecx
  806f45:	89 0d 64 63 a3 00    	mov    %ecx,0xa36364
    }
    mem2->used = 0;
  806f4b:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  806f4f:	8b 0f                	mov    (%edi),%ecx
  806f51:	89 0a                	mov    %ecx,(%edx)
    mem2->prev = ptr;
  806f53:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806f56:	89 4a 04             	mov    %ecx,0x4(%edx)
    mem->next = ptr2;
  806f59:	89 1f                	mov    %ebx,(%edi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  806f5b:	8b 12                	mov    (%edx),%edx
  806f5d:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  806f63:	74 04                	je     806f69 <mem_realloc+0x14e>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  806f65:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  806f69:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806f6e:	89 04 24             	mov    %eax,(%esp)
  806f71:	e8 01 67 00 00       	call   80d677 <sys_sem_signal>
  return rmem;
}
  806f76:	89 f0                	mov    %esi,%eax
  806f78:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  806f7b:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806f7e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806f81:	89 ec                	mov    %ebp,%esp
  806f83:	5d                   	pop    %ebp
  806f84:	c3                   	ret    

00806f85 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  806f85:	55                   	push   %ebp
  806f86:	89 e5                	mov    %esp,%ebp
  806f88:	83 ec 18             	sub    $0x18,%esp
  806f8b:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  806f8e:	89 75 fc             	mov    %esi,-0x4(%ebp)
  806f91:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  806f94:	85 db                	test   %ebx,%ebx
  806f96:	0f 84 7d 01 00 00    	je     807119 <mem_free+0x194>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  806f9c:	f6 c3 03             	test   $0x3,%bl
  806f9f:	74 1c                	je     806fbd <mem_free+0x38>
  806fa1:	c7 44 24 08 d8 30 81 	movl   $0x8130d8,0x8(%esp)
  806fa8:	00 
  806fa9:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  806fb0:	00 
  806fb1:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806fb8:	e8 57 99 ff ff       	call   800914 <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  806fbd:	3b 1d 5c 63 a3 00    	cmp    0xa3635c,%ebx
  806fc3:	72 08                	jb     806fcd <mem_free+0x48>
  806fc5:	3b 1d 60 63 a3 00    	cmp    0xa36360,%ebx
  806fcb:	72 1c                	jb     806fe9 <mem_free+0x64>
  806fcd:	c7 44 24 08 d4 2f 81 	movl   $0x812fd4,0x8(%esp)
  806fd4:	00 
  806fd5:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  806fdc:	00 
  806fdd:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  806fe4:	e8 2b 99 ff ff       	call   800914 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  806fe9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806ff0:	00 
  806ff1:	a1 68 63 a3 00       	mov    0xa36368,%eax
  806ff6:	89 04 24             	mov    %eax,(%esp)
  806ff9:	e8 88 63 00 00       	call   80d386 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  806ffe:	83 eb 0c             	sub    $0xc,%ebx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  807001:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  807005:	75 1c                	jne    807023 <mem_free+0x9e>
  807007:	c7 44 24 08 eb 2f 81 	movl   $0x812feb,0x8(%esp)
  80700e:	00 
  80700f:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  807016:	00 
  807017:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  80701e:	e8 f1 98 ff ff       	call   800914 <_panic>
  /* ... and is now unused. */
  mem->used = 0;
  807023:	c6 43 08 00          	movb   $0x0,0x8(%ebx)

  if (mem < lfree) {
  807027:	3b 1d 64 63 a3 00    	cmp    0xa36364,%ebx
  80702d:	73 06                	jae    807035 <mem_free+0xb0>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  80702f:	89 1d 64 63 a3 00    	mov    %ebx,0xa36364
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  807035:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  80703a:	39 c3                	cmp    %eax,%ebx
  80703c:	73 1c                	jae    80705a <mem_free+0xd5>
  80703e:	c7 44 24 08 ff 2f 81 	movl   $0x812fff,0x8(%esp)
  807045:	00 
  807046:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  80704d:	00 
  80704e:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  807055:	e8 ba 98 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80705a:	8b 35 60 63 a3 00    	mov    0xa36360,%esi
  807060:	39 f3                	cmp    %esi,%ebx
  807062:	72 1c                	jb     807080 <mem_free+0xfb>
  807064:	c7 44 24 08 16 30 81 	movl   $0x813016,0x8(%esp)
  80706b:	00 
  80706c:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  807073:	00 
  807074:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  80707b:	e8 94 98 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  807080:	8b 13                	mov    (%ebx),%edx
  807082:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  807088:	76 1c                	jbe    8070a6 <mem_free+0x121>
  80708a:	c7 44 24 08 fc 30 81 	movl   $0x8130fc,0x8(%esp)
  807091:	00 
  807092:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  807099:	00 
  80709a:	c7 04 24 a6 2f 81 00 	movl   $0x812fa6,(%esp)
  8070a1:	e8 6e 98 ff ff       	call   800914 <_panic>

  nmem = (struct mem *)&ram[mem->next];
  8070a6:	89 c1                	mov    %eax,%ecx
  8070a8:	8d 14 10             	lea    (%eax,%edx,1),%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  8070ab:	39 d3                	cmp    %edx,%ebx
  8070ad:	74 2d                	je     8070dc <mem_free+0x157>
  8070af:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8070b3:	75 27                	jne    8070dc <mem_free+0x157>
  8070b5:	39 d6                	cmp    %edx,%esi
  8070b7:	74 23                	je     8070dc <mem_free+0x157>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
      lfree = mem;
  8070b9:	3b 15 64 63 a3 00    	cmp    0xa36364,%edx
  8070bf:	8b 35 64 63 a3 00    	mov    0xa36364,%esi
  8070c5:	0f 44 f3             	cmove  %ebx,%esi
  8070c8:	89 35 64 63 a3 00    	mov    %esi,0xa36364
    }
    mem->next = nmem->next;
  8070ce:	8b 32                	mov    (%edx),%esi
  8070d0:	89 33                	mov    %esi,(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  8070d2:	8b 12                	mov    (%edx),%edx
  8070d4:	89 de                	mov    %ebx,%esi
  8070d6:	29 c6                	sub    %eax,%esi
  8070d8:	89 74 10 04          	mov    %esi,0x4(%eax,%edx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  8070dc:	89 ca                	mov    %ecx,%edx
  8070de:	03 53 04             	add    0x4(%ebx),%edx
  if (pmem != mem && pmem->used == 0) {
  8070e1:	39 d3                	cmp    %edx,%ebx
  8070e3:	74 27                	je     80710c <mem_free+0x187>
  8070e5:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8070e9:	75 21                	jne    80710c <mem_free+0x187>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
      lfree = pmem;
  8070eb:	3b 1d 64 63 a3 00    	cmp    0xa36364,%ebx
  8070f1:	8b 35 64 63 a3 00    	mov    0xa36364,%esi
  8070f7:	0f 44 f2             	cmove  %edx,%esi
  8070fa:	89 35 64 63 a3 00    	mov    %esi,0xa36364
    }
    pmem->next = mem->next;
  807100:	8b 33                	mov    (%ebx),%esi
  807102:	89 32                	mov    %esi,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  807104:	8b 1b                	mov    (%ebx),%ebx
  807106:	29 c2                	sub    %eax,%edx
  807108:	89 54 19 04          	mov    %edx,0x4(%ecx,%ebx,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80710c:	a1 68 63 a3 00       	mov    0xa36368,%eax
  807111:	89 04 24             	mov    %eax,(%esp)
  807114:	e8 5e 65 00 00       	call   80d677 <sys_sem_signal>
}
  807119:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80711c:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80711f:	89 ec                	mov    %ebp,%esp
  807121:	5d                   	pop    %ebp
  807122:	c3                   	ret    

00807123 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  807123:	55                   	push   %ebp
  807124:	89 e5                	mov    %esp,%ebp
  807126:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  807129:	b8 43 63 81 00       	mov    $0x816343,%eax
  80712e:	83 e0 fc             	and    $0xfffffffc,%eax
  807131:	a3 5c 63 a3 00       	mov    %eax,0xa3635c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  807136:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  80713c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  807143:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  807147:	05 00 00 22 00       	add    $0x220000,%eax
  80714c:	a3 60 63 a3 00       	mov    %eax,0xa36360
  ram_end->used = 1;
  807151:	c6 40 08 01          	movb   $0x1,0x8(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  807155:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  80715b:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%eax)

  mem_sem = sys_sem_new(1);
  807162:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  807169:	e8 67 63 00 00       	call   80d4d5 <sys_sem_new>
  80716e:	a3 68 63 a3 00       	mov    %eax,0xa36368

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  807173:	a1 5c 63 a3 00       	mov    0xa3635c,%eax
  807178:	a3 64 63 a3 00       	mov    %eax,0xa36364

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  80717d:	c9                   	leave  
  80717e:	c3                   	ret    
	...

00807180 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  807180:	55                   	push   %ebp
  807181:	89 e5                	mov    %esp,%ebp
  807183:	57                   	push   %edi
  807184:	56                   	push   %esi
  807185:	53                   	push   %ebx
  807186:	83 ec 04             	sub    $0x4,%esp
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  807189:	b8 c3 63 a3 00       	mov    $0xa363c3,%eax
  80718e:	83 e0 fc             	and    $0xfffffffc,%eax
  807191:	89 45 f0             	mov    %eax,-0x10(%ebp)
  807194:	bf 00 00 00 00       	mov    $0x0,%edi
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  807199:	c7 84 3f 80 63 a3 00 	movl   $0x0,0xa36380(%edi,%edi,1)
  8071a0:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8071a4:	0f b7 9f ba 31 81 00 	movzwl 0x8131ba(%edi),%ebx
  8071ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8071ae:	66 85 db             	test   %bx,%bx
  8071b1:	74 3c                	je     8071ef <memp_init+0x6f>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  8071b3:	0f b7 b7 9e 31 81 00 	movzwl 0x81319e(%edi),%esi
  8071ba:	b9 00 00 00 00       	mov    $0x0,%ecx
  8071bf:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  8071c4:	89 08                	mov    %ecx,(%eax)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8071c6:	83 c2 01             	add    $0x1,%edx
  8071c9:	89 c1                	mov    %eax,%ecx
  8071cb:	8d 04 30             	lea    (%eax,%esi,1),%eax
  8071ce:	66 39 da             	cmp    %bx,%dx
  8071d1:	72 f1                	jb     8071c4 <memp_init+0x44>
 * Initialize this module.
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
  8071d3:	83 eb 01             	sub    $0x1,%ebx
  8071d6:	0f b7 db             	movzwl %bx,%ebx
  8071d9:	8d 43 01             	lea    0x1(%ebx),%eax
  8071dc:	0f af c6             	imul   %esi,%eax
  8071df:	03 45 f0             	add    -0x10(%ebp),%eax
  8071e2:	0f af de             	imul   %esi,%ebx
  8071e5:	03 5d f0             	add    -0x10(%ebp),%ebx
  8071e8:	89 9c 3f 80 63 a3 00 	mov    %ebx,0xa36380(%edi,%edi,1)
  8071ef:	83 c7 02             	add    $0x2,%edi
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  8071f2:	83 ff 1c             	cmp    $0x1c,%edi
  8071f5:	74 05                	je     8071fc <memp_init+0x7c>
  8071f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8071fa:	eb 9d                	jmp    807199 <memp_init+0x19>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  8071fc:	83 c4 04             	add    $0x4,%esp
  8071ff:	5b                   	pop    %ebx
  807200:	5e                   	pop    %esi
  807201:	5f                   	pop    %edi
  807202:	5d                   	pop    %ebp
  807203:	c3                   	ret    

00807204 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  807204:	55                   	push   %ebp
  807205:	89 e5                	mov    %esp,%ebp
  807207:	53                   	push   %ebx
  807208:	83 ec 14             	sub    $0x14,%esp
  80720b:	8b 55 08             	mov    0x8(%ebp),%edx
  80720e:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  807211:	85 c0                	test   %eax,%eax
  807213:	74 2d                	je     807242 <memp_free+0x3e>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  807215:	a8 03                	test   $0x3,%al
  807217:	74 1c                	je     807235 <memp_free+0x31>
  807219:	c7 44 24 08 28 31 81 	movl   $0x813128,0x8(%esp)
  807220:	00 
  807221:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  807228:	00 
  807229:	c7 04 24 6b 31 81 00 	movl   $0x81316b,(%esp)
  807230:	e8 df 96 ff ff       	call   800914 <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  807235:	b9 80 63 a3 00       	mov    $0xa36380,%ecx
  80723a:	8b 1c 91             	mov    (%ecx,%edx,4),%ebx
  80723d:	89 18                	mov    %ebx,(%eax)
  memp_tab[type] = memp;
  80723f:	89 04 91             	mov    %eax,(%ecx,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  807242:	83 c4 14             	add    $0x14,%esp
  807245:	5b                   	pop    %ebx
  807246:	5d                   	pop    %ebp
  807247:	c3                   	ret    

00807248 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  807248:	55                   	push   %ebp
  807249:	89 e5                	mov    %esp,%ebp
  80724b:	83 ec 18             	sub    $0x18,%esp
  80724e:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  807251:	83 fa 0d             	cmp    $0xd,%edx
  807254:	76 1c                	jbe    807272 <memp_malloc+0x2a>
  807256:	c7 44 24 08 80 31 81 	movl   $0x813180,0x8(%esp)
  80725d:	00 
  80725e:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  807265:	00 
  807266:	c7 04 24 6b 31 81 00 	movl   $0x81316b,(%esp)
  80726d:	e8 a2 96 ff ff       	call   800914 <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  807272:	8b 04 95 80 63 a3 00 	mov    0xa36380(,%edx,4),%eax
  
  if (memp != NULL) {    
  807279:	85 c0                	test   %eax,%eax
  80727b:	74 29                	je     8072a6 <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  80727d:	8b 08                	mov    (%eax),%ecx
  80727f:	89 0c 95 80 63 a3 00 	mov    %ecx,0xa36380(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  807286:	a8 03                	test   $0x3,%al
  807288:	74 1c                	je     8072a6 <memp_malloc+0x5e>
  80728a:	c7 44 24 08 48 31 81 	movl   $0x813148,0x8(%esp)
  807291:	00 
  807292:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  807299:	00 
  80729a:	c7 04 24 6b 31 81 00 	movl   $0x81316b,(%esp)
  8072a1:	e8 6e 96 ff ff       	call   800914 <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  8072a6:	c9                   	leave  
  8072a7:	c3                   	ret    
	...

008072b0 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  8072b0:	55                   	push   %ebp
  8072b1:	89 e5                	mov    %esp,%ebp
  8072b3:	53                   	push   %ebx
  8072b4:	8b 55 08             	mov    0x8(%ebp),%edx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  8072b7:	b8 00 00 00 00       	mov    $0x0,%eax
  8072bc:	85 d2                	test   %edx,%edx
  8072be:	74 2c                	je     8072ec <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';
  8072c0:	0f b6 5a 02          	movzbl 0x2(%edx),%ebx
  8072c4:	83 eb 30             	sub    $0x30,%ebx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8072c7:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
  8072cc:	85 c0                	test   %eax,%eax
  8072ce:	74 1c                	je     8072ec <netif_find+0x3c>
    if (num == netif->num &&
  8072d0:	38 58 31             	cmp    %bl,0x31(%eax)
  8072d3:	75 11                	jne    8072e6 <netif_find+0x36>
       name[0] == netif->name[0] &&
  8072d5:	0f b6 0a             	movzbl (%edx),%ecx
  8072d8:	3a 48 2f             	cmp    0x2f(%eax),%cl
  8072db:	75 09                	jne    8072e6 <netif_find+0x36>
       name[1] == netif->name[1]) {
  8072dd:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
  8072e1:	3a 48 30             	cmp    0x30(%eax),%cl
  8072e4:	74 06                	je     8072ec <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8072e6:	8b 00                	mov    (%eax),%eax
  8072e8:	85 c0                	test   %eax,%eax
  8072ea:	75 e4                	jne    8072d0 <netif_find+0x20>
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  8072ec:	5b                   	pop    %ebx
  8072ed:	5d                   	pop    %ebp
  8072ee:	c3                   	ret    

008072ef <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  8072ef:	55                   	push   %ebp
  8072f0:	89 e5                	mov    %esp,%ebp
  8072f2:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  8072f5:	b8 00 00 00 00       	mov    $0x0,%eax
  8072fa:	85 d2                	test   %edx,%edx
  8072fc:	74 02                	je     807300 <netif_set_gw+0x11>
  8072fe:	8b 02                	mov    (%edx),%eax
  807300:	8b 55 08             	mov    0x8(%ebp),%edx
  807303:	89 42 0c             	mov    %eax,0xc(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  807306:	5d                   	pop    %ebp
  807307:	c3                   	ret    

00807308 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  807308:	55                   	push   %ebp
  807309:	89 e5                	mov    %esp,%ebp
  80730b:	8b 55 0c             	mov    0xc(%ebp),%edx
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  80730e:	b8 00 00 00 00       	mov    $0x0,%eax
  807313:	85 d2                	test   %edx,%edx
  807315:	74 02                	je     807319 <netif_set_netmask+0x11>
  807317:	8b 02                	mov    (%edx),%eax
  807319:	8b 55 08             	mov    0x8(%ebp),%edx
  80731c:	89 42 08             	mov    %eax,0x8(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  80731f:	5d                   	pop    %ebp
  807320:	c3                   	ret    

00807321 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  807321:	55                   	push   %ebp
  807322:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  807324:	8b 45 08             	mov    0x8(%ebp),%eax
  807327:	a3 08 f0 b3 00       	mov    %eax,0xb3f008
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  80732c:	5d                   	pop    %ebp
  80732d:	c3                   	ret    

0080732e <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  80732e:	55                   	push   %ebp
  80732f:	89 e5                	mov    %esp,%ebp
  807331:	83 ec 04             	sub    $0x4,%esp
  807334:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  807337:	85 c9                	test   %ecx,%ecx
  807339:	74 4b                	je     807386 <netif_remove+0x58>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  80733b:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
  807340:	39 c8                	cmp    %ecx,%eax
  807342:	75 1e                	jne    807362 <netif_remove+0x34>
    netif_list = netif->next;
  807344:	8b 00                	mov    (%eax),%eax
  807346:	a3 04 f0 b3 00       	mov    %eax,0xb3f004
  80734b:	eb 25                	jmp    807372 <netif_remove+0x44>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  80734d:	8b 10                	mov    (%eax),%edx
  80734f:	39 ca                	cmp    %ecx,%edx
  807351:	74 08                	je     80735b <netif_remove+0x2d>
  807353:	89 d0                	mov    %edx,%eax
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  807355:	85 c0                	test   %eax,%eax
  807357:	75 f4                	jne    80734d <netif_remove+0x1f>
  807359:	eb 2b                	jmp    807386 <netif_remove+0x58>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
  80735b:	8b 11                	mov    (%ecx),%edx
  80735d:	89 10                	mov    %edx,(%eax)
  80735f:	90                   	nop
  807360:	eb 10                	jmp    807372 <netif_remove+0x44>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  807362:	85 c0                	test   %eax,%eax
  807364:	74 20                	je     807386 <netif_remove+0x58>
      if (tmpNetif->next == netif) {
  807366:	8b 10                	mov    (%eax),%edx
  807368:	39 ca                	cmp    %ecx,%edx
  80736a:	74 ef                	je     80735b <netif_remove+0x2d>
  80736c:	89 d0                	mov    %edx,%eax
  80736e:	66 90                	xchg   %ax,%ax
  807370:	eb e3                	jmp    807355 <netif_remove+0x27>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  807372:	39 0d 08 f0 b3 00    	cmp    %ecx,0xb3f008
  807378:	75 0c                	jne    807386 <netif_remove+0x58>
    /* reset default netif */
    netif_set_default(NULL);
  80737a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  807381:	e8 9b ff ff ff       	call   807321 <netif_set_default>
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  807386:	c9                   	leave  
  807387:	c3                   	ret    

00807388 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  807388:	55                   	push   %ebp
  807389:	89 e5                	mov    %esp,%ebp
  80738b:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  80738e:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  807392:	f6 c2 01             	test   $0x1,%dl
  807395:	74 06                	je     80739d <netif_set_down+0x15>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  807397:	83 e2 fe             	and    $0xfffffffe,%edx
  80739a:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80739d:	5d                   	pop    %ebp
  80739e:	c3                   	ret    

0080739f <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80739f:	55                   	push   %ebp
  8073a0:	89 e5                	mov    %esp,%ebp
  8073a2:	8b 45 08             	mov    0x8(%ebp),%eax
  8073a5:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  8073a9:	83 e0 01             	and    $0x1,%eax
  return (netif->flags & NETIF_FLAG_UP)?1:0;
}
  8073ac:	5d                   	pop    %ebp
  8073ad:	c3                   	ret    

008073ae <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8073ae:	55                   	push   %ebp
  8073af:	89 e5                	mov    %esp,%ebp
  8073b1:	83 ec 18             	sub    $0x18,%esp
  8073b4:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8073b7:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  8073bb:	f6 c2 01             	test   $0x1,%dl
  8073be:	75 22                	jne    8073e2 <netif_set_up+0x34>
    netif->flags |= NETIF_FLAG_UP;
  8073c0:	83 ca 01             	or     $0x1,%edx
  8073c3:	88 50 2e             	mov    %dl,0x2e(%eax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  8073c6:	f6 c2 20             	test   $0x20,%dl
  8073c9:	74 17                	je     8073e2 <netif_set_up+0x34>
      etharp_query(netif, &(netif->ip_addr), NULL);
  8073cb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8073d2:	00 
  8073d3:	8d 50 04             	lea    0x4(%eax),%edx
  8073d6:	89 54 24 04          	mov    %edx,0x4(%esp)
  8073da:	89 04 24             	mov    %eax,(%esp)
  8073dd:	e8 65 53 00 00       	call   80c747 <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  8073e2:	c9                   	leave  
  8073e3:	c3                   	ret    

008073e4 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  8073e4:	55                   	push   %ebp
  8073e5:	89 e5                	mov    %esp,%ebp
  8073e7:	57                   	push   %edi
  8073e8:	56                   	push   %esi
  8073e9:	53                   	push   %ebx
  8073ea:	83 ec 1c             	sub    $0x1c,%esp
  8073ed:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8073f0:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  8073f3:	8b 06                	mov    (%esi),%eax
  8073f5:	3b 43 04             	cmp    0x4(%ebx),%eax
  8073f8:	74 54                	je     80744e <netif_set_ipaddr+0x6a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  8073fa:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
    while (pcb != NULL) {
  8073ff:	85 c0                	test   %eax,%eax
  807401:	74 1d                	je     807420 <netif_set_ipaddr+0x3c>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  807403:	8b 10                	mov    (%eax),%edx
  807405:	3b 53 04             	cmp    0x4(%ebx),%edx
  807408:	75 0f                	jne    807419 <netif_set_ipaddr+0x35>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  80740a:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  80740d:	89 04 24             	mov    %eax,(%esp)
  807410:	e8 99 16 00 00       	call   808aae <tcp_abort>
  807415:	89 f8                	mov    %edi,%eax
  807417:	eb 03                	jmp    80741c <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
  807419:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  80741c:	85 c0                	test   %eax,%eax
  80741e:	75 e3                	jne    807403 <netif_set_ipaddr+0x1f>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  807420:	a1 14 f0 b3 00       	mov    0xb3f014,%eax
  807425:	85 c0                	test   %eax,%eax
  807427:	74 25                	je     80744e <netif_set_ipaddr+0x6a>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  807429:	b9 00 00 00 00       	mov    $0x0,%ecx
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  80742e:	85 c0                	test   %eax,%eax
  807430:	74 15                	je     807447 <netif_set_ipaddr+0x63>
  807432:	8b 10                	mov    (%eax),%edx
  807434:	85 d2                	test   %edx,%edx
  807436:	74 0f                	je     807447 <netif_set_ipaddr+0x63>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  807438:	3b 53 04             	cmp    0x4(%ebx),%edx
  80743b:	75 0a                	jne    807447 <netif_set_ipaddr+0x63>
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  80743d:	89 ca                	mov    %ecx,%edx
  80743f:	85 f6                	test   %esi,%esi
  807441:	74 02                	je     807445 <netif_set_ipaddr+0x61>
  807443:	8b 16                	mov    (%esi),%edx
  807445:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  807447:	8b 40 0c             	mov    0xc(%eax),%eax
  80744a:	85 c0                	test   %eax,%eax
  80744c:	75 e0                	jne    80742e <netif_set_ipaddr+0x4a>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  80744e:	b8 00 00 00 00       	mov    $0x0,%eax
  807453:	85 f6                	test   %esi,%esi
  807455:	74 02                	je     807459 <netif_set_ipaddr+0x75>
  807457:	8b 06                	mov    (%esi),%eax
  807459:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  80745c:	83 c4 1c             	add    $0x1c,%esp
  80745f:	5b                   	pop    %ebx
  807460:	5e                   	pop    %esi
  807461:	5f                   	pop    %edi
  807462:	5d                   	pop    %ebp
  807463:	c3                   	ret    

00807464 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  807464:	55                   	push   %ebp
  807465:	89 e5                	mov    %esp,%ebp
  807467:	53                   	push   %ebx
  807468:	83 ec 14             	sub    $0x14,%esp
  80746b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif_set_ipaddr(netif, ipaddr);
  80746e:	8b 45 0c             	mov    0xc(%ebp),%eax
  807471:	89 44 24 04          	mov    %eax,0x4(%esp)
  807475:	89 1c 24             	mov    %ebx,(%esp)
  807478:	e8 67 ff ff ff       	call   8073e4 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  80747d:	8b 45 10             	mov    0x10(%ebp),%eax
  807480:	89 44 24 04          	mov    %eax,0x4(%esp)
  807484:	89 1c 24             	mov    %ebx,(%esp)
  807487:	e8 7c fe ff ff       	call   807308 <netif_set_netmask>
  netif_set_gw(netif, gw);
  80748c:	8b 45 14             	mov    0x14(%ebp),%eax
  80748f:	89 44 24 04          	mov    %eax,0x4(%esp)
  807493:	89 1c 24             	mov    %ebx,(%esp)
  807496:	e8 54 fe ff ff       	call   8072ef <netif_set_gw>
}
  80749b:	83 c4 14             	add    $0x14,%esp
  80749e:	5b                   	pop    %ebx
  80749f:	5d                   	pop    %ebp
  8074a0:	c3                   	ret    

008074a1 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  8074a1:	55                   	push   %ebp
  8074a2:	89 e5                	mov    %esp,%ebp
  8074a4:	53                   	push   %ebx
  8074a5:	83 ec 14             	sub    $0x14,%esp
  8074a8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  8074ab:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  8074b2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  8074b9:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  8074c0:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  8074c4:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  8074cb:	8b 45 18             	mov    0x18(%ebp),%eax
  8074ce:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  8074d1:	0f b6 05 24 54 b3 00 	movzbl 0xb35424,%eax
  8074d8:	88 43 31             	mov    %al,0x31(%ebx)
  8074db:	83 c0 01             	add    $0x1,%eax
  8074de:	a2 24 54 b3 00       	mov    %al,0xb35424
  netif->input = input;
  8074e3:	8b 45 20             	mov    0x20(%ebp),%eax
  8074e6:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  8074e9:	8b 45 14             	mov    0x14(%ebp),%eax
  8074ec:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8074f0:	8b 45 10             	mov    0x10(%ebp),%eax
  8074f3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8074f7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8074fa:	89 44 24 04          	mov    %eax,0x4(%esp)
  8074fe:	89 1c 24             	mov    %ebx,(%esp)
  807501:	e8 5e ff ff ff       	call   807464 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  807506:	89 1c 24             	mov    %ebx,(%esp)
  807509:	ff 55 1c             	call   *0x1c(%ebp)
  80750c:	84 c0                	test   %al,%al
  80750e:	74 07                	je     807517 <netif_add+0x76>
  807510:	bb 00 00 00 00       	mov    $0x0,%ebx
  807515:	eb 0d                	jmp    807524 <netif_add+0x83>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  807517:	a1 04 f0 b3 00       	mov    0xb3f004,%eax
  80751c:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  80751e:	89 1d 04 f0 b3 00    	mov    %ebx,0xb3f004
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  807524:	89 d8                	mov    %ebx,%eax
  807526:	83 c4 14             	add    $0x14,%esp
  807529:	5b                   	pop    %ebx
  80752a:	5d                   	pop    %ebp
  80752b:	c3                   	ret    
  80752c:	00 00                	add    %al,(%eax)
	...

00807530 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  807530:	55                   	push   %ebp
  807531:	89 e5                	mov    %esp,%ebp
  807533:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  while (p != NULL) {
  807536:	b8 00 00 00 00       	mov    $0x0,%eax
  80753b:	85 d2                	test   %edx,%edx
  80753d:	74 09                	je     807548 <pbuf_clen+0x18>
    ++len;
  80753f:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  807542:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  807544:	85 d2                	test   %edx,%edx
  807546:	75 f7                	jne    80753f <pbuf_clen+0xf>
    ++len;
    p = p->next;
  }
  return len;
}
  807548:	5d                   	pop    %ebp
  807549:	c3                   	ret    

0080754a <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  80754a:	55                   	push   %ebp
  80754b:	89 e5                	mov    %esp,%ebp
  80754d:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  807550:	85 c0                	test   %eax,%eax
  807552:	74 05                	je     807559 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  807554:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  807559:	5d                   	pop    %ebp
  80755a:	c3                   	ret    

0080755b <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  80755b:	55                   	push   %ebp
  80755c:	89 e5                	mov    %esp,%ebp
  80755e:	53                   	push   %ebx
  80755f:	83 ec 14             	sub    $0x14,%esp
  807562:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807565:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807568:	85 db                	test   %ebx,%ebx
  80756a:	74 0e                	je     80757a <pbuf_cat+0x1f>
  80756c:	85 c9                	test   %ecx,%ecx
  80756e:	74 0a                	je     80757a <pbuf_cat+0x1f>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807570:	8b 13                	mov    (%ebx),%edx
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807572:	89 d8                	mov    %ebx,%eax
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807574:	85 d2                	test   %edx,%edx
  807576:	75 1e                	jne    807596 <pbuf_cat+0x3b>
  807578:	eb 2c                	jmp    8075a6 <pbuf_cat+0x4b>
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80757a:	c7 44 24 08 d8 31 81 	movl   $0x8131d8,0x8(%esp)
  807581:	00 
  807582:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  807589:	00 
  80758a:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807591:	e8 7e 93 ff ff       	call   800914 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  807596:	0f b7 51 08          	movzwl 0x8(%ecx),%edx
  80759a:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80759e:	8b 00                	mov    (%eax),%eax
  8075a0:	8b 10                	mov    (%eax),%edx
  8075a2:	85 d2                	test   %edx,%edx
  8075a4:	75 f0                	jne    807596 <pbuf_cat+0x3b>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  8075a6:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  8075aa:	66 3b 58 0a          	cmp    0xa(%eax),%bx
  8075ae:	74 1c                	je     8075cc <pbuf_cat+0x71>
  8075b0:	c7 44 24 08 10 32 81 	movl   $0x813210,0x8(%esp)
  8075b7:	00 
  8075b8:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  8075bf:	00 
  8075c0:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8075c7:	e8 48 93 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  8075cc:	85 d2                	test   %edx,%edx
  8075ce:	74 1c                	je     8075ec <pbuf_cat+0x91>
  8075d0:	c7 44 24 08 82 33 81 	movl   $0x813382,0x8(%esp)
  8075d7:	00 
  8075d8:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  8075df:	00 
  8075e0:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8075e7:	e8 28 93 ff ff       	call   800914 <_panic>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  8075ec:	66 03 59 08          	add    0x8(%ecx),%bx
  8075f0:	66 89 58 08          	mov    %bx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  8075f4:	89 08                	mov    %ecx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  8075f6:	83 c4 14             	add    $0x14,%esp
  8075f9:	5b                   	pop    %ebx
  8075fa:	5d                   	pop    %ebp
  8075fb:	c3                   	ret    

008075fc <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  8075fc:	55                   	push   %ebp
  8075fd:	89 e5                	mov    %esp,%ebp
  8075ff:	53                   	push   %ebx
  807600:	83 ec 14             	sub    $0x14,%esp
  807603:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  807606:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80760a:	8b 45 08             	mov    0x8(%ebp),%eax
  80760d:	89 04 24             	mov    %eax,(%esp)
  807610:	e8 46 ff ff ff       	call   80755b <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  807615:	89 1c 24             	mov    %ebx,(%esp)
  807618:	e8 2d ff ff ff       	call   80754a <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80761d:	83 c4 14             	add    $0x14,%esp
  807620:	5b                   	pop    %ebx
  807621:	5d                   	pop    %ebp
  807622:	c3                   	ret    

00807623 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  807623:	55                   	push   %ebp
  807624:	89 e5                	mov    %esp,%ebp
  807626:	83 ec 18             	sub    $0x18,%esp
  807629:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80762c:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80762f:	8b 55 08             	mov    0x8(%ebp),%edx
  807632:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  807636:	85 d2                	test   %edx,%edx
  807638:	75 1c                	jne    807656 <pbuf_header+0x33>
  80763a:	c7 44 24 08 4b 34 81 	movl   $0x81344b,0x8(%esp)
  807641:	00 
  807642:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  807649:	00 
  80764a:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807651:	e8 be 92 ff ff       	call   800914 <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  807656:	b8 00 00 00 00       	mov    $0x0,%eax
  80765b:	66 85 c9             	test   %cx,%cx
  80765e:	0f 84 a8 00 00 00    	je     80770c <pbuf_header+0xe9>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  807664:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  807666:	66 85 c9             	test   %cx,%cx
  807669:	79 24                	jns    80768f <pbuf_header+0x6c>
    increment_magnitude = -header_size_increment;
  80766b:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  80766d:	66 3b 72 0a          	cmp    0xa(%edx),%si
  807671:	76 1c                	jbe    80768f <pbuf_header+0x6c>
  807673:	c7 44 24 08 92 33 81 	movl   $0x813392,0x8(%esp)
  80767a:	00 
  80767b:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  807682:	00 
  807683:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  80768a:	e8 85 92 ff ff       	call   800914 <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  80768f:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  807693:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  807696:	66 85 c0             	test   %ax,%ax
  807699:	74 06                	je     8076a1 <pbuf_header+0x7e>
  80769b:	66 83 f8 03          	cmp    $0x3,%ax
  80769f:	75 1d                	jne    8076be <pbuf_header+0x9b>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  8076a1:	0f bf c1             	movswl %cx,%eax
  8076a4:	89 de                	mov    %ebx,%esi
  8076a6:	29 c6                	sub    %eax,%esi
  8076a8:	89 f0                	mov    %esi,%eax
  8076aa:	89 72 04             	mov    %esi,0x4(%edx)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  8076ad:	8d 72 10             	lea    0x10(%edx),%esi
  8076b0:	39 f0                	cmp    %esi,%eax
  8076b2:	73 44                	jae    8076f8 <pbuf_header+0xd5>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  8076b4:	89 5a 04             	mov    %ebx,0x4(%edx)
  8076b7:	b8 01 00 00 00       	mov    $0x1,%eax
      /* bail out unsuccesfully */
      return 1;
  8076bc:	eb 4e                	jmp    80770c <pbuf_header+0xe9>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  8076be:	83 e8 01             	sub    $0x1,%eax
  8076c1:	66 83 f8 01          	cmp    $0x1,%ax
  8076c5:	77 15                	ja     8076dc <pbuf_header+0xb9>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8076c7:	66 85 c9             	test   %cx,%cx
  8076ca:	79 3b                	jns    807707 <pbuf_header+0xe4>
  8076cc:	66 3b 72 0a          	cmp    0xa(%edx),%si
  8076d0:	77 35                	ja     807707 <pbuf_header+0xe4>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  8076d2:	0f bf c1             	movswl %cx,%eax
  8076d5:	29 c3                	sub    %eax,%ebx
  8076d7:	89 5a 04             	mov    %ebx,0x4(%edx)
  8076da:	eb 1c                	jmp    8076f8 <pbuf_header+0xd5>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  8076dc:	c7 44 24 08 b0 33 81 	movl   $0x8133b0,0x8(%esp)
  8076e3:	00 
  8076e4:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  8076eb:	00 
  8076ec:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8076f3:	e8 1c 92 ff ff       	call   800914 <_panic>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8076f8:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  8076fc:	66 01 4a 08          	add    %cx,0x8(%edx)
  807700:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  807705:	eb 05                	jmp    80770c <pbuf_header+0xe9>
  807707:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80770c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80770f:	8b 75 fc             	mov    -0x4(%ebp),%esi
  807712:	89 ec                	mov    %ebp,%esp
  807714:	5d                   	pop    %ebp
  807715:	c3                   	ret    

00807716 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  807716:	55                   	push   %ebp
  807717:	89 e5                	mov    %esp,%ebp
  807719:	57                   	push   %edi
  80771a:	56                   	push   %esi
  80771b:	53                   	push   %ebx
  80771c:	83 ec 2c             	sub    $0x2c,%esp
  80771f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807722:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  807726:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  80772a:	85 db                	test   %ebx,%ebx
  80772c:	75 1c                	jne    80774a <pbuf_copy_partial+0x34>
  80772e:	c7 44 24 08 40 32 81 	movl   $0x813240,0x8(%esp)
  807735:	00 
  807736:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  80773d:	00 
  80773e:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807745:	e8 ca 91 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  80774a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80774e:	75 1c                	jne    80776c <pbuf_copy_partial+0x56>
  807750:	c7 44 24 08 64 32 81 	movl   $0x813264,0x8(%esp)
  807757:	00 
  807758:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  80775f:	00 
  807760:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807767:	e8 a8 91 ff ff       	call   800914 <_panic>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  80776c:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  807772:	66 85 f6             	test   %si,%si
  807775:	74 61                	je     8077d8 <pbuf_copy_partial+0xc2>
  807777:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    if ((offset != 0) && (offset >= p->len)) {
  80777d:	66 85 c0             	test   %ax,%ax
  807780:	74 0e                	je     807790 <pbuf_copy_partial+0x7a>
  807782:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807786:	66 39 c2             	cmp    %ax,%dx
  807789:	77 05                	ja     807790 <pbuf_copy_partial+0x7a>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  80778b:	66 29 d0             	sub    %dx,%ax
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  80778e:	eb 3d                	jmp    8077cd <pbuf_copy_partial+0xb7>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  807790:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  807794:	66 29 c7             	sub    %ax,%di
  807797:	66 39 f7             	cmp    %si,%di
  80779a:	0f 47 fe             	cmova  %esi,%edi
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  80779d:	0f b7 d7             	movzwl %di,%edx
  8077a0:	89 54 24 08          	mov    %edx,0x8(%esp)
  8077a4:	0f b7 c0             	movzwl %ax,%eax
  8077a7:	03 43 04             	add    0x4(%ebx),%eax
  8077aa:	89 44 24 04          	mov    %eax,0x4(%esp)
  8077ae:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8077b2:	03 45 0c             	add    0xc(%ebp),%eax
  8077b5:	89 04 24             	mov    %eax,(%esp)
  8077b8:	e8 b4 9b ff ff       	call   801371 <memcpy>
      copied_total += buf_copy_len;
  8077bd:	66 01 7d e4          	add    %di,-0x1c(%ebp)
      left += buf_copy_len;
  8077c1:	66 01 7d e6          	add    %di,-0x1a(%ebp)
      len -= buf_copy_len;
  8077c5:	66 29 fe             	sub    %di,%si
  8077c8:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  8077cd:	8b 1b                	mov    (%ebx),%ebx
  8077cf:	66 85 f6             	test   %si,%si
  8077d2:	74 04                	je     8077d8 <pbuf_copy_partial+0xc2>
  8077d4:	85 db                	test   %ebx,%ebx
  8077d6:	75 a5                	jne    80777d <pbuf_copy_partial+0x67>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  8077d8:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8077dc:	83 c4 2c             	add    $0x2c,%esp
  8077df:	5b                   	pop    %ebx
  8077e0:	5e                   	pop    %esi
  8077e1:	5f                   	pop    %edi
  8077e2:	5d                   	pop    %ebp
  8077e3:	c3                   	ret    

008077e4 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  8077e4:	55                   	push   %ebp
  8077e5:	89 e5                	mov    %esp,%ebp
  8077e7:	57                   	push   %edi
  8077e8:	56                   	push   %esi
  8077e9:	53                   	push   %ebx
  8077ea:	83 ec 4c             	sub    $0x4c,%esp
  8077ed:	8b 75 08             	mov    0x8(%ebp),%esi
  8077f0:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  8077f3:	85 f6                	test   %esi,%esi
  8077f5:	0f 94 c0             	sete   %al
  8077f8:	74 0e                	je     807808 <pbuf_copy+0x24>
  8077fa:	85 db                	test   %ebx,%ebx
  8077fc:	74 0a                	je     807808 <pbuf_copy+0x24>
  8077fe:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  807802:	66 3b 53 08          	cmp    0x8(%ebx),%dx
  807806:	73 1c                	jae    807824 <pbuf_copy+0x40>
  807808:	c7 44 24 08 8c 32 81 	movl   $0x81328c,0x8(%esp)
  80780f:	00 
  807810:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  807817:	00 
  807818:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  80781f:	e8 f0 90 ff ff       	call   800914 <_panic>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  807824:	84 c0                	test   %al,%al
  807826:	74 26                	je     80784e <pbuf_copy+0x6a>
  807828:	eb 08                	jmp    807832 <pbuf_copy+0x4e>
  80782a:	85 f6                	test   %esi,%esi
  80782c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  807830:	75 27                	jne    807859 <pbuf_copy+0x75>
  807832:	c7 44 24 08 be 33 81 	movl   $0x8133be,0x8(%esp)
  807839:	00 
  80783a:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  807841:	00 
  807842:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807849:	e8 c6 90 ff ff       	call   800914 <_panic>
  80784e:	bf 00 00 00 00       	mov    $0x0,%edi
  807853:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  807859:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  80785d:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807861:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807865:	29 c2                	sub    %eax,%edx
  807867:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80786a:	0f b7 d1             	movzwl %cx,%edx
  80786d:	0f b7 c7             	movzwl %di,%eax
  807870:	29 c2                	sub    %eax,%edx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  807872:	66 29 f9             	sub    %di,%cx
  807875:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807879:	66 2b 45 e6          	sub    -0x1a(%ebp),%ax
  80787d:	39 55 c4             	cmp    %edx,-0x3c(%ebp)
  807880:	89 ca                	mov    %ecx,%edx
  807882:	0f 4c d0             	cmovl  %eax,%edx
  807885:	66 89 55 c8          	mov    %dx,-0x38(%ebp)
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  807889:	0f b7 c2             	movzwl %dx,%eax
  80788c:	89 44 24 08          	mov    %eax,0x8(%esp)
  807890:	0f b7 c7             	movzwl %di,%eax
  807893:	03 43 04             	add    0x4(%ebx),%eax
  807896:	89 44 24 04          	mov    %eax,0x4(%esp)
  80789a:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80789e:	03 46 04             	add    0x4(%esi),%eax
  8078a1:	89 04 24             	mov    %eax,(%esp)
  8078a4:	e8 c8 9a ff ff       	call   801371 <memcpy>
    offset_to += len;
  8078a9:	0f b7 45 c8          	movzwl -0x38(%ebp),%eax
  8078ad:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  8078b1:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8078b5:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  8078b9:	76 1c                	jbe    8078d7 <pbuf_copy+0xf3>
  8078bb:	c7 44 24 08 cb 33 81 	movl   $0x8133cb,0x8(%esp)
  8078c2:	00 
  8078c3:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  8078ca:	00 
  8078cb:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8078d2:	e8 3d 90 ff ff       	call   800914 <_panic>
    if (offset_to == p_to->len) {
  8078d7:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  8078db:	75 08                	jne    8078e5 <pbuf_copy+0x101>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  8078dd:	8b 36                	mov    (%esi),%esi
  8078df:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
  8078e5:	66 03 7d c8          	add    -0x38(%ebp),%di
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  8078e9:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8078ed:	66 39 c7             	cmp    %ax,%di
  8078f0:	76 1c                	jbe    80790e <pbuf_copy+0x12a>
  8078f2:	c7 44 24 08 e2 33 81 	movl   $0x8133e2,0x8(%esp)
  8078f9:	00 
  8078fa:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  807901:	00 
  807902:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807909:	e8 06 90 ff ff       	call   800914 <_panic>
    if (offset_from >= p_from->len) {
  80790e:	66 39 c7             	cmp    %ax,%di
  807911:	72 07                	jb     80791a <pbuf_copy+0x136>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  807913:	8b 1b                	mov    (%ebx),%ebx
  807915:	bf 00 00 00 00       	mov    $0x0,%edi
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80791a:	85 db                	test   %ebx,%ebx
  80791c:	74 2b                	je     807949 <pbuf_copy+0x165>
  80791e:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807922:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  807926:	75 21                	jne    807949 <pbuf_copy+0x165>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807928:	83 3b 00             	cmpl   $0x0,(%ebx)
  80792b:	74 1c                	je     807949 <pbuf_copy+0x165>
  80792d:	c7 44 24 08 bc 32 81 	movl   $0x8132bc,0x8(%esp)
  807934:	00 
  807935:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  80793c:	00 
  80793d:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807944:	e8 cb 8f ff ff       	call   800914 <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  807949:	85 f6                	test   %esi,%esi
  80794b:	74 2b                	je     807978 <pbuf_copy+0x194>
  80794d:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807951:	66 3b 46 08          	cmp    0x8(%esi),%ax
  807955:	75 21                	jne    807978 <pbuf_copy+0x194>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807957:	83 3e 00             	cmpl   $0x0,(%esi)
  80795a:	74 1c                	je     807978 <pbuf_copy+0x194>
  80795c:	c7 44 24 08 bc 32 81 	movl   $0x8132bc,0x8(%esp)
  807963:	00 
  807964:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  80796b:	00 
  80796c:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807973:	e8 9c 8f ff ff       	call   800914 <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  807978:	85 db                	test   %ebx,%ebx
  80797a:	0f 85 aa fe ff ff    	jne    80782a <pbuf_copy+0x46>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  807980:	b8 00 00 00 00       	mov    $0x0,%eax
  807985:	83 c4 4c             	add    $0x4c,%esp
  807988:	5b                   	pop    %ebx
  807989:	5e                   	pop    %esi
  80798a:	5f                   	pop    %edi
  80798b:	5d                   	pop    %ebp
  80798c:	c3                   	ret    

0080798d <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  80798d:	55                   	push   %ebp
  80798e:	89 e5                	mov    %esp,%ebp
  807990:	56                   	push   %esi
  807991:	53                   	push   %ebx
  807992:	83 ec 10             	sub    $0x10,%esp
  807995:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  807998:	85 c0                	test   %eax,%eax
  80799a:	75 1c                	jne    8079b8 <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  80799c:	c7 44 24 08 4b 34 81 	movl   $0x81344b,0x8(%esp)
  8079a3:	00 
  8079a4:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  8079ab:	00 
  8079ac:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8079b3:	e8 5c 8f ff ff       	call   800914 <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  8079b8:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  8079bc:	77 0a                	ja     8079c8 <pbuf_free+0x3b>
  8079be:	be 00 00 00 00       	mov    $0x0,%esi
  8079c3:	e9 82 00 00 00       	jmp    807a4a <pbuf_free+0xbd>
  8079c8:	c7 44 24 08 fd 33 81 	movl   $0x8133fd,0x8(%esp)
  8079cf:	00 
  8079d0:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  8079d7:	00 
  8079d8:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8079df:	e8 30 8f ff ff       	call   800914 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  8079e4:	c7 44 24 08 12 34 81 	movl   $0x813412,0x8(%esp)
  8079eb:	00 
  8079ec:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  8079f3:	00 
  8079f4:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  8079fb:	e8 14 8f ff ff       	call   800914 <_panic>
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  807a00:	8b 18                	mov    (%eax),%ebx
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  807a02:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  807a06:	66 83 fa 03          	cmp    $0x3,%dx
  807a0a:	75 12                	jne    807a1e <pbuf_free+0x91>
        memp_free(MEMP_PBUF_POOL, p);
  807a0c:	89 44 24 04          	mov    %eax,0x4(%esp)
  807a10:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807a17:	e8 e8 f7 ff ff       	call   807204 <memp_free>
  807a1c:	eb 23                	jmp    807a41 <pbuf_free+0xb4>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  807a1e:	83 ea 01             	sub    $0x1,%edx
  807a21:	66 83 fa 01          	cmp    $0x1,%dx
  807a25:	77 12                	ja     807a39 <pbuf_free+0xac>
        memp_free(MEMP_PBUF, p);
  807a27:	89 44 24 04          	mov    %eax,0x4(%esp)
  807a2b:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  807a32:	e8 cd f7 ff ff       	call   807204 <memp_free>
  807a37:	eb 08                	jmp    807a41 <pbuf_free+0xb4>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  807a39:	89 04 24             	mov    %eax,(%esp)
  807a3c:	e8 44 f5 ff ff       	call   806f85 <mem_free>
      }
      count++;
  807a41:	83 c6 01             	add    $0x1,%esi
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  807a44:	85 db                	test   %ebx,%ebx
  807a46:	74 17                	je     807a5f <pbuf_free+0xd2>
  807a48:	89 d8                	mov    %ebx,%eax
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  807a4a:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  807a4e:	66 85 d2             	test   %dx,%dx
  807a51:	74 91                	je     8079e4 <pbuf_free+0x57>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  807a53:	83 ea 01             	sub    $0x1,%edx
  807a56:	66 89 50 0e          	mov    %dx,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  807a5a:	66 85 d2             	test   %dx,%dx
  807a5d:	74 a1                	je     807a00 <pbuf_free+0x73>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  807a5f:	89 f0                	mov    %esi,%eax
  807a61:	83 c4 10             	add    $0x10,%esp
  807a64:	5b                   	pop    %ebx
  807a65:	5e                   	pop    %esi
  807a66:	5d                   	pop    %ebp
  807a67:	c3                   	ret    

00807a68 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  807a68:	55                   	push   %ebp
  807a69:	89 e5                	mov    %esp,%ebp
  807a6b:	83 ec 38             	sub    $0x38,%esp
  807a6e:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  807a71:	89 75 f8             	mov    %esi,-0x8(%ebp)
  807a74:	89 7d fc             	mov    %edi,-0x4(%ebp)
  807a77:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  807a7a:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  807a7c:	b8 01 00 00 00       	mov    $0x1,%eax
  807a81:	85 f6                	test   %esi,%esi
  807a83:	74 55                	je     807ada <pbuf_dechain+0x72>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  807a85:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  807a89:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807a8d:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  807a91:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  807a94:	0f b7 fa             	movzwl %dx,%edi
  807a97:	0f b7 c8             	movzwl %ax,%ecx
  807a9a:	29 cf                	sub    %ecx,%edi
  807a9c:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  807a9f:	74 1c                	je     807abd <pbuf_dechain+0x55>
  807aa1:	c7 44 24 08 e8 32 81 	movl   $0x8132e8,0x8(%esp)
  807aa8:	00 
  807aa9:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  807ab0:	00 
  807ab1:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807ab8:	e8 57 8e ff ff       	call   800914 <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  807abd:	66 29 c2             	sub    %ax,%dx
  807ac0:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  807ac4:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  807aca:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807ace:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  807ad2:	89 34 24             	mov    %esi,(%esp)
  807ad5:	e8 b3 fe ff ff       	call   80798d <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  807ada:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  807ade:	66 3b 53 0a          	cmp    0xa(%ebx),%dx
  807ae2:	74 1c                	je     807b00 <pbuf_dechain+0x98>
  807ae4:	c7 44 24 08 28 34 81 	movl   $0x813428,0x8(%esp)
  807aeb:	00 
  807aec:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  807af3:	00 
  807af4:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807afb:	e8 14 8e ff ff       	call   800914 <_panic>
  return ((tail_gone > 0) ? NULL : q);
  807b00:	84 c0                	test   %al,%al
  807b02:	b8 00 00 00 00       	mov    $0x0,%eax
  807b07:	0f 45 f0             	cmovne %eax,%esi
}
  807b0a:	89 f0                	mov    %esi,%eax
  807b0c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  807b0f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  807b12:	8b 7d fc             	mov    -0x4(%ebp),%edi
  807b15:	89 ec                	mov    %ebp,%esp
  807b17:	5d                   	pop    %ebp
  807b18:	c3                   	ret    

00807b19 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  807b19:	55                   	push   %ebp
  807b1a:	89 e5                	mov    %esp,%ebp
  807b1c:	56                   	push   %esi
  807b1d:	53                   	push   %ebx
  807b1e:	83 ec 10             	sub    $0x10,%esp
  807b21:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807b24:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  807b28:	85 db                	test   %ebx,%ebx
  807b2a:	75 1c                	jne    807b48 <pbuf_realloc+0x2f>
  807b2c:	c7 44 24 08 3d 34 81 	movl   $0x81343d,0x8(%esp)
  807b33:	00 
  807b34:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  807b3b:	00 
  807b3c:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807b43:	e8 cc 8d ff ff       	call   800914 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  807b48:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  807b4c:	3c 03                	cmp    $0x3,%al
  807b4e:	74 28                	je     807b78 <pbuf_realloc+0x5f>
  807b50:	3c 01                	cmp    $0x1,%al
  807b52:	74 24                	je     807b78 <pbuf_realloc+0x5f>
  807b54:	84 c0                	test   %al,%al
  807b56:	74 20                	je     807b78 <pbuf_realloc+0x5f>
  807b58:	3c 02                	cmp    $0x2,%al
  807b5a:	74 1c                	je     807b78 <pbuf_realloc+0x5f>
  807b5c:	c7 44 24 08 55 34 81 	movl   $0x813455,0x8(%esp)
  807b63:	00 
  807b64:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  807b6b:	00 
  807b6c:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807b73:	e8 9c 8d ff ff       	call   800914 <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  807b78:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  807b7c:	66 39 f0             	cmp    %si,%ax
  807b7f:	0f 86 bd 00 00 00    	jbe    807c42 <pbuf_realloc+0x129>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  807b85:	0f b7 d6             	movzwl %si,%edx
  807b88:	0f b7 c0             	movzwl %ax,%eax
  807b8b:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  807b8d:	eb 4d                	jmp    807bdc <pbuf_realloc+0xc3>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  807b8f:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  807b95:	7e 1c                	jle    807bb3 <pbuf_realloc+0x9a>
  807b97:	c7 44 24 08 70 34 81 	movl   $0x813470,0x8(%esp)
  807b9e:	00 
  807b9f:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  807ba6:	00 
  807ba7:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807bae:	e8 61 8d ff ff       	call   800914 <_panic>
    q->tot_len += (u16_t)grow;
  807bb3:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  807bb7:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  807bb9:	85 db                	test   %ebx,%ebx
  807bbb:	75 1c                	jne    807bd9 <pbuf_realloc+0xc0>
  807bbd:	c7 44 24 08 81 34 81 	movl   $0x813481,0x8(%esp)
  807bc4:	00 
  807bc5:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  807bcc:	00 
  807bcd:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807bd4:	e8 3b 8d ff ff       	call   800914 <_panic>
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  807bd9:	66 29 c6             	sub    %ax,%si

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  807bdc:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807be0:	66 39 c6             	cmp    %ax,%si
  807be3:	77 aa                	ja     807b8f <pbuf_realloc+0x76>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  807be5:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  807be9:	75 3b                	jne    807c26 <pbuf_realloc+0x10d>
  807beb:	66 39 f0             	cmp    %si,%ax
  807bee:	74 36                	je     807c26 <pbuf_realloc+0x10d>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  807bf0:	0f b7 c6             	movzwl %si,%eax
  807bf3:	03 43 04             	add    0x4(%ebx),%eax
  807bf6:	29 d8                	sub    %ebx,%eax
  807bf8:	89 44 24 04          	mov    %eax,0x4(%esp)
  807bfc:	89 1c 24             	mov    %ebx,(%esp)
  807bff:	e8 17 f2 ff ff       	call   806e1b <mem_realloc>
  807c04:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  807c06:	85 c0                	test   %eax,%eax
  807c08:	75 1c                	jne    807c26 <pbuf_realloc+0x10d>
  807c0a:	c7 44 24 08 99 34 81 	movl   $0x813499,0x8(%esp)
  807c11:	00 
  807c12:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  807c19:	00 
  807c1a:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807c21:	e8 ee 8c ff ff       	call   800914 <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  807c26:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  807c2a:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  807c2e:	8b 03                	mov    (%ebx),%eax
  807c30:	85 c0                	test   %eax,%eax
  807c32:	74 08                	je     807c3c <pbuf_realloc+0x123>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  807c34:	89 04 24             	mov    %eax,(%esp)
  807c37:	e8 51 fd ff ff       	call   80798d <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  807c3c:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  807c42:	83 c4 10             	add    $0x10,%esp
  807c45:	5b                   	pop    %ebx
  807c46:	5e                   	pop    %esi
  807c47:	5d                   	pop    %ebp
  807c48:	c3                   	ret    

00807c49 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  807c49:	55                   	push   %ebp
  807c4a:	89 e5                	mov    %esp,%ebp
  807c4c:	57                   	push   %edi
  807c4d:	56                   	push   %esi
  807c4e:	53                   	push   %ebx
  807c4f:	83 ec 2c             	sub    $0x2c,%esp
  807c52:	8b 45 08             	mov    0x8(%ebp),%eax
  807c55:	8b 7d 10             	mov    0x10(%ebp),%edi
  807c58:	0f b7 5d 0c          	movzwl 0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  807c5c:	83 f8 01             	cmp    $0x1,%eax
  807c5f:	74 21                	je     807c82 <pbuf_alloc+0x39>
  807c61:	ba 14 00 00 00       	mov    $0x14,%edx
  807c66:	83 f8 01             	cmp    $0x1,%eax
  807c69:	72 1c                	jb     807c87 <pbuf_alloc+0x3e>
  807c6b:	83 f8 02             	cmp    $0x2,%eax
  807c6e:	74 0a                	je     807c7a <pbuf_alloc+0x31>
  807c70:	83 f8 03             	cmp    $0x3,%eax
  807c73:	75 1e                	jne    807c93 <pbuf_alloc+0x4a>
  807c75:	8d 76 00             	lea    0x0(%esi),%esi
  807c78:	eb 35                	jmp    807caf <pbuf_alloc+0x66>
  807c7a:	ba 00 00 00 00       	mov    $0x0,%edx
  807c7f:	90                   	nop
  807c80:	eb 08                	jmp    807c8a <pbuf_alloc+0x41>
  807c82:	ba 00 00 00 00       	mov    $0x0,%edx
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  807c87:	83 c2 14             	add    $0x14,%edx
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  807c8a:	83 c2 0e             	add    $0xe,%edx
  807c8d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    break;
  807c91:	eb 22                	jmp    807cb5 <pbuf_alloc+0x6c>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  807c93:	c7 44 24 08 b4 34 81 	movl   $0x8134b4,0x8(%esp)
  807c9a:	00 
  807c9b:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  807ca2:	00 
  807ca3:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807caa:	e8 65 8c ff ff       	call   800914 <_panic>
  807caf:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
    return NULL;
  }

  switch (type) {
  807cb5:	83 ff 02             	cmp    $0x2,%edi
  807cb8:	77 0e                	ja     807cc8 <pbuf_alloc+0x7f>
  807cba:	83 ff 01             	cmp    $0x1,%edi
  807cbd:	0f 83 bf 01 00 00    	jae    807e82 <pbuf_alloc+0x239>
  807cc3:	e9 78 01 00 00       	jmp    807e40 <pbuf_alloc+0x1f7>
  807cc8:	83 ff 03             	cmp    $0x3,%edi
  807ccb:	90                   	nop
  807ccc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  807cd0:	0f 85 da 01 00 00    	jne    807eb0 <pbuf_alloc+0x267>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  807cd6:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807cdd:	8d 76 00             	lea    0x0(%esi),%esi
  807ce0:	e8 63 f5 ff ff       	call   807248 <memp_malloc>
  807ce5:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  807ce7:	85 c0                	test   %eax,%eax
  807ce9:	0f 84 e7 01 00 00    	je     807ed6 <pbuf_alloc+0x28d>
      return NULL;
    }
    p->type = type;
  807cef:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  807cf3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  807cf9:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807cfd:	8d 54 06 13          	lea    0x13(%esi,%eax,1),%edx
  807d01:	83 e2 fc             	and    $0xfffffffc,%edx
  807d04:	89 56 04             	mov    %edx,0x4(%esi)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  807d07:	66 89 5e 08          	mov    %bx,0x8(%esi)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  807d0b:	0f b7 db             	movzwl %bx,%ebx
  807d0e:	83 c0 03             	add    $0x3,%eax
  807d11:	89 c1                	mov    %eax,%ecx
  807d13:	83 e1 fc             	and    $0xfffffffc,%ecx
  807d16:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  807d1b:	29 c8                	sub    %ecx,%eax
  807d1d:	39 d8                	cmp    %ebx,%eax
  807d1f:	0f 4f c3             	cmovg  %ebx,%eax
  807d22:	89 c1                	mov    %eax,%ecx
  807d24:	66 89 46 0a          	mov    %ax,0xa(%esi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  807d28:	8d 86 e0 07 00 00    	lea    0x7e0(%esi),%eax
  807d2e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807d31:	0f b7 c1             	movzwl %cx,%eax
  807d34:	01 c2                	add    %eax,%edx
  807d36:	3b 55 e4             	cmp    -0x1c(%ebp),%edx
  807d39:	76 1c                	jbe    807d57 <pbuf_alloc+0x10e>
  807d3b:	c7 44 24 08 0c 33 81 	movl   $0x81330c,0x8(%esp)
  807d42:	00 
  807d43:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  807d4a:	00 
  807d4b:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807d52:	e8 bd 8b ff ff       	call   800914 <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  807d57:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  807d5d:	0f b7 c9             	movzwl %cx,%ecx
  807d60:	29 cb                	sub    %ecx,%ebx
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  807d62:	85 db                	test   %ebx,%ebx
  807d64:	0f 8e 62 01 00 00    	jle    807ecc <pbuf_alloc+0x283>
  807d6a:	89 f7                	mov    %esi,%edi
      q = memp_malloc(MEMP_PBUF_POOL);
  807d6c:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807d73:	e8 d0 f4 ff ff       	call   807248 <memp_malloc>
      if (q == NULL) {
  807d78:	85 c0                	test   %eax,%eax
  807d7a:	75 12                	jne    807d8e <pbuf_alloc+0x145>
        /* free chain so far allocated */
        pbuf_free(p);
  807d7c:	89 34 24             	mov    %esi,(%esp)
  807d7f:	e8 09 fc ff ff       	call   80798d <pbuf_free>
  807d84:	be 00 00 00 00       	mov    $0x0,%esi
        /* bail out unsuccesfully */
        return NULL;
  807d89:	e9 48 01 00 00       	jmp    807ed6 <pbuf_alloc+0x28d>
      }
      q->type = type;
  807d8e:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  807d92:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  807d96:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  807d9c:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  807d9e:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  807da4:	7e 1c                	jle    807dc2 <pbuf_alloc+0x179>
  807da6:	c7 44 24 08 cf 34 81 	movl   $0x8134cf,0x8(%esp)
  807dad:	00 
  807dae:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  807db5:	00 
  807db6:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807dbd:	e8 52 8b ff ff       	call   800914 <_panic>
      q->tot_len = (u16_t)rem_len;
  807dc2:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  807dc6:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  807dcb:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
  807dd0:	0f 46 cb             	cmovbe %ebx,%ecx
  807dd3:	66 89 48 0a          	mov    %cx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  807dd7:	8d 50 10             	lea    0x10(%eax),%edx
  807dda:	89 50 04             	mov    %edx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  807ddd:	f6 c2 03             	test   $0x3,%dl
  807de0:	74 1c                	je     807dfe <pbuf_alloc+0x1b5>
  807de2:	c7 44 24 08 40 33 81 	movl   $0x813340,0x8(%esp)
  807de9:	00 
  807dea:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  807df1:	00 
  807df2:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807df9:	e8 16 8b ff ff       	call   800914 <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  807dfe:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  807e02:	03 56 04             	add    0x4(%esi),%edx
  807e05:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  807e08:	73 1c                	jae    807e26 <pbuf_alloc+0x1dd>
  807e0a:	c7 44 24 08 0c 33 81 	movl   $0x81330c,0x8(%esp)
  807e11:	00 
  807e12:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  807e19:	00 
  807e1a:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807e21:	e8 ee 8a ff ff       	call   800914 <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  807e26:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  807e2c:	0f b7 c9             	movzwl %cx,%ecx
  807e2f:	29 cb                	sub    %ecx,%ebx
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  807e31:	85 db                	test   %ebx,%ebx
  807e33:	0f 8e 93 00 00 00    	jle    807ecc <pbuf_alloc+0x283>
  807e39:	89 c7                	mov    %eax,%edi
  807e3b:	e9 2c ff ff ff       	jmp    807d6c <pbuf_alloc+0x123>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  807e40:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  807e44:	8d 57 13             	lea    0x13(%edi),%edx
  807e47:	83 e2 fc             	and    $0xfffffffc,%edx
  807e4a:	0f b7 c3             	movzwl %bx,%eax
  807e4d:	83 c0 03             	add    $0x3,%eax
  807e50:	83 e0 fc             	and    $0xfffffffc,%eax
  807e53:	8d 04 02             	lea    (%edx,%eax,1),%eax
  807e56:	89 04 24             	mov    %eax,(%esp)
  807e59:	e8 92 ed ff ff       	call   806bf0 <mem_malloc>
  807e5e:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  807e60:	85 c0                	test   %eax,%eax
  807e62:	74 72                	je     807ed6 <pbuf_alloc+0x28d>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  807e64:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  807e68:	83 e0 fc             	and    $0xfffffffc,%eax
  807e6b:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  807e6e:	66 89 5e 08          	mov    %bx,0x8(%esi)
  807e72:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  807e76:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  807e7c:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  807e80:	eb 4a                	jmp    807ecc <pbuf_alloc+0x283>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  807e82:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  807e89:	e8 ba f3 ff ff       	call   807248 <memp_malloc>
  807e8e:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  807e90:	85 c0                	test   %eax,%eax
  807e92:	74 42                	je     807ed6 <pbuf_alloc+0x28d>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  807e94:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  807e9b:	66 89 58 08          	mov    %bx,0x8(%eax)
  807e9f:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  807ea3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  807ea9:	89 f8                	mov    %edi,%eax
  807eab:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  807eae:	eb 1c                	jmp    807ecc <pbuf_alloc+0x283>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  807eb0:	c7 44 24 08 e3 34 81 	movl   $0x8134e3,0x8(%esp)
  807eb7:	00 
  807eb8:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  807ebf:	00 
  807ec0:	c7 04 24 6d 33 81 00 	movl   $0x81336d,(%esp)
  807ec7:	e8 48 8a ff ff       	call   800914 <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  807ecc:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  807ed2:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  807ed6:	89 f0                	mov    %esi,%eax
  807ed8:	83 c4 2c             	add    $0x2c,%esp
  807edb:	5b                   	pop    %ebx
  807edc:	5e                   	pop    %esi
  807edd:	5f                   	pop    %edi
  807ede:	5d                   	pop    %ebp
  807edf:	c3                   	ret    

00807ee0 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  807ee0:	55                   	push   %ebp
  807ee1:	89 e5                	mov    %esp,%ebp
  807ee3:	83 ec 18             	sub    $0x18,%esp
  807ee6:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  807ee9:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  807eee:	8b 40 04             	mov    0x4(%eax),%eax
  807ef1:	8b 00                	mov    (%eax),%eax
  807ef3:	89 04 24             	mov    %eax,(%esp)
  807ef6:	e8 7c 57 00 00       	call   80d677 <sys_sem_signal>
}
  807efb:	c9                   	leave  
  807efc:	c3                   	ret    

00807efd <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  807efd:	55                   	push   %ebp
  807efe:	89 e5                	mov    %esp,%ebp
  807f00:	57                   	push   %edi
  807f01:	56                   	push   %esi
  807f02:	53                   	push   %ebx
  807f03:	83 ec 1c             	sub    $0x1c,%esp
  807f06:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807f09:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  807f0c:	e8 3a 52 00 00       	call   80d14b <sys_arch_timeouts>

  if (timeouts == NULL) {
  807f11:	85 c0                	test   %eax,%eax
  807f13:	75 1c                	jne    807f31 <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  807f15:	c7 44 24 08 00 35 81 	movl   $0x813500,0x8(%esp)
  807f1c:	00 
  807f1d:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  807f24:	00 
  807f25:	c7 04 24 20 35 81 00 	movl   $0x813520,(%esp)
  807f2c:	e8 e3 89 ff ff       	call   800914 <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  807f31:	8b 10                	mov    (%eax),%edx
  807f33:	85 d2                	test   %edx,%edx
  807f35:	74 4b                	je     807f82 <sys_untimeout+0x85>
  807f37:	bf 00 00 00 00       	mov    $0x0,%edi
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == h) && (t->arg == arg)) {
  807f3c:	39 5a 08             	cmp    %ebx,0x8(%edx)
  807f3f:	75 33                	jne    807f74 <sys_untimeout+0x77>
  807f41:	39 72 0c             	cmp    %esi,0xc(%edx)
  807f44:	75 2e                	jne    807f74 <sys_untimeout+0x77>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  807f46:	85 ff                	test   %edi,%edi
  807f48:	75 08                	jne    807f52 <sys_untimeout+0x55>
        timeouts->next = t->next;
  807f4a:	8b 0a                	mov    (%edx),%ecx
  807f4c:	89 08                	mov    %ecx,(%eax)
  807f4e:	66 90                	xchg   %ax,%ax
  807f50:	eb 04                	jmp    807f56 <sys_untimeout+0x59>
      else
        prev_t->next = t->next;
  807f52:	8b 02                	mov    (%edx),%eax
  807f54:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  807f56:	8b 02                	mov    (%edx),%eax
  807f58:	85 c0                	test   %eax,%eax
  807f5a:	74 06                	je     807f62 <sys_untimeout+0x65>
        t->next->time += t->time;
  807f5c:	8b 4a 04             	mov    0x4(%edx),%ecx
  807f5f:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  807f62:	89 54 24 04          	mov    %edx,0x4(%esp)
  807f66:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  807f6d:	e8 92 f2 ff ff       	call   807204 <memp_free>
      return;
  807f72:	eb 0e                	jmp    807f82 <sys_untimeout+0x85>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  807f74:	8b 0a                	mov    (%edx),%ecx
  807f76:	85 c9                	test   %ecx,%ecx
  807f78:	74 08                	je     807f82 <sys_untimeout+0x85>
  807f7a:	89 d7                	mov    %edx,%edi
  807f7c:	89 ca                	mov    %ecx,%edx
  807f7e:	66 90                	xchg   %ax,%ax
  807f80:	eb ba                	jmp    807f3c <sys_untimeout+0x3f>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  807f82:	83 c4 1c             	add    $0x1c,%esp
  807f85:	5b                   	pop    %ebx
  807f86:	5e                   	pop    %esi
  807f87:	5f                   	pop    %edi
  807f88:	5d                   	pop    %ebp
  807f89:	c3                   	ret    

00807f8a <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  807f8a:	55                   	push   %ebp
  807f8b:	89 e5                	mov    %esp,%ebp
  807f8d:	56                   	push   %esi
  807f8e:	53                   	push   %ebx
  807f8f:	83 ec 10             	sub    $0x10,%esp
  807f92:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  807f95:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  807f9c:	e8 a7 f2 ff ff       	call   807248 <memp_malloc>
  807fa1:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  807fa3:	85 c0                	test   %eax,%eax
  807fa5:	75 1c                	jne    807fc3 <sys_timeout+0x39>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  807fa7:	c7 44 24 08 34 35 81 	movl   $0x813534,0x8(%esp)
  807fae:	00 
  807faf:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  807fb6:	00 
  807fb7:	c7 04 24 20 35 81 00 	movl   $0x813520,(%esp)
  807fbe:	e8 51 89 ff ff       	call   800914 <_panic>
    return;
  }
  timeout->next = NULL;
  807fc3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  807fc9:	8b 45 0c             	mov    0xc(%ebp),%eax
  807fcc:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  807fcf:	8b 45 10             	mov    0x10(%ebp),%eax
  807fd2:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  807fd5:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  807fd8:	e8 6e 51 00 00       	call   80d14b <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  807fdd:	85 c0                	test   %eax,%eax
  807fdf:	75 1c                	jne    807ffd <sys_timeout+0x73>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  807fe1:	c7 44 24 08 51 35 81 	movl   $0x813551,0x8(%esp)
  807fe8:	00 
  807fe9:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  807ff0:	00 
  807ff1:	c7 04 24 20 35 81 00 	movl   $0x813520,(%esp)
  807ff8:	e8 17 89 ff ff       	call   800914 <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  807ffd:	8b 10                	mov    (%eax),%edx
  807fff:	85 d2                	test   %edx,%edx
  808001:	75 04                	jne    808007 <sys_timeout+0x7d>
    timeouts->next = timeout;
  808003:	89 18                	mov    %ebx,(%eax)
    return;
  808005:	eb 4c                	jmp    808053 <sys_timeout+0xc9>
  }

  if (timeouts->next->time > msecs) {
  808007:	8b 4a 04             	mov    0x4(%edx),%ecx
  80800a:	39 ce                	cmp    %ecx,%esi
  80800c:	73 2d                	jae    80803b <sys_timeout+0xb1>
    timeouts->next->time -= msecs;
  80800e:	29 f1                	sub    %esi,%ecx
  808010:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  808013:	8b 10                	mov    (%eax),%edx
  808015:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  808017:	89 18                	mov    %ebx,(%eax)
  808019:	eb 38                	jmp    808053 <sys_timeout+0xc9>
  80801b:	89 c2                	mov    %eax,%edx
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  80801d:	8b 73 04             	mov    0x4(%ebx),%esi
  808020:	2b 70 04             	sub    0x4(%eax),%esi
  808023:	89 73 04             	mov    %esi,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  808026:	8b 00                	mov    (%eax),%eax
  808028:	85 c0                	test   %eax,%eax
  80802a:	74 07                	je     808033 <sys_timeout+0xa9>
  80802c:	3b 70 04             	cmp    0x4(%eax),%esi
  80802f:	73 ea                	jae    80801b <sys_timeout+0x91>
  808031:	eb 1b                	jmp    80804e <sys_timeout+0xc4>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
  808033:	8b 02                	mov    (%edx),%eax
  808035:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  808037:	89 1a                	mov    %ebx,(%edx)
  808039:	eb 18                	jmp    808053 <sys_timeout+0xc9>
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  80803b:	8b 73 04             	mov    0x4(%ebx),%esi
  80803e:	29 ce                	sub    %ecx,%esi
  808040:	89 73 04             	mov    %esi,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  808043:	8b 02                	mov    (%edx),%eax
  808045:	85 c0                	test   %eax,%eax
  808047:	74 ea                	je     808033 <sys_timeout+0xa9>
  808049:	3b 70 04             	cmp    0x4(%eax),%esi
  80804c:	73 cd                	jae    80801b <sys_timeout+0x91>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  80804e:	29 70 04             	sub    %esi,0x4(%eax)
  808051:	eb e0                	jmp    808033 <sys_timeout+0xa9>
        t->next = timeout;
        break;
      }
    }
  }
}
  808053:	83 c4 10             	add    $0x10,%esp
  808056:	5b                   	pop    %ebx
  808057:	5e                   	pop    %esi
  808058:	5d                   	pop    %ebp
  808059:	c3                   	ret    

0080805a <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80805a:	55                   	push   %ebp
  80805b:	89 e5                	mov    %esp,%ebp
  80805d:	57                   	push   %edi
  80805e:	56                   	push   %esi
  80805f:	53                   	push   %ebx
  808060:	83 ec 1c             	sub    $0x1c,%esp
  808063:	8b 7d 08             	mov    0x8(%ebp),%edi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  808066:	e8 e0 50 00 00       	call   80d14b <sys_arch_timeouts>
  80806b:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80806d:	85 c0                	test   %eax,%eax
  80806f:	74 06                	je     808077 <sys_sem_wait+0x1d>
  808071:	8b 00                	mov    (%eax),%eax
  808073:	85 c0                	test   %eax,%eax
  808075:	75 12                	jne    808089 <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  808077:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80807e:	00 
  80807f:	89 3c 24             	mov    %edi,(%esp)
  808082:	e8 ff 52 00 00       	call   80d386 <sys_arch_sem_wait>

 again:

  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  808087:	eb 58                	jmp    8080e1 <sys_sem_wait+0x87>
    sys_arch_sem_wait(sem, 0);
  } else {
    if (timeouts->next->time > 0) {
  808089:	8b 40 04             	mov    0x4(%eax),%eax
  80808c:	85 c0                	test   %eax,%eax
  80808e:	74 11                	je     8080a1 <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  808090:	89 44 24 04          	mov    %eax,0x4(%esp)
  808094:	89 3c 24             	mov    %edi,(%esp)
  808097:	e8 ea 52 00 00       	call   80d386 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80809c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80809f:	75 29                	jne    8080ca <sys_sem_wait+0x70>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8080a1:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8080a3:	8b 10                	mov    (%eax),%edx
  8080a5:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  8080a7:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8080aa:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8080ad:	89 44 24 04          	mov    %eax,0x4(%esp)
  8080b1:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8080b8:	e8 47 f1 ff ff       	call   807204 <memp_free>
      if (h != NULL) {
  8080bd:	85 db                	test   %ebx,%ebx
  8080bf:	74 a5                	je     808066 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  8080c1:	89 34 24             	mov    %esi,(%esp)
  8080c4:	ff d3                	call   *%ebx
  8080c6:	66 90                	xchg   %ax,%ax
  8080c8:	eb 9c                	jmp    808066 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8080ca:	8b 13                	mov    (%ebx),%edx
  8080cc:	8b 4a 04             	mov    0x4(%edx),%ecx
  8080cf:	39 c8                	cmp    %ecx,%eax
  8080d1:	73 07                	jae    8080da <sys_sem_wait+0x80>
        timeouts->next->time -= time_needed;
  8080d3:	29 c1                	sub    %eax,%ecx
  8080d5:	89 4a 04             	mov    %ecx,0x4(%edx)
  8080d8:	eb 07                	jmp    8080e1 <sys_sem_wait+0x87>
      } else {
        timeouts->next->time = 0;
  8080da:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  8080e1:	83 c4 1c             	add    $0x1c,%esp
  8080e4:	5b                   	pop    %ebx
  8080e5:	5e                   	pop    %esi
  8080e6:	5f                   	pop    %edi
  8080e7:	5d                   	pop    %ebp
  8080e8:	c3                   	ret    

008080e9 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8080e9:	55                   	push   %ebp
  8080ea:	89 e5                	mov    %esp,%ebp
  8080ec:	83 ec 28             	sub    $0x28,%esp
  8080ef:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8080f2:	8d 55 08             	lea    0x8(%ebp),%edx
  8080f5:	89 55 f4             	mov    %edx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8080f8:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8080fe:	85 c0                	test   %eax,%eax
  808100:	74 17                	je     808119 <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  808102:	8d 55 f0             	lea    -0x10(%ebp),%edx
  808105:	89 54 24 08          	mov    %edx,0x8(%esp)
  808109:	c7 44 24 04 e0 7e 80 	movl   $0x807ee0,0x4(%esp)
  808110:	00 
  808111:	89 04 24             	mov    %eax,(%esp)
  808114:	e8 71 fe ff ff       	call   807f8a <sys_timeout>
  }
  sys_sem_wait(sem);
  808119:	8b 45 08             	mov    0x8(%ebp),%eax
  80811c:	89 04 24             	mov    %eax,(%esp)
  80811f:	e8 36 ff ff ff       	call   80805a <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  808124:	b8 00 00 00 00       	mov    $0x0,%eax
  808129:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80812e:	75 18                	jne    808148 <sys_sem_wait_timeout+0x5f>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  808130:	8d 45 f0             	lea    -0x10(%ebp),%eax
  808133:	89 44 24 04          	mov    %eax,0x4(%esp)
  808137:	c7 04 24 e0 7e 80 00 	movl   $0x807ee0,(%esp)
  80813e:	e8 ba fd ff ff       	call   807efd <sys_untimeout>
  808143:	b8 01 00 00 00       	mov    $0x1,%eax
    return 1;
  }
}
  808148:	c9                   	leave  
  808149:	c3                   	ret    

0080814a <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80814a:	55                   	push   %ebp
  80814b:	89 e5                	mov    %esp,%ebp
  80814d:	53                   	push   %ebx
  80814e:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  808151:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808158:	e8 78 53 00 00       	call   80d4d5 <sys_sem_new>
  80815d:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  80815f:	8b 45 08             	mov    0x8(%ebp),%eax
  808162:	89 44 24 04          	mov    %eax,0x4(%esp)
  808166:	89 1c 24             	mov    %ebx,(%esp)
  808169:	e8 7b ff ff ff       	call   8080e9 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  80816e:	89 1c 24             	mov    %ebx,(%esp)
  808171:	e8 9d 4e 00 00       	call   80d013 <sys_sem_free>
}
  808176:	83 c4 14             	add    $0x14,%esp
  808179:	5b                   	pop    %ebx
  80817a:	5d                   	pop    %ebp
  80817b:	c3                   	ret    

0080817c <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80817c:	55                   	push   %ebp
  80817d:	89 e5                	mov    %esp,%ebp
  80817f:	57                   	push   %edi
  808180:	56                   	push   %esi
  808181:	53                   	push   %ebx
  808182:	83 ec 1c             	sub    $0x1c,%esp
  808185:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  808188:	e8 be 4f 00 00       	call   80d14b <sys_arch_timeouts>
  80818d:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80818f:	85 c0                	test   %eax,%eax
  808191:	74 06                	je     808199 <sys_mbox_fetch+0x1d>
  808193:	8b 00                	mov    (%eax),%eax
  808195:	85 c0                	test   %eax,%eax
  808197:	75 19                	jne    8081b2 <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  808199:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8081a0:	00 
  8081a1:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8081a5:	8b 45 08             	mov    0x8(%ebp),%eax
  8081a8:	89 04 24             	mov    %eax,(%esp)
  8081ab:	e8 53 55 00 00       	call   80d703 <sys_arch_mbox_fetch>
  void *arg;

 again:
  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  8081b0:	eb 5f                	jmp    808211 <sys_mbox_fetch+0x95>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  8081b2:	8b 40 04             	mov    0x4(%eax),%eax
  8081b5:	85 c0                	test   %eax,%eax
  8081b7:	74 18                	je     8081d1 <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8081b9:	89 44 24 08          	mov    %eax,0x8(%esp)
  8081bd:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8081c1:	8b 45 08             	mov    0x8(%ebp),%eax
  8081c4:	89 04 24             	mov    %eax,(%esp)
  8081c7:	e8 37 55 00 00       	call   80d703 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8081cc:	83 f8 ff             	cmp    $0xffffffff,%eax
  8081cf:	75 29                	jne    8081fa <sys_mbox_fetch+0x7e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8081d1:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8081d3:	8b 10                	mov    (%eax),%edx
  8081d5:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8081d7:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8081da:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8081dd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8081e1:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8081e8:	e8 17 f0 ff ff       	call   807204 <memp_free>
      if (h != NULL) {
  8081ed:	85 db                	test   %ebx,%ebx
  8081ef:	74 97                	je     808188 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  8081f1:	89 34 24             	mov    %esi,(%esp)
  8081f4:	ff d3                	call   *%ebx
  8081f6:	66 90                	xchg   %ax,%ax
  8081f8:	eb 8e                	jmp    808188 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8081fa:	8b 13                	mov    (%ebx),%edx
  8081fc:	8b 4a 04             	mov    0x4(%edx),%ecx
  8081ff:	39 c8                	cmp    %ecx,%eax
  808201:	73 07                	jae    80820a <sys_mbox_fetch+0x8e>
        timeouts->next->time -= time_needed;
  808203:	29 c1                	sub    %eax,%ecx
  808205:	89 4a 04             	mov    %ecx,0x4(%edx)
  808208:	eb 07                	jmp    808211 <sys_mbox_fetch+0x95>
      } else {
        timeouts->next->time = 0;
  80820a:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  808211:	83 c4 1c             	add    $0x1c,%esp
  808214:	5b                   	pop    %ebx
  808215:	5e                   	pop    %esi
  808216:	5f                   	pop    %edi
  808217:	5d                   	pop    %ebp
  808218:	c3                   	ret    
  808219:	00 00                	add    %al,(%eax)
  80821b:	00 00                	add    %al,(%eax)
  80821d:	00 00                	add    %al,(%eax)
	...

00808220 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  808220:	55                   	push   %ebp
  808221:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  808223:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  808228:	5d                   	pop    %ebp
  808229:	c3                   	ret    

0080822a <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80822a:	55                   	push   %ebp
  80822b:	89 e5                	mov    %esp,%ebp
  80822d:	57                   	push   %edi
  80822e:	56                   	push   %esi
  80822f:	53                   	push   %ebx
  808230:	83 ec 08             	sub    $0x8,%esp
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808233:	8b 0d 0c f0 b3 00    	mov    0xb3f00c,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808239:	8b 1d 20 f0 b3 00    	mov    0xb3f020,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80823f:	a1 14 f0 b3 00       	mov    0xb3f014,%eax
  808244:	89 45 f0             	mov    %eax,-0x10(%ebp)
  808247:	0f b7 15 48 50 81 00 	movzwl 0x815048,%edx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80824e:	be 00 10 00 00       	mov    $0x1000,%esi
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  808253:	89 cf                	mov    %ecx,%edi
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  808255:	66 83 c2 01          	add    $0x1,%dx
  808259:	0f 48 d6             	cmovs  %esi,%edx
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80825c:	85 c9                	test   %ecx,%ecx
  80825e:	74 19                	je     808279 <tcp_new_port+0x4f>
    if (pcb->local_port == port) {
  808260:	89 f8                	mov    %edi,%eax
  808262:	66 3b 51 1c          	cmp    0x1c(%ecx),%dx
  808266:	75 0a                	jne    808272 <tcp_new_port+0x48>
  808268:	eb eb                	jmp    808255 <tcp_new_port+0x2b>
  80826a:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  80826e:	66 90                	xchg   %ax,%ax
  808270:	74 e3                	je     808255 <tcp_new_port+0x2b>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808272:	8b 40 0c             	mov    0xc(%eax),%eax
  808275:	85 c0                	test   %eax,%eax
  808277:	75 f1                	jne    80826a <tcp_new_port+0x40>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808279:	85 db                	test   %ebx,%ebx
  80827b:	74 1c                	je     808299 <tcp_new_port+0x6f>
    if (pcb->local_port == port) {
  80827d:	89 d8                	mov    %ebx,%eax
  80827f:	66 3b 53 1c          	cmp    0x1c(%ebx),%dx
  808283:	75 0d                	jne    808292 <tcp_new_port+0x68>
  808285:	eb ce                	jmp    808255 <tcp_new_port+0x2b>
  808287:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  80828b:	90                   	nop
  80828c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  808290:	74 c3                	je     808255 <tcp_new_port+0x2b>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808292:	8b 40 0c             	mov    0xc(%eax),%eax
  808295:	85 c0                	test   %eax,%eax
  808297:	75 ee                	jne    808287 <tcp_new_port+0x5d>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  808299:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  80829d:	8d 76 00             	lea    0x0(%esi),%esi
  8082a0:	75 09                	jne    8082ab <tcp_new_port+0x81>
  8082a2:	66 89 15 48 50 81 00 	mov    %dx,0x815048
  8082a9:	eb 30                	jmp    8082db <tcp_new_port+0xb1>
    if (pcb->local_port == port) {
  8082ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8082ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
  8082b1:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  8082b5:	75 13                	jne    8082ca <tcp_new_port+0xa0>
  8082b7:	eb 9c                	jmp    808255 <tcp_new_port+0x2b>
  8082b9:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  8082bd:	8d 76 00             	lea    0x0(%esi),%esi
  8082c0:	75 0b                	jne    8082cd <tcp_new_port+0xa3>
  8082c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  8082c8:	eb 8b                	jmp    808255 <tcp_new_port+0x2b>
  8082ca:	8b 45 ec             	mov    -0x14(%ebp),%eax
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8082cd:	8b 40 0c             	mov    0xc(%eax),%eax
  8082d0:	85 c0                	test   %eax,%eax
  8082d2:	75 e5                	jne    8082b9 <tcp_new_port+0x8f>
  8082d4:	66 89 15 48 50 81 00 	mov    %dx,0x815048
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  8082db:	0f b7 05 48 50 81 00 	movzwl 0x815048,%eax
  8082e2:	83 c4 08             	add    $0x8,%esp
  8082e5:	5b                   	pop    %ebx
  8082e6:	5e                   	pop    %esi
  8082e7:	5f                   	pop    %edi
  8082e8:	5d                   	pop    %ebp
  8082e9:	c3                   	ret    

008082ea <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8082ea:	55                   	push   %ebp
  8082eb:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8082ed:	8b 55 0c             	mov    0xc(%ebp),%edx
  8082f0:	8b 45 08             	mov    0x8(%ebp),%eax
  8082f3:	88 50 14             	mov    %dl,0x14(%eax)
}
  8082f6:	5d                   	pop    %ebp
  8082f7:	c3                   	ret    

008082f8 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8082f8:	55                   	push   %ebp
  8082f9:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  8082fb:	8b 55 0c             	mov    0xc(%ebp),%edx
  8082fe:	8b 45 08             	mov    0x8(%ebp),%eax
  808301:	89 50 18             	mov    %edx,0x18(%eax)
}
  808304:	5d                   	pop    %ebp
  808305:	c3                   	ret    

00808306 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  808306:	55                   	push   %ebp
  808307:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  808309:	8b 55 0c             	mov    0xc(%ebp),%edx
  80830c:	8b 45 08             	mov    0x8(%ebp),%eax
  80830f:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  808315:	5d                   	pop    %ebp
  808316:	c3                   	ret    

00808317 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  808317:	55                   	push   %ebp
  808318:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  80831a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80831d:	8b 45 08             	mov    0x8(%ebp),%eax
  808320:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  808326:	5d                   	pop    %ebp
  808327:	c3                   	ret    

00808328 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  808328:	55                   	push   %ebp
  808329:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  80832b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80832e:	8b 45 08             	mov    0x8(%ebp),%eax
  808331:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  808337:	5d                   	pop    %ebp
  808338:	c3                   	ret    

00808339 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  808339:	55                   	push   %ebp
  80833a:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  80833c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80833f:	8b 45 08             	mov    0x8(%ebp),%eax
  808342:	89 50 20             	mov    %edx,0x20(%eax)
}
  808345:	5d                   	pop    %ebp
  808346:	c3                   	ret    

00808347 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  808347:	55                   	push   %ebp
  808348:	89 e5                	mov    %esp,%ebp
  80834a:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  80834d:	8b 55 0c             	mov    0xc(%ebp),%edx
  808350:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  808356:	8b 55 10             	mov    0x10(%ebp),%edx
  808359:	88 50 31             	mov    %dl,0x31(%eax)
}
  80835c:	5d                   	pop    %ebp
  80835d:	c3                   	ret    

0080835e <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  80835e:	55                   	push   %ebp
  80835f:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  808361:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  808366:	03 05 44 50 81 00    	add    0x815044,%eax
  80836c:	a3 44 50 81 00       	mov    %eax,0x815044
  return iss;
}
  808371:	5d                   	pop    %ebp
  808372:	c3                   	ret    

00808373 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  808373:	55                   	push   %ebp
  808374:	89 e5                	mov    %esp,%ebp
  808376:	53                   	push   %ebx
  808377:	83 ec 14             	sub    $0x14,%esp
  80837a:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80837e:	8b 45 0c             	mov    0xc(%ebp),%eax
  808381:	89 04 24             	mov    %eax,(%esp)
  808384:	e8 e8 11 00 00       	call   809571 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  808389:	85 c0                	test   %eax,%eax
  80838b:	74 12                	je     80839f <tcp_eff_send_mss+0x2c>
  80838d:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  808391:	66 85 c0             	test   %ax,%ax
  808394:	74 09                	je     80839f <tcp_eff_send_mss+0x2c>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  808396:	83 e8 28             	sub    $0x28,%eax
  808399:	66 39 c3             	cmp    %ax,%bx
  80839c:	0f 47 d8             	cmova  %eax,%ebx
  }
  return sendmss;
}
  80839f:	89 d8                	mov    %ebx,%eax
  8083a1:	83 c4 14             	add    $0x14,%esp
  8083a4:	5b                   	pop    %ebx
  8083a5:	5d                   	pop    %ebp
  8083a6:	c3                   	ret    

008083a7 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  8083a7:	55                   	push   %ebp
  8083a8:	89 e5                	mov    %esp,%ebp
  8083aa:	83 ec 18             	sub    $0x18,%esp
  8083ad:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8083b0:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8083b3:	8b 45 08             	mov    0x8(%ebp),%eax
  8083b6:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  8083ba:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  8083be:	0f b7 f1             	movzwl %cx,%esi
  8083c1:	0f b7 da             	movzwl %dx,%ebx
  8083c4:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  8083c7:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  8083cd:	76 0e                	jbe    8083dd <tcp_recved+0x36>
    pcb->rcv_wnd = TCP_WND;
  8083cf:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  8083d5:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  8083db:	eb 11                	jmp    8083ee <tcp_recved+0x47>
  } else {
    pcb->rcv_wnd += len;
  8083dd:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  8083e0:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  8083e4:	66 3b 50 34          	cmp    0x34(%eax),%dx
  8083e8:	72 04                	jb     8083ee <tcp_recved+0x47>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8083ea:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  8083ee:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  8083f2:	f6 c2 03             	test   $0x3,%dl
  8083f5:	75 20                	jne    808417 <tcp_recved+0x70>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  8083f7:	f6 c2 01             	test   $0x1,%dl
  8083fa:	74 13                	je     80840f <tcp_recved+0x68>
  8083fc:	83 e2 fe             	and    $0xfffffffe,%edx
  8083ff:	83 ca 02             	or     $0x2,%edx
  808402:	88 50 20             	mov    %dl,0x20(%eax)
  808405:	89 04 24             	mov    %eax,(%esp)
  808408:	e8 fe 29 00 00       	call   80ae0b <tcp_output>
  80840d:	eb 23                	jmp    808432 <tcp_recved+0x8b>
  80840f:	83 ca 01             	or     $0x1,%edx
  808412:	88 50 20             	mov    %dl,0x20(%eax)
  808415:	eb 1b                	jmp    808432 <tcp_recved+0x8b>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  808417:	f6 c2 01             	test   $0x1,%dl
  80841a:	74 16                	je     808432 <tcp_recved+0x8b>
  80841c:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  808422:	76 0e                	jbe    808432 <tcp_recved+0x8b>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  808424:	83 ca 02             	or     $0x2,%edx
  808427:	88 50 20             	mov    %dl,0x20(%eax)
  80842a:	89 04 24             	mov    %eax,(%esp)
  80842d:	e8 d9 29 00 00       	call   80ae0b <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  808432:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808435:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808438:	89 ec                	mov    %ebp,%esp
  80843a:	5d                   	pop    %ebp
  80843b:	c3                   	ret    

0080843c <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  80843c:	55                   	push   %ebp
  80843d:	89 e5                	mov    %esp,%ebp
  80843f:	53                   	push   %ebx
  808440:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808443:	8b 1d 0c f0 b3 00    	mov    0xb3f00c,%ebx
  808449:	85 db                	test   %ebx,%ebx
  80844b:	74 6b                	je     8084b8 <tcp_fasttmr+0x7c>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80844d:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  808453:	85 c0                	test   %eax,%eax
  808455:	74 40                	je     808497 <tcp_fasttmr+0x5b>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  808457:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80845d:	85 d2                	test   %edx,%edx
  80845f:	74 1e                	je     80847f <tcp_fasttmr+0x43>
  808461:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  808468:	00 
  808469:	89 44 24 08          	mov    %eax,0x8(%esp)
  80846d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808471:	8b 43 18             	mov    0x18(%ebx),%eax
  808474:	89 04 24             	mov    %eax,(%esp)
  808477:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  808479:	84 c0                	test   %al,%al
  80847b:	75 1a                	jne    808497 <tcp_fasttmr+0x5b>
  80847d:	eb 0e                	jmp    80848d <tcp_fasttmr+0x51>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80847f:	89 04 24             	mov    %eax,(%esp)
  808482:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  808488:	e8 00 f5 ff ff       	call   80798d <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80848d:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  808494:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  808497:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80849b:	a8 01                	test   $0x1,%al
  80849d:	74 12                	je     8084b1 <tcp_fasttmr+0x75>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  80849f:	83 c8 02             	or     $0x2,%eax
  8084a2:	88 43 20             	mov    %al,0x20(%ebx)
  8084a5:	89 1c 24             	mov    %ebx,(%esp)
  8084a8:	e8 5e 29 00 00       	call   80ae0b <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8084ad:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8084b1:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  8084b4:	85 db                	test   %ebx,%ebx
  8084b6:	75 95                	jne    80844d <tcp_fasttmr+0x11>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  8084b8:	83 c4 14             	add    $0x14,%esp
  8084bb:	5b                   	pop    %ebx
  8084bc:	5d                   	pop    %ebp
  8084bd:	c3                   	ret    

008084be <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  8084be:	55                   	push   %ebp
  8084bf:	89 e5                	mov    %esp,%ebp
  8084c1:	53                   	push   %ebx
  8084c2:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  8084c5:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  8084cc:	e8 77 ed ff ff       	call   807248 <memp_malloc>
  8084d1:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  8084d3:	85 c0                	test   %eax,%eax
  8084d5:	74 22                	je     8084f9 <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  8084d7:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8084de:	00 
  8084df:	8b 45 08             	mov    0x8(%ebp),%eax
  8084e2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8084e6:	89 1c 24             	mov    %ebx,(%esp)
  8084e9:	e8 83 8e ff ff       	call   801371 <memcpy>
  pbuf_ref(cseg->p);
  8084ee:	8b 43 04             	mov    0x4(%ebx),%eax
  8084f1:	89 04 24             	mov    %eax,(%esp)
  8084f4:	e8 51 f0 ff ff       	call   80754a <pbuf_ref>
  return cseg;
}
  8084f9:	89 d8                	mov    %ebx,%eax
  8084fb:	83 c4 14             	add    $0x14,%esp
  8084fe:	5b                   	pop    %ebx
  8084ff:	5d                   	pop    %ebp
  808500:	c3                   	ret    

00808501 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  808501:	55                   	push   %ebp
  808502:	89 e5                	mov    %esp,%ebp
  808504:	83 ec 18             	sub    $0x18,%esp
  808507:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80850a:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80850d:	8b 75 08             	mov    0x8(%ebp),%esi
  u8_t count = 0;
  
  if (seg != NULL) {
  808510:	bb 00 00 00 00       	mov    $0x0,%ebx
  808515:	85 f6                	test   %esi,%esi
  808517:	74 21                	je     80853a <tcp_seg_free+0x39>
    if (seg->p != NULL) {
  808519:	8b 46 04             	mov    0x4(%esi),%eax
  80851c:	85 c0                	test   %eax,%eax
  80851e:	74 0a                	je     80852a <tcp_seg_free+0x29>
      count = pbuf_free(seg->p);
  808520:	89 04 24             	mov    %eax,(%esp)
  808523:	e8 65 f4 ff ff       	call   80798d <pbuf_free>
  808528:	89 c3                	mov    %eax,%ebx
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  80852a:	89 74 24 04          	mov    %esi,0x4(%esp)
  80852e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808535:	e8 ca ec ff ff       	call   807204 <memp_free>
  }
  return count;
}
  80853a:	89 d8                	mov    %ebx,%eax
  80853c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80853f:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808542:	89 ec                	mov    %ebp,%esp
  808544:	5d                   	pop    %ebp
  808545:	c3                   	ret    

00808546 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  808546:	55                   	push   %ebp
  808547:	89 e5                	mov    %esp,%ebp
  808549:	56                   	push   %esi
  80854a:	53                   	push   %ebx
  80854b:	83 ec 10             	sub    $0x10,%esp
  80854e:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808551:	be 00 00 00 00       	mov    $0x0,%esi
  808556:	85 c0                	test   %eax,%eax
  808558:	74 14                	je     80856e <tcp_segs_free+0x28>
    next = seg->next;
  80855a:	8b 18                	mov    (%eax),%ebx
    count += tcp_seg_free(seg);
  80855c:	89 04 24             	mov    %eax,(%esp)
  80855f:	e8 9d ff ff ff       	call   808501 <tcp_seg_free>
  808564:	01 c6                	add    %eax,%esi
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808566:	85 db                	test   %ebx,%ebx
  808568:	74 04                	je     80856e <tcp_segs_free+0x28>
  80856a:	89 d8                	mov    %ebx,%eax
  80856c:	eb ec                	jmp    80855a <tcp_segs_free+0x14>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  80856e:	89 f0                	mov    %esi,%eax
  808570:	83 c4 10             	add    $0x10,%esp
  808573:	5b                   	pop    %ebx
  808574:	5e                   	pop    %esi
  808575:	5d                   	pop    %ebp
  808576:	c3                   	ret    

00808577 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  808577:	55                   	push   %ebp
  808578:	89 e5                	mov    %esp,%ebp
  80857a:	53                   	push   %ebx
  80857b:	83 ec 14             	sub    $0x14,%esp
  80857e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  808581:	8b 43 10             	mov    0x10(%ebx),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  808584:	85 c0                	test   %eax,%eax
  808586:	74 62                	je     8085ea <tcp_pcb_purge+0x73>
  808588:	83 f8 0a             	cmp    $0xa,%eax
  80858b:	74 5d                	je     8085ea <tcp_pcb_purge+0x73>
  80858d:	83 f8 01             	cmp    $0x1,%eax
  808590:	74 58                	je     8085ea <tcp_pcb_purge+0x73>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  808592:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  808598:	85 c0                	test   %eax,%eax
  80859a:	74 12                	je     8085ae <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  80859c:	89 04 24             	mov    %eax,(%esp)
  80859f:	e8 e9 f3 ff ff       	call   80798d <pbuf_free>
      pcb->refused_data = NULL;
  8085a4:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8085ab:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  8085ae:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  8085b4:	8b 43 7c             	mov    0x7c(%ebx),%eax
  8085b7:	89 04 24             	mov    %eax,(%esp)
  8085ba:	e8 87 ff ff ff       	call   808546 <tcp_segs_free>
    pcb->ooseq = NULL;
  8085bf:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  8085c6:	8b 43 74             	mov    0x74(%ebx),%eax
  8085c9:	89 04 24             	mov    %eax,(%esp)
  8085cc:	e8 75 ff ff ff       	call   808546 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  8085d1:	8b 43 78             	mov    0x78(%ebx),%eax
  8085d4:	89 04 24             	mov    %eax,(%esp)
  8085d7:	e8 6a ff ff ff       	call   808546 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  8085dc:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  8085e3:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  8085ea:	83 c4 14             	add    $0x14,%esp
  8085ed:	5b                   	pop    %ebx
  8085ee:	5d                   	pop    %ebp
  8085ef:	c3                   	ret    

008085f0 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  8085f0:	55                   	push   %ebp
  8085f1:	89 e5                	mov    %esp,%ebp
  8085f3:	53                   	push   %ebx
  8085f4:	83 ec 14             	sub    $0x14,%esp
  8085f7:	8b 45 08             	mov    0x8(%ebp),%eax
  8085fa:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  8085fd:	8b 10                	mov    (%eax),%edx
  8085ff:	39 da                	cmp    %ebx,%edx
  808601:	75 07                	jne    80860a <tcp_pcb_remove+0x1a>
  808603:	8b 52 0c             	mov    0xc(%edx),%edx
  808606:	89 10                	mov    %edx,(%eax)
  808608:	eb 2a                	jmp    808634 <tcp_pcb_remove+0x44>
  80860a:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  808610:	85 d2                	test   %edx,%edx
  808612:	74 20                	je     808634 <tcp_pcb_remove+0x44>
  808614:	8b 42 0c             	mov    0xc(%edx),%eax
  808617:	85 c0                	test   %eax,%eax
  808619:	0f 84 c0 00 00 00    	je     8086df <tcp_pcb_remove+0xef>
  80861f:	39 c3                	cmp    %eax,%ebx
  808621:	75 08                	jne    80862b <tcp_pcb_remove+0x3b>
  808623:	8b 43 0c             	mov    0xc(%ebx),%eax
  808626:	89 42 0c             	mov    %eax,0xc(%edx)
  808629:	eb 09                	jmp    808634 <tcp_pcb_remove+0x44>
  80862b:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808630:	89 c2                	mov    %eax,%edx
  808632:	eb e0                	jmp    808614 <tcp_pcb_remove+0x24>
  808634:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  80863b:	89 1c 24             	mov    %ebx,(%esp)
  80863e:	e8 34 ff ff ff       	call   808577 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  808643:	8b 43 10             	mov    0x10(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  808646:	83 f8 0a             	cmp    $0xa,%eax
  808649:	74 1b                	je     808666 <tcp_pcb_remove+0x76>
  80864b:	83 f8 01             	cmp    $0x1,%eax
  80864e:	74 16                	je     808666 <tcp_pcb_remove+0x76>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  808650:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  808654:	a8 01                	test   $0x1,%al
  808656:	74 0e                	je     808666 <tcp_pcb_remove+0x76>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  808658:	83 c8 02             	or     $0x2,%eax
  80865b:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  80865e:	89 1c 24             	mov    %ebx,(%esp)
  808661:	e8 a5 27 00 00       	call   80ae0b <tcp_output>
  }

  if (pcb->state != LISTEN) {
  808666:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  80866a:	74 66                	je     8086d2 <tcp_pcb_remove+0xe2>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  80866c:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  808670:	74 1c                	je     80868e <tcp_pcb_remove+0x9e>
  808672:	c7 44 24 08 6f 35 81 	movl   $0x81356f,0x8(%esp)
  808679:	00 
  80867a:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  808681:	00 
  808682:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808689:	e8 86 82 ff ff       	call   800914 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  80868e:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  808692:	74 1c                	je     8086b0 <tcp_pcb_remove+0xc0>
  808694:	c7 44 24 08 9b 35 81 	movl   $0x81359b,0x8(%esp)
  80869b:	00 
  80869c:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  8086a3:	00 
  8086a4:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  8086ab:	e8 64 82 ff ff       	call   800914 <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  8086b0:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  8086b4:	74 1c                	je     8086d2 <tcp_pcb_remove+0xe2>
  8086b6:	c7 44 24 08 b4 35 81 	movl   $0x8135b4,0x8(%esp)
  8086bd:	00 
  8086be:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  8086c5:	00 
  8086c6:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  8086cd:	e8 42 82 ff ff       	call   800914 <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  8086d2:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  8086d9:	83 c4 14             	add    $0x14,%esp
  8086dc:	5b                   	pop    %ebx
  8086dd:	5d                   	pop    %ebp
  8086de:	c3                   	ret    
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
  8086df:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  8086e4:	e9 4b ff ff ff       	jmp    808634 <tcp_pcb_remove+0x44>

008086e9 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  8086e9:	55                   	push   %ebp
  8086ea:	89 e5                	mov    %esp,%ebp
  8086ec:	83 ec 18             	sub    $0x18,%esp
  8086ef:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8086f2:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8086f5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  8086f8:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8086fc:	74 1c                	je     80871a <tcp_listen_with_backlog+0x31>
  8086fe:	c7 44 24 08 cc 35 81 	movl   $0x8135cc,0x8(%esp)
  808705:	00 
  808706:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  80870d:	00 
  80870e:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808715:	e8 fa 81 ff ff       	call   800914 <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  80871a:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  808721:	e8 22 eb ff ff       	call   807248 <memp_malloc>
  808726:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  808728:	b8 00 00 00 00       	mov    $0x0,%eax
  80872d:	85 f6                	test   %esi,%esi
  80872f:	0f 84 a8 00 00 00    	je     8087dd <tcp_listen_with_backlog+0xf4>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  808735:	8b 43 18             	mov    0x18(%ebx),%eax
  808738:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  80873b:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  80873f:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  808743:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  80874a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80874e:	83 c8 02             	or     $0x2,%eax
  808751:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  808755:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  808759:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  80875c:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  808760:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  808763:	b8 00 00 00 00       	mov    $0x0,%eax
  808768:	85 db                	test   %ebx,%ebx
  80876a:	74 02                	je     80876e <tcp_listen_with_backlog+0x85>
  80876c:	8b 03                	mov    (%ebx),%eax
  80876e:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808770:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  808776:	39 da                	cmp    %ebx,%edx
  808778:	75 0a                	jne    808784 <tcp_listen_with_backlog+0x9b>
  80877a:	8b 42 0c             	mov    0xc(%edx),%eax
  80877d:	a3 1c f0 b3 00       	mov    %eax,0xb3f01c
  808782:	eb 26                	jmp    8087aa <tcp_listen_with_backlog+0xc1>
  808784:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  80878a:	85 d2                	test   %edx,%edx
  80878c:	74 1c                	je     8087aa <tcp_listen_with_backlog+0xc1>
  80878e:	8b 42 0c             	mov    0xc(%edx),%eax
  808791:	85 c0                	test   %eax,%eax
  808793:	74 52                	je     8087e7 <tcp_listen_with_backlog+0xfe>
  808795:	39 c3                	cmp    %eax,%ebx
  808797:	75 08                	jne    8087a1 <tcp_listen_with_backlog+0xb8>
  808799:	8b 43 0c             	mov    0xc(%ebx),%eax
  80879c:	89 42 0c             	mov    %eax,0xc(%edx)
  80879f:	eb 09                	jmp    8087aa <tcp_listen_with_backlog+0xc1>
  8087a1:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  8087a6:	89 c2                	mov    %eax,%edx
  8087a8:	eb e4                	jmp    80878e <tcp_listen_with_backlog+0xa5>
  8087aa:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  8087b1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8087b5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8087bc:	e8 43 ea ff ff       	call   807204 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  8087c1:	c7 46 20 20 82 80 00 	movl   $0x808220,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  8087c8:	a1 14 f0 b3 00       	mov    0xb3f014,%eax
  8087cd:	89 46 0c             	mov    %eax,0xc(%esi)
  8087d0:	89 35 14 f0 b3 00    	mov    %esi,0xb3f014
  8087d6:	e8 52 c2 ff ff       	call   804a2d <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  8087db:	89 f0                	mov    %esi,%eax
}
  8087dd:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8087e0:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8087e3:	89 ec                	mov    %ebp,%esp
  8087e5:	5d                   	pop    %ebp
  8087e6:	c3                   	ret    
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8087e7:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  8087ec:	eb bc                	jmp    8087aa <tcp_listen_with_backlog+0xc1>

008087ee <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  8087ee:	55                   	push   %ebp
  8087ef:	89 e5                	mov    %esp,%ebp
  8087f1:	57                   	push   %edi
  8087f2:	56                   	push   %esi
  8087f3:	53                   	push   %ebx
  8087f4:	83 ec 1c             	sub    $0x1c,%esp
  8087f7:	8b 75 08             	mov    0x8(%ebp),%esi
  8087fa:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8087fd:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808801:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  808805:	74 1c                	je     808823 <tcp_bind+0x35>
  808807:	c7 44 24 08 f0 35 81 	movl   $0x8135f0,0x8(%esp)
  80880e:	00 
  80880f:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  808816:	00 
  808817:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  80881e:	e8 f1 80 ff ff       	call   800914 <_panic>

  if (port == 0) {
  808823:	66 85 c0             	test   %ax,%ax
  808826:	75 05                	jne    80882d <tcp_bind+0x3f>
    port = tcp_new_port();
  808828:	e8 fd f9 ff ff       	call   80822a <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80882d:	8b 15 14 f0 b3 00    	mov    0xb3f014,%edx
  808833:	85 d2                	test   %edx,%edx
  808835:	74 39                	je     808870 <tcp_bind+0x82>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  808837:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80883b:	75 2c                	jne    808869 <tcp_bind+0x7b>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80883d:	85 d2                	test   %edx,%edx
  80883f:	0f 84 e1 00 00 00    	je     808926 <tcp_bind+0x138>
  808845:	8b 0a                	mov    (%edx),%ecx
  808847:	85 c9                	test   %ecx,%ecx
  808849:	0f 84 d7 00 00 00    	je     808926 <tcp_bind+0x138>
  80884f:	85 db                	test   %ebx,%ebx
  808851:	0f 84 cf 00 00 00    	je     808926 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  808857:	8b 3b                	mov    (%ebx),%edi
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808859:	85 ff                	test   %edi,%edi
  80885b:	0f 84 c5 00 00 00    	je     808926 <tcp_bind+0x138>
  808861:	39 f9                	cmp    %edi,%ecx
  808863:	0f 84 bd 00 00 00    	je     808926 <tcp_bind+0x138>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  808869:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  80886c:	85 d2                	test   %edx,%edx
  80886e:	75 c7                	jne    808837 <tcp_bind+0x49>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  808870:	8b 15 0c f0 b3 00    	mov    0xb3f00c,%edx
  808876:	85 d2                	test   %edx,%edx
  808878:	74 35                	je     8088af <tcp_bind+0xc1>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  80887a:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  80887e:	75 28                	jne    8088a8 <tcp_bind+0xba>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808880:	85 d2                	test   %edx,%edx
  808882:	0f 84 9e 00 00 00    	je     808926 <tcp_bind+0x138>
  808888:	8b 0a                	mov    (%edx),%ecx
  80888a:	85 c9                	test   %ecx,%ecx
  80888c:	0f 84 94 00 00 00    	je     808926 <tcp_bind+0x138>
  808892:	85 db                	test   %ebx,%ebx
  808894:	0f 84 8c 00 00 00    	je     808926 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  80889a:	8b 3b                	mov    (%ebx),%edi
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  80889c:	85 ff                	test   %edi,%edi
  80889e:	0f 84 82 00 00 00    	je     808926 <tcp_bind+0x138>
  8088a4:	39 f9                	cmp    %edi,%ecx
  8088a6:	74 7e                	je     808926 <tcp_bind+0x138>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  8088a8:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  8088ab:	85 d2                	test   %edx,%edx
  8088ad:	75 cb                	jne    80887a <tcp_bind+0x8c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8088af:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  8088b5:	85 d2                	test   %edx,%edx
  8088b7:	74 25                	je     8088de <tcp_bind+0xf0>
    if (cpcb->local_port == port) {
  8088b9:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8088bd:	75 18                	jne    8088d7 <tcp_bind+0xe9>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8088bf:	85 d2                	test   %edx,%edx
  8088c1:	74 63                	je     808926 <tcp_bind+0x138>
  8088c3:	8b 0a                	mov    (%edx),%ecx
  8088c5:	85 c9                	test   %ecx,%ecx
  8088c7:	74 5d                	je     808926 <tcp_bind+0x138>
  8088c9:	85 db                	test   %ebx,%ebx
  8088cb:	74 59                	je     808926 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  8088cd:	8b 3b                	mov    (%ebx),%edi
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  8088cf:	85 ff                	test   %edi,%edi
  8088d1:	74 53                	je     808926 <tcp_bind+0x138>
  8088d3:	39 f9                	cmp    %edi,%ecx
  8088d5:	74 4f                	je     808926 <tcp_bind+0x138>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8088d7:	8b 52 0c             	mov    0xc(%edx),%edx
  8088da:	85 d2                	test   %edx,%edx
  8088dc:	75 db                	jne    8088b9 <tcp_bind+0xcb>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8088de:	8b 15 20 f0 b3 00    	mov    0xb3f020,%edx
  8088e4:	85 d2                	test   %edx,%edx
  8088e6:	74 13                	je     8088fb <tcp_bind+0x10d>
    if (cpcb->local_port == port) {
  8088e8:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  8088ec:	75 06                	jne    8088f4 <tcp_bind+0x106>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  8088ee:	8b 0a                	mov    (%edx),%ecx
  8088f0:	3b 0b                	cmp    (%ebx),%ecx
  8088f2:	74 32                	je     808926 <tcp_bind+0x138>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  8088f4:	8b 52 0c             	mov    0xc(%edx),%edx
  8088f7:	85 d2                	test   %edx,%edx
  8088f9:	75 ed                	jne    8088e8 <tcp_bind+0xfa>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  8088fb:	85 db                	test   %ebx,%ebx
  8088fd:	74 09                	je     808908 <tcp_bind+0x11a>
  8088ff:	83 3b 00             	cmpl   $0x0,(%ebx)
  808902:	74 04                	je     808908 <tcp_bind+0x11a>
    pcb->local_ip = *ipaddr;
  808904:	8b 13                	mov    (%ebx),%edx
  808906:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  808908:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80890c:	a1 1c f0 b3 00       	mov    0xb3f01c,%eax
  808911:	89 46 0c             	mov    %eax,0xc(%esi)
  808914:	89 35 1c f0 b3 00    	mov    %esi,0xb3f01c
  80891a:	e8 0e c1 ff ff       	call   804a2d <tcp_timer_needed>
  80891f:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  808924:	eb 05                	jmp    80892b <tcp_bind+0x13d>
  808926:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  80892b:	83 c4 1c             	add    $0x1c,%esp
  80892e:	5b                   	pop    %ebx
  80892f:	5e                   	pop    %esi
  808930:	5f                   	pop    %edi
  808931:	5d                   	pop    %ebp
  808932:	c3                   	ret    

00808933 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  808933:	55                   	push   %ebp
  808934:	89 e5                	mov    %esp,%ebp
  808936:	57                   	push   %edi
  808937:	56                   	push   %esi
  808938:	53                   	push   %ebx
  808939:	83 ec 3c             	sub    $0x3c,%esp
  80893c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80893f:	8b 7d 0c             	mov    0xc(%ebp),%edi
  808942:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808946:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80894a:	74 1c                	je     808968 <tcp_connect+0x35>
  80894c:	c7 44 24 08 1c 36 81 	movl   $0x81361c,0x8(%esp)
  808953:	00 
  808954:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  80895b:	00 
  80895c:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808963:	e8 ac 7f ff ff       	call   800914 <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  808968:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  80896d:	85 ff                	test   %edi,%edi
  80896f:	0f 84 28 01 00 00    	je     808a9d <tcp_connect+0x16a>
    pcb->remote_ip = *ipaddr;
  808975:	8b 17                	mov    (%edi),%edx
  808977:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80897a:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  80897e:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  808983:	75 09                	jne    80898e <tcp_connect+0x5b>
    pcb->local_port = tcp_new_port();
  808985:	e8 a0 f8 ff ff       	call   80822a <tcp_new_port>
  80898a:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  80898e:	e8 cb f9 ff ff       	call   80835e <tcp_next_iss>
  pcb->rcv_nxt = 0;
  808993:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  80899a:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  80899d:	83 e8 01             	sub    $0x1,%eax
  8089a0:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  8089a3:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  8089a6:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  8089ac:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  8089b2:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8089b8:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8089be:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8089c2:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  8089c9:	e8 a5 f9 ff ff       	call   808373 <tcp_eff_send_mss>
  8089ce:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  8089d2:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  8089d8:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8089db:	01 c0                	add    %eax,%eax
  8089dd:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8089e1:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  8089e8:	8b 45 14             	mov    0x14(%ebp),%eax
  8089eb:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  8089f1:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  8089f7:	39 da                	cmp    %ebx,%edx
  8089f9:	75 0a                	jne    808a05 <tcp_connect+0xd2>
  8089fb:	8b 42 0c             	mov    0xc(%edx),%eax
  8089fe:	a3 1c f0 b3 00       	mov    %eax,0xb3f01c
  808a03:	eb 2a                	jmp    808a2f <tcp_connect+0xfc>
  808a05:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  808a0b:	85 d2                	test   %edx,%edx
  808a0d:	74 20                	je     808a2f <tcp_connect+0xfc>
  808a0f:	8b 42 0c             	mov    0xc(%edx),%eax
  808a12:	85 c0                	test   %eax,%eax
  808a14:	0f 84 8d 00 00 00    	je     808aa7 <tcp_connect+0x174>
  808a1a:	39 c3                	cmp    %eax,%ebx
  808a1c:	75 08                	jne    808a26 <tcp_connect+0xf3>
  808a1e:	8b 43 0c             	mov    0xc(%ebx),%eax
  808a21:	89 42 0c             	mov    %eax,0xc(%edx)
  808a24:	eb 09                	jmp    808a2f <tcp_connect+0xfc>
  808a26:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808a2b:	89 c2                	mov    %eax,%edx
  808a2d:	eb e0                	jmp    808a0f <tcp_connect+0xdc>
  808a2f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  TCP_REG(&tcp_active_pcbs, pcb);
  808a36:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  808a3b:	89 43 0c             	mov    %eax,0xc(%ebx)
  808a3e:	89 1d 0c f0 b3 00    	mov    %ebx,0xb3f00c
  808a44:	e8 e4 bf ff ff       	call   804a2d <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  808a49:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  808a50:	e8 4f 1d 00 00       	call   80a7a4 <htonl>
  808a55:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  808a58:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  808a5f:	00 
  808a60:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  808a63:	89 44 24 14          	mov    %eax,0x14(%esp)
  808a67:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808a6e:	00 
  808a6f:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  808a76:	00 
  808a77:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808a7e:	00 
  808a7f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808a86:	00 
  808a87:	89 1c 24             	mov    %ebx,(%esp)
  808a8a:	e8 c9 28 00 00       	call   80b358 <tcp_enqueue>
  808a8f:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  808a91:	84 c0                	test   %al,%al
  808a93:	75 08                	jne    808a9d <tcp_connect+0x16a>
    tcp_output(pcb);
  808a95:	89 1c 24             	mov    %ebx,(%esp)
  808a98:	e8 6e 23 00 00       	call   80ae0b <tcp_output>
  }
  return ret;
} 
  808a9d:	89 f0                	mov    %esi,%eax
  808a9f:	83 c4 3c             	add    $0x3c,%esp
  808aa2:	5b                   	pop    %ebx
  808aa3:	5e                   	pop    %esi
  808aa4:	5f                   	pop    %edi
  808aa5:	5d                   	pop    %ebp
  808aa6:	c3                   	ret    
  pcb->ssthresh = pcb->mss * 10;
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808aa7:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  808aac:	eb 81                	jmp    808a2f <tcp_connect+0xfc>

00808aae <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  808aae:	55                   	push   %ebp
  808aaf:	89 e5                	mov    %esp,%ebp
  808ab1:	57                   	push   %edi
  808ab2:	56                   	push   %esi
  808ab3:	53                   	push   %ebx
  808ab4:	83 ec 4c             	sub    $0x4c,%esp
  808ab7:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  808aba:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  808abe:	75 25                	jne    808ae5 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  808ac0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808ac4:	c7 04 24 20 f0 b3 00 	movl   $0xb3f020,(%esp)
  808acb:	e8 20 fb ff ff       	call   8085f0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  808ad0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808ad4:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808adb:	e8 24 e7 ff ff       	call   807204 <memp_free>
  808ae0:	e9 d1 00 00 00       	jmp    808bb6 <tcp_abort+0x108>
  } else {
    seqno = pcb->snd_nxt;
  808ae5:	8b 43 54             	mov    0x54(%ebx),%eax
  808ae8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    ackno = pcb->rcv_nxt;
  808aeb:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  808aee:	b8 00 00 00 00       	mov    $0x0,%eax
  808af3:	85 db                	test   %ebx,%ebx
  808af5:	74 02                	je     808af9 <tcp_abort+0x4b>
  808af7:	8b 03                	mov    (%ebx),%eax
  808af9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  808afc:	b8 00 00 00 00       	mov    $0x0,%eax
  808b01:	83 fb fc             	cmp    $0xfffffffc,%ebx
  808b04:	74 03                	je     808b09 <tcp_abort+0x5b>
  808b06:	8b 43 04             	mov    0x4(%ebx),%eax
  808b09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  808b0c:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  808b10:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    remote_port = pcb->remote_port;
  808b14:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  808b18:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  808b1c:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  808b22:	8b 43 18             	mov    0x18(%ebx),%eax
  808b25:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  808b28:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808b2c:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  808b33:	e8 b8 fa ff ff       	call   8085f0 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  808b38:	8b 43 78             	mov    0x78(%ebx),%eax
  808b3b:	85 c0                	test   %eax,%eax
  808b3d:	74 08                	je     808b47 <tcp_abort+0x99>
      tcp_segs_free(pcb->unacked);
  808b3f:	89 04 24             	mov    %eax,(%esp)
  808b42:	e8 ff f9 ff ff       	call   808546 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  808b47:	8b 43 74             	mov    0x74(%ebx),%eax
  808b4a:	85 c0                	test   %eax,%eax
  808b4c:	74 08                	je     808b56 <tcp_abort+0xa8>
      tcp_segs_free(pcb->unsent);
  808b4e:	89 04 24             	mov    %eax,(%esp)
  808b51:	e8 f0 f9 ff ff       	call   808546 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  808b56:	8b 43 7c             	mov    0x7c(%ebx),%eax
  808b59:	85 c0                	test   %eax,%eax
  808b5b:	74 08                	je     808b65 <tcp_abort+0xb7>
      tcp_segs_free(pcb->ooseq);
  808b5d:	89 04 24             	mov    %eax,(%esp)
  808b60:	e8 e1 f9 ff ff       	call   808546 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  808b65:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808b69:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808b70:	e8 8f e6 ff ff       	call   807204 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  808b75:	85 f6                	test   %esi,%esi
  808b77:	74 10                	je     808b89 <tcp_abort+0xdb>
  808b79:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  808b80:	ff 
  808b81:	8b 45 cc             	mov    -0x34(%ebp),%eax
  808b84:	89 04 24             	mov    %eax,(%esp)
  808b87:	ff d6                	call   *%esi
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  808b89:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  808b8d:	89 44 24 14          	mov    %eax,0x14(%esp)
  808b91:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  808b95:	89 44 24 10          	mov    %eax,0x10(%esp)
  808b99:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  808b9c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808ba0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  808ba3:	89 44 24 08          	mov    %eax,0x8(%esp)
  808ba7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808bab:	8b 45 d0             	mov    -0x30(%ebp),%eax
  808bae:	89 04 24             	mov    %eax,(%esp)
  808bb1:	e8 f6 20 00 00       	call   80acac <tcp_rst>
  }
}
  808bb6:	83 c4 4c             	add    $0x4c,%esp
  808bb9:	5b                   	pop    %ebx
  808bba:	5e                   	pop    %esi
  808bbb:	5f                   	pop    %edi
  808bbc:	5d                   	pop    %ebp
  808bbd:	c3                   	ret    

00808bbe <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  808bbe:	55                   	push   %ebp
  808bbf:	89 e5                	mov    %esp,%ebp
  808bc1:	83 ec 38             	sub    $0x38,%esp
  808bc4:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  808bc7:	89 75 f8             	mov    %esi,-0x8(%ebp)
  808bca:	89 7d fc             	mov    %edi,-0x4(%ebp)
  808bcd:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  808bd1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808bd8:	e8 6b e6 ff ff       	call   807248 <memp_malloc>
  808bdd:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  808bdf:	85 c0                	test   %eax,%eax
  808be1:	0f 85 c9 00 00 00    	jne    808cb0 <tcp_alloc+0xf2>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808be7:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  808bec:	85 c0                	test   %eax,%eax
  808bee:	74 36                	je     808c26 <tcp_alloc+0x68>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  808bf0:	8b 1d 10 f0 b3 00    	mov    0xb3f010,%ebx
  808bf6:	bf 00 00 00 00       	mov    $0x0,%edi
  808bfb:	b9 00 00 00 00       	mov    $0x0,%ecx
  808c00:	89 da                	mov    %ebx,%edx
  808c02:	2b 50 2c             	sub    0x2c(%eax),%edx
  808c05:	39 ca                	cmp    %ecx,%edx
  808c07:	72 04                	jb     808c0d <tcp_alloc+0x4f>
  808c09:	89 c7                	mov    %eax,%edi
  808c0b:	eb 02                	jmp    808c0f <tcp_alloc+0x51>
  808c0d:	89 ca                	mov    %ecx,%edx
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808c0f:	8b 40 0c             	mov    0xc(%eax),%eax
  808c12:	85 c0                	test   %eax,%eax
  808c14:	74 04                	je     808c1a <tcp_alloc+0x5c>
  808c16:	89 d1                	mov    %edx,%ecx
  808c18:	eb e6                	jmp    808c00 <tcp_alloc+0x42>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  808c1a:	85 ff                	test   %edi,%edi
  808c1c:	74 08                	je     808c26 <tcp_alloc+0x68>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  808c1e:	89 3c 24             	mov    %edi,(%esp)
  808c21:	e8 88 fe ff ff       	call   808aae <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  808c26:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808c2d:	e8 16 e6 ff ff       	call   807248 <memp_malloc>
  808c32:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  808c34:	85 c0                	test   %eax,%eax
  808c36:	75 78                	jne    808cb0 <tcp_alloc+0xf2>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808c38:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  808c3d:	85 c0                	test   %eax,%eax
  808c3f:	74 59                	je     808c9a <tcp_alloc+0xdc>
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  808c41:	8b 15 10 f0 b3 00    	mov    0xb3f010,%edx
  808c47:	89 55 e0             	mov    %edx,-0x20(%ebp)
  808c4a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  808c51:	bf 00 00 00 00       	mov    $0x0,%edi
  808c56:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  808c5b:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  808c5f:	89 f3                	mov    %esi,%ebx
  808c61:	38 d3                	cmp    %dl,%bl
  808c63:	72 13                	jb     808c78 <tcp_alloc+0xba>
  808c65:	38 ca                	cmp    %cl,%dl
  808c67:	77 0f                	ja     808c78 <tcp_alloc+0xba>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  808c69:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  808c6c:	2b 58 2c             	sub    0x2c(%eax),%ebx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  808c6f:	39 df                	cmp    %ebx,%edi
  808c71:	77 05                	ja     808c78 <tcp_alloc+0xba>
  808c73:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808c76:	eb 04                	jmp    808c7c <tcp_alloc+0xbe>
  808c78:	89 ca                	mov    %ecx,%edx
  808c7a:	89 fb                	mov    %edi,%ebx
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808c7c:	8b 40 0c             	mov    0xc(%eax),%eax
  808c7f:	85 c0                	test   %eax,%eax
  808c81:	74 06                	je     808c89 <tcp_alloc+0xcb>
  808c83:	89 df                	mov    %ebx,%edi
  808c85:	89 d1                	mov    %edx,%ecx
  808c87:	eb d2                	jmp    808c5b <tcp_alloc+0x9d>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  808c89:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  808c8d:	74 0b                	je     808c9a <tcp_alloc+0xdc>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  808c8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808c92:	89 04 24             	mov    %eax,(%esp)
  808c95:	e8 14 fe ff ff       	call   808aae <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  808c9a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808ca1:	e8 a2 e5 ff ff       	call   807248 <memp_malloc>
  808ca6:	89 c3                	mov    %eax,%ebx
    }
  }
  if (pcb != NULL) {
  808ca8:	85 c0                	test   %eax,%eax
  808caa:	0f 84 9b 00 00 00    	je     808d4b <tcp_alloc+0x18d>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  808cb0:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  808cb7:	00 
  808cb8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808cbf:	00 
  808cc0:	89 1c 24             	mov    %ebx,(%esp)
  808cc3:	e8 ce 85 ff ff       	call   801296 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  808cc8:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  808ccc:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  808cd2:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  808cd8:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  808cde:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  808ce4:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  808ce8:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  808cec:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  808cf2:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  808cf8:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  808cfe:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  808d04:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  808d0a:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  808d10:	e8 49 f6 ff ff       	call   80835e <tcp_next_iss>
    pcb->snd_wl2 = iss;
  808d15:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  808d18:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  808d1b:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  808d1e:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  808d21:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  808d24:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  808d29:	89 43 2c             	mov    %eax,0x2c(%ebx)

    pcb->polltmr = 0;
  808d2c:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  808d30:	c7 83 88 00 00 00 3f 	movl   $0x80933f,0x88(%ebx)
  808d37:	93 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  808d3a:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  808d41:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  808d44:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  }
  return pcb;
}
  808d4b:	89 d8                	mov    %ebx,%eax
  808d4d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  808d50:	8b 75 f8             	mov    -0x8(%ebp),%esi
  808d53:	8b 7d fc             	mov    -0x4(%ebp),%edi
  808d56:	89 ec                	mov    %ebp,%esp
  808d58:	5d                   	pop    %ebp
  808d59:	c3                   	ret    

00808d5a <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  808d5a:	55                   	push   %ebp
  808d5b:	89 e5                	mov    %esp,%ebp
  808d5d:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  808d60:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  808d67:	e8 52 fe ff ff       	call   808bbe <tcp_alloc>
}
  808d6c:	c9                   	leave  
  808d6d:	c3                   	ret    

00808d6e <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  808d6e:	55                   	push   %ebp
  808d6f:	89 e5                	mov    %esp,%ebp
  808d71:	57                   	push   %edi
  808d72:	56                   	push   %esi
  808d73:	53                   	push   %ebx
  808d74:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  808d77:	83 05 10 f0 b3 00 01 	addl   $0x1,0xb3f010

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  808d7e:	8b 1d 0c f0 b3 00    	mov    0xb3f00c,%ebx
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  808d84:	85 db                	test   %ebx,%ebx
  808d86:	0f 84 5d 03 00 00    	je     8090e9 <tcp_slowtmr+0x37b>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  808d8c:	8b 43 10             	mov    0x10(%ebx),%eax
  808d8f:	85 c0                	test   %eax,%eax
  808d91:	74 1c                	je     808daf <tcp_slowtmr+0x41>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  808d93:	83 f8 01             	cmp    $0x1,%eax
  808d96:	74 38                	je     808dd0 <tcp_slowtmr+0x62>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  808d98:	83 f8 0a             	cmp    $0xa,%eax
  808d9b:	74 54                	je     808df1 <tcp_slowtmr+0x83>
  808d9d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  808da1:	bf 00 00 00 00       	mov    $0x0,%edi
  808da6:	eb 67                	jmp    808e0f <tcp_slowtmr+0xa1>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  808da8:	8b 46 10             	mov    0x10(%esi),%eax
  808dab:	85 c0                	test   %eax,%eax
  808dad:	75 1c                	jne    808dcb <tcp_slowtmr+0x5d>
  808daf:	c7 44 24 08 50 36 81 	movl   $0x813650,0x8(%esp)
  808db6:	00 
  808db7:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  808dbe:	00 
  808dbf:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808dc6:	e8 49 7b ff ff       	call   800914 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  808dcb:	83 f8 01             	cmp    $0x1,%eax
  808dce:	75 1c                	jne    808dec <tcp_slowtmr+0x7e>
  808dd0:	c7 44 24 08 7c 36 81 	movl   $0x81367c,0x8(%esp)
  808dd7:	00 
  808dd8:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  808ddf:	00 
  808de0:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808de7:	e8 28 7b ff ff       	call   800914 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  808dec:	83 f8 0a             	cmp    $0xa,%eax
  808def:	75 1c                	jne    808e0d <tcp_slowtmr+0x9f>
  808df1:	c7 44 24 08 a8 36 81 	movl   $0x8136a8,0x8(%esp)
  808df8:	00 
  808df9:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  808e00:	00 
  808e01:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  808e08:	e8 07 7b ff ff       	call   800914 <_panic>
  808e0d:	89 f3                	mov    %esi,%ebx

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  808e0f:	83 f8 02             	cmp    $0x2,%eax
  808e12:	75 0a                	jne    808e1e <tcp_slowtmr+0xb0>
  808e14:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  808e18:	0f 84 ef 00 00 00    	je     808f0d <tcp_slowtmr+0x19f>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  808e1e:	80 7b 46 0c          	cmpb   $0xc,0x46(%ebx)
  808e22:	0f 84 e5 00 00 00    	je     808f0d <tcp_slowtmr+0x19f>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  808e28:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  808e2f:	90                   	nop
  808e30:	74 55                	je     808e87 <tcp_slowtmr+0x119>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  808e32:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  808e38:	83 c0 01             	add    $0x1,%eax
  808e3b:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  808e41:	0f b6 93 a4 00 00 00 	movzbl 0xa4(%ebx),%edx
  808e48:	0f b6 92 dc 37 81 00 	movzbl 0x8137dc(%edx),%edx
  808e4f:	39 d0                	cmp    %edx,%eax
  808e51:	0f 82 bd 00 00 00    	jb     808f14 <tcp_slowtmr+0x1a6>
          pcb->persist_cnt = 0;
  808e57:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  808e5e:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  808e61:	0f b6 83 a4 00 00 00 	movzbl 0xa4(%ebx),%eax
  808e68:	3c 06                	cmp    $0x6,%al
  808e6a:	77 09                	ja     808e75 <tcp_slowtmr+0x107>
            pcb->persist_backoff++;
  808e6c:	83 c0 01             	add    $0x1,%eax
  808e6f:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  808e75:	89 1c 24             	mov    %ebx,(%esp)
  808e78:	e8 63 1b 00 00       	call   80a9e0 <tcp_zero_window_probe>
  808e7d:	be 00 00 00 00       	mov    $0x0,%esi
  808e82:	e9 92 00 00 00       	jmp    808f19 <tcp_slowtmr+0x1ab>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  808e87:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  808e8b:	66 85 c0             	test   %ax,%ax
  808e8e:	78 07                	js     808e97 <tcp_slowtmr+0x129>
          ++pcb->rtime;
  808e90:	83 c0 01             	add    $0x1,%eax
  808e93:	66 89 43 32          	mov    %ax,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  808e97:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  808e9b:	74 77                	je     808f14 <tcp_slowtmr+0x1a6>
  808e9d:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  808ea1:	66 3b 43 44          	cmp    0x44(%ebx),%ax
  808ea5:	7c 6d                	jl     808f14 <tcp_slowtmr+0x1a6>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  808ea7:	83 7b 10 02          	cmpl   $0x2,0x10(%ebx)
  808eab:	74 20                	je     808ecd <tcp_slowtmr+0x15f>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  808ead:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  808eb1:	66 c1 f8 03          	sar    $0x3,%ax
  808eb5:	98                   	cwtl   
  808eb6:	0f bf 53 42          	movswl 0x42(%ebx),%edx
  808eba:	01 d0                	add    %edx,%eax
  808ebc:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  808ec0:	0f b6 8a d0 37 81 00 	movzbl 0x8137d0(%edx),%ecx
  808ec7:	d3 e0                	shl    %cl,%eax
  808ec9:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  808ecd:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  808ed3:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  808ed7:	66 39 43 4e          	cmp    %ax,0x4e(%ebx)
  808edb:	66 0f 46 43 4e       	cmovbe 0x4e(%ebx),%ax
  808ee0:	66 d1 e8             	shr    %ax
  808ee3:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  808ee7:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  808eeb:	66 39 d0             	cmp    %dx,%ax
  808eee:	73 06                	jae    808ef6 <tcp_slowtmr+0x188>
            pcb->ssthresh = pcb->mss * 2;
  808ef0:	01 d2                	add    %edx,%edx
  808ef2:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  808ef6:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  808efa:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  808efe:	89 1c 24             	mov    %ebx,(%esp)
  808f01:	e8 fd 23 00 00       	call   80b303 <tcp_rexmit_rto>
  808f06:	be 00 00 00 00       	mov    $0x0,%esi
  808f0b:	eb 0c                	jmp    808f19 <tcp_slowtmr+0x1ab>
  808f0d:	be 01 00 00 00       	mov    $0x1,%esi
  808f12:	eb 05                	jmp    808f19 <tcp_slowtmr+0x1ab>
  808f14:	be 00 00 00 00       	mov    $0x0,%esi
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  808f19:	8b 43 10             	mov    0x10(%ebx),%eax
  808f1c:	83 f8 06             	cmp    $0x6,%eax
  808f1f:	75 13                	jne    808f34 <tcp_slowtmr+0x1c6>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  808f21:	8b 15 10 f0 b3 00    	mov    0xb3f010,%edx
  808f27:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  808f2a:	83 fa 29             	cmp    $0x29,%edx
  808f2d:	89 f2                	mov    %esi,%edx
  808f2f:	80 da ff             	sbb    $0xff,%dl
  808f32:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  808f34:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  808f38:	74 6a                	je     808fa4 <tcp_slowtmr+0x236>
  808f3a:	83 f8 04             	cmp    $0x4,%eax
  808f3d:	74 05                	je     808f44 <tcp_slowtmr+0x1d6>
  808f3f:	83 f8 07             	cmp    $0x7,%eax
  808f42:	75 60                	jne    808fa4 <tcp_slowtmr+0x236>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  808f44:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  808f49:	2b 43 2c             	sub    0x2c(%ebx),%eax
  808f4c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  808f4f:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  808f55:	8d 81 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%eax
  808f5b:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  808f60:	f7 e2                	mul    %edx
  808f62:	c1 ea 05             	shr    $0x5,%edx
  808f65:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  808f68:	76 0a                	jbe    808f74 <tcp_slowtmr+0x206>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  808f6a:	89 1c 24             	mov    %ebx,(%esp)
  808f6d:	e8 3c fb ff ff       	call   808aae <tcp_abort>
  808f72:	eb 30                	jmp    808fa4 <tcp_slowtmr+0x236>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  808f74:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  808f7b:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  808f81:	8d 0c 0a             	lea    (%edx,%ecx,1),%ecx
  808f84:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  808f89:	89 c8                	mov    %ecx,%eax
  808f8b:	f7 e2                	mul    %edx
  808f8d:	c1 ea 05             	shr    $0x5,%edx
  808f90:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  808f93:	76 0f                	jbe    808fa4 <tcp_slowtmr+0x236>
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  808f95:	89 1c 24             	mov    %ebx,(%esp)
  808f98:	e8 ba 1b 00 00       	call   80ab57 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  808f9d:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  808fa4:	8b 53 7c             	mov    0x7c(%ebx),%edx
  808fa7:	85 d2                	test   %edx,%edx
  808fa9:	74 25                	je     808fd0 <tcp_slowtmr+0x262>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  808fab:	8b 0d 10 f0 b3 00    	mov    0xb3f010,%ecx
  808fb1:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  808fb4:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  808fb8:	8d 04 40             	lea    (%eax,%eax,2),%eax
  808fbb:	01 c0                	add    %eax,%eax
  808fbd:	39 c1                	cmp    %eax,%ecx
  808fbf:	72 0f                	jb     808fd0 <tcp_slowtmr+0x262>
      tcp_segs_free(pcb->ooseq);
  808fc1:	89 14 24             	mov    %edx,(%esp)
  808fc4:	e8 7d f5 ff ff       	call   808546 <tcp_segs_free>
      pcb->ooseq = NULL;
  808fc9:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  808fd0:	8b 43 10             	mov    0x10(%ebx),%eax
  808fd3:	83 f8 03             	cmp    $0x3,%eax
  808fd6:	75 13                	jne    808feb <tcp_slowtmr+0x27d>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  808fd8:	8b 15 10 f0 b3 00    	mov    0xb3f010,%edx
  808fde:	2b 53 2c             	sub    0x2c(%ebx),%edx
  808fe1:	83 fa 28             	cmp    $0x28,%edx
  808fe4:	76 05                	jbe    808feb <tcp_slowtmr+0x27d>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  808fe6:	83 c6 01             	add    $0x1,%esi
  808fe9:	eb 19                	jmp    809004 <tcp_slowtmr+0x296>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  808feb:	83 f8 09             	cmp    $0x9,%eax
  808fee:	75 14                	jne    809004 <tcp_slowtmr+0x296>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  808ff0:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  808ff5:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  808ff8:	3d f1 00 00 00       	cmp    $0xf1,%eax
  808ffd:	89 f2                	mov    %esi,%edx
  808fff:	80 da ff             	sbb    $0xff,%dl
  809002:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  809004:	89 f0                	mov    %esi,%eax
  809006:	84 c0                	test   %al,%al
  809008:	0f 84 94 00 00 00    	je     8090a2 <tcp_slowtmr+0x334>
      tcp_pcb_purge(pcb);      
  80900e:	89 1c 24             	mov    %ebx,(%esp)
  809011:	e8 61 f5 ff ff       	call   808577 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  809016:	85 ff                	test   %edi,%edi
  809018:	74 2c                	je     809046 <tcp_slowtmr+0x2d8>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80901a:	3b 1d 0c f0 b3 00    	cmp    0xb3f00c,%ebx
  809020:	75 1c                	jne    80903e <tcp_slowtmr+0x2d0>
  809022:	c7 44 24 08 d8 36 81 	movl   $0x8136d8,0x8(%esp)
  809029:	00 
  80902a:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  809031:	00 
  809032:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  809039:	e8 d6 78 ff ff       	call   800914 <_panic>
        prev->next = pcb->next;
  80903e:	8b 43 0c             	mov    0xc(%ebx),%eax
  809041:	89 47 0c             	mov    %eax,0xc(%edi)
  809044:	eb 2d                	jmp    809073 <tcp_slowtmr+0x305>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  809046:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  80904b:	39 d8                	cmp    %ebx,%eax
  80904d:	74 1c                	je     80906b <tcp_slowtmr+0x2fd>
  80904f:	c7 44 24 08 04 37 81 	movl   $0x813704,0x8(%esp)
  809056:	00 
  809057:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  80905e:	00 
  80905f:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  809066:	e8 a9 78 ff ff       	call   800914 <_panic>
        tcp_active_pcbs = pcb->next;
  80906b:	8b 40 0c             	mov    0xc(%eax),%eax
  80906e:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  809073:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  809079:	85 c0                	test   %eax,%eax
  80907b:	74 10                	je     80908d <tcp_slowtmr+0x31f>
  80907d:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  809084:	ff 
  809085:	8b 53 18             	mov    0x18(%ebx),%edx
  809088:	89 14 24             	mov    %edx,(%esp)
  80908b:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  80908d:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  809090:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809094:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80909b:	e8 64 e1 ff ff       	call   807204 <memp_free>
  8090a0:	eb 3f                	jmp    8090e1 <tcp_slowtmr+0x373>
      pcb = pcb2;
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  8090a2:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  8090a6:	83 c0 01             	add    $0x1,%eax
  8090a9:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  8090ac:	3a 43 31             	cmp    0x31(%ebx),%al
  8090af:	72 2b                	jb     8090dc <tcp_slowtmr+0x36e>
        pcb->polltmr = 0;
  8090b1:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  8090b5:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  8090bb:	85 c0                	test   %eax,%eax
  8090bd:	74 0f                	je     8090ce <tcp_slowtmr+0x360>
  8090bf:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8090c3:	8b 53 18             	mov    0x18(%ebx),%edx
  8090c6:	89 14 24             	mov    %edx,(%esp)
  8090c9:	ff d0                	call   *%eax
  8090cb:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  8090ce:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8090d2:	75 08                	jne    8090dc <tcp_slowtmr+0x36e>
          tcp_output(pcb);
  8090d4:	89 1c 24             	mov    %ebx,(%esp)
  8090d7:	e8 2f 1d 00 00       	call   80ae0b <tcp_output>
        }
      }
      
      prev = pcb;
      pcb = pcb->next;
  8090dc:	8b 73 0c             	mov    0xc(%ebx),%esi
  8090df:	89 df                	mov    %ebx,%edi
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  8090e1:	85 f6                	test   %esi,%esi
  8090e3:	0f 85 bf fc ff ff    	jne    808da8 <tcp_slowtmr+0x3a>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  8090e9:	8b 1d 20 f0 b3 00    	mov    0xb3f020,%ebx
  while (pcb != NULL) {
  8090ef:	85 db                	test   %ebx,%ebx
  8090f1:	0f 84 c7 00 00 00    	je     8091be <tcp_slowtmr+0x450>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8090f7:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  8090fb:	75 0d                	jne    80910a <tcp_slowtmr+0x39c>
  8090fd:	be 00 00 00 00       	mov    $0x0,%esi
  809102:	eb 24                	jmp    809128 <tcp_slowtmr+0x3ba>
  809104:	83 7f 10 0a          	cmpl   $0xa,0x10(%edi)
  809108:	74 1c                	je     809126 <tcp_slowtmr+0x3b8>
  80910a:	c7 44 24 08 30 37 81 	movl   $0x813730,0x8(%esp)
  809111:	00 
  809112:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  809119:	00 
  80911a:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  809121:	e8 ee 77 ff ff       	call   800914 <_panic>
  809126:	89 fb                	mov    %edi,%ebx
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  809128:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  80912d:	2b 43 2c             	sub    0x2c(%ebx),%eax
  809130:	3d f0 00 00 00       	cmp    $0xf0,%eax
  809135:	76 7a                	jbe    8091b1 <tcp_slowtmr+0x443>
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      tcp_pcb_purge(pcb);      
  809137:	89 1c 24             	mov    %ebx,(%esp)
  80913a:	e8 38 f4 ff ff       	call   808577 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  80913f:	85 f6                	test   %esi,%esi
  809141:	74 2c                	je     80916f <tcp_slowtmr+0x401>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  809143:	3b 1d 20 f0 b3 00    	cmp    0xb3f020,%ebx
  809149:	75 1c                	jne    809167 <tcp_slowtmr+0x3f9>
  80914b:	c7 44 24 08 60 37 81 	movl   $0x813760,0x8(%esp)
  809152:	00 
  809153:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  80915a:	00 
  80915b:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  809162:	e8 ad 77 ff ff       	call   800914 <_panic>
        prev->next = pcb->next;
  809167:	8b 43 0c             	mov    0xc(%ebx),%eax
  80916a:	89 46 0c             	mov    %eax,0xc(%esi)
  80916d:	eb 2d                	jmp    80919c <tcp_slowtmr+0x42e>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80916f:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  809174:	39 d8                	cmp    %ebx,%eax
  809176:	74 1c                	je     809194 <tcp_slowtmr+0x426>
  809178:	c7 44 24 08 88 37 81 	movl   $0x813788,0x8(%esp)
  80917f:	00 
  809180:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  809187:	00 
  809188:	c7 04 24 87 35 81 00 	movl   $0x813587,(%esp)
  80918f:	e8 80 77 ff ff       	call   800914 <_panic>
        tcp_tw_pcbs = pcb->next;
  809194:	8b 40 0c             	mov    0xc(%eax),%eax
  809197:	a3 20 f0 b3 00       	mov    %eax,0xb3f020
      }
      pcb2 = pcb->next;
  80919c:	8b 7b 0c             	mov    0xc(%ebx),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  80919f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8091a3:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8091aa:	e8 55 e0 ff ff       	call   807204 <memp_free>
  8091af:	eb 05                	jmp    8091b6 <tcp_slowtmr+0x448>
      pcb = pcb2;
    } else {
      prev = pcb;
      pcb = pcb->next;
  8091b1:	8b 7b 0c             	mov    0xc(%ebx),%edi
  8091b4:	89 de                	mov    %ebx,%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  8091b6:	85 ff                	test   %edi,%edi
  8091b8:	0f 85 46 ff ff ff    	jne    809104 <tcp_slowtmr+0x396>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  8091be:	83 c4 2c             	add    $0x2c,%esp
  8091c1:	5b                   	pop    %ebx
  8091c2:	5e                   	pop    %esi
  8091c3:	5f                   	pop    %edi
  8091c4:	5d                   	pop    %ebp
  8091c5:	c3                   	ret    

008091c6 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  8091c6:	55                   	push   %ebp
  8091c7:	89 e5                	mov    %esp,%ebp
  8091c9:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  8091cc:	e8 6b f2 ff ff       	call   80843c <tcp_fasttmr>

  if (++tcp_timer & 1) {
  8091d1:	0f b6 05 28 54 b3 00 	movzbl 0xb35428,%eax
  8091d8:	83 c0 01             	add    $0x1,%eax
  8091db:	a2 28 54 b3 00       	mov    %al,0xb35428
  8091e0:	a8 01                	test   $0x1,%al
  8091e2:	74 05                	je     8091e9 <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  8091e4:	e8 85 fb ff ff       	call   808d6e <tcp_slowtmr>
  }
}
  8091e9:	c9                   	leave  
  8091ea:	c3                   	ret    

008091eb <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  8091eb:	55                   	push   %ebp
  8091ec:	89 e5                	mov    %esp,%ebp
  8091ee:	53                   	push   %ebx
  8091ef:	83 ec 14             	sub    $0x14,%esp
  8091f2:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  8091f5:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8091f9:	77 0a                	ja     809205 <tcp_close+0x1a>
  8091fb:	8b 43 10             	mov    0x10(%ebx),%eax
  8091fe:	ff 24 85 b0 37 81 00 	jmp    *0x8137b0(,%eax,4)
  809205:	bb 00 00 00 00       	mov    $0x0,%ebx
  80920a:	e9 05 01 00 00       	jmp    809314 <tcp_close+0x129>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80920f:	8b 15 1c f0 b3 00    	mov    0xb3f01c,%edx
  809215:	39 da                	cmp    %ebx,%edx
  809217:	75 0a                	jne    809223 <tcp_close+0x38>
  809219:	8b 42 0c             	mov    0xc(%edx),%eax
  80921c:	a3 1c f0 b3 00       	mov    %eax,0xb3f01c
  809221:	eb 2a                	jmp    80924d <tcp_close+0x62>
  809223:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  809229:	85 d2                	test   %edx,%edx
  80922b:	74 20                	je     80924d <tcp_close+0x62>
  80922d:	8b 42 0c             	mov    0xc(%edx),%eax
  809230:	85 c0                	test   %eax,%eax
  809232:	0f 84 fd 00 00 00    	je     809335 <tcp_close+0x14a>
  809238:	39 c3                	cmp    %eax,%ebx
  80923a:	75 08                	jne    809244 <tcp_close+0x59>
  80923c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80923f:	89 42 0c             	mov    %eax,0xc(%edx)
  809242:	eb 09                	jmp    80924d <tcp_close+0x62>
  809244:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  809249:	89 c2                	mov    %eax,%edx
  80924b:	eb e0                	jmp    80922d <tcp_close+0x42>
  80924d:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  809254:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809258:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80925f:	e8 a0 df ff ff       	call   807204 <memp_free>
  809264:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  809269:	e9 c1 00 00 00       	jmp    80932f <tcp_close+0x144>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  80926e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809272:	c7 04 24 14 f0 b3 00 	movl   $0xb3f014,(%esp)
  809279:	e8 72 f3 ff ff       	call   8085f0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  80927e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809282:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  809289:	e8 76 df ff ff       	call   807204 <memp_free>
  80928e:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  809293:	e9 97 00 00 00       	jmp    80932f <tcp_close+0x144>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  809298:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80929c:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  8092a3:	e8 48 f3 ff ff       	call   8085f0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  8092a8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8092ac:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8092b3:	e8 4c df ff ff       	call   807204 <memp_free>
  8092b8:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  8092bd:	eb 70                	jmp    80932f <tcp_close+0x144>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8092bf:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8092c6:	00 
  8092c7:	89 1c 24             	mov    %ebx,(%esp)
  8092ca:	e8 f9 27 00 00       	call   80bac8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8092cf:	84 c0                	test   %al,%al
  8092d1:	75 5c                	jne    80932f <tcp_close+0x144>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  8092d3:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8092da:	eb 38                	jmp    809314 <tcp_close+0x129>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8092dc:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8092e3:	00 
  8092e4:	89 1c 24             	mov    %ebx,(%esp)
  8092e7:	e8 dc 27 00 00       	call   80bac8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8092ec:	84 c0                	test   %al,%al
  8092ee:	75 3f                	jne    80932f <tcp_close+0x144>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  8092f0:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8092f7:	eb 1b                	jmp    809314 <tcp_close+0x129>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8092f9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  809300:	00 
  809301:	89 1c 24             	mov    %ebx,(%esp)
  809304:	e8 bf 27 00 00       	call   80bac8 <tcp_send_ctrl>
    if (err == ERR_OK) {
  809309:	84 c0                	test   %al,%al
  80930b:	75 22                	jne    80932f <tcp_close+0x144>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80930d:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  809314:	85 db                	test   %ebx,%ebx
  809316:	75 0a                	jne    809322 <tcp_close+0x137>
  809318:	b8 00 00 00 00       	mov    $0x0,%eax
  80931d:	8d 76 00             	lea    0x0(%esi),%esi
  809320:	eb 0d                	jmp    80932f <tcp_close+0x144>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  809322:	89 1c 24             	mov    %ebx,(%esp)
  809325:	e8 e1 1a 00 00       	call   80ae0b <tcp_output>
  80932a:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  80932f:	83 c4 14             	add    $0x14,%esp
  809332:	5b                   	pop    %ebx
  809333:	5d                   	pop    %ebp
  809334:	c3                   	ret    
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  809335:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  80933a:	e9 0e ff ff ff       	jmp    80924d <tcp_close+0x62>

0080933f <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80933f:	55                   	push   %ebp
  809340:	89 e5                	mov    %esp,%ebp
  809342:	83 ec 18             	sub    $0x18,%esp
  809345:	8b 45 10             	mov    0x10(%ebp),%eax
  809348:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  80934c:	85 c0                	test   %eax,%eax
  80934e:	74 0f                	je     80935f <tcp_recv_null+0x20>
    pbuf_free(p);
  809350:	89 04 24             	mov    %eax,(%esp)
  809353:	e8 35 e6 ff ff       	call   80798d <pbuf_free>
  809358:	b8 00 00 00 00       	mov    $0x0,%eax
  80935d:	eb 14                	jmp    809373 <tcp_recv_null+0x34>
  } else if (err == ERR_OK) {
  80935f:	b8 00 00 00 00       	mov    $0x0,%eax
  809364:	84 d2                	test   %dl,%dl
  809366:	75 0b                	jne    809373 <tcp_recv_null+0x34>
    return tcp_close(pcb);
  809368:	8b 45 0c             	mov    0xc(%ebp),%eax
  80936b:	89 04 24             	mov    %eax,(%esp)
  80936e:	e8 78 fe ff ff       	call   8091eb <tcp_close>
  }
  return ERR_OK;
}
  809373:	c9                   	leave  
  809374:	c3                   	ret    
  809375:	00 00                	add    %al,(%eax)
	...

00809378 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  809378:	55                   	push   %ebp
  809379:	89 e5                	mov    %esp,%ebp
  80937b:	53                   	push   %ebx
  80937c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  80937f:	8b 45 08             	mov    0x8(%ebp),%eax
  809382:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  809384:	8d 5a ff             	lea    -0x1(%edx),%ebx
  809387:	b8 01 00 00 00       	mov    $0x1,%eax
  80938c:	83 fb fd             	cmp    $0xfffffffd,%ebx
  80938f:	77 26                	ja     8093b7 <ip_addr_isbroadcast+0x3f>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  809391:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  809395:	74 1b                	je     8093b2 <ip_addr_isbroadcast+0x3a>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  809397:	8b 41 04             	mov    0x4(%ecx),%eax
  80939a:	39 d0                	cmp    %edx,%eax
  80939c:	74 14                	je     8093b2 <ip_addr_isbroadcast+0x3a>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  80939e:	8b 49 08             	mov    0x8(%ecx),%ecx
  8093a1:	31 d0                	xor    %edx,%eax
  8093a3:	85 c8                	test   %ecx,%eax
  8093a5:	75 0b                	jne    8093b2 <ip_addr_isbroadcast+0x3a>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  8093a7:	f7 d1                	not    %ecx
  8093a9:	21 ca                	and    %ecx,%edx
  8093ab:	39 d1                	cmp    %edx,%ecx
  8093ad:	0f 94 c0             	sete   %al
  8093b0:	eb 05                	jmp    8093b7 <ip_addr_isbroadcast+0x3f>
  8093b2:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  8093b7:	5b                   	pop    %ebx
  8093b8:	5d                   	pop    %ebp
  8093b9:	c3                   	ret    
  8093ba:	00 00                	add    %al,(%eax)
  8093bc:	00 00                	add    %al,(%eax)
	...

008093c0 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  8093c0:	55                   	push   %ebp
  8093c1:	89 e5                	mov    %esp,%ebp
  8093c3:	83 ec 48             	sub    $0x48,%esp
  8093c6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8093c9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8093cc:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8093cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8093d2:	8b 7d 10             	mov    0x10(%ebp),%edi
  8093d5:	8b 75 20             	mov    0x20(%ebp),%esi
  8093d8:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  8093dc:	88 45 d8             	mov    %al,-0x28(%ebp)
  8093df:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
  8093e3:	88 55 d7             	mov    %dl,-0x29(%ebp)
  8093e6:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  8093ea:	88 45 d6             	mov    %al,-0x2a(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  8093ed:	85 ff                	test   %edi,%edi
  8093ef:	0f 84 3a 01 00 00    	je     80952f <ip_output_if+0x16f>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  8093f5:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8093fc:	00 
  8093fd:	89 1c 24             	mov    %ebx,(%esp)
  809400:	e8 1e e2 ff ff       	call   807623 <pbuf_header>
  809405:	89 c2                	mov    %eax,%edx
  809407:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80940c:	84 d2                	test   %dl,%dl
  80940e:	0f 85 50 01 00 00    	jne    809564 <ip_output_if+0x1a4>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  809414:	8b 43 04             	mov    0x4(%ebx),%eax
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  809417:	66 83 7b 0a 13       	cmpw   $0x13,0xa(%ebx)
  80941c:	77 1c                	ja     80943a <ip_output_if+0x7a>
  80941e:	c7 44 24 08 ec 37 81 	movl   $0x8137ec,0x8(%esp)
  809425:	00 
  809426:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  80942d:	00 
  80942e:	c7 04 24 19 38 81 00 	movl   $0x813819,(%esp)
  809435:	e8 da 74 ff ff       	call   800914 <_panic>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  80943a:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  80943d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  809441:	89 04 24             	mov    %eax,(%esp)
  809444:	e8 47 13 00 00       	call   80a790 <ntohs>
  809449:	0f b6 d0             	movzbl %al,%edx
  80944c:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
  809450:	c1 e0 08             	shl    $0x8,%eax
  809453:	09 d0                	or     %edx,%eax
  809455:	0f b7 c0             	movzwl %ax,%eax
  809458:	89 04 24             	mov    %eax,(%esp)
  80945b:	e8 23 13 00 00       	call   80a783 <htons>
  809460:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809463:	66 89 42 08          	mov    %ax,0x8(%edx)
    IPH_PROTO_SET(iphdr, proto);
  809467:	0f b7 c0             	movzwl %ax,%eax
  80946a:	89 04 24             	mov    %eax,(%esp)
  80946d:	e8 1e 13 00 00       	call   80a790 <ntohs>
  809472:	89 c2                	mov    %eax,%edx
  809474:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  80947a:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
  80947e:	09 d0                	or     %edx,%eax
  809480:	0f b7 c0             	movzwl %ax,%eax
  809483:	89 04 24             	mov    %eax,(%esp)
  809486:	e8 f8 12 00 00       	call   80a783 <htons>
  80948b:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80948e:	66 89 42 08          	mov    %ax,0x8(%edx)

    ip_addr_set(&(iphdr->dest), dest);
  809492:	8b 07                	mov    (%edi),%eax
  809494:	89 42 10             	mov    %eax,0x10(%edx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  809497:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
  80949b:	80 cc 45             	or     $0x45,%ah
  80949e:	89 04 24             	mov    %eax,(%esp)
  8094a1:	e8 dd 12 00 00       	call   80a783 <htons>
  8094a6:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8094a9:	66 89 02             	mov    %ax,(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  8094ac:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8094b0:	89 04 24             	mov    %eax,(%esp)
  8094b3:	e8 cb 12 00 00       	call   80a783 <htons>
  8094b8:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8094bb:	66 89 42 02          	mov    %ax,0x2(%edx)
    IPH_OFFSET_SET(iphdr, 0);
  8094bf:	66 c7 42 06 00 00    	movw   $0x0,0x6(%edx)
    IPH_ID_SET(iphdr, htons(ip_id));
  8094c5:	0f b7 05 2c 54 b3 00 	movzwl 0xb3542c,%eax
  8094cc:	89 04 24             	mov    %eax,(%esp)
  8094cf:	e8 af 12 00 00       	call   80a783 <htons>
  8094d4:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8094d7:	66 89 42 04          	mov    %ax,0x4(%edx)
    ++ip_id;
  8094db:	66 83 05 2c 54 b3 00 	addw   $0x1,0xb3542c
  8094e2:	01 

    if (ip_addr_isany(src)) {
  8094e3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  8094e7:	74 09                	je     8094f2 <ip_output_if+0x132>
  8094e9:	8b 55 0c             	mov    0xc(%ebp),%edx
  8094ec:	8b 02                	mov    (%edx),%eax
  8094ee:	85 c0                	test   %eax,%eax
  8094f0:	75 15                	jne    809507 <ip_output_if+0x147>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  8094f2:	b8 00 00 00 00       	mov    $0x0,%eax
  8094f7:	83 fe fc             	cmp    $0xfffffffc,%esi
  8094fa:	74 03                	je     8094ff <ip_output_if+0x13f>
  8094fc:	8b 46 04             	mov    0x4(%esi),%eax
  8094ff:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809502:	89 42 0c             	mov    %eax,0xc(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    ++ip_id;

    if (ip_addr_isany(src)) {
  809505:	eb 06                	jmp    80950d <ip_output_if+0x14d>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
    } else {
      ip_addr_set(&(iphdr->src), src);
  809507:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80950a:	89 42 0c             	mov    %eax,0xc(%edx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  80950d:	8b 45 d0             	mov    -0x30(%ebp),%eax
  809510:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  809516:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80951d:	00 
  80951e:	89 04 24             	mov    %eax,(%esp)
  809521:	e8 44 0f 00 00       	call   80a46a <inet_chksum>
  809526:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809529:	66 89 42 0a          	mov    %ax,0xa(%edx)
  80952d:	eb 06                	jmp    809535 <ip_output_if+0x175>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  80952f:	8b 7b 04             	mov    0x4(%ebx),%edi
  809532:	83 c7 10             	add    $0x10,%edi
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  809535:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
  809539:	66 85 c0             	test   %ax,%ax
  80953c:	74 18                	je     809556 <ip_output_if+0x196>
  80953e:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  809542:	73 12                	jae    809556 <ip_output_if+0x196>
    return ip_frag(p,netif,dest);
  809544:	89 7c 24 08          	mov    %edi,0x8(%esp)
  809548:	89 74 24 04          	mov    %esi,0x4(%esp)
  80954c:	89 1c 24             	mov    %ebx,(%esp)
  80954f:	e8 ac 03 00 00       	call   809900 <ip_frag>
  809554:	eb 0e                	jmp    809564 <ip_output_if+0x1a4>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  809556:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80955a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80955e:	89 34 24             	mov    %esi,(%esp)
  809561:	ff 56 14             	call   *0x14(%esi)
  }
}
  809564:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809567:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80956a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80956d:	89 ec                	mov    %ebp,%esp
  80956f:	5d                   	pop    %ebp
  809570:	c3                   	ret    

00809571 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  809571:	55                   	push   %ebp
  809572:	89 e5                	mov    %esp,%ebp
  809574:	56                   	push   %esi
  809575:	53                   	push   %ebx
  809576:	83 ec 10             	sub    $0x10,%esp
  809579:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80957c:	8b 1d 04 f0 b3 00    	mov    0xb3f004,%ebx
  809582:	85 db                	test   %ebx,%ebx
  809584:	74 1c                	je     8095a2 <ip_route+0x31>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  809586:	89 1c 24             	mov    %ebx,(%esp)
  809589:	e8 11 de ff ff       	call   80739f <netif_is_up>
  80958e:	84 c0                	test   %al,%al
  809590:	74 0a                	je     80959c <ip_route+0x2b>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  809592:	8b 43 04             	mov    0x4(%ebx),%eax
  809595:	33 06                	xor    (%esi),%eax
  809597:	85 43 08             	test   %eax,0x8(%ebx)
  80959a:	74 28                	je     8095c4 <ip_route+0x53>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80959c:	8b 1b                	mov    (%ebx),%ebx
  80959e:	85 db                	test   %ebx,%ebx
  8095a0:	75 e4                	jne    809586 <ip_route+0x15>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  8095a2:	a1 08 f0 b3 00       	mov    0xb3f008,%eax
  8095a7:	85 c0                	test   %eax,%eax
  8095a9:	74 14                	je     8095bf <ip_route+0x4e>
  8095ab:	89 04 24             	mov    %eax,(%esp)
  8095ae:	e8 ec dd ff ff       	call   80739f <netif_is_up>
  8095b3:	84 c0                	test   %al,%al
  8095b5:	74 08                	je     8095bf <ip_route+0x4e>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  8095b7:	8b 1d 08 f0 b3 00    	mov    0xb3f008,%ebx
  8095bd:	eb 05                	jmp    8095c4 <ip_route+0x53>
  8095bf:	bb 00 00 00 00       	mov    $0x0,%ebx
}
  8095c4:	89 d8                	mov    %ebx,%eax
  8095c6:	83 c4 10             	add    $0x10,%esp
  8095c9:	5b                   	pop    %ebx
  8095ca:	5e                   	pop    %esi
  8095cb:	5d                   	pop    %ebp
  8095cc:	c3                   	ret    

008095cd <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  8095cd:	55                   	push   %ebp
  8095ce:	89 e5                	mov    %esp,%ebp
  8095d0:	83 ec 48             	sub    $0x48,%esp
  8095d3:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8095d6:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8095d9:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8095dc:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8095df:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  8095e3:	88 45 e7             	mov    %al,-0x19(%ebp)
  8095e6:	0f b6 7d 18          	movzbl 0x18(%ebp),%edi
  8095ea:	0f b6 75 1c          	movzbl 0x1c(%ebp),%esi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  8095ee:	89 1c 24             	mov    %ebx,(%esp)
  8095f1:	e8 7b ff ff ff       	call   809571 <ip_route>
  8095f6:	89 c2                	mov    %eax,%edx
  8095f8:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8095fd:	85 d2                	test   %edx,%edx
  8095ff:	74 36                	je     809637 <ip_output+0x6a>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  809601:	89 54 24 18          	mov    %edx,0x18(%esp)
  809605:	81 e6 ff 00 00 00    	and    $0xff,%esi
  80960b:	89 74 24 14          	mov    %esi,0x14(%esp)
  80960f:	81 e7 ff 00 00 00    	and    $0xff,%edi
  809615:	89 7c 24 10          	mov    %edi,0x10(%esp)
  809619:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80961d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809621:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  809625:	8b 45 0c             	mov    0xc(%ebp),%eax
  809628:	89 44 24 04          	mov    %eax,0x4(%esp)
  80962c:	8b 45 08             	mov    0x8(%ebp),%eax
  80962f:	89 04 24             	mov    %eax,(%esp)
  809632:	e8 89 fd ff ff       	call   8093c0 <ip_output_if>
}
  809637:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80963a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80963d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809640:	89 ec                	mov    %ebp,%esp
  809642:	5d                   	pop    %ebp
  809643:	c3                   	ret    

00809644 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  809644:	55                   	push   %ebp
  809645:	89 e5                	mov    %esp,%ebp
  809647:	83 ec 48             	sub    $0x48,%esp
  80964a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80964d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  809650:	89 7d fc             	mov    %edi,-0x4(%ebp)
  809653:	8b 75 08             	mov    0x8(%ebp),%esi

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  809656:	8b 5e 04             	mov    0x4(%esi),%ebx
  if (IPH_V(iphdr) != 4) {
  809659:	0f b7 03             	movzwl (%ebx),%eax
  80965c:	89 04 24             	mov    %eax,(%esp)
  80965f:	e8 2c 11 00 00       	call   80a790 <ntohs>
  809664:	66 c1 e8 0c          	shr    $0xc,%ax
  809668:	66 83 f8 04          	cmp    $0x4,%ax
  80966c:	74 0d                	je     80967b <ip_input+0x37>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  80966e:	89 34 24             	mov    %esi,(%esp)
  809671:	e8 17 e3 ff ff       	call   80798d <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  809676:	e9 72 02 00 00       	jmp    8098ed <ip_input+0x2a9>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  80967b:	0f b7 03             	movzwl (%ebx),%eax
  80967e:	89 04 24             	mov    %eax,(%esp)
  809681:	e8 0a 11 00 00       	call   80a790 <ntohs>
  809686:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  80968a:	83 e0 3c             	and    $0x3c,%eax
  80968d:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  809691:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809695:	89 04 24             	mov    %eax,(%esp)
  809698:	e8 f3 10 00 00       	call   80a790 <ntohs>
  80969d:	89 c7                	mov    %eax,%edi

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  80969f:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8096a3:	66 3b 46 0a          	cmp    0xa(%esi),%ax
  8096a7:	77 06                	ja     8096af <ip_input+0x6b>
  8096a9:	66 3b 7e 08          	cmp    0x8(%esi),%di
  8096ad:	76 0d                	jbe    8096bc <ip_input+0x78>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  8096af:	89 34 24             	mov    %esi,(%esp)
  8096b2:	e8 d6 e2 ff ff       	call   80798d <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  8096b7:	e9 31 02 00 00       	jmp    8098ed <ip_input+0x2a9>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  8096bc:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8096c0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8096c4:	89 1c 24             	mov    %ebx,(%esp)
  8096c7:	e8 9e 0d 00 00       	call   80a46a <inet_chksum>
  8096cc:	66 85 c0             	test   %ax,%ax
  8096cf:	74 0d                	je     8096de <ip_input+0x9a>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  8096d1:	89 34 24             	mov    %esi,(%esp)
  8096d4:	e8 b4 e2 ff ff       	call   80798d <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  8096d9:	e9 0f 02 00 00       	jmp    8098ed <ip_input+0x2a9>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  8096de:	0f b7 ff             	movzwl %di,%edi
  8096e1:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8096e5:	89 34 24             	mov    %esi,(%esp)
  8096e8:	e8 2c e4 ff ff       	call   807b19 <pbuf_realloc>
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  8096ed:	8d 43 10             	lea    0x10(%ebx),%eax
  8096f0:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8096f3:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8096f6:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
        netif = netif->next;
      }
      if (netif == inp) {
        netif = netif->next;
      }
    } while(netif != NULL);
  8096fd:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809700:	89 de                	mov    %ebx,%esi
  809702:	bb 01 00 00 00       	mov    $0x1,%ebx
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  809707:	89 3c 24             	mov    %edi,(%esp)
  80970a:	e8 90 dc ff ff       	call   80739f <netif_is_up>
  80970f:	84 c0                	test   %al,%al
  809711:	74 27                	je     80973a <ip_input+0xf6>
  809713:	83 ff fc             	cmp    $0xfffffffc,%edi
  809716:	74 22                	je     80973a <ip_input+0xf6>
  809718:	8b 47 04             	mov    0x4(%edi),%eax
  80971b:	85 c0                	test   %eax,%eax
  80971d:	8d 76 00             	lea    0x0(%esi),%esi
  809720:	74 18                	je     80973a <ip_input+0xf6>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809722:	3b 46 10             	cmp    0x10(%esi),%eax
  809725:	74 36                	je     80975d <ip_input+0x119>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  809727:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80972b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80972e:	89 04 24             	mov    %eax,(%esp)
  809731:	e8 42 fc ff ff       	call   809378 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809736:	84 c0                	test   %al,%al
  809738:	75 23                	jne    80975d <ip_input+0x119>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  80973a:	85 db                	test   %ebx,%ebx
  80973c:	74 08                	je     809746 <ip_input+0x102>
        first = 0;
        netif = netif_list;
  80973e:	8b 3d 04 f0 b3 00    	mov    0xb3f004,%edi
  809744:	eb 02                	jmp    809748 <ip_input+0x104>
      } else {
        netif = netif->next;
  809746:	8b 3f                	mov    (%edi),%edi
      }
      if (netif == inp) {
  809748:	3b 7d 0c             	cmp    0xc(%ebp),%edi
  80974b:	75 05                	jne    809752 <ip_input+0x10e>
        netif = netif->next;
  80974d:	8b 45 0c             	mov    0xc(%ebp),%eax
  809750:	8b 38                	mov    (%eax),%edi
      }
    } while(netif != NULL);
  809752:	85 ff                	test   %edi,%edi
  809754:	74 12                	je     809768 <ip_input+0x124>
  809756:	bb 00 00 00 00       	mov    $0x0,%ebx
  80975b:	eb aa                	jmp    809707 <ip_input+0xc3>
  80975d:	89 f3                	mov    %esi,%ebx
  80975f:	8b 75 d4             	mov    -0x2c(%ebp),%esi
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  809762:	85 ff                	test   %edi,%edi
  809764:	75 2e                	jne    809794 <ip_input+0x150>
  809766:	eb 05                	jmp    80976d <ip_input+0x129>
  809768:	89 f3                	mov    %esi,%ebx
  80976a:	8b 75 d4             	mov    -0x2c(%ebp),%esi
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  80976d:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809771:	89 04 24             	mov    %eax,(%esp)
  809774:	e8 17 10 00 00       	call   80a790 <ntohs>
  809779:	3c 11                	cmp    $0x11,%al
  80977b:	75 17                	jne    809794 <ip_input+0x150>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  80977d:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809781:	0f b7 44 03 02       	movzwl 0x2(%ebx,%eax,1),%eax
  809786:	89 04 24             	mov    %eax,(%esp)
  809789:	e8 02 10 00 00       	call   80a790 <ntohs>
  80978e:	66 83 f8 44          	cmp    $0x44,%ax
  809792:	74 4e                	je     8097e2 <ip_input+0x19e>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  809794:	8b 45 0c             	mov    0xc(%ebp),%eax
  809797:	89 44 24 04          	mov    %eax,0x4(%esp)
  80979b:	8d 43 0c             	lea    0xc(%ebx),%eax
  80979e:	89 04 24             	mov    %eax,(%esp)
  8097a1:	e8 d2 fb ff ff       	call   809378 <ip_addr_isbroadcast>
  8097a6:	84 c0                	test   %al,%al
  8097a8:	75 2b                	jne    8097d5 <ip_input+0x191>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  8097aa:	8b 43 0c             	mov    0xc(%ebx),%eax
  8097ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
  8097b0:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  8097b7:	e8 09 12 00 00       	call   80a9c5 <ntohl>
  8097bc:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8097bf:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8097c6:	e8 fa 11 00 00       	call   80a9c5 <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  8097cb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8097ce:	23 55 dc             	and    -0x24(%ebp),%edx
  8097d1:	39 c2                	cmp    %eax,%edx
  8097d3:	75 10                	jne    8097e5 <ip_input+0x1a1>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  8097d5:	89 34 24             	mov    %esi,(%esp)
  8097d8:	e8 b0 e1 ff ff       	call   80798d <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  8097dd:	e9 0b 01 00 00       	jmp    8098ed <ip_input+0x2a9>
  8097e2:	8b 7d 0c             	mov    0xc(%ebp),%edi
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  8097e5:	85 ff                	test   %edi,%edi
  8097e7:	75 11                	jne    8097fa <ip_input+0x1b6>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  8097e9:	89 34 24             	mov    %esi,(%esp)
  8097ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8097f0:	e8 98 e1 ff ff       	call   80798d <pbuf_free>
    return ERR_OK;
  8097f5:	e9 f3 00 00 00       	jmp    8098ed <ip_input+0x2a9>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  8097fa:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
  8097fe:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  809805:	e8 79 0f 00 00       	call   80a783 <htons>
  80980a:	66 85 f8             	test   %di,%ax
  80980d:	74 15                	je     809824 <ip_input+0x1e0>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  80980f:	89 34 24             	mov    %esi,(%esp)
  809812:	e8 4a 05 00 00       	call   809d61 <ip_reass>
  809817:	89 c6                	mov    %eax,%esi
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  809819:	85 c0                	test   %eax,%eax
  80981b:	0f 84 cc 00 00 00    	je     8098ed <ip_input+0x2a9>
      return ERR_OK;
    }
    iphdr = p->payload;
  809821:	8b 58 04             	mov    0x4(%eax),%ebx
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  809824:	8b 45 0c             	mov    0xc(%ebp),%eax
  809827:	89 44 24 04          	mov    %eax,0x4(%esp)
  80982b:	89 34 24             	mov    %esi,(%esp)
  80982e:	e8 50 7e 00 00       	call   811683 <raw_input>
  809833:	84 c0                	test   %al,%al
  809835:	0f 85 b2 00 00 00    	jne    8098ed <ip_input+0x2a9>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  80983b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80983f:	89 04 24             	mov    %eax,(%esp)
  809842:	e8 49 0f 00 00       	call   80a790 <ntohs>
  809847:	0f b6 c0             	movzbl %al,%eax
  80984a:	83 f8 06             	cmp    $0x6,%eax
  80984d:	74 24                	je     809873 <ip_input+0x22f>
  80984f:	83 f8 11             	cmp    $0x11,%eax
  809852:	74 0e                	je     809862 <ip_input+0x21e>
  809854:	83 f8 01             	cmp    $0x1,%eax
  809857:	75 3c                	jne    809895 <ip_input+0x251>
  809859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  809860:	eb 22                	jmp    809884 <ip_input+0x240>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  809862:	8b 45 0c             	mov    0xc(%ebp),%eax
  809865:	89 44 24 04          	mov    %eax,0x4(%esp)
  809869:	89 34 24             	mov    %esi,(%esp)
  80986c:	e8 c7 26 00 00       	call   80bf38 <udp_input>
      break;
  809871:	eb 7a                	jmp    8098ed <ip_input+0x2a9>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  809873:	8b 45 0c             	mov    0xc(%ebp),%eax
  809876:	89 44 24 04          	mov    %eax,0x4(%esp)
  80987a:	89 34 24             	mov    %esi,(%esp)
  80987d:	e8 c5 6d 00 00       	call   810647 <tcp_input>
      break;
  809882:	eb 69                	jmp    8098ed <ip_input+0x2a9>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  809884:	8b 45 0c             	mov    0xc(%ebp),%eax
  809887:	89 44 24 04          	mov    %eax,0x4(%esp)
  80988b:	89 34 24             	mov    %esi,(%esp)
  80988e:	e8 c1 80 00 00       	call   811954 <icmp_input>
      break;
  809893:	eb 58                	jmp    8098ed <ip_input+0x2a9>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  809895:	8b 45 0c             	mov    0xc(%ebp),%eax
  809898:	89 44 24 04          	mov    %eax,0x4(%esp)
  80989c:	8d 43 10             	lea    0x10(%ebx),%eax
  80989f:	89 04 24             	mov    %eax,(%esp)
  8098a2:	e8 d1 fa ff ff       	call   809378 <ip_addr_isbroadcast>
  8098a7:	84 c0                	test   %al,%al
  8098a9:	75 3a                	jne    8098e5 <ip_input+0x2a1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  8098ab:	8b 43 10             	mov    0x10(%ebx),%eax
  8098ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8098b1:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  8098b8:	e8 08 11 00 00       	call   80a9c5 <ntohl>
  8098bd:	89 c7                	mov    %eax,%edi
  8098bf:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8098c6:	e8 fa 10 00 00       	call   80a9c5 <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  8098cb:	23 7d e4             	and    -0x1c(%ebp),%edi
  8098ce:	39 c7                	cmp    %eax,%edi
  8098d0:	74 13                	je     8098e5 <ip_input+0x2a1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  8098d2:	89 5e 04             	mov    %ebx,0x4(%esi)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  8098d5:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  8098dc:	00 
  8098dd:	89 34 24             	mov    %esi,(%esp)
  8098e0:	e8 5d 7f 00 00       	call   811842 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  8098e5:	89 34 24             	mov    %esi,(%esp)
  8098e8:	e8 a0 e0 ff ff       	call   80798d <pbuf_free>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  8098ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8098f2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8098f5:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8098f8:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8098fb:	89 ec                	mov    %ebp,%esp
  8098fd:	5d                   	pop    %ebp
  8098fe:	c3                   	ret    
	...

00809900 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  809900:	55                   	push   %ebp
  809901:	89 e5                	mov    %esp,%ebp
  809903:	57                   	push   %edi
  809904:	56                   	push   %esi
  809905:	53                   	push   %ebx
  809906:	83 ec 5c             	sub    $0x5c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  809909:	8b 45 0c             	mov    0xc(%ebp),%eax
  80990c:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  809910:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  809917:	00 
  809918:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80991f:	00 
  809920:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809927:	e8 1d e3 ff ff       	call   807c49 <pbuf_alloc>
  80992c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if (rambuf == NULL) {
  80992f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809934:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  809938:	0f 84 c6 01 00 00    	je     809b04 <ip_frag+0x204>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  80993e:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809941:	66 89 72 0a          	mov    %si,0xa(%edx)
  809945:	66 89 72 08          	mov    %si,0x8(%edx)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  809949:	bb 63 54 b3 00       	mov    $0xb35463,%ebx
  80994e:	83 e3 fc             	and    $0xfffffffc,%ebx
  809951:	89 5a 04             	mov    %ebx,0x4(%edx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  809954:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80995b:	00 
  80995c:	8b 55 08             	mov    0x8(%ebp),%edx
  80995f:	8b 42 04             	mov    0x4(%edx),%eax
  809962:	89 44 24 04          	mov    %eax,0x4(%esp)
  809966:	89 1c 24             	mov    %ebx,(%esp)
  809969:	e8 03 7a ff ff       	call   801371 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  80996e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809972:	89 04 24             	mov    %eax,(%esp)
  809975:	e8 16 0e 00 00       	call   80a790 <ntohs>
  80997a:	89 c2                	mov    %eax,%edx
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
  80997c:	66 25 00 20          	and    $0x2000,%ax
  809980:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)

  left = p->tot_len - IP_HLEN;
  809984:	8b 45 08             	mov    0x8(%ebp),%eax
  809987:	0f b7 48 08          	movzwl 0x8(%eax),%ecx

  nfb = (mtu - IP_HLEN) / 8;
  80998b:	0f b7 f6             	movzwl %si,%esi
  80998e:	8d 46 f3             	lea    -0xd(%esi),%eax
  809991:	83 ee 14             	sub    $0x14,%esi
  809994:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809997:	0f 49 c6             	cmovns %esi,%eax
  80999a:	c1 e8 03             	shr    $0x3,%eax
  80999d:	66 89 45 b8          	mov    %ax,-0x48(%ebp)

  while (left) {
  8099a1:	66 83 e9 14          	sub    $0x14,%cx
  8099a5:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
  8099a9:	0f 84 45 01 00 00    	je     809af4 <ip_frag+0x1f4>
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  8099af:	66 81 e2 ff 1f       	and    $0x1fff,%dx
  8099b4:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8099b8:	66 c7 45 e2 14 00    	movw   $0x14,-0x1e(%ebp)
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;
  8099be:	c1 e0 03             	shl    $0x3,%eax
  8099c1:	66 89 45 b2          	mov    %ax,-0x4e(%ebp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8099c5:	8d 53 14             	lea    0x14(%ebx),%edx
  8099c8:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    last = (left <= mtu - IP_HLEN);
  8099cb:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8099cf:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  8099d2:	0f 9d c0             	setge  %al
  8099d5:	0f b6 f0             	movzbl %al,%esi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  8099d8:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  8099dc:	66 25 ff 1f          	and    $0x1fff,%ax
  8099e0:	66 0b 45 d2          	or     -0x2e(%ebp),%ax
  8099e4:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    if (!last)
  8099e8:	0f b7 7d e6          	movzwl -0x1a(%ebp),%edi
  8099ec:	66 85 f6             	test   %si,%si
  8099ef:	75 0a                	jne    8099fb <ip_frag+0xfb>
      tmp = tmp | IP_MF;
  8099f1:	66 81 4d e4 00 20    	orw    $0x2000,-0x1c(%ebp)
  8099f7:	0f b7 7d b2          	movzwl -0x4e(%ebp),%edi

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8099fb:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8099ff:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809a03:	0f b7 c7             	movzwl %di,%eax
  809a06:	89 44 24 08          	mov    %eax,0x8(%esp)
  809a0a:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  809a0d:	89 44 24 04          	mov    %eax,0x4(%esp)
  809a11:	8b 55 08             	mov    0x8(%ebp),%edx
  809a14:	89 14 24             	mov    %edx,(%esp)
  809a17:	e8 fa dc ff ff       	call   807716 <pbuf_copy_partial>
  809a1c:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  809a20:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  809a24:	89 04 24             	mov    %eax,(%esp)
  809a27:	e8 57 0d 00 00       	call   80a783 <htons>
  809a2c:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  809a30:	8d 47 14             	lea    0x14(%edi),%eax
  809a33:	0f b7 c0             	movzwl %ax,%eax
  809a36:	89 04 24             	mov    %eax,(%esp)
  809a39:	e8 45 0d 00 00       	call   80a783 <htons>
  809a3e:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  809a42:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  809a48:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  809a4f:	00 
  809a50:	89 1c 24             	mov    %ebx,(%esp)
  809a53:	e8 12 0a 00 00       	call   80a46a <inet_chksum>
  809a58:	66 89 43 0a          	mov    %ax,0xa(%ebx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  809a5c:	66 85 f6             	test   %si,%si
  809a5f:	74 19                	je     809a7a <ip_frag+0x17a>
      pbuf_realloc(rambuf, left + IP_HLEN);
  809a61:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  809a65:	83 c0 14             	add    $0x14,%eax
  809a68:	0f b7 c0             	movzwl %ax,%eax
  809a6b:	89 44 24 04          	mov    %eax,0x4(%esp)
  809a6f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  809a72:	89 04 24             	mov    %eax,(%esp)
  809a75:	e8 9f e0 ff ff       	call   807b19 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  809a7a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809a81:	00 
  809a82:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809a89:	00 
  809a8a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809a91:	e8 b3 e1 ff ff       	call   807c49 <pbuf_alloc>
  809a96:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  809a98:	85 c0                	test   %eax,%eax
  809a9a:	74 46                	je     809ae2 <ip_frag+0x1e2>
      pbuf_chain(header, rambuf);
  809a9c:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809a9f:	89 54 24 04          	mov    %edx,0x4(%esp)
  809aa3:	89 04 24             	mov    %eax,(%esp)
  809aa6:	e8 51 db ff ff       	call   8075fc <pbuf_chain>
      netif->output(netif, header, dest);
  809aab:	8b 45 10             	mov    0x10(%ebp),%eax
  809aae:	89 44 24 08          	mov    %eax,0x8(%esp)
  809ab2:	89 74 24 04          	mov    %esi,0x4(%esp)
  809ab6:	8b 55 0c             	mov    0xc(%ebp),%edx
  809ab9:	89 14 24             	mov    %edx,(%esp)
  809abc:	ff 52 14             	call   *0x14(%edx)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  809abf:	89 34 24             	mov    %esi,(%esp)
  809ac2:	e8 c6 de ff ff       	call   80798d <pbuf_free>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  809ac7:	66 29 7d e6          	sub    %di,-0x1a(%ebp)
  809acb:	74 27                	je     809af4 <ip_frag+0x1f4>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809acd:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  809ad1:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  809ad5:	0f b7 55 b8          	movzwl -0x48(%ebp),%edx
  809ad9:	66 01 55 e0          	add    %dx,-0x20(%ebp)
  809add:	e9 e9 fe ff ff       	jmp    8099cb <ip_frag+0xcb>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  809ae2:	8b 45 d8             	mov    -0x28(%ebp),%eax
  809ae5:	89 04 24             	mov    %eax,(%esp)
  809ae8:	e8 a0 de ff ff       	call   80798d <pbuf_free>
  809aed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
  809af2:	eb 10                	jmp    809b04 <ip_frag+0x204>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  809af4:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809af7:	89 14 24             	mov    %edx,(%esp)
  809afa:	e8 8e de ff ff       	call   80798d <pbuf_free>
  809aff:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  809b04:	83 c4 5c             	add    $0x5c,%esp
  809b07:	5b                   	pop    %ebx
  809b08:	5e                   	pop    %esi
  809b09:	5f                   	pop    %edi
  809b0a:	5d                   	pop    %ebp
  809b0b:	c3                   	ret    

00809b0c <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  809b0c:	55                   	push   %ebp
  809b0d:	89 e5                	mov    %esp,%ebp
  809b0f:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  809b12:	8b 0d 40 54 b3 00    	mov    0xb35440,%ecx
  809b18:	39 c1                	cmp    %eax,%ecx
  809b1a:	75 0a                	jne    809b26 <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  809b1c:	8b 11                	mov    (%ecx),%edx
  809b1e:	89 15 40 54 b3 00    	mov    %edx,0xb35440
  809b24:	eb 24                	jmp    809b4a <ip_reass_dequeue_datagram+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  809b26:	85 d2                	test   %edx,%edx
  809b28:	75 1c                	jne    809b46 <ip_reass_dequeue_datagram+0x3a>
  809b2a:	c7 44 24 08 31 38 81 	movl   $0x813831,0x8(%esp)
  809b31:	00 
  809b32:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  809b39:	00 
  809b3a:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  809b41:	e8 ce 6d ff ff       	call   800914 <_panic>
    prev->next = ipr->next;
  809b46:	8b 08                	mov    (%eax),%ecx
  809b48:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  809b4a:	89 44 24 04          	mov    %eax,0x4(%esp)
  809b4e:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  809b55:	e8 aa d6 ff ff       	call   807204 <memp_free>
}
  809b5a:	c9                   	leave  
  809b5b:	c3                   	ret    

00809b5c <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  809b5c:	55                   	push   %ebp
  809b5d:	89 e5                	mov    %esp,%ebp
  809b5f:	57                   	push   %edi
  809b60:	56                   	push   %esi
  809b61:	53                   	push   %ebx
  809b62:	83 ec 2c             	sub    $0x2c,%esp
  809b65:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809b68:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  809b6b:	39 c2                	cmp    %eax,%edx
  809b6d:	75 1c                	jne    809b8b <ip_reass_free_complete_datagram+0x2f>
  809b6f:	c7 44 24 08 67 38 81 	movl   $0x813867,0x8(%esp)
  809b76:	00 
  809b77:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  809b7e:	00 
  809b7f:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  809b86:	e8 89 6d ff ff       	call   800914 <_panic>
  if (prev != NULL) {
  809b8b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  809b8f:	74 26                	je     809bb7 <ip_reass_free_complete_datagram+0x5b>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  809b91:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809b94:	8b 45 e0             	mov    -0x20(%ebp),%eax
  809b97:	39 10                	cmp    %edx,(%eax)
  809b99:	74 1c                	je     809bb7 <ip_reass_free_complete_datagram+0x5b>
  809b9b:	c7 44 24 08 73 38 81 	movl   $0x813873,0x8(%esp)
  809ba2:	00 
  809ba3:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  809baa:	00 
  809bab:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  809bb2:	e8 5d 6d ff ff       	call   800914 <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  809bb7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809bba:	8b 58 04             	mov    0x4(%eax),%ebx
  809bbd:	8b 43 04             	mov    0x4(%ebx),%eax
  if (iprh->start == 0) {
  809bc0:	bf 00 00 00 00       	mov    $0x0,%edi
  809bc5:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  809bca:	75 47                	jne    809c13 <ip_reass_free_complete_datagram+0xb7>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  809bcc:	8b 00                	mov    (%eax),%eax
  809bce:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809bd1:	89 42 04             	mov    %eax,0x4(%edx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  809bd4:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809bdb:	00 
  809bdc:	89 d0                	mov    %edx,%eax
  809bde:	83 c0 08             	add    $0x8,%eax
  809be1:	89 44 24 04          	mov    %eax,0x4(%esp)
  809be5:	8b 43 04             	mov    0x4(%ebx),%eax
  809be8:	89 04 24             	mov    %eax,(%esp)
  809beb:	e8 81 77 ff ff       	call   801371 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  809bf0:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  809bf7:	00 
  809bf8:	89 1c 24             	mov    %ebx,(%esp)
  809bfb:	e8 30 7b 00 00       	call   811730 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  809c00:	89 1c 24             	mov    %ebx,(%esp)
  809c03:	e8 28 d9 ff ff       	call   807530 <pbuf_clen>
  809c08:	0f b6 f8             	movzbl %al,%edi
    pbuf_free(p);
  809c0b:	89 1c 24             	mov    %ebx,(%esp)
  809c0e:	e8 7a dd ff ff       	call   80798d <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  809c13:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809c16:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  809c19:	85 db                	test   %ebx,%ebx
  809c1b:	74 22                	je     809c3f <ip_reass_free_complete_datagram+0xe3>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  809c1d:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  809c20:	8b 30                	mov    (%eax),%esi
    pbufs_freed += pbuf_clen(pcur);
  809c22:	89 1c 24             	mov    %ebx,(%esp)
  809c25:	e8 06 d9 ff ff       	call   807530 <pbuf_clen>
  809c2a:	0f b6 c0             	movzbl %al,%eax
  809c2d:	01 c7                	add    %eax,%edi
    pbuf_free(pcur);    
  809c2f:	89 1c 24             	mov    %ebx,(%esp)
  809c32:	e8 56 dd ff ff       	call   80798d <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  809c37:	85 f6                	test   %esi,%esi
  809c39:	74 04                	je     809c3f <ip_reass_free_complete_datagram+0xe3>
  809c3b:	89 f3                	mov    %esi,%ebx
  809c3d:	eb de                	jmp    809c1d <ip_reass_free_complete_datagram+0xc1>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  809c3f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  809c42:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809c45:	e8 c2 fe ff ff       	call   809b0c <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  809c4a:	0f b7 05 44 54 b3 00 	movzwl 0xb35444,%eax
  809c51:	0f b7 d0             	movzwl %ax,%edx
  809c54:	39 fa                	cmp    %edi,%edx
  809c56:	7d 1c                	jge    809c74 <ip_reass_free_complete_datagram+0x118>
  809c58:	c7 44 24 08 85 38 81 	movl   $0x813885,0x8(%esp)
  809c5f:	00 
  809c60:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  809c67:	00 
  809c68:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  809c6f:	e8 a0 6c ff ff       	call   800914 <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  809c74:	66 29 f8             	sub    %di,%ax
  809c77:	66 a3 44 54 b3 00    	mov    %ax,0xb35444

  return pbufs_freed;
}
  809c7d:	89 f8                	mov    %edi,%eax
  809c7f:	83 c4 2c             	add    $0x2c,%esp
  809c82:	5b                   	pop    %ebx
  809c83:	5e                   	pop    %esi
  809c84:	5f                   	pop    %edi
  809c85:	5d                   	pop    %ebp
  809c86:	c3                   	ret    

00809c87 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  809c87:	55                   	push   %ebp
  809c88:	89 e5                	mov    %esp,%ebp
  809c8a:	57                   	push   %edi
  809c8b:	56                   	push   %esi
  809c8c:	53                   	push   %ebx
  809c8d:	83 ec 2c             	sub    $0x2c,%esp
  809c90:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809c93:	89 55 dc             	mov    %edx,-0x24(%ebp)
  809c96:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  809c9d:	8b 0d 40 54 b3 00    	mov    0xb35440,%ecx
    while (r != NULL) {
  809ca3:	85 c9                	test   %ecx,%ecx
  809ca5:	74 6f                	je     809d16 <ip_reass_remove_oldest_datagram+0x8f>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  809ca7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809caa:	8b 78 0c             	mov    0xc(%eax),%edi
  809cad:	bb 00 00 00 00       	mov    $0x0,%ebx
  809cb2:	ba 00 00 00 00       	mov    $0x0,%edx
  809cb7:	b8 00 00 00 00       	mov    $0x0,%eax
  809cbc:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  809cbf:	39 79 14             	cmp    %edi,0x14(%ecx)
  809cc2:	75 15                	jne    809cd9 <ip_reass_remove_oldest_datagram+0x52>
  809cc4:	8b 51 18             	mov    0x18(%ecx),%edx
  809cc7:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  809cca:	3b 56 10             	cmp    0x10(%esi),%edx
  809ccd:	75 0a                	jne    809cd9 <ip_reass_remove_oldest_datagram+0x52>
  809ccf:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  809cd3:	66 3b 56 04          	cmp    0x4(%esi),%dx
  809cd7:	74 14                	je     809ced <ip_reass_remove_oldest_datagram+0x66>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  809cd9:	83 c3 01             	add    $0x1,%ebx
        if (oldest == NULL) {
  809cdc:	85 c0                	test   %eax,%eax
  809cde:	74 0b                	je     809ceb <ip_reass_remove_oldest_datagram+0x64>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
  809ce0:	0f b6 71 1f          	movzbl 0x1f(%ecx),%esi
  809ce4:	89 f2                	mov    %esi,%edx
  809ce6:	3a 50 1f             	cmp    0x1f(%eax),%dl
  809ce9:	77 02                	ja     809ced <ip_reass_remove_oldest_datagram+0x66>
  809ceb:	89 c8                	mov    %ecx,%eax
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  809ced:	8b 31                	mov    (%ecx),%esi
  809cef:	85 f6                	test   %esi,%esi
  809cf1:	74 07                	je     809cfa <ip_reass_remove_oldest_datagram+0x73>
  809cf3:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  809cf6:	89 f1                	mov    %esi,%ecx
  809cf8:	eb c5                	jmp    809cbf <ip_reass_remove_oldest_datagram+0x38>
  809cfa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  809cfd:	85 c0                	test   %eax,%eax
  809cff:	74 08                	je     809d09 <ip_reass_remove_oldest_datagram+0x82>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  809d01:	e8 56 fe ff ff       	call   809b5c <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  809d06:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  809d09:	8b 75 dc             	mov    -0x24(%ebp),%esi
  809d0c:	39 75 e0             	cmp    %esi,-0x20(%ebp)
  809d0f:	7d 05                	jge    809d16 <ip_reass_remove_oldest_datagram+0x8f>
  809d11:	83 fb 01             	cmp    $0x1,%ebx
  809d14:	7f 87                	jg     809c9d <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
}
  809d16:	8b 45 e0             	mov    -0x20(%ebp),%eax
  809d19:	83 c4 2c             	add    $0x2c,%esp
  809d1c:	5b                   	pop    %ebx
  809d1d:	5e                   	pop    %esi
  809d1e:	5f                   	pop    %edi
  809d1f:	5d                   	pop    %ebp
  809d20:	c3                   	ret    

00809d21 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  809d21:	55                   	push   %ebp
  809d22:	89 e5                	mov    %esp,%ebp
  809d24:	56                   	push   %esi
  809d25:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  809d26:	a1 40 54 b3 00       	mov    0xb35440,%eax
  while (r != NULL) {
  809d2b:	85 c0                	test   %eax,%eax
  809d2d:	74 2a                	je     809d59 <ip_reass_tmr+0x38>
  809d2f:	be 00 00 00 00       	mov    $0x0,%esi
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  809d34:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  809d38:	84 d2                	test   %dl,%dl
  809d3a:	74 0c                	je     809d48 <ip_reass_tmr+0x27>
      r->timer--;
  809d3c:	83 ea 01             	sub    $0x1,%edx
  809d3f:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
  809d42:	8b 18                	mov    (%eax),%ebx
  809d44:	89 c6                	mov    %eax,%esi
  809d46:	eb 09                	jmp    809d51 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  809d48:	8b 18                	mov    (%eax),%ebx
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  809d4a:	89 f2                	mov    %esi,%edx
  809d4c:	e8 0b fe ff ff       	call   809b5c <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  809d51:	85 db                	test   %ebx,%ebx
  809d53:	74 04                	je     809d59 <ip_reass_tmr+0x38>
  809d55:	89 d8                	mov    %ebx,%eax
  809d57:	eb db                	jmp    809d34 <ip_reass_tmr+0x13>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  809d59:	5b                   	pop    %ebx
  809d5a:	5e                   	pop    %esi
  809d5b:	5d                   	pop    %ebp
  809d5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  809d60:	c3                   	ret    

00809d61 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  809d61:	55                   	push   %ebp
  809d62:	89 e5                	mov    %esp,%ebp
  809d64:	57                   	push   %edi
  809d65:	56                   	push   %esi
  809d66:	53                   	push   %ebx
  809d67:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  809d6a:	8b 45 08             	mov    0x8(%ebp),%eax
  809d6d:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  809d70:	0f b7 03             	movzwl (%ebx),%eax
  809d73:	89 04 24             	mov    %eax,(%esp)
  809d76:	e8 15 0a 00 00       	call   80a790 <ntohs>
  809d7b:	c1 e8 06             	shr    $0x6,%eax
  809d7e:	83 e0 3c             	and    $0x3c,%eax
  809d81:	83 f8 14             	cmp    $0x14,%eax
  809d84:	0f 85 f3 04 00 00    	jne    80a27d <ip_reass+0x51c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  809d8a:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809d8e:	89 04 24             	mov    %eax,(%esp)
  809d91:	e8 fa 09 00 00       	call   80a790 <ntohs>
  809d96:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  809d9a:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809d9e:	89 04 24             	mov    %eax,(%esp)
  809da1:	e8 ea 09 00 00       	call   80a790 <ntohs>
  809da6:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  809daa:	0f b7 03             	movzwl (%ebx),%eax
  809dad:	89 04 24             	mov    %eax,(%esp)
  809db0:	e8 db 09 00 00       	call   80a790 <ntohs>
  809db5:	66 89 45 dc          	mov    %ax,-0x24(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  809db9:	8b 55 08             	mov    0x8(%ebp),%edx
  809dbc:	89 14 24             	mov    %edx,(%esp)
  809dbf:	e8 6c d7 ff ff       	call   807530 <pbuf_clen>
  809dc4:	89 c7                	mov    %eax,%edi
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  809dc6:	0f b6 c8             	movzbl %al,%ecx
  809dc9:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  809dcc:	0f b7 05 44 54 b3 00 	movzwl 0xb35444,%eax
  809dd3:	01 c8                	add    %ecx,%eax
  809dd5:	83 f8 0a             	cmp    $0xa,%eax
  809dd8:	7e 24                	jle    809dfe <ip_reass+0x9d>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  809dda:	89 ca                	mov    %ecx,%edx
  809ddc:	89 d8                	mov    %ebx,%eax
  809dde:	e8 a4 fe ff ff       	call   809c87 <ip_reass_remove_oldest_datagram>
  809de3:	85 c0                	test   %eax,%eax
  809de5:	0f 84 92 04 00 00    	je     80a27d <ip_reass+0x51c>
  809deb:	0f b7 05 44 54 b3 00 	movzwl 0xb35444,%eax
  809df2:	03 45 e0             	add    -0x20(%ebp),%eax
  809df5:	83 f8 0a             	cmp    $0xa,%eax
  809df8:	0f 8f 7f 04 00 00    	jg     80a27d <ip_reass+0x51c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  809dfe:	8b 35 40 54 b3 00    	mov    0xb35440,%esi
  809e04:	85 f6                	test   %esi,%esi
  809e06:	0f 84 97 04 00 00    	je     80a2a3 <ip_reass+0x542>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  809e0c:	8b 53 0c             	mov    0xc(%ebx),%edx
  809e0f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  809e16:	b9 00 00 00 00       	mov    $0x0,%ecx
  809e1b:	39 56 14             	cmp    %edx,0x14(%esi)
  809e1e:	75 12                	jne    809e32 <ip_reass+0xd1>
  809e20:	8b 46 18             	mov    0x18(%esi),%eax
  809e23:	3b 43 10             	cmp    0x10(%ebx),%eax
  809e26:	75 0a                	jne    809e32 <ip_reass+0xd1>
  809e28:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  809e2c:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  809e30:	74 11                	je     809e43 <ip_reass+0xe2>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  809e32:	8b 06                	mov    (%esi),%eax
  809e34:	85 c0                	test   %eax,%eax
  809e36:	75 05                	jne    809e3d <ip_reass+0xdc>
  809e38:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809e3b:	eb 10                	jmp    809e4d <ip_reass+0xec>
  809e3d:	89 f1                	mov    %esi,%ecx
  809e3f:	89 c6                	mov    %eax,%esi
  809e41:	eb d8                	jmp    809e1b <ip_reass+0xba>
  809e43:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  809e46:	89 75 cc             	mov    %esi,-0x34(%ebp)
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  809e49:	85 f6                	test   %esi,%esi
  809e4b:	75 7d                	jne    809eca <ip_reass+0x169>
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  809e4d:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  809e54:	e8 ef d3 ff ff       	call   807248 <memp_malloc>
  809e59:	89 c6                	mov    %eax,%esi
  if (ipr == NULL) {
  809e5b:	85 c0                	test   %eax,%eax
  809e5d:	75 29                	jne    809e88 <ip_reass+0x127>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  809e5f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  809e62:	89 d8                	mov    %ebx,%eax
  809e64:	e8 1e fe ff ff       	call   809c87 <ip_reass_remove_oldest_datagram>
  809e69:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  809e6c:	0f 8f 0b 04 00 00    	jg     80a27d <ip_reass+0x51c>
      ipr = memp_malloc(MEMP_REASSDATA);
  809e72:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  809e79:	e8 ca d3 ff ff       	call   807248 <memp_malloc>
  809e7e:	89 c6                	mov    %eax,%esi
    }
    if (ipr == NULL)
  809e80:	85 c0                	test   %eax,%eax
  809e82:	0f 84 f5 03 00 00    	je     80a27d <ip_reass+0x51c>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  809e88:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  809e8f:	00 
  809e90:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809e97:	00 
  809e98:	89 34 24             	mov    %esi,(%esp)
  809e9b:	e8 f6 73 ff ff       	call   801296 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  809ea0:	c6 46 1f 03          	movb   $0x3,0x1f(%esi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  809ea4:	a1 40 54 b3 00       	mov    0xb35440,%eax
  809ea9:	89 06                	mov    %eax,(%esi)
  reassdatagrams = ipr;
  809eab:	89 35 40 54 b3 00    	mov    %esi,0xb35440
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  809eb1:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809eb8:	00 
  809eb9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809ebd:	8d 46 08             	lea    0x8(%esi),%eax
  809ec0:	89 04 24             	mov    %eax,(%esp)
  809ec3:	e8 a9 74 ff ff       	call   801371 <memcpy>
  809ec8:	eb 41                	jmp    809f0b <ip_reass+0x1aa>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  809eca:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809ece:	89 04 24             	mov    %eax,(%esp)
  809ed1:	e8 ba 08 00 00       	call   80a790 <ntohs>
  809ed6:	66 a9 ff 1f          	test   $0x1fff,%ax
  809eda:	75 2f                	jne    809f0b <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  809edc:	8b 55 cc             	mov    -0x34(%ebp),%edx
  809edf:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  809ee3:	89 04 24             	mov    %eax,(%esp)
  809ee6:	e8 a5 08 00 00       	call   80a790 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  809eeb:	66 a9 ff 1f          	test   $0x1fff,%ax
  809eef:	74 1a                	je     809f0b <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  809ef1:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809ef8:	00 
  809ef9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809efd:	8b 45 cc             	mov    -0x34(%ebp),%eax
  809f00:	83 c0 08             	add    $0x8,%eax
  809f03:	89 04 24             	mov    %eax,(%esp)
  809f06:	e8 66 74 ff ff       	call   801371 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  809f0b:	66 81 e7 ff 00       	and    $0xff,%di
  809f10:	66 01 3d 44 54 b3 00 	add    %di,0xb35444

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  809f17:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809f1b:	89 04 24             	mov    %eax,(%esp)
  809f1e:	e8 6d 08 00 00       	call   80a790 <ntohs>
  809f23:	f6 c4 20             	test   $0x20,%ah
  809f26:	75 23                	jne    809f4b <ip_reass+0x1ea>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  809f28:	80 4e 1e 01          	orb    $0x1,0x1e(%esi)
    ipr->datagram_len = offset + len;
  809f2c:	0f b7 4d d0          	movzwl -0x30(%ebp),%ecx
  809f30:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
  809f34:	8d 14 cb             	lea    (%ebx,%ecx,8),%edx
  809f37:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  809f3b:	66 c1 e8 08          	shr    $0x8,%ax
  809f3f:	83 e0 0f             	and    $0xf,%eax
  809f42:	f7 d8                	neg    %eax
  809f44:	8d 04 82             	lea    (%edx,%eax,4),%eax
  809f47:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  809f4b:	8b 7d 08             	mov    0x8(%ebp),%edi
  809f4e:	8b 5f 04             	mov    0x4(%edi),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  809f51:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809f55:	89 04 24             	mov    %eax,(%esp)
  809f58:	e8 33 08 00 00       	call   80a790 <ntohs>
  809f5d:	89 c7                	mov    %eax,%edi
  809f5f:	0f b7 03             	movzwl (%ebx),%eax
  809f62:	89 04 24             	mov    %eax,(%esp)
  809f65:	e8 26 08 00 00       	call   80a790 <ntohs>
  809f6a:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  809f6e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809f72:	89 04 24             	mov    %eax,(%esp)
  809f75:	e8 16 08 00 00       	call   80a790 <ntohs>
  809f7a:	c1 e0 03             	shl    $0x3,%eax
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  809f7d:	8b 55 08             	mov    0x8(%ebp),%edx
  809f80:	8b 52 04             	mov    0x4(%edx),%edx
  809f83:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  809f86:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  809f8c:	66 89 42 04          	mov    %ax,0x4(%edx)
  iprh->end = offset + len;
  809f90:	8d 0c 38             	lea    (%eax,%edi,1),%ecx
  809f93:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  809f97:	66 c1 ea 08          	shr    $0x8,%dx
  809f9b:	83 e2 0f             	and    $0xf,%edx
  809f9e:	f7 da                	neg    %edx
  809fa0:	8d 14 91             	lea    (%ecx,%edx,4),%edx
  809fa3:	66 89 55 da          	mov    %dx,-0x26(%ebp)
  809fa7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809faa:	66 89 51 06          	mov    %dx,0x6(%ecx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  809fae:	8b 7e 04             	mov    0x4(%esi),%edi
  809fb1:	85 ff                	test   %edi,%edi
  809fb3:	0f 84 0c 03 00 00    	je     80a2c5 <ip_reass+0x564>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  809fb9:	8b 57 04             	mov    0x4(%edi),%edx
    if (iprh->start < iprh_tmp->start) {
  809fbc:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  809fc0:	66 39 c8             	cmp    %cx,%ax
  809fc3:	0f 82 e6 02 00 00    	jb     80a2af <ip_reass+0x54e>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  809fc9:	66 39 c8             	cmp    %cx,%ax
  809fcc:	0f 84 1f 02 00 00    	je     80a1f1 <ip_reass+0x490>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  809fd2:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  809fd9:	66 39 42 06          	cmp    %ax,0x6(%edx)
  809fdd:	0f 86 87 00 00 00    	jbe    80a06a <ip_reass+0x309>
  809fe3:	e9 09 02 00 00       	jmp    80a1f1 <ip_reass+0x490>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  809fe8:	8b 4f 04             	mov    0x4(%edi),%ecx
    if (iprh->start < iprh_tmp->start) {
  809feb:	0f b7 59 04          	movzwl 0x4(%ecx),%ebx
  809fef:	66 39 d8             	cmp    %bx,%ax
  809ff2:	73 49                	jae    80a03d <ip_reass+0x2dc>
  809ff4:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  809ff7:	89 75 dc             	mov    %esi,-0x24(%ebp)
  809ffa:	8b 75 d0             	mov    -0x30(%ebp),%esi
  809ffd:	89 d3                	mov    %edx,%ebx
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  809fff:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80a002:	89 39                	mov    %edi,(%ecx)
      if (iprh_prev != NULL) {
  80a004:	85 d2                	test   %edx,%edx
  80a006:	74 25                	je     80a02d <ip_reass+0x2cc>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80a008:	66 3b 42 06          	cmp    0x6(%edx),%ax
  80a00c:	0f 82 df 01 00 00    	jb     80a1f1 <ip_reass+0x490>
  80a012:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80a016:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80a019:	66 3b 47 04          	cmp    0x4(%edi),%ax
  80a01d:	0f 87 ce 01 00 00    	ja     80a1f1 <ip_reass+0x490>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  80a023:	8b 55 08             	mov    0x8(%ebp),%edx
  80a026:	89 13                	mov    %edx,(%ebx)
  80a028:	e9 c6 00 00 00       	jmp    80a0f3 <ip_reass+0x392>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  80a02d:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a030:	89 4e 04             	mov    %ecx,0x4(%esi)
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  80a033:	85 ff                	test   %edi,%edi
  80a035:	0f 85 b8 00 00 00    	jne    80a0f3 <ip_reass+0x392>
  80a03b:	eb 43                	jmp    80a080 <ip_reass+0x31f>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80a03d:	66 39 d8             	cmp    %bx,%ax
  80a040:	0f 84 ab 01 00 00    	je     80a1f1 <ip_reass+0x490>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80a046:	66 3b 41 06          	cmp    0x6(%ecx),%ax
  80a04a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80a050:	0f 82 9b 01 00 00    	jb     80a1f1 <ip_reass+0x490>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  80a056:	85 d2                	test   %edx,%edx
  80a058:	74 0c                	je     80a066 <ip_reass+0x305>
        if (iprh_prev->end != iprh_tmp->start) {
  80a05a:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  80a05e:	bb 00 00 00 00       	mov    $0x0,%ebx
  80a063:	0f 45 f3             	cmovne %ebx,%esi
  80a066:	89 ca                	mov    %ecx,%edx
  80a068:	eb 06                	jmp    80a070 <ip_reass+0x30f>
  80a06a:	89 75 d0             	mov    %esi,-0x30(%ebp)
  80a06d:	8b 75 dc             	mov    -0x24(%ebp),%esi
           * and the previous fragment */
          valid = 0;
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  80a070:	8b 3a                	mov    (%edx),%edi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80a072:	85 ff                	test   %edi,%edi
  80a074:	0f 85 6e ff ff ff    	jne    809fe8 <ip_reass+0x287>
  80a07a:	89 75 dc             	mov    %esi,-0x24(%ebp)
  80a07d:	8b 75 d0             	mov    -0x30(%ebp),%esi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  80a080:	85 d2                	test   %edx,%edx
  80a082:	74 47                	je     80a0cb <ip_reass+0x36a>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  80a084:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a088:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80a08b:	66 3b 47 04          	cmp    0x4(%edi),%ax
  80a08f:	76 1c                	jbe    80a0ad <ip_reass+0x34c>
  80a091:	c7 44 24 08 a0 38 81 	movl   $0x8138a0,0x8(%esp)
  80a098:	00 
  80a099:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  80a0a0:	00 
  80a0a1:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a0a8:	e8 67 68 ff ff       	call   800914 <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  80a0ad:	8b 45 08             	mov    0x8(%ebp),%eax
  80a0b0:	89 02                	mov    %eax,(%edx)
      if (iprh_prev->end != iprh->start) {
  80a0b2:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a0b6:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a0b9:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80a0bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80a0c2:	0f 44 45 dc          	cmove  -0x24(%ebp),%eax
  80a0c6:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80a0c9:	eb 28                	jmp    80a0f3 <ip_reass+0x392>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  80a0cb:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  80a0cf:	74 1c                	je     80a0ed <ip_reass+0x38c>
  80a0d1:	c7 44 24 08 cc 38 81 	movl   $0x8138cc,0x8(%esp)
  80a0d8:	00 
  80a0d9:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  80a0e0:	00 
  80a0e1:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a0e8:	e8 27 68 ff ff       	call   800914 <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  80a0ed:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a0f0:	89 4e 04             	mov    %ecx,0x4(%esi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80a0f3:	f6 46 1e 01          	testb  $0x1,0x1e(%esi)
  80a0f7:	0f 84 94 01 00 00    	je     80a291 <ip_reass+0x530>
    /* and had no wholes so far */
    if (valid) {
  80a0fd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80a101:	0f 84 8a 01 00 00    	je     80a291 <ip_reass+0x530>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  80a107:	8b 56 04             	mov    0x4(%esi),%edx
  80a10a:	8b 42 04             	mov    0x4(%edx),%eax
  80a10d:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  80a112:	0f 85 79 01 00 00    	jne    80a291 <ip_reass+0x530>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  80a118:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a11b:	8b 0b                	mov    (%ebx),%ecx
        while (q != NULL) {
  80a11d:	85 c9                	test   %ecx,%ecx
  80a11f:	0f 84 b1 01 00 00    	je     80a2d6 <ip_reass+0x575>
          iprh = (struct ip_reass_helper*)q->payload;
  80a125:	8b 49 04             	mov    0x4(%ecx),%ecx
          if (iprh_prev->end != iprh->start) {
  80a128:	0f b7 5b 06          	movzwl 0x6(%ebx),%ebx
  80a12c:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80a12f:	66 3b 59 04          	cmp    0x4(%ecx),%bx
  80a133:	74 1d                	je     80a152 <ip_reass+0x3f1>
  80a135:	e9 57 01 00 00       	jmp    80a291 <ip_reass+0x530>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80a13a:	8b 49 04             	mov    0x4(%ecx),%ecx
          if (iprh_prev->end != iprh->start) {
  80a13d:	0f b7 5b 06          	movzwl 0x6(%ebx),%ebx
  80a141:	66 3b 59 04          	cmp    0x4(%ecx),%bx
  80a145:	0f 85 46 01 00 00    	jne    80a291 <ip_reass+0x530>
  80a14b:	89 cb                	mov    %ecx,%ebx
  80a14d:	8d 76 00             	lea    0x0(%esi),%esi
  80a150:	eb 03                	jmp    80a155 <ip_reass+0x3f4>
  80a152:	8b 5d e0             	mov    -0x20(%ebp),%ebx
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  80a155:	8b 0b                	mov    (%ebx),%ecx
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  80a157:	85 c9                	test   %ecx,%ecx
  80a159:	75 df                	jne    80a13a <ip_reass+0x3d9>
  80a15b:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  80a15e:	e9 73 01 00 00       	jmp    80a2d6 <ip_reass+0x575>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a163:	c7 44 24 08 be 38 81 	movl   $0x8138be,0x8(%esp)
  80a16a:	00 
  80a16b:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  80a172:	00 
  80a173:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a17a:	e8 95 67 ff ff       	call   800914 <_panic>
          LWIP_ASSERT("sanity check",
  80a17f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80a182:	75 1c                	jne    80a1a0 <ip_reass+0x43f>
  80a184:	c7 44 24 08 be 38 81 	movl   $0x8138be,0x8(%esp)
  80a18b:	00 
  80a18c:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  80a193:	00 
  80a194:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a19b:	e8 74 67 ff ff       	call   800914 <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80a1a0:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a1a3:	83 38 00             	cmpl   $0x0,(%eax)
  80a1a6:	74 1c                	je     80a1c4 <ip_reass+0x463>
  80a1a8:	c7 44 24 08 04 39 81 	movl   $0x813904,0x8(%esp)
  80a1af:	00 
  80a1b0:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  80a1b7:	00 
  80a1b8:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a1bf:	e8 50 67 ff ff       	call   800914 <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80a1c4:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a1c7:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a1cb:	66 3b 46 1c          	cmp    0x1c(%esi),%ax
  80a1cf:	0f 84 10 01 00 00    	je     80a2e5 <ip_reass+0x584>
  80a1d5:	c7 44 24 08 28 39 81 	movl   $0x813928,0x8(%esp)
  80a1dc:	00 
  80a1dd:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80a1e4:	00 
  80a1e5:	c7 04 24 4a 38 81 00 	movl   $0x81384a,(%esp)
  80a1ec:	e8 23 67 ff ff       	call   800914 <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80a1f1:	0f b7 1d 44 54 b3 00 	movzwl 0xb35444,%ebx
  80a1f8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a1fb:	89 0c 24             	mov    %ecx,(%esp)
  80a1fe:	e8 2d d3 ff ff       	call   807530 <pbuf_clen>
  80a203:	0f b6 c0             	movzbl %al,%eax
  80a206:	66 29 c3             	sub    %ax,%bx
  80a209:	66 89 1d 44 54 b3 00 	mov    %bx,0xb35444
  pbuf_free(new_p);
  80a210:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a213:	89 1c 24             	mov    %ebx,(%esp)
  80a216:	e8 72 d7 ff ff       	call   80798d <pbuf_free>
  80a21b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80a222:	eb 74                	jmp    80a298 <ip_reass+0x537>
  80a224:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80a227:	8b 75 e4             	mov    -0x1c(%ebp),%esi

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  80a22a:	8b 5f 04             	mov    0x4(%edi),%ebx

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  80a22d:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80a234:	ff 
  80a235:	89 3c 24             	mov    %edi,(%esp)
  80a238:	e8 e6 d3 ff ff       	call   807623 <pbuf_header>
      pbuf_cat(p, r);
  80a23d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a241:	89 34 24             	mov    %esi,(%esp)
  80a244:	e8 12 d3 ff ff       	call   80755b <pbuf_cat>
      r = iprh->next_pbuf;
  80a249:	8b 3b                	mov    (%ebx),%edi
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a24b:	85 ff                	test   %edi,%edi
  80a24d:	75 db                	jne    80a22a <ip_reass+0x4c9>
  80a24f:	8b 75 e0             	mov    -0x20(%ebp),%esi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80a252:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80a255:	89 f0                	mov    %esi,%eax
  80a257:	e8 b0 f8 ff ff       	call   809b0c <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  80a25c:	0f b7 1d 44 54 b3 00 	movzwl 0xb35444,%ebx
  80a263:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80a266:	89 3c 24             	mov    %edi,(%esp)
  80a269:	e8 c2 d2 ff ff       	call   807530 <pbuf_clen>
  80a26e:	0f b6 c0             	movzbl %al,%eax
  80a271:	66 29 c3             	sub    %ax,%bx
  80a274:	66 89 1d 44 54 b3 00 	mov    %bx,0xb35444

    /* Return the pbuf chain */
    return p;
  80a27b:	eb 1b                	jmp    80a298 <ip_reass+0x537>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  80a27d:	8b 45 08             	mov    0x8(%ebp),%eax
  80a280:	89 04 24             	mov    %eax,(%esp)
  80a283:	e8 05 d7 ff ff       	call   80798d <pbuf_free>
  80a288:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  return NULL;
  80a28f:	eb 07                	jmp    80a298 <ip_reass+0x537>
  80a291:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  80a298:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a29b:	83 c4 3c             	add    $0x3c,%esp
  80a29e:	5b                   	pop    %ebx
  80a29f:	5e                   	pop    %esi
  80a2a0:	5f                   	pop    %edi
  80a2a1:	5d                   	pop    %ebp
  80a2a2:	c3                   	ret    

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
  80a2a3:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  80a2aa:	e9 9e fb ff ff       	jmp    809e4d <ip_reass+0xec>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80a2af:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a2b2:	89 3a                	mov    %edi,(%edx)
  80a2b4:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a2bb:	ba 00 00 00 00       	mov    $0x0,%edx
  80a2c0:	e9 68 fd ff ff       	jmp    80a02d <ip_reass+0x2cc>
  80a2c5:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a2cc:	ba 00 00 00 00       	mov    $0x0,%edx
  80a2d1:	e9 aa fd ff ff       	jmp    80a080 <ip_reass+0x31f>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a2d6:	85 d2                	test   %edx,%edx
  80a2d8:	0f 85 a1 fe ff ff    	jne    80a17f <ip_reass+0x41e>
  80a2de:	66 90                	xchg   %ax,%ax
  80a2e0:	e9 7e fe ff ff       	jmp    80a163 <ip_reass+0x402>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  80a2e5:	83 c0 14             	add    $0x14,%eax
  80a2e8:	66 89 46 1c          	mov    %ax,0x1c(%esi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80a2ec:	8b 46 04             	mov    0x4(%esi),%eax
  80a2ef:	8b 58 04             	mov    0x4(%eax),%ebx
  80a2f2:	8b 3b                	mov    (%ebx),%edi

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  80a2f4:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a2fb:	00 
  80a2fc:	8d 46 08             	lea    0x8(%esi),%eax
  80a2ff:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a303:	89 1c 24             	mov    %ebx,(%esp)
  80a306:	e8 66 70 ff ff       	call   801371 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  80a30b:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80a30f:	89 04 24             	mov    %eax,(%esp)
  80a312:	e8 6c 04 00 00       	call   80a783 <htons>
  80a317:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(fraghdr, 0);
  80a31b:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_CHKSUM_SET(fraghdr, 0);
  80a321:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  80a327:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80a32e:	00 
  80a32f:	89 1c 24             	mov    %ebx,(%esp)
  80a332:	e8 33 01 00 00       	call   80a46a <inet_chksum>
  80a337:	66 89 43 0a          	mov    %ax,0xa(%ebx)

    p = ipr->p;
  80a33b:	8b 4e 04             	mov    0x4(%esi),%ecx
  80a33e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a341:	85 ff                	test   %edi,%edi
  80a343:	0f 85 db fe ff ff    	jne    80a224 <ip_reass+0x4c3>
  80a349:	e9 04 ff ff ff       	jmp    80a252 <ip_reass+0x4f1>
	...

0080a350 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80a350:	55                   	push   %ebp
  80a351:	89 e5                	mov    %esp,%ebp
  80a353:	57                   	push   %edi
  80a354:	56                   	push   %esi
  80a355:	53                   	push   %ebx
  80a356:	83 ec 2c             	sub    $0x2c,%esp
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  80a359:	89 c7                	mov    %eax,%edi
  while (len > 1) {
  80a35b:	b9 00 00 00 00       	mov    $0x0,%ecx
  80a360:	66 83 fa 01          	cmp    $0x1,%dx
  80a364:	76 3a                	jbe    80a3a0 <lwip_standard_chksum+0x50>
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80a366:	83 ea 02             	sub    $0x2,%edx
  80a369:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
  80a36d:	66 d1 ea             	shr    %dx
  80a370:	0f b7 d2             	movzwl %dx,%edx
  80a373:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80a376:	8d 74 50 02          	lea    0x2(%eax,%edx,2),%esi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80a37a:	0f b6 18             	movzbl (%eax),%ebx
  80a37d:	c1 e3 08             	shl    $0x8,%ebx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  80a380:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  80a384:	09 da                	or     %ebx,%edx
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80a386:	83 c0 02             	add    $0x2,%eax
    src = (*octetptr) << 8;
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
  80a389:	0f b7 d2             	movzwl %dx,%edx
  80a38c:	01 d1                	add    %edx,%ecx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80a38e:	39 c6                	cmp    %eax,%esi
  80a390:	75 e8                	jne    80a37a <lwip_standard_chksum+0x2a>
  80a392:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a395:	8d 7c 47 02          	lea    0x2(%edi,%eax,2),%edi
  80a399:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  80a39d:	83 e2 01             	and    $0x1,%edx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  80a3a0:	66 85 d2             	test   %dx,%dx
  80a3a3:	74 0b                	je     80a3b0 <lwip_standard_chksum+0x60>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  80a3a5:	0f b6 07             	movzbl (%edi),%eax
  80a3a8:	c1 e0 08             	shl    $0x8,%eax
  80a3ab:	0f b7 c0             	movzwl %ax,%eax
  80a3ae:	01 c1                	add    %eax,%ecx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a3b0:	89 c8                	mov    %ecx,%eax
  80a3b2:	c1 e8 10             	shr    $0x10,%eax
  80a3b5:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  80a3bb:	01 c1                	add    %eax,%ecx
  if ((acc & 0xffff0000) != 0) {
  80a3bd:	f7 c1 00 00 ff ff    	test   $0xffff0000,%ecx
  80a3c3:	74 0d                	je     80a3d2 <lwip_standard_chksum+0x82>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a3c5:	89 c8                	mov    %ecx,%eax
  80a3c7:	c1 e8 10             	shr    $0x10,%eax
  80a3ca:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  80a3d0:	01 c1                	add    %eax,%ecx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  80a3d2:	0f b7 c9             	movzwl %cx,%ecx
  80a3d5:	89 0c 24             	mov    %ecx,(%esp)
  80a3d8:	e8 a6 03 00 00       	call   80a783 <htons>
}
  80a3dd:	83 c4 2c             	add    $0x2c,%esp
  80a3e0:	5b                   	pop    %ebx
  80a3e1:	5e                   	pop    %esi
  80a3e2:	5f                   	pop    %edi
  80a3e3:	5d                   	pop    %ebp
  80a3e4:	c3                   	ret    

0080a3e5 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  80a3e5:	55                   	push   %ebp
  80a3e6:	89 e5                	mov    %esp,%ebp
  80a3e8:	57                   	push   %edi
  80a3e9:	56                   	push   %esi
  80a3ea:	53                   	push   %ebx
  80a3eb:	83 ec 0c             	sub    $0xc,%esp
  80a3ee:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80a3f1:	be 00 00 00 00       	mov    $0x0,%esi
  80a3f6:	85 db                	test   %ebx,%ebx
  80a3f8:	74 64                	je     80a45e <inet_chksum_pbuf+0x79>
  80a3fa:	bf 00 00 00 00       	mov    $0x0,%edi
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a3ff:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80a403:	8b 43 04             	mov    0x4(%ebx),%eax
  80a406:	e8 45 ff ff ff       	call   80a350 <lwip_standard_chksum>
  80a40b:	0f b7 c0             	movzwl %ax,%eax
  80a40e:	8d 34 30             	lea    (%eax,%esi,1),%esi
    acc = FOLD_U32T(acc);
  80a411:	89 f0                	mov    %esi,%eax
  80a413:	c1 e8 10             	shr    $0x10,%eax
  80a416:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80a41c:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80a41e:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a422:	74 1c                	je     80a440 <inet_chksum_pbuf+0x5b>
      swapped = 1 - swapped;
  80a424:	b8 01 00 00 00       	mov    $0x1,%eax
  80a429:	89 fa                	mov    %edi,%edx
  80a42b:	28 d0                	sub    %dl,%al
  80a42d:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80a42f:	89 f0                	mov    %esi,%eax
  80a431:	c1 e0 08             	shl    $0x8,%eax
  80a434:	25 ff ff 00 00       	and    $0xffff,%eax
  80a439:	89 f2                	mov    %esi,%edx
  80a43b:	0f b6 f6             	movzbl %dh,%esi
  80a43e:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80a440:	8b 1b                	mov    (%ebx),%ebx
  80a442:	85 db                	test   %ebx,%ebx
  80a444:	75 b9                	jne    80a3ff <inet_chksum_pbuf+0x1a>
  80a446:	89 f0                	mov    %esi,%eax
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  80a448:	89 fa                	mov    %edi,%edx
  80a44a:	84 d2                	test   %dl,%dl
  80a44c:	74 10                	je     80a45e <inet_chksum_pbuf+0x79>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a44e:	89 f2                	mov    %esi,%edx
  80a450:	c1 e2 08             	shl    $0x8,%edx
  80a453:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a459:	0f b6 f4             	movzbl %ah,%esi
  80a45c:	09 d6                	or     %edx,%esi
  80a45e:	89 f0                	mov    %esi,%eax
  80a460:	f7 d0                	not    %eax
  }
  return (u16_t)~(acc & 0xffffUL);
}
  80a462:	83 c4 0c             	add    $0xc,%esp
  80a465:	5b                   	pop    %ebx
  80a466:	5e                   	pop    %esi
  80a467:	5f                   	pop    %edi
  80a468:	5d                   	pop    %ebp
  80a469:	c3                   	ret    

0080a46a <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  80a46a:	55                   	push   %ebp
  80a46b:	89 e5                	mov    %esp,%ebp
  80a46d:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80a470:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  80a474:	8b 45 08             	mov    0x8(%ebp),%eax
  80a477:	e8 d4 fe ff ff       	call   80a350 <lwip_standard_chksum>
  80a47c:	f7 d0                	not    %eax
}
  80a47e:	c9                   	leave  
  80a47f:	c3                   	ret    

0080a480 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  80a480:	55                   	push   %ebp
  80a481:	89 e5                	mov    %esp,%ebp
  80a483:	57                   	push   %edi
  80a484:	56                   	push   %esi
  80a485:	53                   	push   %ebx
  80a486:	83 ec 2c             	sub    $0x2c,%esp
  80a489:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a48c:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80a490:	88 45 e7             	mov    %al,-0x19(%ebp)
  80a493:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80a497:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80a49b:	be 00 00 00 00       	mov    $0x0,%esi
  80a4a0:	85 db                	test   %ebx,%ebx
  80a4a2:	74 64                	je     80a508 <inet_chksum_pseudo+0x88>
  80a4a4:	bf 00 00 00 00       	mov    $0x0,%edi
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a4a9:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80a4ad:	8b 43 04             	mov    0x4(%ebx),%eax
  80a4b0:	e8 9b fe ff ff       	call   80a350 <lwip_standard_chksum>
  80a4b5:	0f b7 c0             	movzwl %ax,%eax
  80a4b8:	8d 34 30             	lea    (%eax,%esi,1),%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  80a4bb:	89 f0                	mov    %esi,%eax
  80a4bd:	c1 e8 10             	shr    $0x10,%eax
  80a4c0:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80a4c6:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80a4c8:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a4cc:	74 1c                	je     80a4ea <inet_chksum_pseudo+0x6a>
      swapped = 1 - swapped;
  80a4ce:	b8 01 00 00 00       	mov    $0x1,%eax
  80a4d3:	89 fa                	mov    %edi,%edx
  80a4d5:	28 d0                	sub    %dl,%al
  80a4d7:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80a4d9:	89 f0                	mov    %esi,%eax
  80a4db:	c1 e0 08             	shl    $0x8,%eax
  80a4de:	25 ff ff 00 00       	and    $0xffff,%eax
  80a4e3:	89 f2                	mov    %esi,%edx
  80a4e5:	0f b6 f6             	movzbl %dh,%esi
  80a4e8:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80a4ea:	8b 1b                	mov    (%ebx),%ebx
  80a4ec:	85 db                	test   %ebx,%ebx
  80a4ee:	75 b9                	jne    80a4a9 <inet_chksum_pseudo+0x29>
  80a4f0:	89 f0                	mov    %esi,%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80a4f2:	89 fa                	mov    %edi,%edx
  80a4f4:	84 d2                	test   %dl,%dl
  80a4f6:	74 10                	je     80a508 <inet_chksum_pseudo+0x88>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a4f8:	89 f2                	mov    %esi,%edx
  80a4fa:	c1 e2 08             	shl    $0x8,%edx
  80a4fd:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a503:	0f b6 f4             	movzbl %ah,%esi
  80a506:	09 d6                	or     %edx,%esi
  }
  acc += (src->addr & 0xffffUL);
  80a508:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a50b:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80a50d:	8b 45 10             	mov    0x10(%ebp),%eax
  80a510:	8b 00                	mov    (%eax),%eax
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80a512:	89 d1                	mov    %edx,%ecx
  80a514:	c1 e9 10             	shr    $0x10,%ecx
  80a517:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a51d:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  80a520:	0f b7 c8             	movzwl %ax,%ecx
  80a523:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  80a525:	c1 e8 10             	shr    $0x10,%eax
  80a528:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80a52b:	8d 34 30             	lea    (%eax,%esi,1),%esi
  acc += (u32_t)htons((u16_t)proto);
  80a52e:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80a532:	89 04 24             	mov    %eax,(%esp)
  80a535:	e8 49 02 00 00       	call   80a783 <htons>
  80a53a:	0f b7 c0             	movzwl %ax,%eax
  80a53d:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  80a53f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80a543:	89 04 24             	mov    %eax,(%esp)
  80a546:	e8 38 02 00 00       	call   80a783 <htons>
  80a54b:	0f b7 c0             	movzwl %ax,%eax
  80a54e:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80a550:	89 f0                	mov    %esi,%eax
  80a552:	c1 e8 10             	shr    $0x10,%eax
  80a555:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80a55b:	01 c6                	add    %eax,%esi
  acc = FOLD_U32T(acc);
  80a55d:	89 f0                	mov    %esi,%eax
  80a55f:	c1 e8 10             	shr    $0x10,%eax
  80a562:	8d 04 06             	lea    (%esi,%eax,1),%eax
  80a565:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80a567:	83 c4 2c             	add    $0x2c,%esp
  80a56a:	5b                   	pop    %ebx
  80a56b:	5e                   	pop    %esi
  80a56c:	5f                   	pop    %edi
  80a56d:	5d                   	pop    %ebp
  80a56e:	c3                   	ret    

0080a56f <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80a56f:	55                   	push   %ebp
  80a570:	89 e5                	mov    %esp,%ebp
  80a572:	57                   	push   %edi
  80a573:	56                   	push   %esi
  80a574:	53                   	push   %ebx
  80a575:	83 ec 3c             	sub    $0x3c,%esp
  80a578:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a57b:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80a57f:	88 45 d6             	mov    %al,-0x2a(%ebp)
  80a582:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80a586:	66 89 55 d4          	mov    %dx,-0x2c(%ebp)
  80a58a:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80a58e:	85 db                	test   %ebx,%ebx
  80a590:	74 05                	je     80a597 <inet_chksum_pseudo_partial+0x28>
  80a592:	66 85 f6             	test   %si,%si
  80a595:	75 0a                	jne    80a5a1 <inet_chksum_pseudo_partial+0x32>
  80a597:	bf 00 00 00 00       	mov    $0x0,%edi
  80a59c:	e9 a7 00 00 00       	jmp    80a648 <inet_chksum_pseudo_partial+0xd9>
  80a5a1:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
  80a5a5:	bf 00 00 00 00       	mov    $0x0,%edi
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  80a5aa:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80a5ae:	66 39 c6             	cmp    %ax,%si
  80a5b1:	89 c2                	mov    %eax,%edx
  80a5b3:	0f 46 d6             	cmovbe %esi,%edx
  80a5b6:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80a5ba:	0f b7 d2             	movzwl %dx,%edx
  80a5bd:	8b 43 04             	mov    0x4(%ebx),%eax
  80a5c0:	e8 8b fd ff ff       	call   80a350 <lwip_standard_chksum>
    chksum_len -= chklen;
  80a5c5:	66 2b 75 d8          	sub    -0x28(%ebp),%si
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  80a5c9:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  80a5ce:	76 1c                	jbe    80a5ec <inet_chksum_pseudo_partial+0x7d>
  80a5d0:	c7 44 24 08 55 39 81 	movl   $0x813955,0x8(%esp)
  80a5d7:	00 
  80a5d8:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  80a5df:	00 
  80a5e0:	c7 04 24 60 39 81 00 	movl   $0x813960,(%esp)
  80a5e7:	e8 28 63 ff ff       	call   800914 <_panic>
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80a5ec:	0f b7 c0             	movzwl %ax,%eax
  80a5ef:	8d 3c 38             	lea    (%eax,%edi,1),%edi
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80a5f2:	89 fa                	mov    %edi,%edx
  80a5f4:	c1 ea 10             	shr    $0x10,%edx
  80a5f7:	81 e7 ff ff 00 00    	and    $0xffff,%edi
  80a5fd:	01 d7                	add    %edx,%edi
    if (q->len % 2 != 0) {
  80a5ff:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a603:	74 1c                	je     80a621 <inet_chksum_pseudo_partial+0xb2>
      swapped = 1 - swapped;
  80a605:	b8 01 00 00 00       	mov    $0x1,%eax
  80a60a:	2a 45 d7             	sub    -0x29(%ebp),%al
  80a60d:	88 45 d7             	mov    %al,-0x29(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80a610:	89 f8                	mov    %edi,%eax
  80a612:	c1 e0 08             	shl    $0x8,%eax
  80a615:	25 ff ff 00 00       	and    $0xffff,%eax
  80a61a:	89 fa                	mov    %edi,%edx
  80a61c:	0f b6 fe             	movzbl %dh,%edi
  80a61f:	09 c7                	or     %eax,%edi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80a621:	8b 1b                	mov    (%ebx),%ebx
  80a623:	85 db                	test   %ebx,%ebx
  80a625:	74 09                	je     80a630 <inet_chksum_pseudo_partial+0xc1>
  80a627:	66 85 f6             	test   %si,%si
  80a62a:	0f 85 7a ff ff ff    	jne    80a5aa <inet_chksum_pseudo_partial+0x3b>
  80a630:	89 f8                	mov    %edi,%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80a632:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80a636:	74 10                	je     80a648 <inet_chksum_pseudo_partial+0xd9>
    acc = SWAP_BYTES_IN_WORD(acc);
  80a638:	89 fa                	mov    %edi,%edx
  80a63a:	c1 e2 08             	shl    $0x8,%edx
  80a63d:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a643:	0f b6 fc             	movzbl %ah,%edi
  80a646:	09 d7                	or     %edx,%edi
  }
  acc += (src->addr & 0xffffUL);
  80a648:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a64b:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80a64d:	8b 45 10             	mov    0x10(%ebp),%eax
  80a650:	8b 00                	mov    (%eax),%eax
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80a652:	89 d1                	mov    %edx,%ecx
  80a654:	c1 e9 10             	shr    $0x10,%ecx
  80a657:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80a65d:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  80a660:	0f b7 c8             	movzwl %ax,%ecx
  80a663:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  80a665:	c1 e8 10             	shr    $0x10,%eax
  80a668:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80a66b:	8d 3c 38             	lea    (%eax,%edi,1),%edi
  acc += (u32_t)htons((u16_t)proto);
  80a66e:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
  80a672:	89 04 24             	mov    %eax,(%esp)
  80a675:	e8 09 01 00 00       	call   80a783 <htons>
  80a67a:	0f b7 c0             	movzwl %ax,%eax
  80a67d:	01 c7                	add    %eax,%edi
  acc += (u32_t)htons(proto_len);
  80a67f:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80a683:	89 04 24             	mov    %eax,(%esp)
  80a686:	e8 f8 00 00 00       	call   80a783 <htons>
  80a68b:	0f b7 c0             	movzwl %ax,%eax
  80a68e:	01 c7                	add    %eax,%edi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80a690:	89 f8                	mov    %edi,%eax
  80a692:	c1 e8 10             	shr    $0x10,%eax
  80a695:	81 e7 ff ff 00 00    	and    $0xffff,%edi
  80a69b:	8d 04 07             	lea    (%edi,%eax,1),%eax
  acc = FOLD_U32T(acc);
  80a69e:	89 c2                	mov    %eax,%edx
  80a6a0:	c1 ea 10             	shr    $0x10,%edx
  80a6a3:	01 d0                	add    %edx,%eax
  80a6a5:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80a6a7:	83 c4 3c             	add    $0x3c,%esp
  80a6aa:	5b                   	pop    %ebx
  80a6ab:	5e                   	pop    %esi
  80a6ac:	5f                   	pop    %edi
  80a6ad:	5d                   	pop    %ebp
  80a6ae:	c3                   	ret    
	...

0080a6b0 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80a6b0:	55                   	push   %ebp
  80a6b1:	89 e5                	mov    %esp,%ebp
  80a6b3:	57                   	push   %edi
  80a6b4:	56                   	push   %esi
  80a6b5:	53                   	push   %ebx
  80a6b6:	83 ec 20             	sub    $0x20,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  80a6b9:	8b 45 08             	mov    0x8(%ebp),%eax
  80a6bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  80a6bf:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80a6c2:	89 45 e0             	mov    %eax,-0x20(%ebp)
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80a6c5:	8d 55 f3             	lea    -0xd(%ebp),%edx
  80a6c8:	89 55 d8             	mov    %edx,-0x28(%ebp)
  80a6cb:	bb 3c 5a b3 00       	mov    $0xb35a3c,%ebx
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80a6d0:	b9 cd ff ff ff       	mov    $0xffffffcd,%ecx
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80a6d5:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80a6d8:	0f b6 37             	movzbl (%edi),%esi
  80a6db:	ba 00 00 00 00       	mov    $0x0,%edx
  80a6e0:	89 d0                	mov    %edx,%eax
  80a6e2:	89 f2                	mov    %esi,%edx
  80a6e4:	89 de                	mov    %ebx,%esi
  80a6e6:	89 c3                	mov    %eax,%ebx
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80a6e8:	89 d0                	mov    %edx,%eax
  80a6ea:	f6 e1                	mul    %cl
  80a6ec:	66 c1 e8 08          	shr    $0x8,%ax
  80a6f0:	c0 e8 03             	shr    $0x3,%al
  80a6f3:	89 c7                	mov    %eax,%edi
  80a6f5:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a6f8:	01 c0                	add    %eax,%eax
  80a6fa:	28 c2                	sub    %al,%dl
  80a6fc:	89 d0                	mov    %edx,%eax
      *ap /= (u8_t)10;
  80a6fe:	89 fa                	mov    %edi,%edx
      inv[i++] = '0' + rem;
  80a700:	0f b6 fb             	movzbl %bl,%edi
  80a703:	83 c0 30             	add    $0x30,%eax
  80a706:	88 44 3d ed          	mov    %al,-0x13(%ebp,%edi,1)
  80a70a:	8d 43 01             	lea    0x1(%ebx),%eax
    } while(*ap);
  80a70d:	84 d2                	test   %dl,%dl
  80a70f:	74 04                	je     80a715 <inet_ntoa+0x65>
  80a711:	89 c3                	mov    %eax,%ebx
  80a713:	eb d3                	jmp    80a6e8 <inet_ntoa+0x38>
  80a715:	88 45 d7             	mov    %al,-0x29(%ebp)
  80a718:	89 df                	mov    %ebx,%edi
  80a71a:	89 f3                	mov    %esi,%ebx
  80a71c:	89 d6                	mov    %edx,%esi
  80a71e:	89 fa                	mov    %edi,%edx
  80a720:	88 55 dc             	mov    %dl,-0x24(%ebp)
  80a723:	89 f0                	mov    %esi,%eax
  80a725:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80a728:	88 07                	mov    %al,(%edi)
    while(i--)
  80a72a:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80a72e:	74 2a                	je     80a75a <inet_ntoa+0xaa>
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80a730:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  80a734:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80a737:	8d 7c 03 01          	lea    0x1(%ebx,%eax,1),%edi
  80a73b:	89 d8                	mov    %ebx,%eax
  80a73d:	89 de                	mov    %ebx,%esi
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  80a73f:	0f b6 da             	movzbl %dl,%ebx
  80a742:	0f b6 5c 1d ed       	movzbl -0x13(%ebp,%ebx,1),%ebx
  80a747:	88 18                	mov    %bl,(%eax)
  80a749:	83 c0 01             	add    $0x1,%eax
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  80a74c:	83 ea 01             	sub    $0x1,%edx
  80a74f:	39 f8                	cmp    %edi,%eax
  80a751:	75 ec                	jne    80a73f <inet_ntoa+0x8f>
  80a753:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80a756:	8d 5c 16 01          	lea    0x1(%esi,%edx,1),%ebx
      *rp++ = inv[i];
    *rp++ = '.';
  80a75a:	c6 03 2e             	movb   $0x2e,(%ebx)
  80a75d:	8d 43 01             	lea    0x1(%ebx),%eax
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  80a760:	8b 7d d8             	mov    -0x28(%ebp),%edi
  80a763:	39 7d e0             	cmp    %edi,-0x20(%ebp)
  80a766:	74 0b                	je     80a773 <inet_ntoa+0xc3>
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  80a768:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  80a76c:	89 c3                	mov    %eax,%ebx
  80a76e:	e9 62 ff ff ff       	jmp    80a6d5 <inet_ntoa+0x25>
  }
  *--rp = 0;
  80a773:	c6 03 00             	movb   $0x0,(%ebx)
  return str;
}
  80a776:	b8 3c 5a b3 00       	mov    $0xb35a3c,%eax
  80a77b:	83 c4 20             	add    $0x20,%esp
  80a77e:	5b                   	pop    %ebx
  80a77f:	5e                   	pop    %esi
  80a780:	5f                   	pop    %edi
  80a781:	5d                   	pop    %ebp
  80a782:	c3                   	ret    

0080a783 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  80a783:	55                   	push   %ebp
  80a784:	89 e5                	mov    %esp,%ebp
  80a786:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80a78a:	66 c1 c0 08          	rol    $0x8,%ax
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
}
  80a78e:	5d                   	pop    %ebp
  80a78f:	c3                   	ret    

0080a790 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  80a790:	55                   	push   %ebp
  80a791:	89 e5                	mov    %esp,%ebp
  80a793:	83 ec 04             	sub    $0x4,%esp
  return htons(n);
  80a796:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80a79a:	89 04 24             	mov    %eax,(%esp)
  80a79d:	e8 e1 ff ff ff       	call   80a783 <htons>
}
  80a7a2:	c9                   	leave  
  80a7a3:	c3                   	ret    

0080a7a4 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  80a7a4:	55                   	push   %ebp
  80a7a5:	89 e5                	mov    %esp,%ebp
  80a7a7:	8b 55 08             	mov    0x8(%ebp),%edx
  80a7aa:	89 d1                	mov    %edx,%ecx
  80a7ac:	c1 e9 18             	shr    $0x18,%ecx
  80a7af:	89 d0                	mov    %edx,%eax
  80a7b1:	c1 e0 18             	shl    $0x18,%eax
  80a7b4:	09 c8                	or     %ecx,%eax
  80a7b6:	89 d1                	mov    %edx,%ecx
  80a7b8:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80a7be:	c1 e1 08             	shl    $0x8,%ecx
  80a7c1:	09 c8                	or     %ecx,%eax
  80a7c3:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  80a7c9:	c1 ea 08             	shr    $0x8,%edx
  80a7cc:	09 d0                	or     %edx,%eax
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  80a7ce:	5d                   	pop    %ebp
  80a7cf:	c3                   	ret    

0080a7d0 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  80a7d0:	55                   	push   %ebp
  80a7d1:	89 e5                	mov    %esp,%ebp
  80a7d3:	57                   	push   %edi
  80a7d4:	56                   	push   %esi
  80a7d5:	53                   	push   %ebx
  80a7d6:	83 ec 28             	sub    $0x28,%esp
  80a7d9:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  80a7dc:	0f be 10             	movsbl (%eax),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80a7df:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80a7e2:	80 f9 09             	cmp    $0x9,%cl
  80a7e5:	0f 87 a8 01 00 00    	ja     80a993 <inet_aton+0x1c3>
  80a7eb:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  80a7ee:	89 4d d8             	mov    %ecx,-0x28(%ebp)
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80a7f1:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  80a7f4:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
  80a7f7:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
  80a7fe:	83 fa 30             	cmp    $0x30,%edx
  80a801:	75 24                	jne    80a827 <inet_aton+0x57>
      c = *++cp;
  80a803:	83 c0 01             	add    $0x1,%eax
  80a806:	0f be 10             	movsbl (%eax),%edx
      if (c == 'x' || c == 'X') {
  80a809:	83 fa 78             	cmp    $0x78,%edx
  80a80c:	74 0c                	je     80a81a <inet_aton+0x4a>
  80a80e:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
  80a815:	83 fa 58             	cmp    $0x58,%edx
  80a818:	75 0d                	jne    80a827 <inet_aton+0x57>
        base = 16;
        c = *++cp;
  80a81a:	83 c0 01             	add    $0x1,%eax
  80a81d:	0f be 10             	movsbl (%eax),%edx
  80a820:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
  80a827:	83 c0 01             	add    $0x1,%eax
  80a82a:	be 00 00 00 00       	mov    $0x0,%esi
  80a82f:	eb 03                	jmp    80a834 <inet_aton+0x64>
  80a831:	83 c0 01             	add    $0x1,%eax
  80a834:	8d 78 ff             	lea    -0x1(%eax),%edi
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  80a837:	89 d1                	mov    %edx,%ecx
  80a839:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  80a83c:	80 fb 09             	cmp    $0x9,%bl
  80a83f:	77 0d                	ja     80a84e <inet_aton+0x7e>
        val = (val * base) + (int)(c - '0');
  80a841:	0f af 75 e0          	imul   -0x20(%ebp),%esi
  80a845:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  80a849:	0f be 10             	movsbl (%eax),%edx
  80a84c:	eb e3                	jmp    80a831 <inet_aton+0x61>
      } else if (base == 16 && isxdigit(c)) {
  80a84e:	83 7d e0 10          	cmpl   $0x10,-0x20(%ebp)
  80a852:	75 2b                	jne    80a87f <inet_aton+0xaf>
  80a854:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  80a857:	88 5d d3             	mov    %bl,-0x2d(%ebp)
  80a85a:	80 fb 05             	cmp    $0x5,%bl
  80a85d:	76 08                	jbe    80a867 <inet_aton+0x97>
  80a85f:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  80a862:	80 fb 05             	cmp    $0x5,%bl
  80a865:	77 18                	ja     80a87f <inet_aton+0xaf>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80a867:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  80a86b:	19 c9                	sbb    %ecx,%ecx
  80a86d:	83 e1 20             	and    $0x20,%ecx
  80a870:	c1 e6 04             	shl    $0x4,%esi
  80a873:	29 ca                	sub    %ecx,%edx
  80a875:	8d 52 c9             	lea    -0x37(%edx),%edx
  80a878:	09 d6                	or     %edx,%esi
        c = *++cp;
  80a87a:	0f be 10             	movsbl (%eax),%edx
  80a87d:	eb b2                	jmp    80a831 <inet_aton+0x61>
      } else
        break;
    }
    if (c == '.') {
  80a87f:	83 fa 2e             	cmp    $0x2e,%edx
  80a882:	75 29                	jne    80a8ad <inet_aton+0xdd>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80a884:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80a887:	39 55 d4             	cmp    %edx,-0x2c(%ebp)
  80a88a:	0f 86 03 01 00 00    	jbe    80a993 <inet_aton+0x1c3>
        return (0);
      *pp++ = val;
  80a890:	89 32                	mov    %esi,(%edx)
      c = *++cp;
  80a892:	8d 47 01             	lea    0x1(%edi),%eax
  80a895:	0f be 10             	movsbl (%eax),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80a898:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80a89b:	80 f9 09             	cmp    $0x9,%cl
  80a89e:	0f 87 ef 00 00 00    	ja     80a993 <inet_aton+0x1c3>
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
  80a8a4:	83 45 d8 04          	addl   $0x4,-0x28(%ebp)
  80a8a8:	e9 4a ff ff ff       	jmp    80a7f7 <inet_aton+0x27>
  80a8ad:	89 f3                	mov    %esi,%ebx
  80a8af:	89 f0                	mov    %esi,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80a8b1:	85 d2                	test   %edx,%edx
  80a8b3:	74 36                	je     80a8eb <inet_aton+0x11b>
  80a8b5:	80 f9 1f             	cmp    $0x1f,%cl
  80a8b8:	0f 86 d5 00 00 00    	jbe    80a993 <inet_aton+0x1c3>
  80a8be:	84 d2                	test   %dl,%dl
  80a8c0:	0f 88 cd 00 00 00    	js     80a993 <inet_aton+0x1c3>
  80a8c6:	83 fa 20             	cmp    $0x20,%edx
  80a8c9:	74 20                	je     80a8eb <inet_aton+0x11b>
  80a8cb:	83 fa 0c             	cmp    $0xc,%edx
  80a8ce:	66 90                	xchg   %ax,%ax
  80a8d0:	74 19                	je     80a8eb <inet_aton+0x11b>
  80a8d2:	83 fa 0a             	cmp    $0xa,%edx
  80a8d5:	74 14                	je     80a8eb <inet_aton+0x11b>
  80a8d7:	83 fa 0d             	cmp    $0xd,%edx
  80a8da:	74 0f                	je     80a8eb <inet_aton+0x11b>
  80a8dc:	83 fa 09             	cmp    $0x9,%edx
  80a8df:	90                   	nop
  80a8e0:	74 09                	je     80a8eb <inet_aton+0x11b>
  80a8e2:	83 fa 0b             	cmp    $0xb,%edx
  80a8e5:	0f 85 a8 00 00 00    	jne    80a993 <inet_aton+0x1c3>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  80a8eb:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80a8ee:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80a8f1:	29 d1                	sub    %edx,%ecx
  80a8f3:	89 ca                	mov    %ecx,%edx
  80a8f5:	c1 fa 02             	sar    $0x2,%edx
  80a8f8:	83 c2 01             	add    $0x1,%edx
  80a8fb:	83 fa 02             	cmp    $0x2,%edx
  80a8fe:	74 2a                	je     80a92a <inet_aton+0x15a>
  80a900:	83 fa 02             	cmp    $0x2,%edx
  80a903:	7f 0d                	jg     80a912 <inet_aton+0x142>
  80a905:	85 d2                	test   %edx,%edx
  80a907:	0f 84 86 00 00 00    	je     80a993 <inet_aton+0x1c3>
  80a90d:	8d 76 00             	lea    0x0(%esi),%esi
  80a910:	eb 62                	jmp    80a974 <inet_aton+0x1a4>
  80a912:	83 fa 03             	cmp    $0x3,%edx
  80a915:	8d 76 00             	lea    0x0(%esi),%esi
  80a918:	74 22                	je     80a93c <inet_aton+0x16c>
  80a91a:	83 fa 04             	cmp    $0x4,%edx
  80a91d:	8d 76 00             	lea    0x0(%esi),%esi
  80a920:	75 52                	jne    80a974 <inet_aton+0x1a4>
  80a922:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80a928:	eb 2b                	jmp    80a955 <inet_aton+0x185>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  80a92a:	3d ff ff ff 00       	cmp    $0xffffff,%eax
  80a92f:	90                   	nop
  80a930:	77 61                	ja     80a993 <inet_aton+0x1c3>
      return (0);
    val |= parts[0] << 24;
  80a932:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80a935:	c1 e3 18             	shl    $0x18,%ebx
  80a938:	09 c3                	or     %eax,%ebx
    break;
  80a93a:	eb 38                	jmp    80a974 <inet_aton+0x1a4>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  80a93c:	3d ff ff 00 00       	cmp    $0xffff,%eax
  80a941:	77 50                	ja     80a993 <inet_aton+0x1c3>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  80a943:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80a946:	c1 e3 10             	shl    $0x10,%ebx
  80a949:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a94c:	c1 e2 18             	shl    $0x18,%edx
  80a94f:	09 d3                	or     %edx,%ebx
  80a951:	09 c3                	or     %eax,%ebx
    break;
  80a953:	eb 1f                	jmp    80a974 <inet_aton+0x1a4>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  80a955:	3d ff 00 00 00       	cmp    $0xff,%eax
  80a95a:	77 37                	ja     80a993 <inet_aton+0x1c3>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  80a95c:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80a95f:	c1 e3 10             	shl    $0x10,%ebx
  80a962:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a965:	c1 e2 18             	shl    $0x18,%edx
  80a968:	09 d3                	or     %edx,%ebx
  80a96a:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80a96d:	c1 e2 08             	shl    $0x8,%edx
  80a970:	09 d3                	or     %edx,%ebx
  80a972:	09 c3                	or     %eax,%ebx
    break;
  }
  if (addr)
  80a974:	b8 01 00 00 00       	mov    $0x1,%eax
  80a979:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80a97d:	74 19                	je     80a998 <inet_aton+0x1c8>
    addr->s_addr = htonl(val);
  80a97f:	89 1c 24             	mov    %ebx,(%esp)
  80a982:	e8 1d fe ff ff       	call   80a7a4 <htonl>
  80a987:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80a98a:	89 03                	mov    %eax,(%ebx)
  80a98c:	b8 01 00 00 00       	mov    $0x1,%eax
  80a991:	eb 05                	jmp    80a998 <inet_aton+0x1c8>
  80a993:	b8 00 00 00 00       	mov    $0x0,%eax
  return (1);
}
  80a998:	83 c4 28             	add    $0x28,%esp
  80a99b:	5b                   	pop    %ebx
  80a99c:	5e                   	pop    %esi
  80a99d:	5f                   	pop    %edi
  80a99e:	5d                   	pop    %ebp
  80a99f:	c3                   	ret    

0080a9a0 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  80a9a0:	55                   	push   %ebp
  80a9a1:	89 e5                	mov    %esp,%ebp
  80a9a3:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  80a9a6:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80a9a9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a9ad:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9b0:	89 04 24             	mov    %eax,(%esp)
  80a9b3:	e8 18 fe ff ff       	call   80a7d0 <inet_aton>
  80a9b8:	85 c0                	test   %eax,%eax
  80a9ba:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a9bf:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
    return (val.s_addr);
  }
  return (INADDR_NONE);
}
  80a9c3:	c9                   	leave  
  80a9c4:	c3                   	ret    

0080a9c5 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  80a9c5:	55                   	push   %ebp
  80a9c6:	89 e5                	mov    %esp,%ebp
  80a9c8:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  80a9cb:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9ce:	89 04 24             	mov    %eax,(%esp)
  80a9d1:	e8 ce fd ff ff       	call   80a7a4 <htonl>
}
  80a9d6:	c9                   	leave  
  80a9d7:	c3                   	ret    
	...

0080a9e0 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80a9e0:	55                   	push   %ebp
  80a9e1:	89 e5                	mov    %esp,%ebp
  80a9e3:	57                   	push   %edi
  80a9e4:	56                   	push   %esi
  80a9e5:	53                   	push   %ebx
  80a9e6:	83 ec 3c             	sub    $0x3c,%esp
  80a9e9:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  80a9ec:	8b 46 78             	mov    0x78(%esi),%eax
  80a9ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  80a9f2:	85 c0                	test   %eax,%eax
  80a9f4:	75 0e                	jne    80aa04 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  80a9f6:	8b 56 74             	mov    0x74(%esi),%edx
  80a9f9:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  if(seg == NULL)
  80a9fc:	85 d2                	test   %edx,%edx
  80a9fe:	0f 84 4b 01 00 00    	je     80ab4f <tcp_zero_window_probe+0x16f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  80aa04:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80aa0b:	00 
  80aa0c:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  80aa13:	00 
  80aa14:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80aa1b:	e8 29 d2 ff ff       	call   807c49 <pbuf_alloc>
  80aa20:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80aa22:	85 c0                	test   %eax,%eax
  80aa24:	0f 84 25 01 00 00    	je     80ab4f <tcp_zero_window_probe+0x16f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80aa2a:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80aa2f:	77 1c                	ja     80aa4d <tcp_zero_window_probe+0x6d>
  80aa31:	c7 44 24 08 84 39 81 	movl   $0x813984,0x8(%esp)
  80aa38:	00 
  80aa39:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  80aa40:	00 
  80aa41:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80aa48:	e8 c7 5e ff ff       	call   800914 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80aa4d:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80aa50:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80aa54:	89 04 24             	mov    %eax,(%esp)
  80aa57:	e8 27 fd ff ff       	call   80a783 <htons>
  80aa5c:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80aa5f:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80aa63:	89 04 24             	mov    %eax,(%esp)
  80aa66:	e8 18 fd ff ff       	call   80a783 <htons>
  80aa6b:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  80aa6f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80aa72:	8b 41 10             	mov    0x10(%ecx),%eax
  80aa75:	8b 40 04             	mov    0x4(%eax),%eax
  80aa78:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80aa7b:	8b 46 24             	mov    0x24(%esi),%eax
  80aa7e:	89 04 24             	mov    %eax,(%esp)
  80aa81:	e8 1e fd ff ff       	call   80a7a4 <htonl>
  80aa86:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80aa89:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80aa8d:	89 04 24             	mov    %eax,(%esp)
  80aa90:	e8 fb fc ff ff       	call   80a790 <ntohs>
  80aa95:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80aa9a:	89 04 24             	mov    %eax,(%esp)
  80aa9d:	e8 e1 fc ff ff       	call   80a783 <htons>
  80aaa2:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80aaa6:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80aaaa:	89 04 24             	mov    %eax,(%esp)
  80aaad:	e8 d1 fc ff ff       	call   80a783 <htons>
  80aab2:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80aab6:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80aabc:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80aac0:	89 04 24             	mov    %eax,(%esp)
  80aac3:	e8 c8 fc ff ff       	call   80a790 <ntohs>
  80aac8:	83 e0 3f             	and    $0x3f,%eax
  80aacb:	80 cc 50             	or     $0x50,%ah
  80aace:	89 04 24             	mov    %eax,(%esp)
  80aad1:	e8 ad fc ff ff       	call   80a783 <htons>
  80aad6:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80aada:	8b 47 04             	mov    0x4(%edi),%eax
  80aadd:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80aae0:	8b 51 08             	mov    0x8(%ecx),%edx
  80aae3:	0f b6 12             	movzbl (%edx),%edx
  80aae6:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  80aae9:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80aaef:	8d 46 04             	lea    0x4(%esi),%eax
  80aaf2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80aaf5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80aaf9:	89 44 24 10          	mov    %eax,0x10(%esp)
  80aafd:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80ab04:	00 
  80ab05:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80ab08:	89 54 24 08          	mov    %edx,0x8(%esp)
  80ab0c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ab10:	89 3c 24             	mov    %edi,(%esp)
  80ab13:	e8 68 f9 ff ff       	call   80a480 <inet_chksum_pseudo>
  80ab18:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80ab1c:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80ab23:	00 
  80ab24:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ab2b:	00 
  80ab2c:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80ab30:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ab34:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80ab37:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80ab3b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ab3f:	89 3c 24             	mov    %edi,(%esp)
  80ab42:	e8 86 ea ff ff       	call   8095cd <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80ab47:	89 3c 24             	mov    %edi,(%esp)
  80ab4a:	e8 3e ce ff ff       	call   80798d <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80ab4f:	83 c4 3c             	add    $0x3c,%esp
  80ab52:	5b                   	pop    %ebx
  80ab53:	5e                   	pop    %esi
  80ab54:	5f                   	pop    %edi
  80ab55:	5d                   	pop    %ebp
  80ab56:	c3                   	ret    

0080ab57 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80ab57:	55                   	push   %ebp
  80ab58:	89 e5                	mov    %esp,%ebp
  80ab5a:	57                   	push   %edi
  80ab5b:	56                   	push   %esi
  80ab5c:	53                   	push   %ebx
  80ab5d:	83 ec 3c             	sub    $0x3c,%esp
  80ab60:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80ab63:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ab6a:	00 
  80ab6b:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80ab72:	00 
  80ab73:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ab7a:	e8 ca d0 ff ff       	call   807c49 <pbuf_alloc>
  80ab7f:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80ab81:	85 c0                	test   %eax,%eax
  80ab83:	0f 84 1b 01 00 00    	je     80aca4 <tcp_keepalive+0x14d>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80ab89:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80ab8e:	77 1c                	ja     80abac <tcp_keepalive+0x55>
  80ab90:	c7 44 24 08 84 39 81 	movl   $0x813984,0x8(%esp)
  80ab97:	00 
  80ab98:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  80ab9f:	00 
  80aba0:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80aba7:	e8 68 5d ff ff       	call   800914 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80abac:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80abaf:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80abb3:	89 04 24             	mov    %eax,(%esp)
  80abb6:	e8 c8 fb ff ff       	call   80a783 <htons>
  80abbb:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80abbe:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80abc2:	89 04 24             	mov    %eax,(%esp)
  80abc5:	e8 b9 fb ff ff       	call   80a783 <htons>
  80abca:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  80abce:	8b 46 54             	mov    0x54(%esi),%eax
  80abd1:	83 e8 01             	sub    $0x1,%eax
  80abd4:	89 04 24             	mov    %eax,(%esp)
  80abd7:	e8 c8 fb ff ff       	call   80a7a4 <htonl>
  80abdc:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80abdf:	8b 46 24             	mov    0x24(%esi),%eax
  80abe2:	89 04 24             	mov    %eax,(%esp)
  80abe5:	e8 ba fb ff ff       	call   80a7a4 <htonl>
  80abea:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80abed:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80abf1:	89 04 24             	mov    %eax,(%esp)
  80abf4:	e8 97 fb ff ff       	call   80a790 <ntohs>
  80abf9:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80abfe:	89 04 24             	mov    %eax,(%esp)
  80ac01:	e8 7d fb ff ff       	call   80a783 <htons>
  80ac06:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80ac0a:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80ac0e:	89 04 24             	mov    %eax,(%esp)
  80ac11:	e8 6d fb ff ff       	call   80a783 <htons>
  80ac16:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80ac1a:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80ac20:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ac24:	89 04 24             	mov    %eax,(%esp)
  80ac27:	e8 64 fb ff ff       	call   80a790 <ntohs>
  80ac2c:	83 e0 3f             	and    $0x3f,%eax
  80ac2f:	80 cc 50             	or     $0x50,%ah
  80ac32:	89 04 24             	mov    %eax,(%esp)
  80ac35:	e8 49 fb ff ff       	call   80a783 <htons>
  80ac3a:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80ac3e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80ac44:	8d 46 04             	lea    0x4(%esi),%eax
  80ac47:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ac4a:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80ac4e:	89 44 24 10          	mov    %eax,0x10(%esp)
  80ac52:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80ac59:	00 
  80ac5a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ac5d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ac61:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ac65:	89 3c 24             	mov    %edi,(%esp)
  80ac68:	e8 13 f8 ff ff       	call   80a480 <inet_chksum_pseudo>
  80ac6d:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80ac71:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80ac78:	00 
  80ac79:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80ac80:	00 
  80ac81:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80ac85:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ac89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ac8c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ac90:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ac94:	89 3c 24             	mov    %edi,(%esp)
  80ac97:	e8 31 e9 ff ff       	call   8095cd <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80ac9c:	89 3c 24             	mov    %edi,(%esp)
  80ac9f:	e8 e9 cc ff ff       	call   80798d <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80aca4:	83 c4 3c             	add    $0x3c,%esp
  80aca7:	5b                   	pop    %ebx
  80aca8:	5e                   	pop    %esi
  80aca9:	5f                   	pop    %edi
  80acaa:	5d                   	pop    %ebp
  80acab:	c3                   	ret    

0080acac <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80acac:	55                   	push   %ebp
  80acad:	89 e5                	mov    %esp,%ebp
  80acaf:	57                   	push   %edi
  80acb0:	56                   	push   %esi
  80acb1:	53                   	push   %ebx
  80acb2:	83 ec 3c             	sub    $0x3c,%esp
  80acb5:	8b 7d 14             	mov    0x14(%ebp),%edi
  80acb8:	0f b7 45 18          	movzwl 0x18(%ebp),%eax
  80acbc:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  80acc0:	0f b7 45 1c          	movzwl 0x1c(%ebp),%eax
  80acc4:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80acc8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80accf:	00 
  80acd0:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80acd7:	00 
  80acd8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80acdf:	e8 65 cf ff ff       	call   807c49 <pbuf_alloc>
  80ace4:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  80ace6:	85 c0                	test   %eax,%eax
  80ace8:	0f 84 15 01 00 00    	je     80ae03 <tcp_rst+0x157>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80acee:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80acf3:	77 1c                	ja     80ad11 <tcp_rst+0x65>
  80acf5:	c7 44 24 08 84 39 81 	movl   $0x813984,0x8(%esp)
  80acfc:	00 
  80acfd:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  80ad04:	00 
  80ad05:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80ad0c:	e8 03 5c ff ff       	call   800914 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80ad11:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  80ad14:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80ad18:	89 04 24             	mov    %eax,(%esp)
  80ad1b:	e8 63 fa ff ff       	call   80a783 <htons>
  80ad20:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  80ad23:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80ad27:	89 04 24             	mov    %eax,(%esp)
  80ad2a:	e8 54 fa ff ff       	call   80a783 <htons>
  80ad2f:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  80ad33:	8b 45 08             	mov    0x8(%ebp),%eax
  80ad36:	89 04 24             	mov    %eax,(%esp)
  80ad39:	e8 66 fa ff ff       	call   80a7a4 <htonl>
  80ad3e:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  80ad41:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ad44:	89 04 24             	mov    %eax,(%esp)
  80ad47:	e8 58 fa ff ff       	call   80a7a4 <htonl>
  80ad4c:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  80ad4f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ad53:	89 04 24             	mov    %eax,(%esp)
  80ad56:	e8 35 fa ff ff       	call   80a790 <ntohs>
  80ad5b:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80ad60:	83 c8 14             	or     $0x14,%eax
  80ad63:	89 04 24             	mov    %eax,(%esp)
  80ad66:	e8 18 fa ff ff       	call   80a783 <htons>
  80ad6b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  80ad6f:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80ad76:	e8 08 fa ff ff       	call   80a783 <htons>
  80ad7b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80ad7f:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80ad85:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80ad89:	89 04 24             	mov    %eax,(%esp)
  80ad8c:	e8 ff f9 ff ff       	call   80a790 <ntohs>
  80ad91:	83 e0 3f             	and    $0x3f,%eax
  80ad94:	80 cc 50             	or     $0x50,%ah
  80ad97:	89 04 24             	mov    %eax,(%esp)
  80ad9a:	e8 e4 f9 ff ff       	call   80a783 <htons>
  80ad9f:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80ada3:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  80ada9:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80adad:	89 44 24 10          	mov    %eax,0x10(%esp)
  80adb1:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80adb8:	00 
  80adb9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80adbd:	8b 45 10             	mov    0x10(%ebp),%eax
  80adc0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80adc4:	89 34 24             	mov    %esi,(%esp)
  80adc7:	e8 b4 f6 ff ff       	call   80a480 <inet_chksum_pseudo>
  80adcc:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80add0:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80add7:	00 
  80add8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80addf:	00 
  80ade0:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80ade7:	00 
  80ade8:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80adec:	8b 45 10             	mov    0x10(%ebp),%eax
  80adef:	89 44 24 04          	mov    %eax,0x4(%esp)
  80adf3:	89 34 24             	mov    %esi,(%esp)
  80adf6:	e8 d2 e7 ff ff       	call   8095cd <ip_output>
  pbuf_free(p);
  80adfb:	89 34 24             	mov    %esi,(%esp)
  80adfe:	e8 8a cb ff ff       	call   80798d <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80ae03:	83 c4 3c             	add    $0x3c,%esp
  80ae06:	5b                   	pop    %ebx
  80ae07:	5e                   	pop    %esi
  80ae08:	5f                   	pop    %edi
  80ae09:	5d                   	pop    %ebp
  80ae0a:	c3                   	ret    

0080ae0b <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80ae0b:	55                   	push   %ebp
  80ae0c:	89 e5                	mov    %esp,%ebp
  80ae0e:	57                   	push   %edi
  80ae0f:	56                   	push   %esi
  80ae10:	53                   	push   %ebx
  80ae11:	83 ec 4c             	sub    $0x4c,%esp
  80ae14:	8b 75 08             	mov    0x8(%ebp),%esi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80ae17:	b8 00 00 00 00       	mov    $0x0,%eax
  80ae1c:	39 35 28 f0 b3 00    	cmp    %esi,0xb3f028
  80ae22:	0f 84 7e 04 00 00    	je     80b2a6 <tcp_output+0x49b>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  80ae28:	0f b7 46 4e          	movzwl 0x4e(%esi),%eax
  80ae2c:	66 39 46 5c          	cmp    %ax,0x5c(%esi)
  80ae30:	66 0f 46 46 5c       	cmovbe 0x5c(%esi),%ax
  80ae35:	0f b7 c0             	movzwl %ax,%eax
  80ae38:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  seg = pcb->unsent;
  80ae3b:	8b 5e 74             	mov    0x74(%esi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80ae3e:	8b 7e 78             	mov    0x78(%esi),%edi
  if (useg != NULL) {
  80ae41:	85 ff                	test   %edi,%edi
  80ae43:	74 0a                	je     80ae4f <tcp_output+0x44>
    for (; useg->next != NULL; useg = useg->next);
  80ae45:	8b 07                	mov    (%edi),%eax
  80ae47:	85 c0                	test   %eax,%eax
  80ae49:	74 04                	je     80ae4f <tcp_output+0x44>
  80ae4b:	89 c7                	mov    %eax,%edi
  80ae4d:	eb f6                	jmp    80ae45 <tcp_output+0x3a>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80ae4f:	f6 46 20 02          	testb  $0x2,0x20(%esi)
  80ae53:	75 10                	jne    80ae65 <tcp_output+0x5a>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80ae55:	85 db                	test   %ebx,%ebx
  80ae57:	75 2e                	jne    80ae87 <tcp_output+0x7c>
  80ae59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80ae60:	e9 38 04 00 00       	jmp    80b29d <tcp_output+0x492>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80ae65:	85 db                	test   %ebx,%ebx
  80ae67:	90                   	nop
  80ae68:	74 2e                	je     80ae98 <tcp_output+0x8d>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80ae6a:	8b 43 10             	mov    0x10(%ebx),%eax
  80ae6d:	8b 40 04             	mov    0x4(%eax),%eax
  80ae70:	89 04 24             	mov    %eax,(%esp)
  80ae73:	e8 4d fb ff ff       	call   80a9c5 <ntohl>
  80ae78:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80ae7c:	2b 56 48             	sub    0x48(%esi),%edx
  80ae7f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80ae82:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80ae85:	72 11                	jb     80ae98 <tcp_output+0x8d>
  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80ae87:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    netif = ip_route(&(pcb->remote_ip));
  80ae8a:	8d 46 04             	lea    0x4(%esi),%eax
  80ae8d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80ae90:	89 7d d8             	mov    %edi,-0x28(%ebp)
  80ae93:	e9 a7 03 00 00       	jmp    80b23f <tcp_output+0x434>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80ae98:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ae9f:	00 
  80aea0:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80aea7:	00 
  80aea8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80aeaf:	e8 95 cd ff ff       	call   807c49 <pbuf_alloc>
  80aeb4:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  80aeb6:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80aebb:	85 ff                	test   %edi,%edi
  80aebd:	0f 84 e3 03 00 00    	je     80b2a6 <tcp_output+0x49b>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80aec3:	80 66 20 fc          	andb   $0xfc,0x20(%esi)

    tcphdr = p->payload;
  80aec7:	8b 5f 04             	mov    0x4(%edi),%ebx
    tcphdr->src = htons(pcb->local_port);
  80aeca:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80aece:	89 04 24             	mov    %eax,(%esp)
  80aed1:	e8 ad f8 ff ff       	call   80a783 <htons>
  80aed6:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  80aed9:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80aedd:	89 04 24             	mov    %eax,(%esp)
  80aee0:	e8 9e f8 ff ff       	call   80a783 <htons>
  80aee5:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  80aee9:	8b 46 54             	mov    0x54(%esi),%eax
  80aeec:	89 04 24             	mov    %eax,(%esp)
  80aeef:	e8 b0 f8 ff ff       	call   80a7a4 <htonl>
  80aef4:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  80aef7:	8b 46 24             	mov    0x24(%esi),%eax
  80aefa:	89 04 24             	mov    %eax,(%esp)
  80aefd:	e8 a2 f8 ff ff       	call   80a7a4 <htonl>
  80af02:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  80af05:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80af09:	89 04 24             	mov    %eax,(%esp)
  80af0c:	e8 7f f8 ff ff       	call   80a790 <ntohs>
  80af11:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80af16:	83 c8 10             	or     $0x10,%eax
  80af19:	89 04 24             	mov    %eax,(%esp)
  80af1c:	e8 62 f8 ff ff       	call   80a783 <htons>
  80af21:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80af25:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80af29:	89 04 24             	mov    %eax,(%esp)
  80af2c:	e8 52 f8 ff ff       	call   80a783 <htons>
  80af31:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  80af35:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80af3b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80af3f:	89 04 24             	mov    %eax,(%esp)
  80af42:	e8 49 f8 ff ff       	call   80a790 <ntohs>
  80af47:	83 e0 3f             	and    $0x3f,%eax
  80af4a:	80 cc 50             	or     $0x50,%ah
  80af4d:	89 04 24             	mov    %eax,(%esp)
  80af50:	e8 2e f8 ff ff       	call   80a783 <htons>
  80af55:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80af59:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80af5f:	8d 56 04             	lea    0x4(%esi),%edx
  80af62:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80af65:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80af69:	89 44 24 10          	mov    %eax,0x10(%esp)
  80af6d:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80af74:	00 
  80af75:	89 54 24 08          	mov    %edx,0x8(%esp)
  80af79:	89 74 24 04          	mov    %esi,0x4(%esp)
  80af7d:	89 3c 24             	mov    %edi,(%esp)
  80af80:	e8 fb f4 ff ff       	call   80a480 <inet_chksum_pseudo>
  80af85:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80af89:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80af90:	00 
  80af91:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80af95:	89 44 24 10          	mov    %eax,0x10(%esp)
  80af99:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80af9d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80afa1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80afa4:	89 44 24 08          	mov    %eax,0x8(%esp)
  80afa8:	89 74 24 04          	mov    %esi,0x4(%esp)
  80afac:	89 3c 24             	mov    %edi,(%esp)
  80afaf:	e8 19 e6 ff ff       	call   8095cd <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80afb4:	89 3c 24             	mov    %edi,(%esp)
  80afb7:	e8 d1 c9 ff ff       	call   80798d <pbuf_free>
  80afbc:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
  80afc1:	e9 e0 02 00 00       	jmp    80b2a6 <tcp_output+0x49b>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80afc6:	8b 43 10             	mov    0x10(%ebx),%eax
  80afc9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80afcd:	89 04 24             	mov    %eax,(%esp)
  80afd0:	e8 bb f7 ff ff       	call   80a790 <ntohs>
  80afd5:	a8 04                	test   $0x4,%al
  80afd7:	74 1c                	je     80aff5 <tcp_output+0x1ea>
  80afd9:	c7 44 24 08 40 3b 81 	movl   $0x813b40,0x8(%esp)
  80afe0:	00 
  80afe1:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  80afe8:	00 
  80afe9:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80aff0:	e8 1f 59 ff ff       	call   800914 <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80aff5:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80aff9:	74 1c                	je     80b017 <tcp_output+0x20c>
  80affb:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  80afff:	a8 40                	test   $0x40,%al
  80b001:	75 14                	jne    80b017 <tcp_output+0x20c>
  80b003:	8b 56 74             	mov    0x74(%esi),%edx
  80b006:	85 d2                	test   %edx,%edx
  80b008:	0f 84 a0 02 00 00    	je     80b2ae <tcp_output+0x4a3>
  80b00e:	83 3a 00             	cmpl   $0x0,(%edx)
  80b011:	0f 84 97 02 00 00    	je     80b2ae <tcp_output+0x4a3>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  80b017:	8b 03                	mov    (%ebx),%eax
  80b019:	89 46 74             	mov    %eax,0x74(%esi)

    if (pcb->state != SYN_SENT) {
  80b01c:	83 7e 10 02          	cmpl   $0x2,0x10(%esi)
  80b020:	74 25                	je     80b047 <tcp_output+0x23c>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  80b022:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b025:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80b029:	89 04 24             	mov    %eax,(%esp)
  80b02c:	e8 5f f7 ff ff       	call   80a790 <ntohs>
  80b031:	83 c8 10             	or     $0x10,%eax
  80b034:	0f b7 c0             	movzwl %ax,%eax
  80b037:	89 04 24             	mov    %eax,(%esp)
  80b03a:	e8 44 f7 ff ff       	call   80a783 <htons>
  80b03f:	66 89 47 0c          	mov    %ax,0xc(%edi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80b043:	80 66 20 fc          	andb   $0xfc,0x20(%esi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b047:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b04a:	8b 46 24             	mov    0x24(%esi),%eax
  80b04d:	89 04 24             	mov    %eax,(%esp)
  80b050:	e8 4f f7 ff ff       	call   80a7a4 <htonl>
  80b055:	89 47 08             	mov    %eax,0x8(%edi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b058:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b05b:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b05f:	89 04 24             	mov    %eax,(%esp)
  80b062:	e8 1c f7 ff ff       	call   80a783 <htons>
  80b067:	66 89 47 0e          	mov    %ax,0xe(%edi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80b06b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80b06f:	74 05                	je     80b076 <tcp_output+0x26b>
  80b071:	83 3e 00             	cmpl   $0x0,(%esi)
  80b074:	75 22                	jne    80b098 <tcp_output+0x28d>
    netif = ip_route(&(pcb->remote_ip));
  80b076:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b079:	89 14 24             	mov    %edx,(%esp)
  80b07c:	e8 f0 e4 ff ff       	call   809571 <ip_route>
    if (netif == NULL) {
  80b081:	85 c0                	test   %eax,%eax
  80b083:	0f 84 c3 00 00 00    	je     80b14c <tcp_output+0x341>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  80b089:	ba 00 00 00 00       	mov    $0x0,%edx
  80b08e:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80b091:	74 03                	je     80b096 <tcp_output+0x28b>
  80b093:	8b 50 04             	mov    0x4(%eax),%edx
  80b096:	89 16                	mov    %edx,(%esi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  80b098:	66 83 7e 32 ff       	cmpw   $0xffffffff,0x32(%esi)
  80b09d:	75 06                	jne    80b0a5 <tcp_output+0x29a>
    pcb->rtime = 0;
  80b09f:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)

  if (pcb->rttest == 0) {
  80b0a5:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
  80b0a9:	75 19                	jne    80b0c4 <tcp_output+0x2b9>
    pcb->rttest = tcp_ticks;
  80b0ab:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  80b0b0:	89 46 38             	mov    %eax,0x38(%esi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  80b0b3:	8b 43 10             	mov    0x10(%ebx),%eax
  80b0b6:	8b 40 04             	mov    0x4(%eax),%eax
  80b0b9:	89 04 24             	mov    %eax,(%esp)
  80b0bc:	e8 04 f9 ff ff       	call   80a9c5 <ntohl>
  80b0c1:	89 46 3c             	mov    %eax,0x3c(%esi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  80b0c4:	8b 43 04             	mov    0x4(%ebx),%eax
  80b0c7:	8b 53 10             	mov    0x10(%ebx),%edx
  80b0ca:	66 2b 50 04          	sub    0x4(%eax),%dx

  seg->p->len -= len;
  80b0ce:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  80b0d2:	8b 43 04             	mov    0x4(%ebx),%eax
  80b0d5:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  80b0d9:	8b 43 04             	mov    0x4(%ebx),%eax
  80b0dc:	8b 53 10             	mov    0x10(%ebx),%edx
  80b0df:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  80b0e2:	8b 43 10             	mov    0x10(%ebx),%eax
  80b0e5:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b0eb:	8b 7b 10             	mov    0x10(%ebx),%edi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80b0ee:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b0f1:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80b0f5:	89 54 24 10          	mov    %edx,0x10(%esp)
  80b0f9:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b100:	00 
  80b101:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b104:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b108:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b10b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b10f:	89 04 24             	mov    %eax,(%esp)
  80b112:	e8 69 f3 ff ff       	call   80a480 <inet_chksum_pseudo>
  80b117:	66 89 47 10          	mov    %ax,0x10(%edi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80b11b:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b122:	00 
  80b123:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80b127:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b12b:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b12f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b133:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b136:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b13a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b13d:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b141:	8b 43 04             	mov    0x4(%ebx),%eax
  80b144:	89 04 24             	mov    %eax,(%esp)
  80b147:	e8 81 e4 ff ff       	call   8095cd <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80b14c:	8b 43 10             	mov    0x10(%ebx),%eax
  80b14f:	8b 40 04             	mov    0x4(%eax),%eax
  80b152:	89 04 24             	mov    %eax,(%esp)
  80b155:	e8 6b f8 ff ff       	call   80a9c5 <ntohl>
  80b15a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80b15d:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80b161:	8b 43 10             	mov    0x10(%ebx),%eax
  80b164:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b168:	89 04 24             	mov    %eax,(%esp)
  80b16b:	e8 20 f6 ff ff       	call   80a790 <ntohs>
  80b170:	a8 01                	test   $0x1,%al
  80b172:	75 1b                	jne    80b18f <tcp_output+0x384>
  80b174:	8b 43 10             	mov    0x10(%ebx),%eax
  80b177:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b17b:	89 04 24             	mov    %eax,(%esp)
  80b17e:	e8 0d f6 ff ff       	call   80a790 <ntohs>
  80b183:	89 c2                	mov    %eax,%edx
  80b185:	b8 00 00 00 00       	mov    $0x0,%eax
  80b18a:	f6 c2 02             	test   $0x2,%dl
  80b18d:	74 05                	je     80b194 <tcp_output+0x389>
  80b18f:	b8 01 00 00 00       	mov    $0x1,%eax
  80b194:	0f b7 ff             	movzwl %di,%edi
  80b197:	8d 3c 38             	lea    (%eax,%edi,1),%edi
  80b19a:	03 7d dc             	add    -0x24(%ebp),%edi
  80b19d:	89 7e 54             	mov    %edi,0x54(%esi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80b1a0:	39 7e 58             	cmp    %edi,0x58(%esi)
  80b1a3:	79 03                	jns    80b1a8 <tcp_output+0x39d>
      pcb->snd_max = pcb->snd_nxt;
  80b1a5:	89 7e 58             	mov    %edi,0x58(%esi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  80b1a8:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80b1ac:	8b 43 10             	mov    0x10(%ebx),%eax
  80b1af:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b1b3:	89 04 24             	mov    %eax,(%esp)
  80b1b6:	e8 d5 f5 ff ff       	call   80a790 <ntohs>
  80b1bb:	a8 01                	test   $0x1,%al
  80b1bd:	75 18                	jne    80b1d7 <tcp_output+0x3cc>
  80b1bf:	8b 43 10             	mov    0x10(%ebx),%eax
  80b1c2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b1c6:	89 04 24             	mov    %eax,(%esp)
  80b1c9:	e8 c2 f5 ff ff       	call   80a790 <ntohs>
  80b1ce:	ba 00 00 00 00       	mov    $0x0,%edx
  80b1d3:	a8 02                	test   $0x2,%al
  80b1d5:	74 05                	je     80b1dc <tcp_output+0x3d1>
  80b1d7:	ba 01 00 00 00       	mov    $0x1,%edx
  80b1dc:	0f b7 ff             	movzwl %di,%edi
  80b1df:	01 fa                	add    %edi,%edx
  80b1e1:	74 4d                	je     80b230 <tcp_output+0x425>
      seg->next = NULL;
  80b1e3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  80b1e9:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80b1ed:	75 08                	jne    80b1f7 <tcp_output+0x3ec>
        pcb->unacked = seg;
  80b1ef:	89 5e 78             	mov    %ebx,0x78(%esi)
  80b1f2:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80b1f5:	eb 41                	jmp    80b238 <tcp_output+0x42d>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  80b1f7:	8b 43 10             	mov    0x10(%ebx),%eax
  80b1fa:	8b 40 04             	mov    0x4(%eax),%eax
  80b1fd:	89 04 24             	mov    %eax,(%esp)
  80b200:	e8 c0 f7 ff ff       	call   80a9c5 <ntohl>
  80b205:	89 c7                	mov    %eax,%edi
  80b207:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b20a:	8b 42 10             	mov    0x10(%edx),%eax
  80b20d:	8b 40 04             	mov    0x4(%eax),%eax
  80b210:	89 04 24             	mov    %eax,(%esp)
  80b213:	e8 ad f7 ff ff       	call   80a9c5 <ntohl>
  80b218:	39 c7                	cmp    %eax,%edi
  80b21a:	79 0a                	jns    80b226 <tcp_output+0x41b>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  80b21c:	8b 46 78             	mov    0x78(%esi),%eax
  80b21f:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80b221:	89 5e 78             	mov    %ebx,0x78(%esi)
  80b224:	eb 12                	jmp    80b238 <tcp_output+0x42d>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  80b226:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80b229:	89 18                	mov    %ebx,(%eax)
  80b22b:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80b22e:	eb 08                	jmp    80b238 <tcp_output+0x42d>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  80b230:	89 1c 24             	mov    %ebx,(%esp)
  80b233:	e8 c9 d2 ff ff       	call   808501 <tcp_seg_free>
    }
    seg = pcb->unsent;
  80b238:	8b 5e 74             	mov    0x74(%esi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80b23b:	85 db                	test   %ebx,%ebx
  80b23d:	74 5e                	je     80b29d <tcp_output+0x492>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  80b23f:	8b 43 10             	mov    0x10(%ebx),%eax
  80b242:	8b 40 04             	mov    0x4(%eax),%eax
  80b245:	89 04 24             	mov    %eax,(%esp)
  80b248:	e8 78 f7 ff ff       	call   80a9c5 <ntohl>
  80b24d:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b251:	2b 56 48             	sub    0x48(%esi),%edx
  80b254:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80b257:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80b25a:	0f 83 66 fd ff ff    	jae    80afc6 <tcp_output+0x1bb>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80b260:	85 db                	test   %ebx,%ebx
  80b262:	74 39                	je     80b29d <tcp_output+0x492>
  80b264:	80 be a4 00 00 00 00 	cmpb   $0x0,0xa4(%esi)
  80b26b:	75 30                	jne    80b29d <tcp_output+0x492>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  80b26d:	8b 43 10             	mov    0x10(%ebx),%eax
  80b270:	8b 40 04             	mov    0x4(%eax),%eax
  80b273:	89 04 24             	mov    %eax,(%esp)
  80b276:	e8 4a f7 ff ff       	call   80a9c5 <ntohl>
  80b27b:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b27f:	2b 56 48             	sub    0x48(%esi),%edx
  80b282:	01 c2                	add    %eax,%edx
  80b284:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
  80b288:	39 c2                	cmp    %eax,%edx
  80b28a:	76 11                	jbe    80b29d <tcp_output+0x492>
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  80b28c:	c7 86 a0 00 00 00 00 	movl   $0x0,0xa0(%esi)
  80b293:	00 00 00 
    pcb->persist_backoff = 1;
  80b296:	c6 86 a4 00 00 00 01 	movb   $0x1,0xa4(%esi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  80b29d:	80 66 20 7f          	andb   $0x7f,0x20(%esi)
  80b2a1:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80b2a6:	83 c4 4c             	add    $0x4c,%esp
  80b2a9:	5b                   	pop    %ebx
  80b2aa:	5e                   	pop    %esi
  80b2ab:	5f                   	pop    %edi
  80b2ac:	5d                   	pop    %ebp
  80b2ad:	c3                   	ret    
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80b2ae:	a8 a0                	test   $0xa0,%al
  80b2b0:	0f 85 61 fd ff ff    	jne    80b017 <tcp_output+0x20c>
  80b2b6:	eb a8                	jmp    80b260 <tcp_output+0x455>

0080b2b8 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  80b2b8:	55                   	push   %ebp
  80b2b9:	89 e5                	mov    %esp,%ebp
  80b2bb:	53                   	push   %ebx
  80b2bc:	83 ec 14             	sub    $0x14,%esp
  80b2bf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b2c2:	8b 43 78             	mov    0x78(%ebx),%eax
  80b2c5:	85 c0                	test   %eax,%eax
  80b2c7:	74 34                	je     80b2fd <tcp_rexmit+0x45>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  80b2c9:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  80b2cb:	8b 4b 74             	mov    0x74(%ebx),%ecx
  80b2ce:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  80b2d0:	8b 43 78             	mov    0x78(%ebx),%eax
  80b2d3:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80b2d6:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b2d9:	8b 40 10             	mov    0x10(%eax),%eax
  80b2dc:	8b 40 04             	mov    0x4(%eax),%eax
  80b2df:	89 04 24             	mov    %eax,(%esp)
  80b2e2:	e8 de f6 ff ff       	call   80a9c5 <ntohl>
  80b2e7:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  80b2ea:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80b2ee:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80b2f5:	89 1c 24             	mov    %ebx,(%esp)
  80b2f8:	e8 0e fb ff ff       	call   80ae0b <tcp_output>
}
  80b2fd:	83 c4 14             	add    $0x14,%esp
  80b300:	5b                   	pop    %ebx
  80b301:	5d                   	pop    %ebp
  80b302:	c3                   	ret    

0080b303 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  80b303:	55                   	push   %ebp
  80b304:	89 e5                	mov    %esp,%ebp
  80b306:	53                   	push   %ebx
  80b307:	83 ec 14             	sub    $0x14,%esp
  80b30a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b30d:	8b 43 78             	mov    0x78(%ebx),%eax
  80b310:	85 c0                	test   %eax,%eax
  80b312:	74 3e                	je     80b352 <tcp_rexmit_rto+0x4f>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  80b314:	89 c2                	mov    %eax,%edx
  80b316:	8b 00                	mov    (%eax),%eax
  80b318:	85 c0                	test   %eax,%eax
  80b31a:	75 f8                	jne    80b314 <tcp_rexmit_rto+0x11>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  80b31c:	8b 43 74             	mov    0x74(%ebx),%eax
  80b31f:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  80b321:	8b 43 78             	mov    0x78(%ebx),%eax
  80b324:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  80b327:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b32e:	8b 40 10             	mov    0x10(%eax),%eax
  80b331:	8b 40 04             	mov    0x4(%eax),%eax
  80b334:	89 04 24             	mov    %eax,(%esp)
  80b337:	e8 89 f6 ff ff       	call   80a9c5 <ntohl>
  80b33c:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  80b33f:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80b343:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  80b34a:	89 1c 24             	mov    %ebx,(%esp)
  80b34d:	e8 b9 fa ff ff       	call   80ae0b <tcp_output>
}
  80b352:	83 c4 14             	add    $0x14,%esp
  80b355:	5b                   	pop    %ebx
  80b356:	5d                   	pop    %ebp
  80b357:	c3                   	ret    

0080b358 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  80b358:	55                   	push   %ebp
  80b359:	89 e5                	mov    %esp,%ebp
  80b35b:	57                   	push   %edi
  80b35c:	56                   	push   %esi
  80b35d:	53                   	push   %ebx
  80b35e:	83 ec 6c             	sub    $0x6c,%esp
  80b361:	8b 7d 08             	mov    0x8(%ebp),%edi
  80b364:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b367:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  80b36b:	66 89 45 b6          	mov    %ax,-0x4a(%ebp)
  80b36f:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  80b373:	88 4d af             	mov    %cl,-0x51(%ebp)
  80b376:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  80b37a:	88 45 98             	mov    %al,-0x68(%ebp)
  80b37d:	0f b6 45 20          	movzbl 0x20(%ebp),%eax
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  80b381:	66 83 7d b6 00       	cmpw   $0x0,-0x4a(%ebp)
  80b386:	74 20                	je     80b3a8 <tcp_enqueue+0x50>
  80b388:	84 c0                	test   %al,%al
  80b38a:	74 1c                	je     80b3a8 <tcp_enqueue+0x50>
  80b38c:	c7 44 24 08 b4 39 81 	movl   $0x8139b4,0x8(%esp)
  80b393:	00 
  80b394:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  80b39b:	00 
  80b39c:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b3a3:	e8 6c 55 ff ff       	call   800914 <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  80b3a8:	85 d2                	test   %edx,%edx
  80b3aa:	0f 95 45 b5          	setne  -0x4b(%ebp)
  80b3ae:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80b3b2:	0f 95 45 bf          	setne  -0x41(%ebp)
  80b3b6:	80 7d b5 00          	cmpb   $0x0,-0x4b(%ebp)
  80b3ba:	74 22                	je     80b3de <tcp_enqueue+0x86>
  80b3bc:	80 7d bf 00          	cmpb   $0x0,-0x41(%ebp)
  80b3c0:	74 1c                	je     80b3de <tcp_enqueue+0x86>
  80b3c2:	c7 44 24 08 f4 39 81 	movl   $0x8139f4,0x8(%esp)
  80b3c9:	00 
  80b3ca:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  80b3d1:	00 
  80b3d2:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b3d9:	e8 36 55 ff ff       	call   800914 <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80b3de:	0f b7 4d b6          	movzwl -0x4a(%ebp),%ecx
  80b3e2:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  80b3e6:	76 0e                	jbe    80b3f6 <tcp_enqueue+0x9e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  80b3e8:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  80b3ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80b3f1:	e9 34 06 00 00       	jmp    80ba2a <tcp_enqueue+0x6d2>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  80b3f6:	8b 4f 68             	mov    0x68(%edi),%ecx
  80b3f9:	89 4d cc             	mov    %ecx,-0x34(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80b3fc:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  80b400:	66 89 4d d6          	mov    %cx,-0x2a(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80b404:	66 83 f9 1f          	cmp    $0x1f,%cx
  80b408:	76 0e                	jbe    80b418 <tcp_enqueue+0xc0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  80b40a:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  80b40e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80b413:	e9 12 06 00 00       	jmp    80ba2a <tcp_enqueue+0x6d2>
  }
  if (queuelen != 0) {
  80b418:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  80b41d:	74 76                	je     80b495 <tcp_enqueue+0x13d>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80b41f:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b423:	74 4e                	je     80b473 <tcp_enqueue+0x11b>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80b425:	89 c1                	mov    %eax,%ecx
  80b427:	c0 e9 02             	shr    $0x2,%cl
  80b42a:	c1 e1 0c             	shl    $0xc,%ecx
  80b42d:	66 81 c1 00 50       	add    $0x5000,%cx
  80b432:	66 89 4d ba          	mov    %cx,-0x46(%ebp)
  80b436:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  80b439:	0f b7 55 b6          	movzwl -0x4a(%ebp),%edx
  80b43d:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
  80b441:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  80b448:	bb 00 00 00 00       	mov    $0x0,%ebx
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80b44d:	0f b6 4d 98          	movzbl -0x68(%ebp),%ecx
  80b451:	83 e1 01             	and    $0x1,%ecx
  80b454:	89 4d b0             	mov    %ecx,-0x50(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80b457:	0f b6 d0             	movzbl %al,%edx
  80b45a:	89 55 c0             	mov    %edx,-0x40(%ebp)
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80b45d:	0f b6 c0             	movzbl %al,%eax
  80b460:	66 89 45 b8          	mov    %ax,-0x48(%ebp)
    seg->tcphdr = seg->p->payload;
    seg->tcphdr->src = htons(pcb->local_port);
    seg->tcphdr->dest = htons(pcb->remote_port);
    seg->tcphdr->seqno = htonl(seqno);
    seg->tcphdr->urgp = 0;
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80b464:	0f b6 4d af          	movzbl -0x51(%ebp),%ecx
  80b468:	66 89 4d bc          	mov    %cx,-0x44(%ebp)
  80b46c:	89 7d d0             	mov    %edi,-0x30(%ebp)
  80b46f:	89 df                	mov    %ebx,%edi
  80b471:	eb 55                	jmp    80b4c8 <tcp_enqueue+0x170>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80b473:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b477:	75 ac                	jne    80b425 <tcp_enqueue+0xcd>
  80b479:	c7 44 24 08 3c 3a 81 	movl   $0x813a3c,0x8(%esp)
  80b480:	00 
  80b481:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  80b488:	00 
  80b489:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b490:	e8 7f 54 ff ff       	call   800914 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  80b495:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b499:	75 06                	jne    80b4a1 <tcp_enqueue+0x149>
  80b49b:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b49f:	74 84                	je     80b425 <tcp_enqueue+0xcd>
  80b4a1:	c7 44 24 08 78 3a 81 	movl   $0x813a78,0x8(%esp)
  80b4a8:	00 
  80b4a9:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  80b4b0:	00 
  80b4b1:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b4b8:	e8 57 54 ff ff       	call   800914 <_panic>
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  80b4bd:	0f b7 f6             	movzwl %si,%esi
  80b4c0:	01 75 cc             	add    %esi,-0x34(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  80b4c3:	01 75 c4             	add    %esi,-0x3c(%ebp)
  80b4c6:	89 df                	mov    %ebx,%edi
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80b4c8:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80b4cb:	0f b7 70 34          	movzwl 0x34(%eax),%esi

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80b4cf:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80b4d6:	e8 6d bd ff ff       	call   807248 <memp_malloc>
  80b4db:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  80b4dd:	85 c0                	test   %eax,%eax
  80b4df:	0f 84 d2 04 00 00    	je     80b9b7 <tcp_enqueue+0x65f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  80b4e5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  80b4eb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  80b4f2:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80b4f6:	75 05                	jne    80b4fd <tcp_enqueue+0x1a5>
  80b4f8:	89 45 c8             	mov    %eax,-0x38(%ebp)
  80b4fb:	eb 22                	jmp    80b51f <tcp_enqueue+0x1c7>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  80b4fd:	85 ff                	test   %edi,%edi
  80b4ff:	75 1c                	jne    80b51d <tcp_enqueue+0x1c5>
  80b501:	c7 44 24 08 57 3b 81 	movl   $0x813b57,0x8(%esp)
  80b508:	00 
  80b509:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80b510:	00 
  80b511:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b518:	e8 f7 53 ff ff       	call   800914 <_panic>
      useg->next = seg;
  80b51d:	89 07                	mov    %eax,(%edi)
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80b51f:	66 39 75 d8          	cmp    %si,-0x28(%ebp)
  80b523:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
  80b527:	0f 46 f2             	cmovbe %edx,%esi
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  80b52a:	80 7d bf 00          	cmpb   $0x0,-0x41(%ebp)
  80b52e:	74 69                	je     80b599 <tcp_enqueue+0x241>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80b530:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b537:	00 
  80b538:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  80b53b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80b53f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b546:	e8 fe c6 ff ff       	call   807c49 <pbuf_alloc>
  80b54b:	89 43 04             	mov    %eax,0x4(%ebx)
  80b54e:	85 c0                	test   %eax,%eax
  80b550:	0f 84 66 04 00 00    	je     80b9bc <tcp_enqueue+0x664>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80b556:	0f b7 55 b8          	movzwl -0x48(%ebp),%edx
  80b55a:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  80b55e:	73 1c                	jae    80b57c <tcp_enqueue+0x224>
  80b560:	c7 44 24 08 ac 3a 81 	movl   $0x813aac,0x8(%esp)
  80b567:	00 
  80b568:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  80b56f:	00 
  80b570:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b577:	e8 98 53 ff ff       	call   800914 <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  80b57c:	89 04 24             	mov    %eax,(%esp)
  80b57f:	e8 ac bf ff ff       	call   807530 <pbuf_clen>
  80b584:	0f b6 c0             	movzbl %al,%eax
  80b587:	66 01 45 d6          	add    %ax,-0x2a(%ebp)
      seg->dataptr = seg->p->payload;
  80b58b:	8b 43 04             	mov    0x4(%ebx),%eax
  80b58e:	8b 40 04             	mov    0x4(%eax),%eax
  80b591:	89 43 08             	mov    %eax,0x8(%ebx)
  80b594:	e9 1e 01 00 00       	jmp    80b6b7 <tcp_enqueue+0x35f>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80b599:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  80b59d:	0f 84 8b 00 00 00    	je     80b62e <tcp_enqueue+0x2d6>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  80b5a3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b5aa:	00 
  80b5ab:	0f b7 c6             	movzwl %si,%eax
  80b5ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b5b2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b5b9:	e8 8b c6 ff ff       	call   807c49 <pbuf_alloc>
  80b5be:	89 43 04             	mov    %eax,0x4(%ebx)
  80b5c1:	85 c0                	test   %eax,%eax
  80b5c3:	0f 84 f9 03 00 00    	je     80b9c2 <tcp_enqueue+0x66a>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  80b5c9:	66 3b 70 0a          	cmp    0xa(%eax),%si
  80b5cd:	76 1c                	jbe    80b5eb <tcp_enqueue+0x293>
  80b5cf:	c7 44 24 08 d4 3a 81 	movl   $0x813ad4,0x8(%esp)
  80b5d6:	00 
  80b5d7:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  80b5de:	00 
  80b5df:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b5e6:	e8 29 53 ff ff       	call   800914 <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80b5eb:	89 04 24             	mov    %eax,(%esp)
  80b5ee:	e8 3d bf ff ff       	call   807530 <pbuf_clen>
  80b5f3:	89 c7                	mov    %eax,%edi
      if (arg != NULL) {
  80b5f5:	80 7d b5 00          	cmpb   $0x0,-0x4b(%ebp)
  80b5f9:	74 1c                	je     80b617 <tcp_enqueue+0x2bf>
        MEMCPY(seg->p->payload, ptr, seglen);
  80b5fb:	0f b7 c6             	movzwl %si,%eax
  80b5fe:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b602:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  80b605:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80b609:	8b 43 04             	mov    0x4(%ebx),%eax
  80b60c:	8b 40 04             	mov    0x4(%eax),%eax
  80b60f:	89 04 24             	mov    %eax,(%esp)
  80b612:	e8 5a 5d ff ff       	call   801371 <memcpy>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80b617:	89 fa                	mov    %edi,%edx
  80b619:	0f b6 c2             	movzbl %dl,%eax
  80b61c:	66 01 45 d6          	add    %ax,-0x2a(%ebp)
      if (arg != NULL) {
        MEMCPY(seg->p->payload, ptr, seglen);
      }
      seg->dataptr = seg->p->payload;
  80b620:	8b 43 04             	mov    0x4(%ebx),%eax
  80b623:	8b 40 04             	mov    0x4(%eax),%eax
  80b626:	89 43 08             	mov    %eax,0x8(%ebx)
  80b629:	e9 89 00 00 00       	jmp    80b6b7 <tcp_enqueue+0x35f>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  80b62e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80b635:	00 
  80b636:	0f b7 c6             	movzwl %si,%eax
  80b639:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b63d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b644:	e8 00 c6 ff ff       	call   807c49 <pbuf_alloc>
  80b649:	89 c7                	mov    %eax,%edi
  80b64b:	85 c0                	test   %eax,%eax
  80b64d:	0f 84 74 03 00 00    	je     80b9c7 <tcp_enqueue+0x66f>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
      /* reference the non-volatile payload data */
      p->payload = ptr;
  80b653:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  80b656:	89 48 04             	mov    %ecx,0x4(%eax)
      seg->dataptr = ptr;
  80b659:	89 4b 08             	mov    %ecx,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  80b65c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b663:	00 
  80b664:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80b66b:	00 
  80b66c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b673:	e8 d1 c5 ff ff       	call   807c49 <pbuf_alloc>
  80b678:	89 43 04             	mov    %eax,0x4(%ebx)
  80b67b:	85 c0                	test   %eax,%eax
  80b67d:	75 12                	jne    80b691 <tcp_enqueue+0x339>
  80b67f:	89 fb                	mov    %edi,%ebx
  80b681:	8b 7d d0             	mov    -0x30(%ebp),%edi
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  80b684:	89 1c 24             	mov    %ebx,(%esp)
  80b687:	e8 01 c3 ff ff       	call   80798d <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  80b68c:	e9 44 03 00 00       	jmp    80b9d5 <tcp_enqueue+0x67d>
      }
      queuelen += pbuf_clen(seg->p);
  80b691:	89 04 24             	mov    %eax,(%esp)
  80b694:	e8 97 be ff ff       	call   807530 <pbuf_clen>
  80b699:	0f b6 c0             	movzbl %al,%eax
  80b69c:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
  80b6a0:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  80b6a4:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  80b6a8:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80b6ac:	8b 43 04             	mov    0x4(%ebx),%eax
  80b6af:	89 04 24             	mov    %eax,(%esp)
  80b6b2:	e8 a4 be ff ff       	call   80755b <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80b6b7:	66 83 7d d6 20       	cmpw   $0x20,-0x2a(%ebp)
  80b6bc:	0f 87 0a 03 00 00    	ja     80b9cc <tcp_enqueue+0x674>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  80b6c2:	66 89 73 0c          	mov    %si,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  80b6c6:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b6cd:	00 
  80b6ce:	8b 43 04             	mov    0x4(%ebx),%eax
  80b6d1:	89 04 24             	mov    %eax,(%esp)
  80b6d4:	e8 4a bf ff ff       	call   807623 <pbuf_header>
  80b6d9:	84 c0                	test   %al,%al
  80b6db:	0f 85 f1 02 00 00    	jne    80b9d2 <tcp_enqueue+0x67a>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  80b6e1:	8b 43 04             	mov    0x4(%ebx),%eax
  80b6e4:	8b 78 04             	mov    0x4(%eax),%edi
  80b6e7:	89 7b 10             	mov    %edi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  80b6ea:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80b6ed:	0f b7 41 1c          	movzwl 0x1c(%ecx),%eax
  80b6f1:	89 04 24             	mov    %eax,(%esp)
  80b6f4:	e8 8a f0 ff ff       	call   80a783 <htons>
  80b6f9:	66 89 07             	mov    %ax,(%edi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  80b6fc:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b6ff:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b702:	0f b7 42 1e          	movzwl 0x1e(%edx),%eax
  80b706:	89 04 24             	mov    %eax,(%esp)
  80b709:	e8 75 f0 ff ff       	call   80a783 <htons>
  80b70e:	66 89 47 02          	mov    %ax,0x2(%edi)
    seg->tcphdr->seqno = htonl(seqno);
  80b712:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b715:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  80b718:	89 0c 24             	mov    %ecx,(%esp)
  80b71b:	e8 84 f0 ff ff       	call   80a7a4 <htonl>
  80b720:	89 47 04             	mov    %eax,0x4(%edi)
    seg->tcphdr->urgp = 0;
  80b723:	8b 43 10             	mov    0x10(%ebx),%eax
  80b726:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80b72c:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b72f:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80b733:	89 04 24             	mov    %eax,(%esp)
  80b736:	e8 55 f0 ff ff       	call   80a790 <ntohs>
  80b73b:	83 e0 c0             	and    $0xffffffc0,%eax
  80b73e:	66 0b 45 bc          	or     -0x44(%ebp),%ax
  80b742:	0f b7 c0             	movzwl %ax,%eax
  80b745:	89 04 24             	mov    %eax,(%esp)
  80b748:	e8 36 f0 ff ff       	call   80a783 <htons>
  80b74d:	66 89 47 0c          	mov    %ax,0xc(%edi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  80b751:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80b755:	75 23                	jne    80b77a <tcp_enqueue+0x422>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  80b757:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b75a:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80b75e:	89 04 24             	mov    %eax,(%esp)
  80b761:	e8 2a f0 ff ff       	call   80a790 <ntohs>
  80b766:	83 e0 3f             	and    $0x3f,%eax
  80b769:	80 cc 50             	or     $0x50,%ah
  80b76c:	89 04 24             	mov    %eax,(%esp)
  80b76f:	e8 0f f0 ff ff       	call   80a783 <htons>
  80b774:	66 89 47 0c          	mov    %ax,0xc(%edi)
  80b778:	eb 3e                	jmp    80b7b8 <tcp_enqueue+0x460>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80b77a:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b77d:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80b781:	89 04 24             	mov    %eax,(%esp)
  80b784:	e8 07 f0 ff ff       	call   80a790 <ntohs>
  80b789:	83 e0 3f             	and    $0x3f,%eax
  80b78c:	66 0b 45 ba          	or     -0x46(%ebp),%ax
  80b790:	0f b7 c0             	movzwl %ax,%eax
  80b793:	89 04 24             	mov    %eax,(%esp)
  80b796:	e8 e8 ef ff ff       	call   80a783 <htons>
  80b79b:	66 89 47 0c          	mov    %ax,0xc(%edi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  80b79f:	8b 45 c0             	mov    -0x40(%ebp),%eax
  80b7a2:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b7a6:	8b 55 1c             	mov    0x1c(%ebp),%edx
  80b7a9:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b7ad:	8b 43 08             	mov    0x8(%ebx),%eax
  80b7b0:	89 04 24             	mov    %eax,(%esp)
  80b7b3:	e8 b9 5b ff ff       	call   801371 <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  80b7b8:	66 29 75 d8          	sub    %si,-0x28(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  80b7bc:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80b7c0:	0f 84 f7 fc ff ff    	je     80b4bd <tcp_enqueue+0x165>
  80b7c6:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
  80b7cb:	0f 85 ec fc ff ff    	jne    80b4bd <tcp_enqueue+0x165>
  80b7d1:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b7d4:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  80b7d7:	8b 4f 74             	mov    0x74(%edi),%ecx
  80b7da:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  80b7dd:	85 c9                	test   %ecx,%ecx
  80b7df:	0f 84 1c 01 00 00    	je     80b901 <tcp_enqueue+0x5a9>
  80b7e5:	89 ca                	mov    %ecx,%edx
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  80b7e7:	89 d0                	mov    %edx,%eax
  80b7e9:	8b 12                	mov    (%edx),%edx
  80b7eb:	85 d2                	test   %edx,%edx
  80b7ed:	75 f8                	jne    80b7e7 <tcp_enqueue+0x48f>
  80b7ef:	89 45 d8             	mov    %eax,-0x28(%ebp)
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80b7f2:	85 c0                	test   %eax,%eax
  80b7f4:	0f 84 07 01 00 00    	je     80b901 <tcp_enqueue+0x5a9>
    TCP_TCPLEN(useg) != 0 &&
  80b7fa:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b7fe:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
  80b802:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b805:	8b 42 10             	mov    0x10(%edx),%eax
  80b808:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b80c:	89 04 24             	mov    %eax,(%esp)
  80b80f:	e8 7c ef ff ff       	call   80a790 <ntohs>
  80b814:	a8 01                	test   $0x1,%al
  80b816:	75 1b                	jne    80b833 <tcp_enqueue+0x4db>
  80b818:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80b81b:	8b 41 10             	mov    0x10(%ecx),%eax
  80b81e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b822:	89 04 24             	mov    %eax,(%esp)
  80b825:	e8 66 ef ff ff       	call   80a790 <ntohs>
  80b82a:	ba 00 00 00 00       	mov    $0x0,%edx
  80b82f:	a8 02                	test   $0x2,%al
  80b831:	74 05                	je     80b838 <tcp_enqueue+0x4e0>
  80b833:	ba 01 00 00 00       	mov    $0x1,%edx
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80b838:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  80b83c:	01 c2                	add    %eax,%edx
  80b83e:	0f 84 ee 01 00 00    	je     80ba32 <tcp_enqueue+0x6da>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  80b844:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b847:	8b 42 10             	mov    0x10(%edx),%eax
  80b84a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b84e:	89 04 24             	mov    %eax,(%esp)
  80b851:	e8 3a ef ff ff       	call   80a790 <ntohs>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80b856:	a8 03                	test   $0x3,%al
  80b858:	0f 85 d4 01 00 00    	jne    80ba32 <tcp_enqueue+0x6da>
  80b85e:	f6 45 af 03          	testb  $0x3,-0x51(%ebp)
  80b862:	0f 85 ca 01 00 00    	jne    80ba32 <tcp_enqueue+0x6da>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  80b868:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80b86b:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  80b86f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80b872:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80b876:	01 c2                	add    %eax,%edx
  80b878:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80b87c:	39 c2                	cmp    %eax,%edx
  80b87e:	0f 8f ae 01 00 00    	jg     80ba32 <tcp_enqueue+0x6da>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  80b884:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80b88b:	ff 
  80b88c:	8b 55 c8             	mov    -0x38(%ebp),%edx
  80b88f:	8b 42 04             	mov    0x4(%edx),%eax
  80b892:	89 04 24             	mov    %eax,(%esp)
  80b895:	e8 89 bd ff ff       	call   807623 <pbuf_header>
  80b89a:	84 c0                	test   %al,%al
  80b89c:	74 1c                	je     80b8ba <tcp_enqueue+0x562>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80b89e:	c7 44 24 08 64 3b 81 	movl   $0x813b64,0x8(%esp)
  80b8a5:	00 
  80b8a6:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  80b8ad:	00 
  80b8ae:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b8b5:	e8 5a 50 ff ff       	call   800914 <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  80b8ba:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80b8bd:	8b 41 04             	mov    0x4(%ecx),%eax
  80b8c0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b8c4:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b8c7:	8b 42 04             	mov    0x4(%edx),%eax
  80b8ca:	89 04 24             	mov    %eax,(%esp)
  80b8cd:	e8 89 bc ff ff       	call   80755b <pbuf_cat>
    useg->len += queue->len;
  80b8d2:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80b8d5:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80b8d9:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b8dc:	66 01 42 0c          	add    %ax,0xc(%edx)
    useg->next = queue->next;
  80b8e0:	8b 01                	mov    (%ecx),%eax
  80b8e2:	89 02                	mov    %eax,(%edx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  80b8e4:	39 4d cc             	cmp    %ecx,-0x34(%ebp)
  80b8e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80b8ec:	0f 44 d8             	cmove  %eax,%ebx
      seg = NULL;
    }
    memp_free(MEMP_TCP_SEG, queue);
  80b8ef:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80b8f3:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80b8fa:	e8 05 b9 ff ff       	call   807204 <memp_free>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80b8ff:	eb 06                	jmp    80b907 <tcp_enqueue+0x5af>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80b901:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80b904:	89 4f 74             	mov    %ecx,0x74(%edi)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80b907:	f6 45 af 02          	testb  $0x2,-0x51(%ebp)
  80b90b:	75 0c                	jne    80b919 <tcp_enqueue+0x5c1>
  80b90d:	f6 45 af 01          	testb  $0x1,-0x51(%ebp)
  80b911:	0f 85 28 01 00 00    	jne    80ba3f <tcp_enqueue+0x6e7>
  80b917:	eb 0f                	jmp    80b928 <tcp_enqueue+0x5d0>
    ++len;
  80b919:	66 83 45 b6 01       	addw   $0x1,-0x4a(%ebp)
  }
  if (flags & TCP_FIN) {
  80b91e:	f6 45 af 01          	testb  $0x1,-0x51(%ebp)
  80b922:	74 04                	je     80b928 <tcp_enqueue+0x5d0>
    pcb->flags |= TF_FIN;
  80b924:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  80b928:	0f b7 45 b6          	movzwl -0x4a(%ebp),%eax
  80b92c:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  80b92f:	0f b7 45 b6          	movzwl -0x4a(%ebp),%eax
  80b933:	66 29 47 6e          	sub    %ax,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80b937:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
  80b93b:	66 89 57 70          	mov    %dx,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  80b93f:	66 85 d2             	test   %dx,%dx
  80b942:	74 28                	je     80b96c <tcp_enqueue+0x614>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80b944:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b948:	75 22                	jne    80b96c <tcp_enqueue+0x614>
  80b94a:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b94e:	75 1c                	jne    80b96c <tcp_enqueue+0x614>
  80b950:	c7 44 24 08 08 3b 81 	movl   $0x813b08,0x8(%esp)
  80b957:	00 
  80b958:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  80b95f:	00 
  80b960:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80b967:	e8 a8 4f ff ff       	call   800914 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  80b96c:	85 db                	test   %ebx,%ebx
  80b96e:	0f 84 b1 00 00 00    	je     80ba25 <tcp_enqueue+0x6cd>
  80b974:	66 85 f6             	test   %si,%si
  80b977:	0f 84 a8 00 00 00    	je     80ba25 <tcp_enqueue+0x6cd>
  80b97d:	8b 5b 10             	mov    0x10(%ebx),%ebx
  80b980:	85 db                	test   %ebx,%ebx
  80b982:	0f 84 9d 00 00 00    	je     80ba25 <tcp_enqueue+0x6cd>
  80b988:	f6 45 98 02          	testb  $0x2,-0x68(%ebp)
  80b98c:	0f 85 93 00 00 00    	jne    80ba25 <tcp_enqueue+0x6cd>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  80b992:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b996:	89 04 24             	mov    %eax,(%esp)
  80b999:	e8 f2 ed ff ff       	call   80a790 <ntohs>
  80b99e:	83 c8 08             	or     $0x8,%eax
  80b9a1:	0f b7 c0             	movzwl %ax,%eax
  80b9a4:	89 04 24             	mov    %eax,(%esp)
  80b9a7:	e8 d7 ed ff ff       	call   80a783 <htons>
  80b9ac:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  80b9b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9b5:	eb 73                	jmp    80ba2a <tcp_enqueue+0x6d2>
  80b9b7:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b9ba:	eb 19                	jmp    80b9d5 <tcp_enqueue+0x67d>
  80b9bc:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b9bf:	90                   	nop
  80b9c0:	eb 13                	jmp    80b9d5 <tcp_enqueue+0x67d>
  80b9c2:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b9c5:	eb 0e                	jmp    80b9d5 <tcp_enqueue+0x67d>
  80b9c7:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b9ca:	eb 09                	jmp    80b9d5 <tcp_enqueue+0x67d>
  80b9cc:	8b 7d d0             	mov    -0x30(%ebp),%edi
  80b9cf:	90                   	nop
  80b9d0:	eb 03                	jmp    80b9d5 <tcp_enqueue+0x67d>
  80b9d2:	8b 7d d0             	mov    -0x30(%ebp),%edi
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  80b9d5:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  80b9d9:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
  80b9dd:	74 0b                	je     80b9ea <tcp_enqueue+0x692>
    tcp_segs_free(queue);
  80b9df:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  80b9e2:	89 0c 24             	mov    %ecx,(%esp)
  80b9e5:	e8 5c cb ff ff       	call   808546 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  80b9ea:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80b9ef:	74 2d                	je     80ba1e <tcp_enqueue+0x6c6>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80b9f1:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b9f5:	75 27                	jne    80ba1e <tcp_enqueue+0x6c6>
  80b9f7:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80b9fb:	90                   	nop
  80b9fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80ba00:	75 1c                	jne    80ba1e <tcp_enqueue+0x6c6>
  80ba02:	c7 44 24 08 08 3b 81 	movl   $0x813b08,0x8(%esp)
  80ba09:	00 
  80ba0a:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  80ba11:	00 
  80ba12:	c7 04 24 28 3b 81 00 	movl   $0x813b28,(%esp)
  80ba19:	e8 f6 4e ff ff       	call   800914 <_panic>
  80ba1e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ba23:	eb 05                	jmp    80ba2a <tcp_enqueue+0x6d2>
  80ba25:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  80ba2a:	83 c4 6c             	add    $0x6c,%esp
  80ba2d:	5b                   	pop    %ebx
  80ba2e:	5e                   	pop    %esi
  80ba2f:	5f                   	pop    %edi
  80ba30:	5d                   	pop    %ebp
  80ba31:	c3                   	ret    
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  80ba32:	8b 55 c8             	mov    -0x38(%ebp),%edx
  80ba35:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ba38:	89 10                	mov    %edx,(%eax)
  80ba3a:	e9 c8 fe ff ff       	jmp    80b907 <tcp_enqueue+0x5af>
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    ++len;
  80ba3f:	66 83 45 b6 01       	addw   $0x1,-0x4a(%ebp)
  80ba44:	e9 db fe ff ff       	jmp    80b924 <tcp_enqueue+0x5cc>

0080ba49 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  80ba49:	55                   	push   %ebp
  80ba4a:	89 e5                	mov    %esp,%ebp
  80ba4c:	83 ec 28             	sub    $0x28,%esp
  80ba4f:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80ba52:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80ba55:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ba58:	0f b7 5d 10          	movzwl 0x10(%ebp),%ebx
  80ba5c:	0f b6 75 14          	movzbl 0x14(%ebp),%esi
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  80ba60:	8b 51 10             	mov    0x10(%ecx),%edx
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  80ba63:	83 fa 04             	cmp    $0x4,%edx
  80ba66:	74 14                	je     80ba7c <tcp_write+0x33>
  80ba68:	83 fa 07             	cmp    $0x7,%edx
  80ba6b:	74 0f                	je     80ba7c <tcp_write+0x33>
  80ba6d:	83 fa 02             	cmp    $0x2,%edx
  80ba70:	74 0a                	je     80ba7c <tcp_write+0x33>
  80ba72:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  80ba77:	83 fa 03             	cmp    $0x3,%edx
  80ba7a:	75 42                	jne    80babe <tcp_write+0x75>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  80ba7c:	b8 00 00 00 00       	mov    $0x0,%eax
  80ba81:	66 85 db             	test   %bx,%bx
  80ba84:	74 38                	je     80babe <tcp_write+0x75>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  80ba86:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80ba8d:	00 
  80ba8e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80ba95:	00 
  80ba96:	81 e6 ff 00 00 00    	and    $0xff,%esi
  80ba9c:	89 74 24 10          	mov    %esi,0x10(%esp)
  80baa0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80baa7:	00 
  80baa8:	0f b7 db             	movzwl %bx,%ebx
  80baab:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80baaf:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bab2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bab6:	89 0c 24             	mov    %ecx,(%esp)
  80bab9:	e8 9a f8 ff ff       	call   80b358 <tcp_enqueue>
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  80babe:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80bac1:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80bac4:	89 ec                	mov    %ebp,%esp
  80bac6:	5d                   	pop    %ebp
  80bac7:	c3                   	ret    

0080bac8 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  80bac8:	55                   	push   %ebp
  80bac9:	89 e5                	mov    %esp,%ebp
  80bacb:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  80bace:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80bad5:	00 
  80bad6:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80badd:	00 
  80bade:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  80bae5:	00 
  80bae6:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80baea:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80baee:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80baf5:	00 
  80baf6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bafd:	00 
  80bafe:	8b 45 08             	mov    0x8(%ebp),%eax
  80bb01:	89 04 24             	mov    %eax,(%esp)
  80bb04:	e8 4f f8 ff ff       	call   80b358 <tcp_enqueue>
}
  80bb09:	c9                   	leave  
  80bb0a:	c3                   	ret    
  80bb0b:	00 00                	add    %al,(%eax)
  80bb0d:	00 00                	add    %al,(%eax)
	...

0080bb10 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80bb10:	55                   	push   %ebp
  80bb11:	89 e5                	mov    %esp,%ebp
  80bb13:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  80bb16:	8b 15 e4 37 81 00    	mov    0x8137e4,%edx
  80bb1c:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  80bb1f:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  80bb25:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80bb29:	5d                   	pop    %ebp
  80bb2a:	c3                   	ret    

0080bb2b <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80bb2b:	55                   	push   %ebp
  80bb2c:	89 e5                	mov    %esp,%ebp
  80bb2e:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80bb31:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bb34:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  80bb37:	8b 55 10             	mov    0x10(%ebp),%edx
  80bb3a:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80bb3d:	5d                   	pop    %ebp
  80bb3e:	c3                   	ret    

0080bb3f <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  80bb3f:	55                   	push   %ebp
  80bb40:	89 e5                	mov    %esp,%ebp
  80bb42:	53                   	push   %ebx
  80bb43:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  80bb46:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80bb4d:	e8 f6 b6 ff ff       	call   807248 <memp_malloc>
  80bb52:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  80bb54:	85 c0                	test   %eax,%eax
  80bb56:	74 1c                	je     80bb74 <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  80bb58:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80bb5f:	00 
  80bb60:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bb67:	00 
  80bb68:	89 04 24             	mov    %eax,(%esp)
  80bb6b:	e8 26 57 ff ff       	call   801296 <memset>
    pcb->ttl = UDP_TTL;
  80bb70:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  80bb74:	89 d8                	mov    %ebx,%eax
  80bb76:	83 c4 14             	add    $0x14,%esp
  80bb79:	5b                   	pop    %ebx
  80bb7a:	5d                   	pop    %ebp
  80bb7b:	c3                   	ret    

0080bb7c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80bb7c:	55                   	push   %ebp
  80bb7d:	89 e5                	mov    %esp,%ebp
  80bb7f:	83 ec 18             	sub    $0x18,%esp
  80bb82:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  80bb85:	8b 15 24 f0 b3 00    	mov    0xb3f024,%edx
  80bb8b:	39 ca                	cmp    %ecx,%edx
  80bb8d:	74 06                	je     80bb95 <udp_remove+0x19>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80bb8f:	85 d2                	test   %edx,%edx
  80bb91:	75 0e                	jne    80bba1 <udp_remove+0x25>
  80bb93:	eb 21                	jmp    80bbb6 <udp_remove+0x3a>

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  80bb95:	8b 42 0c             	mov    0xc(%edx),%eax
  80bb98:	a3 24 f0 b3 00       	mov    %eax,0xb3f024
  80bb9d:	eb 17                	jmp    80bbb6 <udp_remove+0x3a>
  80bb9f:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80bba1:	8b 42 0c             	mov    0xc(%edx),%eax
  80bba4:	85 c0                	test   %eax,%eax
  80bba6:	74 0e                	je     80bbb6 <udp_remove+0x3a>
  80bba8:	39 c1                	cmp    %eax,%ecx
  80bbaa:	75 f3                	jne    80bb9f <udp_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80bbac:	8b 41 0c             	mov    0xc(%ecx),%eax
  80bbaf:	89 42 0c             	mov    %eax,0xc(%edx)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80bbb2:	85 c0                	test   %eax,%eax
  80bbb4:	75 e9                	jne    80bb9f <udp_remove+0x23>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  80bbb6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80bbba:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80bbc1:	e8 3e b6 ff ff       	call   807204 <memp_free>
}
  80bbc6:	c9                   	leave  
  80bbc7:	c3                   	ret    

0080bbc8 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80bbc8:	55                   	push   %ebp
  80bbc9:	89 e5                	mov    %esp,%ebp
  80bbcb:	57                   	push   %edi
  80bbcc:	56                   	push   %esi
  80bbcd:	53                   	push   %ebx
  80bbce:	83 ec 1c             	sub    $0x1c,%esp
  80bbd1:	8b 55 08             	mov    0x8(%ebp),%edx
  80bbd4:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80bbd7:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bbdb:	a1 24 f0 b3 00       	mov    0xb3f024,%eax
  80bbe0:	b9 00 00 00 00       	mov    $0x0,%ecx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80bbe5:	bb 01 00 00 00       	mov    $0x1,%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bbea:	85 c0                	test   %eax,%eax
  80bbec:	74 2d                	je     80bc1b <udp_bind+0x53>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  80bbee:	39 c2                	cmp    %eax,%edx
  80bbf0:	75 22                	jne    80bc14 <udp_bind+0x4c>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80bbf2:	84 c9                	test   %cl,%cl
  80bbf4:	74 1c                	je     80bc12 <udp_bind+0x4a>
  80bbf6:	c7 44 24 08 78 3b 81 	movl   $0x813b78,0x8(%esp)
  80bbfd:	00 
  80bbfe:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  80bc05:	00 
  80bc06:	c7 04 24 84 3b 81 00 	movl   $0x813b84,(%esp)
  80bc0d:	e8 02 4d ff ff       	call   800914 <_panic>
  80bc12:	89 d9                	mov    %ebx,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bc14:	8b 40 0c             	mov    0xc(%eax),%eax
  80bc17:	85 c0                	test   %eax,%eax
  80bc19:	75 d3                	jne    80bbee <udp_bind+0x26>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  80bc1b:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc20:	85 ff                	test   %edi,%edi
  80bc22:	74 02                	je     80bc26 <udp_bind+0x5e>
  80bc24:	8b 07                	mov    (%edi),%eax
  80bc26:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  80bc28:	66 85 f6             	test   %si,%si
  80bc2b:	75 39                	jne    80bc66 <udp_bind+0x9e>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  80bc2d:	8b 3d 24 f0 b3 00    	mov    0xb3f024,%edi
  80bc33:	89 f8                	mov    %edi,%eax
  80bc35:	be 00 10 00 00       	mov    $0x1000,%esi
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80bc3a:	eb 13                	jmp    80bc4f <udp_bind+0x87>
      if (ipcb->local_port == port) {
  80bc3c:	0f b7 58 12          	movzwl 0x12(%eax),%ebx
  80bc40:	66 39 f3             	cmp    %si,%bx
  80bc43:	75 07                	jne    80bc4c <udp_bind+0x84>
        /* port is already used by another udp_pcb */
        port++;
  80bc45:	8d 73 01             	lea    0x1(%ebx),%esi
  80bc48:	89 f8                	mov    %edi,%eax
  80bc4a:	eb 03                	jmp    80bc4f <udp_bind+0x87>
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  80bc4c:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80bc4f:	85 c0                	test   %eax,%eax
  80bc51:	0f 95 c3             	setne  %bl
  80bc54:	74 07                	je     80bc5d <udp_bind+0x95>
  80bc56:	66 81 fe ff 7f       	cmp    $0x7fff,%si
  80bc5b:	75 df                	jne    80bc3c <udp_bind+0x74>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  80bc5d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80bc62:	84 db                	test   %bl,%bl
  80bc64:	75 20                	jne    80bc86 <udp_bind+0xbe>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  80bc66:	66 89 72 12          	mov    %si,0x12(%edx)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  80bc6a:	b8 00 00 00 00       	mov    $0x0,%eax
  80bc6f:	84 c9                	test   %cl,%cl
  80bc71:	75 13                	jne    80bc86 <udp_bind+0xbe>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  80bc73:	a1 24 f0 b3 00       	mov    0xb3f024,%eax
  80bc78:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  80bc7b:	89 15 24 f0 b3 00    	mov    %edx,0xb3f024
  80bc81:	b8 00 00 00 00       	mov    $0x0,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  80bc86:	83 c4 1c             	add    $0x1c,%esp
  80bc89:	5b                   	pop    %ebx
  80bc8a:	5e                   	pop    %esi
  80bc8b:	5f                   	pop    %edi
  80bc8c:	5d                   	pop    %ebp
  80bc8d:	c3                   	ret    

0080bc8e <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80bc8e:	55                   	push   %ebp
  80bc8f:	89 e5                	mov    %esp,%ebp
  80bc91:	57                   	push   %edi
  80bc92:	56                   	push   %esi
  80bc93:	53                   	push   %ebx
  80bc94:	83 ec 1c             	sub    $0x1c,%esp
  80bc97:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bc9a:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80bc9d:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  80bca1:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80bca6:	75 18                	jne    80bcc0 <udp_connect+0x32>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80bca8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bcaf:	00 
  80bcb0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80bcb4:	89 1c 24             	mov    %ebx,(%esp)
  80bcb7:	e8 0c ff ff ff       	call   80bbc8 <udp_bind>
    if (err != ERR_OK)
  80bcbc:	84 c0                	test   %al,%al
  80bcbe:	75 48                	jne    80bd08 <udp_connect+0x7a>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  80bcc0:	b8 00 00 00 00       	mov    $0x0,%eax
  80bcc5:	85 ff                	test   %edi,%edi
  80bcc7:	74 02                	je     80bccb <udp_connect+0x3d>
  80bcc9:	8b 07                	mov    (%edi),%eax
  80bccb:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  80bcce:	66 89 73 14          	mov    %si,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  80bcd2:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bcd6:	8b 15 24 f0 b3 00    	mov    0xb3f024,%edx
  80bcdc:	85 d2                	test   %edx,%edx
  80bcde:	74 13                	je     80bcf3 <udp_connect+0x65>
    if (pcb == ipcb) {
  80bce0:	89 d0                	mov    %edx,%eax
  80bce2:	39 d3                	cmp    %edx,%ebx
  80bce4:	75 06                	jne    80bcec <udp_connect+0x5e>
  80bce6:	eb 1b                	jmp    80bd03 <udp_connect+0x75>
  80bce8:	39 c3                	cmp    %eax,%ebx
  80bcea:	74 17                	je     80bd03 <udp_connect+0x75>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80bcec:	8b 40 0c             	mov    0xc(%eax),%eax
  80bcef:	85 c0                	test   %eax,%eax
  80bcf1:	75 f5                	jne    80bce8 <udp_connect+0x5a>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80bcf3:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80bcf6:	89 1d 24 f0 b3 00    	mov    %ebx,0xb3f024
  80bcfc:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
  80bd01:	eb 05                	jmp    80bd08 <udp_connect+0x7a>
  80bd03:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80bd08:	83 c4 1c             	add    $0x1c,%esp
  80bd0b:	5b                   	pop    %ebx
  80bd0c:	5e                   	pop    %esi
  80bd0d:	5f                   	pop    %edi
  80bd0e:	5d                   	pop    %ebp
  80bd0f:	c3                   	ret    

0080bd10 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  80bd10:	55                   	push   %ebp
  80bd11:	89 e5                	mov    %esp,%ebp
  80bd13:	57                   	push   %edi
  80bd14:	56                   	push   %esi
  80bd15:	53                   	push   %ebx
  80bd16:	83 ec 3c             	sub    $0x3c,%esp
  80bd19:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bd1c:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  80bd20:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  80bd24:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80bd29:	75 1e                	jne    80bd49 <udp_sendto_if+0x39>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80bd2b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bd32:	00 
  80bd33:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80bd37:	89 1c 24             	mov    %ebx,(%esp)
  80bd3a:	e8 89 fe ff ff       	call   80bbc8 <udp_bind>
  80bd3f:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  80bd41:	84 c0                	test   %al,%al
  80bd43:	0f 85 6b 01 00 00    	jne    80beb4 <udp_sendto_if+0x1a4>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  80bd49:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80bd50:	00 
  80bd51:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bd54:	89 14 24             	mov    %edx,(%esp)
  80bd57:	e8 c7 b8 ff ff       	call   807623 <pbuf_header>
  80bd5c:	84 c0                	test   %al,%al
  80bd5e:	75 05                	jne    80bd65 <udp_sendto_if+0x55>
  80bd60:	8b 75 0c             	mov    0xc(%ebp),%esi
  80bd63:	eb 3a                	jmp    80bd9f <udp_sendto_if+0x8f>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  80bd65:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bd6c:	00 
  80bd6d:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80bd74:	00 
  80bd75:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80bd7c:	e8 c8 be ff ff       	call   807c49 <pbuf_alloc>
  80bd81:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80bd83:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80bd88:	85 c0                	test   %eax,%eax
  80bd8a:	0f 84 24 01 00 00    	je     80beb4 <udp_sendto_if+0x1a4>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80bd90:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bd93:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bd97:	89 34 24             	mov    %esi,(%esp)
  80bd9a:	e8 5d b8 ff ff       	call   8075fc <pbuf_chain>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  80bd9f:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  80bda4:	77 1c                	ja     80bdc2 <udp_sendto_if+0xb2>
  80bda6:	c7 44 24 08 ac 3b 81 	movl   $0x813bac,0x8(%esp)
  80bdad:	00 
  80bdae:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80bdb5:	00 
  80bdb6:	c7 04 24 84 3b 81 00 	movl   $0x813b84,(%esp)
  80bdbd:	e8 52 4b ff ff       	call   800914 <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  80bdc2:	8b 7e 04             	mov    0x4(%esi),%edi
  udphdr->src = htons(pcb->local_port);
  80bdc5:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  80bdc9:	89 04 24             	mov    %eax,(%esp)
  80bdcc:	e8 b2 e9 ff ff       	call   80a783 <htons>
  80bdd1:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  80bdd4:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80bdd8:	89 04 24             	mov    %eax,(%esp)
  80bddb:	e8 a3 e9 ff ff       	call   80a783 <htons>
  80bde0:	66 89 47 02          	mov    %ax,0x2(%edi)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  80bde4:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80bdea:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80bded:	85 db                	test   %ebx,%ebx
  80bdef:	74 06                	je     80bdf7 <udp_sendto_if+0xe7>
  80bdf1:	8b 03                	mov    (%ebx),%eax
  80bdf3:	85 c0                	test   %eax,%eax
  80bdf5:	75 0b                	jne    80be02 <udp_sendto_if+0xf2>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80bdf7:	8b 55 18             	mov    0x18(%ebp),%edx
  80bdfa:	83 c2 04             	add    $0x4,%edx
  80bdfd:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  udphdr->dest = htons(dst_port);
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80be00:	eb 23                	jmp    80be25 <udp_sendto_if+0x115>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80be02:	8b 55 18             	mov    0x18(%ebp),%edx
  80be05:	3b 42 04             	cmp    0x4(%edx),%eax
  80be08:	74 1b                	je     80be25 <udp_sendto_if+0x115>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  80be0a:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
  80be0f:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80be12:	0f 84 9c 00 00 00    	je     80beb4 <udp_sendto_if+0x1a4>
        /* free the header pbuf */
        pbuf_free(q);
  80be18:	89 34 24             	mov    %esi,(%esp)
  80be1b:	e8 6d bb ff ff       	call   80798d <pbuf_free>
  80be20:	e9 8f 00 00 00       	jmp    80beb4 <udp_sendto_if+0x1a4>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  80be25:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80be29:	89 04 24             	mov    %eax,(%esp)
  80be2c:	e8 52 e9 ff ff       	call   80a783 <htons>
  80be31:	66 89 47 04          	mov    %ax,0x4(%edi)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  80be35:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  80be39:	75 35                	jne    80be70 <udp_sendto_if+0x160>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80be3b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80be3f:	89 44 24 10          	mov    %eax,0x10(%esp)
  80be43:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80be4a:	00 
  80be4b:	8b 45 10             	mov    0x10(%ebp),%eax
  80be4e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80be52:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80be55:	89 54 24 04          	mov    %edx,0x4(%esp)
  80be59:	89 34 24             	mov    %esi,(%esp)
  80be5c:	e8 1f e6 ff ff       	call   80a480 <inet_chksum_pseudo>
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  80be61:	66 85 c0             	test   %ax,%ax
  80be64:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80be69:	0f 44 c2             	cmove  %edx,%eax
  80be6c:	66 89 47 06          	mov    %ax,0x6(%edi)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  80be70:	8b 45 18             	mov    0x18(%ebp),%eax
  80be73:	89 44 24 18          	mov    %eax,0x18(%esp)
  80be77:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  80be7e:	00 
  80be7f:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80be83:	89 44 24 10          	mov    %eax,0x10(%esp)
  80be87:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80be8b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80be8f:	8b 55 10             	mov    0x10(%ebp),%edx
  80be92:	89 54 24 08          	mov    %edx,0x8(%esp)
  80be96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80be99:	89 44 24 04          	mov    %eax,0x4(%esp)
  80be9d:	89 34 24             	mov    %esi,(%esp)
  80bea0:	e8 1b d5 ff ff       	call   8093c0 <ip_output_if>
  80bea5:	89 c7                	mov    %eax,%edi
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  80bea7:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80beaa:	74 08                	je     80beb4 <udp_sendto_if+0x1a4>
    /* free the header pbuf */
    pbuf_free(q);
  80beac:	89 34 24             	mov    %esi,(%esp)
  80beaf:	e8 d9 ba ff ff       	call   80798d <pbuf_free>
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  80beb4:	89 f8                	mov    %edi,%eax
  80beb6:	83 c4 3c             	add    $0x3c,%esp
  80beb9:	5b                   	pop    %ebx
  80beba:	5e                   	pop    %esi
  80bebb:	5f                   	pop    %edi
  80bebc:	5d                   	pop    %ebp
  80bebd:	c3                   	ret    

0080bebe <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  80bebe:	55                   	push   %ebp
  80bebf:	89 e5                	mov    %esp,%ebp
  80bec1:	83 ec 28             	sub    $0x28,%esp
  80bec4:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80bec7:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80beca:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80becd:	0f b7 75 14          	movzwl 0x14(%ebp),%esi

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  80bed1:	89 1c 24             	mov    %ebx,(%esp)
  80bed4:	e8 98 d6 ff ff       	call   809571 <ip_route>
  80bed9:	89 c2                	mov    %eax,%edx
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  80bedb:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80bee0:	85 d2                	test   %edx,%edx
  80bee2:	74 21                	je     80bf05 <udp_sendto+0x47>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80bee4:	89 54 24 10          	mov    %edx,0x10(%esp)
  80bee8:	0f b7 f6             	movzwl %si,%esi
  80beeb:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80beef:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80bef3:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bef6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80befa:	8b 45 08             	mov    0x8(%ebp),%eax
  80befd:	89 04 24             	mov    %eax,(%esp)
  80bf00:	e8 0b fe ff ff       	call   80bd10 <udp_sendto_if>
}
  80bf05:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80bf08:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80bf0b:	89 ec                	mov    %ebp,%esp
  80bf0d:	5d                   	pop    %ebp
  80bf0e:	c3                   	ret    

0080bf0f <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  80bf0f:	55                   	push   %ebp
  80bf10:	89 e5                	mov    %esp,%ebp
  80bf12:	83 ec 18             	sub    $0x18,%esp
  80bf15:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  80bf18:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  80bf1c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80bf20:	8d 50 04             	lea    0x4(%eax),%edx
  80bf23:	89 54 24 08          	mov    %edx,0x8(%esp)
  80bf27:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bf2a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80bf2e:	89 04 24             	mov    %eax,(%esp)
  80bf31:	e8 88 ff ff ff       	call   80bebe <udp_sendto>
}
  80bf36:	c9                   	leave  
  80bf37:	c3                   	ret    

0080bf38 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  80bf38:	55                   	push   %ebp
  80bf39:	89 e5                	mov    %esp,%ebp
  80bf3b:	57                   	push   %edi
  80bf3c:	56                   	push   %esi
  80bf3d:	53                   	push   %ebx
  80bf3e:	83 ec 4c             	sub    $0x4c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  80bf41:	8b 45 08             	mov    0x8(%ebp),%eax
  80bf44:	8b 40 04             	mov    0x4(%eax),%eax
  80bf47:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  80bf4a:	8b 55 08             	mov    0x8(%ebp),%edx
  80bf4d:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  80bf51:	0f b7 00             	movzwl (%eax),%eax
  80bf54:	89 04 24             	mov    %eax,(%esp)
  80bf57:	e8 34 e8 ff ff       	call   80a790 <ntohs>
  80bf5c:	0f b6 c4             	movzbl %ah,%eax
  80bf5f:	83 e0 0f             	and    $0xf,%eax
  80bf62:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80bf69:	39 c3                	cmp    %eax,%ebx
  80bf6b:	7c 2b                	jl     80bf98 <udp_input+0x60>
  80bf6d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80bf70:	0f b7 02             	movzwl (%edx),%eax
  80bf73:	89 04 24             	mov    %eax,(%esp)
  80bf76:	e8 15 e8 ff ff       	call   80a790 <ntohs>
  80bf7b:	66 c1 e8 06          	shr    $0x6,%ax
  80bf7f:	83 e0 3c             	and    $0x3c,%eax
  80bf82:	f7 d8                	neg    %eax
  80bf84:	98                   	cwtl   
  80bf85:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bf89:	8b 45 08             	mov    0x8(%ebp),%eax
  80bf8c:	89 04 24             	mov    %eax,(%esp)
  80bf8f:	e8 8f b6 ff ff       	call   807623 <pbuf_header>
  80bf94:	84 c0                	test   %al,%al
  80bf96:	74 10                	je     80bfa8 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  80bf98:	8b 55 08             	mov    0x8(%ebp),%edx
  80bf9b:	89 14 24             	mov    %edx,(%esp)
  80bf9e:	e8 ea b9 ff ff       	call   80798d <pbuf_free>
    goto end;
  80bfa3:	e9 f1 02 00 00       	jmp    80c299 <udp_input+0x361>
  }

  udphdr = (struct udp_hdr *)p->payload;
  80bfa8:	8b 45 08             	mov    0x8(%ebp),%eax
  80bfab:	8b 40 04             	mov    0x4(%eax),%eax
  80bfae:	89 45 d8             	mov    %eax,-0x28(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80bfb1:	0f b7 00             	movzwl (%eax),%eax
  80bfb4:	89 04 24             	mov    %eax,(%esp)
  80bfb7:	e8 d4 e7 ff ff       	call   80a790 <ntohs>
  80bfbc:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  dest = ntohs(udphdr->dest);
  80bfc0:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80bfc3:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80bfc7:	89 04 24             	mov    %eax,(%esp)
  80bfca:	e8 c1 e7 ff ff       	call   80a790 <ntohs>
  80bfcf:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  80bfd1:	66 83 f8 44          	cmp    $0x44,%ax
  80bfd5:	75 49                	jne    80c020 <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  80bfd7:	66 83 7d de 43       	cmpw   $0x43,-0x22(%ebp)
  80bfdc:	0f 85 f9 00 00 00    	jne    80c0db <udp_input+0x1a3>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80bfe2:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bfe5:	8b 42 20             	mov    0x20(%edx),%eax
  80bfe8:	85 c0                	test   %eax,%eax
  80bfea:	0f 84 eb 00 00 00    	je     80c0db <udp_input+0x1a3>
  80bff0:	8b 58 08             	mov    0x8(%eax),%ebx
  80bff3:	85 db                	test   %ebx,%ebx
  80bff5:	0f 84 e5 00 00 00    	je     80c0e0 <udp_input+0x1a8>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80bffb:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80bffe:	0f 84 ee 00 00 00    	je     80c0f2 <udp_input+0x1ba>
  80c004:	8b 43 04             	mov    0x4(%ebx),%eax
  80c007:	85 c0                	test   %eax,%eax
  80c009:	0f 84 e3 00 00 00    	je     80c0f2 <udp_input+0x1ba>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  80c00f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c012:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c015:	0f 85 c0 00 00 00    	jne    80c0db <udp_input+0x1a3>
  80c01b:	e9 d2 00 00 00       	jmp    80c0f2 <udp_input+0x1ba>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c020:	8b 1d 24 f0 b3 00    	mov    0xb3f024,%ebx
  80c026:	85 db                	test   %ebx,%ebx
  80c028:	0f 84 5f 02 00 00    	je     80c28d <udp_input+0x355>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80c02e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c031:	83 c0 10             	add    $0x10,%eax
  80c034:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80c037:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80c03e:	bf 00 00 00 00       	mov    $0x0,%edi
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c043:	66 3b 73 12          	cmp    0x12(%ebx),%si
  80c047:	75 75                	jne    80c0be <udp_input+0x186>
          (ip_addr_isany(&pcb->local_ip) ||
  80c049:	85 db                	test   %ebx,%ebx
  80c04b:	74 24                	je     80c071 <udp_input+0x139>
  80c04d:	8b 03                	mov    (%ebx),%eax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c04f:	85 c0                	test   %eax,%eax
  80c051:	74 1e                	je     80c071 <udp_input+0x139>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  80c053:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c056:	3b 42 10             	cmp    0x10(%edx),%eax
  80c059:	74 16                	je     80c071 <udp_input+0x139>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80c05b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c05e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c062:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80c065:	89 14 24             	mov    %edx,(%esp)
  80c068:	e8 0b d3 ff ff       	call   809378 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c06d:	84 c0                	test   %al,%al
  80c06f:	74 4d                	je     80c0be <udp_input+0x186>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  80c071:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80c075:	0f 85 fe 01 00 00    	jne    80c279 <udp_input+0x341>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80c07b:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  80c07f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80c082:	0f 44 c3             	cmove  %ebx,%eax
  80c085:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80c088:	e9 ec 01 00 00       	jmp    80c279 <udp_input+0x341>
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  80c08d:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80c090:	74 0f                	je     80c0a1 <udp_input+0x169>
  80c092:	8b 43 04             	mov    0x4(%ebx),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80c095:	85 c0                	test   %eax,%eax
  80c097:	74 08                	je     80c0a1 <udp_input+0x169>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  80c099:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c09c:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c09f:	75 1d                	jne    80c0be <udp_input+0x186>
  80c0a1:	89 d8                	mov    %ebx,%eax
        /* the first fully matching PCB */
        if (prev != NULL) {
  80c0a3:	85 ff                	test   %edi,%edi
  80c0a5:	74 27                	je     80c0ce <udp_input+0x196>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  80c0a7:	8b 53 0c             	mov    0xc(%ebx),%edx
  80c0aa:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  80c0ad:	8b 15 24 f0 b3 00    	mov    0xb3f024,%edx
  80c0b3:	89 53 0c             	mov    %edx,0xc(%ebx)
          udp_pcbs = pcb;
  80c0b6:	89 1d 24 f0 b3 00    	mov    %ebx,0xb3f024
  80c0bc:	eb 10                	jmp    80c0ce <udp_input+0x196>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c0be:	8b 43 0c             	mov    0xc(%ebx),%eax
  80c0c1:	85 c0                	test   %eax,%eax
  80c0c3:	74 0d                	je     80c0d2 <udp_input+0x19a>
  80c0c5:	89 df                	mov    %ebx,%edi
  80c0c7:	89 c3                	mov    %eax,%ebx
  80c0c9:	e9 75 ff ff ff       	jmp    80c043 <udp_input+0x10b>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  80c0ce:	85 c0                	test   %eax,%eax
  80c0d0:	75 20                	jne    80c0f2 <udp_input+0x1ba>
  80c0d2:	8b 5d e0             	mov    -0x20(%ebp),%ebx
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80c0d5:	85 db                	test   %ebx,%ebx
  80c0d7:	75 19                	jne    80c0f2 <udp_input+0x1ba>
  80c0d9:	eb 05                	jmp    80c0e0 <udp_input+0x1a8>
  80c0db:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c0e0:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c0e3:	8b 42 04             	mov    0x4(%edx),%eax
  80c0e6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c0e9:	3b 42 10             	cmp    0x10(%edx),%eax
  80c0ec:	0f 85 7a 01 00 00    	jne    80c26c <udp_input+0x334>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  80c0f2:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80c0f5:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80c0fa:	74 44                	je     80c140 <udp_input+0x208>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80c0fc:	8b 55 08             	mov    0x8(%ebp),%edx
  80c0ff:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80c103:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c107:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80c10e:	00 
  80c10f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c112:	83 c0 10             	add    $0x10,%eax
  80c115:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c119:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c11c:	83 c0 0c             	add    $0xc,%eax
  80c11f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c123:	89 14 24             	mov    %edx,(%esp)
  80c126:	e8 55 e3 ff ff       	call   80a480 <inet_chksum_pseudo>
  80c12b:	66 85 c0             	test   %ax,%ax
  80c12e:	74 10                	je     80c140 <udp_input+0x208>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  80c130:	8b 45 08             	mov    0x8(%ebp),%eax
  80c133:	89 04 24             	mov    %eax,(%esp)
  80c136:	e8 52 b8 ff ff       	call   80798d <pbuf_free>
          goto end;
  80c13b:	e9 59 01 00 00       	jmp    80c299 <udp_input+0x361>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  80c140:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  80c147:	ff 
  80c148:	8b 55 08             	mov    0x8(%ebp),%edx
  80c14b:	89 14 24             	mov    %edx,(%esp)
  80c14e:	e8 d0 b4 ff ff       	call   807623 <pbuf_header>
  80c153:	84 c0                	test   %al,%al
  80c155:	74 1c                	je     80c173 <udp_input+0x23b>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80c157:	c7 44 24 08 64 3b 81 	movl   $0x813b64,0x8(%esp)
  80c15e:	00 
  80c15f:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80c166:	00 
  80c167:	c7 04 24 84 3b 81 00 	movl   $0x813b84,(%esp)
  80c16e:	e8 a1 47 ff ff       	call   800914 <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  80c173:	85 db                	test   %ebx,%ebx
  80c175:	74 41                	je     80c1b8 <udp_input+0x280>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  80c177:	8b 43 18             	mov    0x18(%ebx),%eax
  80c17a:	85 c0                	test   %eax,%eax
  80c17c:	74 2a                	je     80c1a8 <udp_input+0x270>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  80c17e:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  80c182:	89 54 24 10          	mov    %edx,0x10(%esp)
  80c186:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c189:	83 c2 0c             	add    $0xc,%edx
  80c18c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80c190:	8b 55 08             	mov    0x8(%ebp),%edx
  80c193:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c197:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c19b:	8b 53 1c             	mov    0x1c(%ebx),%edx
  80c19e:	89 14 24             	mov    %edx,(%esp)
  80c1a1:	ff d0                	call   *%eax
  80c1a3:	e9 f1 00 00 00       	jmp    80c299 <udp_input+0x361>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  80c1a8:	8b 45 08             	mov    0x8(%ebp),%eax
  80c1ab:	89 04 24             	mov    %eax,(%esp)
  80c1ae:	e8 da b7 ff ff       	call   80798d <pbuf_free>
        goto end;
  80c1b3:	e9 e1 00 00 00       	jmp    80c299 <udp_input+0x361>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80c1b8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c1bb:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c1bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c1c2:	83 c0 10             	add    $0x10,%eax
  80c1c5:	89 04 24             	mov    %eax,(%esp)
  80c1c8:	e8 ab d1 ff ff       	call   809378 <ip_addr_isbroadcast>
  80c1cd:	84 c0                	test   %al,%al
  80c1cf:	0f 85 8a 00 00 00    	jne    80c25f <udp_input+0x327>
          !ip_addr_ismulticast(&iphdr->dest)) {
  80c1d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c1d8:	8b 70 10             	mov    0x10(%eax),%esi
  80c1db:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80c1e2:	e8 de e7 ff ff       	call   80a9c5 <ntohl>
  80c1e7:	89 c3                	mov    %eax,%ebx
  80c1e9:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c1f0:	e8 d0 e7 ff ff       	call   80a9c5 <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80c1f5:	21 f3                	and    %esi,%ebx
  80c1f7:	39 c3                	cmp    %eax,%ebx
  80c1f9:	74 64                	je     80c25f <udp_input+0x327>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  80c1fb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c1fe:	0f b7 02             	movzwl (%edx),%eax
  80c201:	89 04 24             	mov    %eax,(%esp)
  80c204:	e8 87 e5 ff ff       	call   80a790 <ntohs>
  80c209:	0f b6 c4             	movzbl %ah,%eax
  80c20c:	83 e0 0f             	and    $0xf,%eax
  80c20f:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80c216:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c21a:	8b 45 08             	mov    0x8(%ebp),%eax
  80c21d:	89 04 24             	mov    %eax,(%esp)
  80c220:	e8 fe b3 ff ff       	call   807623 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  80c225:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c228:	8b 55 08             	mov    0x8(%ebp),%edx
  80c22b:	39 42 04             	cmp    %eax,0x4(%edx)
  80c22e:	74 1c                	je     80c24c <udp_input+0x314>
  80c230:	c7 44 24 08 98 3b 81 	movl   $0x813b98,0x8(%esp)
  80c237:	00 
  80c238:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  80c23f:	00 
  80c240:	c7 04 24 84 3b 81 00 	movl   $0x813b84,(%esp)
  80c247:	e8 c8 46 ff ff       	call   800914 <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  80c24c:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80c253:	00 
  80c254:	8b 55 08             	mov    0x8(%ebp),%edx
  80c257:	89 14 24             	mov    %edx,(%esp)
  80c25a:	e8 e3 55 00 00       	call   811842 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  80c25f:	8b 45 08             	mov    0x8(%ebp),%eax
  80c262:	89 04 24             	mov    %eax,(%esp)
  80c265:	e8 23 b7 ff ff       	call   80798d <pbuf_free>
  80c26a:	eb 2d                	jmp    80c299 <udp_input+0x361>
    }
  } else {
    pbuf_free(p);
  80c26c:	8b 55 08             	mov    0x8(%ebp),%edx
  80c26f:	89 14 24             	mov    %edx,(%esp)
  80c272:	e8 16 b7 ff ff       	call   80798d <pbuf_free>
  80c277:	eb 20                	jmp    80c299 <udp_input+0x361>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  80c279:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  80c27d:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  80c281:	0f 85 37 fe ff ff    	jne    80c0be <udp_input+0x186>
  80c287:	90                   	nop
  80c288:	e9 00 fe ff ff       	jmp    80c08d <udp_input+0x155>
  80c28d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80c294:	e9 39 fe ff ff       	jmp    80c0d2 <udp_input+0x19a>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80c299:	83 c4 4c             	add    $0x4c,%esp
  80c29c:	5b                   	pop    %ebx
  80c29d:	5e                   	pop    %esi
  80c29e:	5f                   	pop    %edi
  80c29f:	5d                   	pop    %ebp
  80c2a0:	c3                   	ret    
	...

0080c2b0 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  80c2b0:	55                   	push   %ebp
  80c2b1:	89 e5                	mov    %esp,%ebp
  80c2b3:	57                   	push   %edi
  80c2b4:	56                   	push   %esi
  80c2b5:	53                   	push   %ebx
  80c2b6:	83 ec 2c             	sub    $0x2c,%esp
  80c2b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c2bc:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80c2bf:	89 ce                	mov    %ecx,%esi
  80c2c1:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  80c2c4:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c2c7:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80c2cb:	74 1c                	je     80c2e9 <etharp_send_ip+0x39>
  80c2cd:	c7 44 24 08 dc 3b 81 	movl   $0x813bdc,0x8(%esp)
  80c2d4:	00 
  80c2d5:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  80c2dc:	00 
  80c2dd:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c2e4:	e8 2b 46 ff ff       	call   800914 <_panic>
  80c2e9:	ba 06 00 00 00       	mov    $0x6,%edx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  80c2ee:	83 ea 01             	sub    $0x1,%edx
    ethhdr->dest.addr[k] = dst->addr[k];
  80c2f1:	0f b6 c2             	movzbl %dl,%eax
  80c2f4:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80c2f8:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80c2fb:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c2ff:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  80c303:	84 d2                	test   %dl,%dl
  80c305:	75 e7                	jne    80c2ee <etharp_send_ip+0x3e>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80c307:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c30e:	e8 70 e4 ff ff       	call   80a783 <htons>
  80c313:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  80c317:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80c31a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c31e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c321:	89 14 24             	mov    %edx,(%esp)
  80c324:	ff 52 18             	call   *0x18(%edx)
}
  80c327:	83 c4 2c             	add    $0x2c,%esp
  80c32a:	5b                   	pop    %ebx
  80c32b:	5e                   	pop    %esi
  80c32c:	5f                   	pop    %edi
  80c32d:	5d                   	pop    %ebp
  80c32e:	c3                   	ret    

0080c32f <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80c32f:	55                   	push   %ebp
  80c330:	89 e5                	mov    %esp,%ebp
  80c332:	57                   	push   %edi
  80c333:	56                   	push   %esi
  80c334:	53                   	push   %ebx
  80c335:	83 ec 3c             	sub    $0x3c,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  80c338:	8b 75 08             	mov    0x8(%ebp),%esi
  80c33b:	83 c6 25             	add    $0x25,%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80c33e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c345:	00 
  80c346:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  80c34d:	00 
  80c34e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80c355:	e8 ef b8 ff ff       	call   807c49 <pbuf_alloc>
  80c35a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  80c35d:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80c362:	85 c0                	test   %eax,%eax
  80c364:	0f 84 02 01 00 00    	je     80c46c <etharp_request+0x13d>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80c36a:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  80c36f:	77 1c                	ja     80c38d <etharp_request+0x5e>
  80c371:	c7 44 24 08 20 3c 81 	movl   $0x813c20,0x8(%esp)
  80c378:	00 
  80c379:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  80c380:	00 
  80c381:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c388:	e8 87 45 ff ff       	call   800914 <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  80c38d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c390:	8b 5a 04             	mov    0x4(%edx),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80c393:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c39a:	e8 e4 e3 ff ff       	call   80a783 <htons>
  80c39f:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c3a3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80c3a6:	80 79 24 06          	cmpb   $0x6,0x24(%ecx)
  80c3aa:	74 1c                	je     80c3c8 <etharp_request+0x99>
  80c3ac:	c7 44 24 08 dc 3b 81 	movl   $0x813bdc,0x8(%esp)
  80c3b3:	00 
  80c3b4:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  80c3bb:	00 
  80c3bc:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c3c3:	e8 4c 45 ff ff       	call   800914 <_panic>
  80c3c8:	ba 06 00 00 00       	mov    $0x6,%edx
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c3cd:	bf 41 3d 81 00       	mov    $0x813d41,%edi
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80c3d2:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80c3d5:	0f b6 c2             	movzbl %dl,%eax
  80c3d8:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c3dc:	88 4c 18 16          	mov    %cl,0x16(%eax,%ebx,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c3e0:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80c3e4:	88 4c 18 20          	mov    %cl,0x20(%eax,%ebx,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80c3e8:	0f b6 88 3b 3d 81 00 	movzbl 0x813d3b(%eax),%ecx
  80c3ef:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80c3f2:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c3f6:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  80c3fa:	84 d2                	test   %dl,%dl
  80c3fc:	75 d4                	jne    80c3d2 <etharp_request+0xa3>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80c3fe:	8b 55 08             	mov    0x8(%ebp),%edx
  80c401:	8b 42 04             	mov    0x4(%edx),%eax
  80c404:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80c407:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c40a:	8b 00                	mov    (%eax),%eax
  80c40c:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80c40f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c416:	e8 68 e3 ff ff       	call   80a783 <htons>
  80c41b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80c41f:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c426:	e8 58 e3 ff ff       	call   80a783 <htons>
  80c42b:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80c42f:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80c436:	e8 48 e3 ff ff       	call   80a783 <htons>
  80c43b:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80c43f:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80c446:	e8 38 e3 ff ff       	call   80a783 <htons>
  80c44b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80c44f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80c452:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80c456:	8b 45 08             	mov    0x8(%ebp),%eax
  80c459:	89 04 24             	mov    %eax,(%esp)
  80c45c:	ff 50 18             	call   *0x18(%eax)
  80c45f:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80c461:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80c464:	89 0c 24             	mov    %ecx,(%esp)
  80c467:	e8 21 b5 ff ff       	call   80798d <pbuf_free>
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80c46c:	89 d8                	mov    %ebx,%eax
  80c46e:	83 c4 3c             	add    $0x3c,%esp
  80c471:	5b                   	pop    %ebx
  80c472:	5e                   	pop    %esi
  80c473:	5f                   	pop    %edi
  80c474:	5d                   	pop    %ebp
  80c475:	c3                   	ret    

0080c476 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  80c476:	55                   	push   %ebp
  80c477:	89 e5                	mov    %esp,%ebp
  80c479:	56                   	push   %esi
  80c47a:	53                   	push   %ebx
  80c47b:	83 ec 10             	sub    $0x10,%esp
  80c47e:	89 c6                	mov    %eax,%esi
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  80c480:	85 c0                	test   %eax,%eax
  80c482:	75 1c                	jne    80c4a0 <free_etharp_q+0x2a>
  80c484:	c7 44 24 08 8f 34 81 	movl   $0x81348f,0x8(%esp)
  80c48b:	00 
  80c48c:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  80c493:	00 
  80c494:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c49b:	e8 74 44 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80c4a0:	8b 40 04             	mov    0x4(%eax),%eax
  80c4a3:	85 c0                	test   %eax,%eax
  80c4a5:	74 04                	je     80c4ab <free_etharp_q+0x35>
  while (q) {
    r = q;
    q = q->next;
  80c4a7:	8b 1e                	mov    (%esi),%ebx
  80c4a9:	eb 45                	jmp    80c4f0 <free_etharp_q+0x7a>
static void
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80c4ab:	c7 44 24 08 dd 3c 81 	movl   $0x813cdd,0x8(%esp)
  80c4b2:	00 
  80c4b3:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  80c4ba:	00 
  80c4bb:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c4c2:	e8 4d 44 ff ff       	call   800914 <_panic>
  while (q) {
    r = q;
    q = q->next;
  80c4c7:	8b 13                	mov    (%ebx),%edx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80c4c9:	8b 43 04             	mov    0x4(%ebx),%eax
  80c4cc:	85 c0                	test   %eax,%eax
  80c4ce:	75 1c                	jne    80c4ec <free_etharp_q+0x76>
  80c4d0:	c7 44 24 08 ea 3c 81 	movl   $0x813cea,0x8(%esp)
  80c4d7:	00 
  80c4d8:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80c4df:	00 
  80c4e0:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c4e7:	e8 28 44 ff ff       	call   800914 <_panic>
  80c4ec:	89 de                	mov    %ebx,%esi
  80c4ee:	89 d3                	mov    %edx,%ebx
    pbuf_free(r->p);
  80c4f0:	89 04 24             	mov    %eax,(%esp)
  80c4f3:	e8 95 b4 ff ff       	call   80798d <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80c4f8:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c4fc:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80c503:	e8 fc ac ff ff       	call   807204 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  80c508:	85 db                	test   %ebx,%ebx
  80c50a:	75 bb                	jne    80c4c7 <free_etharp_q+0x51>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  80c50c:	83 c4 10             	add    $0x10,%esp
  80c50f:	5b                   	pop    %ebx
  80c510:	5e                   	pop    %esi
  80c511:	5d                   	pop    %ebp
  80c512:	c3                   	ret    

0080c513 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80c513:	55                   	push   %ebp
  80c514:	89 e5                	mov    %esp,%ebp
  80c516:	57                   	push   %edi
  80c517:	56                   	push   %esi
  80c518:	53                   	push   %ebx
  80c519:	83 ec 3c             	sub    $0x3c,%esp
  80c51c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80c51f:	88 55 dd             	mov    %dl,-0x23(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  80c522:	85 c0                	test   %eax,%eax
  80c524:	74 16                	je     80c53c <find_entry+0x29>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80c526:	0f b6 05 78 5b b3 00 	movzbl 0xb35b78,%eax
  80c52d:	0f b6 d0             	movzbl %al,%edx
  80c530:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80c533:	83 b9 70 5a b3 00 02 	cmpl   $0x2,0xb35a70(%ecx)
  80c53a:	74 2a                	je     80c566 <find_entry+0x53>
  80c53c:	ba 74 5a b3 00       	mov    $0xb35a74,%edx
  80c541:	be 00 00 00 00       	mov    $0x0,%esi
  80c546:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  80c54a:	bf 00 00 00 00       	mov    $0x0,%edi
  80c54f:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80c553:	b8 00 00 00 00       	mov    $0x0,%eax
  80c558:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80c55c:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  80c560:	c6 45 dc 0a          	movb   $0xa,-0x24(%ebp)
  80c564:	eb 22                	jmp    80c588 <find_entry+0x75>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80c566:	6b d2 1c             	imul   $0x1c,%edx,%edx
  80c569:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80c56c:	8b 0b                	mov    (%ebx),%ecx
  80c56e:	3b 8a 64 5a b3 00    	cmp    0xb35a64(%edx),%ecx
  80c574:	75 c6                	jne    80c53c <find_entry+0x29>
  80c576:	e9 c4 01 00 00       	jmp    80c73f <find_entry+0x22c>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  80c57b:	89 ce                	mov    %ecx,%esi
  80c57d:	0f b6 7d d7          	movzbl -0x29(%ebp),%edi
  80c581:	0f b6 4d e6          	movzbl -0x1a(%ebp),%ecx
  80c585:	88 4d e7             	mov    %cl,-0x19(%ebp)
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80c588:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  80c58c:	75 1c                	jne    80c5aa <find_entry+0x97>
  80c58e:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  80c592:	75 16                	jne    80c5aa <find_entry+0x97>
  80c594:	88 45 e5             	mov    %al,-0x1b(%ebp)
  80c597:	89 f1                	mov    %esi,%ecx
  80c599:	89 fb                	mov    %edi,%ebx
  80c59b:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80c59e:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80c5a2:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80c5a5:	e9 a0 00 00 00       	jmp    80c64a <find_entry+0x137>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80c5aa:	8b 4a fc             	mov    -0x4(%edx),%ecx
  80c5ad:	83 f9 01             	cmp    $0x1,%ecx
  80c5b0:	75 51                	jne    80c603 <find_entry+0xf0>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80c5b2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80c5b6:	74 14                	je     80c5cc <find_entry+0xb9>
  80c5b8:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80c5bb:	8b 0b                	mov    (%ebx),%ecx
  80c5bd:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  80c5c0:	75 0a                	jne    80c5cc <find_entry+0xb9>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80c5c2:	a2 78 5b b3 00       	mov    %al,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80c5c7:	e9 73 01 00 00       	jmp    80c73f <find_entry+0x22c>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  80c5cc:	83 7a ec 00          	cmpl   $0x0,-0x14(%edx)
  80c5d0:	74 1a                	je     80c5ec <find_entry+0xd9>
        if (arp_table[i].ctime >= age_queue) {
  80c5d2:	0f b6 0a             	movzbl (%edx),%ecx
  80c5d5:	89 f3                	mov    %esi,%ebx
  80c5d7:	38 cb                	cmp    %cl,%bl
  80c5d9:	77 61                	ja     80c63c <find_entry+0x129>
  80c5db:	88 45 df             	mov    %al,-0x21(%ebp)
  80c5de:	89 fb                	mov    %edi,%ebx
  80c5e0:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80c5e3:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80c5e7:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80c5ea:	eb 5e                	jmp    80c64a <find_entry+0x137>
          age_queue = arp_table[i].ctime;
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  80c5ec:	0f b6 0a             	movzbl (%edx),%ecx
  80c5ef:	88 4d e6             	mov    %cl,-0x1a(%ebp)
  80c5f2:	38 4d e7             	cmp    %cl,-0x19(%ebp)
  80c5f5:	77 45                	ja     80c63c <find_entry+0x129>
  80c5f7:	88 45 dc             	mov    %al,-0x24(%ebp)
  80c5fa:	89 f1                	mov    %esi,%ecx
  80c5fc:	89 fb                	mov    %edi,%ebx
  80c5fe:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80c601:	eb 47                	jmp    80c64a <find_entry+0x137>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80c603:	83 f9 02             	cmp    $0x2,%ecx
  80c606:	75 34                	jne    80c63c <find_entry+0x129>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80c608:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80c60c:	74 14                	je     80c622 <find_entry+0x10f>
  80c60e:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80c611:	8b 0b                	mov    (%ebx),%ecx
  80c613:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  80c616:	75 0a                	jne    80c622 <find_entry+0x10f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80c618:	a2 78 5b b3 00       	mov    %al,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80c61d:	e9 1d 01 00 00       	jmp    80c73f <find_entry+0x22c>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  80c622:	0f b6 0a             	movzbl (%edx),%ecx
  80c625:	88 4d d7             	mov    %cl,-0x29(%ebp)
  80c628:	89 fb                	mov    %edi,%ebx
  80c62a:	38 cb                	cmp    %cl,%bl
  80c62c:	77 0e                	ja     80c63c <find_entry+0x129>
  80c62e:	88 45 de             	mov    %al,-0x22(%ebp)
  80c631:	89 f1                	mov    %esi,%ecx
  80c633:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80c637:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80c63a:	eb 0e                	jmp    80c64a <find_entry+0x137>
  80c63c:	89 f1                	mov    %esi,%ecx
  80c63e:	89 fb                	mov    %edi,%ebx
  80c640:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80c643:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80c647:	88 5d e6             	mov    %bl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80c64a:	83 c0 01             	add    $0x1,%eax
  80c64d:	83 c2 1c             	add    $0x1c,%edx
  80c650:	3c 0a                	cmp    $0xa,%al
  80c652:	0f 85 23 ff ff ff    	jne    80c57b <find_entry+0x68>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80c658:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  80c65c:	75 0a                	jne    80c668 <find_entry+0x155>
  80c65e:	f6 45 dd 01          	testb  $0x1,-0x23(%ebp)
  80c662:	0f 84 d2 00 00 00    	je     80c73a <find_entry+0x227>
  80c668:	f6 45 dd 02          	testb  $0x2,-0x23(%ebp)
  80c66c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c670:	0f 85 c4 00 00 00    	jne    80c73a <find_entry+0x227>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  80c676:	0f b6 5d e5          	movzbl -0x1b(%ebp),%ebx
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  80c67a:	80 fb 09             	cmp    $0x9,%bl
  80c67d:	8d 76 00             	lea    0x0(%esi),%esi
  80c680:	7e 62                	jle    80c6e4 <find_entry+0x1d1>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  80c682:	80 7d de 09          	cmpb   $0x9,-0x22(%ebp)
  80c686:	7f 2f                	jg     80c6b7 <find_entry+0x1a4>
    /* recycle oldest stable*/
    i = old_stable;
  80c688:	0f b6 5d de          	movzbl -0x22(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80c68c:	0f b6 c3             	movzbl %bl,%eax
  80c68f:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80c692:	83 b8 60 5a b3 00 00 	cmpl   $0x0,0xb35a60(%eax)
  80c699:	74 49                	je     80c6e4 <find_entry+0x1d1>
  80c69b:	c7 44 24 08 f7 3c 81 	movl   $0x813cf7,0x8(%esp)
  80c6a2:	00 
  80c6a3:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  80c6aa:	00 
  80c6ab:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c6b2:	e8 5d 42 ff ff       	call   800914 <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
    /* recycle oldest pending */
    i = old_pending;
  80c6b7:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  80c6bb:	80 fb 09             	cmp    $0x9,%bl
  80c6be:	7e 24                	jle    80c6e4 <find_entry+0x1d1>
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  80c6c0:	80 7d df 09          	cmpb   $0x9,-0x21(%ebp)
  80c6c4:	7f 74                	jg     80c73a <find_entry+0x227>
    /* recycle oldest pending */
    i = old_queue;
  80c6c6:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  80c6ca:	0f b6 f3             	movzbl %bl,%esi
  80c6cd:	bf 60 5a b3 00       	mov    $0xb35a60,%edi
  80c6d2:	6b f6 1c             	imul   $0x1c,%esi,%esi
  80c6d5:	8b 04 3e             	mov    (%esi,%edi,1),%eax
  80c6d8:	e8 99 fd ff ff       	call   80c476 <free_etharp_q>
    arp_table[i].q = NULL;
  80c6dd:	c7 04 3e 00 00 00 00 	movl   $0x0,(%esi,%edi,1)
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  80c6e4:	80 fb 09             	cmp    $0x9,%bl
  80c6e7:	76 1c                	jbe    80c705 <find_entry+0x1f2>
  80c6e9:	c7 44 24 08 0e 3d 81 	movl   $0x813d0e,0x8(%esp)
  80c6f0:	00 
  80c6f1:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  80c6f8:	00 
  80c6f9:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c700:	e8 0f 42 ff ff       	call   800914 <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  80c705:	0f b6 c3             	movzbl %bl,%eax
  80c708:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80c70b:	c7 82 70 5a b3 00 00 	movl   $0x0,0xb35a70(%edx)
  80c712:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  80c715:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80c719:	74 0b                	je     80c726 <find_entry+0x213>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  80c71b:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80c71e:	8b 0e                	mov    (%esi),%ecx
  80c720:	89 8a 64 5a b3 00    	mov    %ecx,0xb35a64(%edx)
  }
  arp_table[i].ctime = 0;
  80c726:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80c729:	c6 80 74 5a b3 00 00 	movb   $0x0,0xb35a74(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80c730:	88 1d 78 5b b3 00    	mov    %bl,0xb35b78
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  80c736:	89 d8                	mov    %ebx,%eax
  80c738:	eb 05                	jmp    80c73f <find_entry+0x22c>
  80c73a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80c73f:	83 c4 3c             	add    $0x3c,%esp
  80c742:	5b                   	pop    %ebx
  80c743:	5e                   	pop    %esi
  80c744:	5f                   	pop    %edi
  80c745:	5d                   	pop    %ebp
  80c746:	c3                   	ret    

0080c747 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80c747:	55                   	push   %ebp
  80c748:	89 e5                	mov    %esp,%ebp
  80c74a:	83 ec 38             	sub    $0x38,%esp
  80c74d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80c750:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80c753:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80c756:	8b 75 08             	mov    0x8(%ebp),%esi
  80c759:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80c75c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c760:	89 1c 24             	mov    %ebx,(%esp)
  80c763:	e8 10 cc ff ff       	call   809378 <ip_addr_isbroadcast>
  80c768:	84 c0                	test   %al,%al
  80c76a:	0f 85 c4 01 00 00    	jne    80c934 <etharp_query+0x1ed>
      ip_addr_ismulticast(ipaddr) ||
  80c770:	8b 03                	mov    (%ebx),%eax
  80c772:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c775:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80c77c:	e8 44 e2 ff ff       	call   80a9c5 <ntohl>
  80c781:	89 c7                	mov    %eax,%edi
  80c783:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c78a:	e8 36 e2 ff ff       	call   80a9c5 <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80c78f:	23 7d e4             	and    -0x1c(%ebp),%edi
  80c792:	39 c7                	cmp    %eax,%edi
  80c794:	0f 84 9a 01 00 00    	je     80c934 <etharp_query+0x1ed>
  80c79a:	85 db                	test   %ebx,%ebx
  80c79c:	0f 84 92 01 00 00    	je     80c934 <etharp_query+0x1ed>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
  80c7a2:	83 3b 00             	cmpl   $0x0,(%ebx)
  80c7a5:	0f 84 89 01 00 00    	je     80c934 <etharp_query+0x1ed>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80c7ab:	ba 01 00 00 00       	mov    $0x1,%edx
  80c7b0:	89 d8                	mov    %ebx,%eax
  80c7b2:	e8 5c fd ff ff       	call   80c513 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80c7b7:	84 c0                	test   %al,%al
  80c7b9:	0f 88 80 01 00 00    	js     80c93f <etharp_query+0x1f8>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80c7bf:	0f be f8             	movsbl %al,%edi
  80c7c2:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80c7c5:	8b 80 70 5a b3 00    	mov    0xb35a70(%eax),%eax
  80c7cb:	85 c0                	test   %eax,%eax
  80c7cd:	75 0f                	jne    80c7de <etharp_query+0x97>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80c7cf:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80c7d2:	c7 80 70 5a b3 00 01 	movl   $0x1,0xb35a70(%eax)
  80c7d9:	00 00 00 
  80c7dc:	eb 33                	jmp    80c811 <etharp_query+0xca>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80c7de:	8d 50 ff             	lea    -0x1(%eax),%edx
  80c7e1:	83 fa 01             	cmp    $0x1,%edx
  80c7e4:	76 1c                	jbe    80c802 <etharp_query+0xbb>
  80c7e6:	c7 44 24 08 54 3c 81 	movl   $0x813c54,0x8(%esp)
  80c7ed:	00 
  80c7ee:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80c7f5:	00 
  80c7f6:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c7fd:	e8 12 41 ff ff       	call   800914 <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80c802:	83 f8 01             	cmp    $0x1,%eax
  80c805:	74 0a                	je     80c811 <etharp_query+0xca>
  80c807:	c6 45 e4 ff          	movb   $0xff,-0x1c(%ebp)
  80c80b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80c80f:	75 0f                	jne    80c820 <etharp_query+0xd9>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80c811:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c815:	89 34 24             	mov    %esi,(%esp)
  80c818:	e8 12 fb ff ff       	call   80c32f <etharp_request>
  80c81d:	88 45 e4             	mov    %al,-0x1c(%ebp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80c820:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80c824:	0f 84 11 01 00 00    	je     80c93b <etharp_query+0x1f4>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80c82a:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80c82d:	8b 80 70 5a b3 00    	mov    0xb35a70(%eax),%eax
  80c833:	83 f8 02             	cmp    $0x2,%eax
  80c836:	75 1d                	jne    80c855 <etharp_query+0x10e>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80c838:	8d 4e 25             	lea    0x25(%esi),%ecx
  80c83b:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80c83e:	05 68 5a b3 00       	add    $0xb35a68,%eax
  80c843:	89 04 24             	mov    %eax,(%esp)
  80c846:	8b 55 10             	mov    0x10(%ebp),%edx
  80c849:	89 f0                	mov    %esi,%eax
  80c84b:	e8 60 fa ff ff       	call   80c2b0 <etharp_send_ip>
  80c850:	e9 ea 00 00 00       	jmp    80c93f <etharp_query+0x1f8>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80c855:	83 f8 01             	cmp    $0x1,%eax
  80c858:	0f 85 dd 00 00 00    	jne    80c93b <etharp_query+0x1f4>
  80c85e:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80c861:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80c865:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  80c869:	75 21                	jne    80c88c <etharp_query+0x145>
  80c86b:	83 38 00             	cmpl   $0x0,(%eax)
  80c86e:	74 1c                	je     80c88c <etharp_query+0x145>
  80c870:	c7 44 24 08 21 3d 81 	movl   $0x813d21,0x8(%esp)
  80c877:	00 
  80c878:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80c87f:	00 
  80c880:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80c887:	e8 88 40 ff ff       	call   800914 <_panic>
        if(p->type != PBUF_ROM) {
  80c88c:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80c890:	75 0b                	jne    80c89d <etharp_query+0x156>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80c892:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80c894:	85 c0                	test   %eax,%eax
  80c896:	75 c9                	jne    80c861 <etharp_query+0x11a>
  80c898:	e9 af 00 00 00       	jmp    80c94c <etharp_query+0x205>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80c89d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c8a4:	00 
  80c8a5:	0f b7 d2             	movzwl %dx,%edx
  80c8a8:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c8ac:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80c8b3:	e8 91 b3 ff ff       	call   807c49 <pbuf_alloc>
  80c8b8:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  80c8ba:	85 c0                	test   %eax,%eax
  80c8bc:	74 7d                	je     80c93b <etharp_query+0x1f4>
          if (pbuf_copy(p, q) != ERR_OK) {
  80c8be:	8b 45 10             	mov    0x10(%ebp),%eax
  80c8c1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c8c5:	89 1c 24             	mov    %ebx,(%esp)
  80c8c8:	e8 17 af ff ff       	call   8077e4 <pbuf_copy>
  80c8cd:	84 c0                	test   %al,%al
  80c8cf:	74 0e                	je     80c8df <etharp_query+0x198>
            pbuf_free(p);
  80c8d1:	89 1c 24             	mov    %ebx,(%esp)
  80c8d4:	e8 b4 b0 ff ff       	call   80798d <pbuf_free>
  80c8d9:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80c8dd:	eb 60                	jmp    80c93f <etharp_query+0x1f8>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80c8df:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80c8e6:	e8 5d a9 ff ff       	call   807248 <memp_malloc>
        if (new_entry != NULL) {
  80c8eb:	85 c0                	test   %eax,%eax
  80c8ed:	74 37                	je     80c926 <etharp_query+0x1df>
          new_entry->next = 0;
  80c8ef:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80c8f5:	89 58 04             	mov    %ebx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80c8f8:	6b d7 1c             	imul   $0x1c,%edi,%edx
  80c8fb:	8b 92 60 5a b3 00    	mov    0xb35a60(%edx),%edx
  80c901:	85 d2                	test   %edx,%edx
  80c903:	74 11                	je     80c916 <etharp_query+0x1cf>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80c905:	89 d1                	mov    %edx,%ecx
  80c907:	8b 12                	mov    (%edx),%edx
  80c909:	85 d2                	test   %edx,%edx
  80c90b:	75 f8                	jne    80c905 <etharp_query+0x1be>
              r = r->next;
            }
            r->next = new_entry;
  80c90d:	89 01                	mov    %eax,(%ecx)
  80c90f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c914:	eb 29                	jmp    80c93f <etharp_query+0x1f8>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80c916:	6b ff 1c             	imul   $0x1c,%edi,%edi
  80c919:	89 87 60 5a b3 00    	mov    %eax,0xb35a60(%edi)
  80c91f:	b8 00 00 00 00       	mov    $0x0,%eax
  80c924:	eb 19                	jmp    80c93f <etharp_query+0x1f8>
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80c926:	89 1c 24             	mov    %ebx,(%esp)
  80c929:	e8 5f b0 ff ff       	call   80798d <pbuf_free>
  80c92e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
  80c932:	eb 0b                	jmp    80c93f <etharp_query+0x1f8>
  80c934:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80c939:	eb 04                	jmp    80c93f <etharp_query+0x1f8>
  80c93b:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80c93f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80c942:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80c945:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80c948:	89 ec                	mov    %ebp,%esp
  80c94a:	5d                   	pop    %ebp
  80c94b:	c3                   	ret    
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80c94c:	8b 45 10             	mov    0x10(%ebp),%eax
  80c94f:	89 04 24             	mov    %eax,(%esp)
  80c952:	e8 f3 ab ff ff       	call   80754a <pbuf_ref>
  80c957:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80c95a:	eb 83                	jmp    80c8df <etharp_query+0x198>

0080c95c <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80c95c:	55                   	push   %ebp
  80c95d:	89 e5                	mov    %esp,%ebp
  80c95f:	83 ec 48             	sub    $0x48,%esp
  80c962:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80c965:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80c968:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80c96b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c96e:	8b 75 0c             	mov    0xc(%ebp),%esi
  80c971:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80c974:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80c97b:	00 
  80c97c:	89 34 24             	mov    %esi,(%esp)
  80c97f:	e8 9f ac ff ff       	call   807623 <pbuf_header>
  80c984:	89 c2                	mov    %eax,%edx
  80c986:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80c98b:	84 d2                	test   %dl,%dl
  80c98d:	0f 85 bd 00 00 00    	jne    80ca50 <etharp_output+0xf4>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80c993:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c997:	89 3c 24             	mov    %edi,(%esp)
  80c99a:	e8 d9 c9 ff ff       	call   809378 <ip_addr_isbroadcast>
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80c99f:	ba 3b 3d 81 00       	mov    $0x813d3b,%edx
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80c9a4:	84 c0                	test   %al,%al
  80c9a6:	0f 85 95 00 00 00    	jne    80ca41 <etharp_output+0xe5>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80c9ac:	8b 07                	mov    (%edi),%eax
  80c9ae:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80c9b1:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80c9b8:	e8 08 e0 ff ff       	call   80a9c5 <ntohl>
  80c9bd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80c9c0:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c9c7:	e8 f9 df ff ff       	call   80a9c5 <ntohl>
  80c9cc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80c9cf:	23 55 d0             	and    -0x30(%ebp),%edx
  80c9d2:	39 c2                	cmp    %eax,%edx
  80c9d4:	75 41                	jne    80ca17 <etharp_output+0xbb>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80c9d6:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80c9da:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80c9de:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80c9e2:	8b 07                	mov    (%edi),%eax
  80c9e4:	89 04 24             	mov    %eax,(%esp)
  80c9e7:	e8 d9 df ff ff       	call   80a9c5 <ntohl>
  80c9ec:	c1 e8 10             	shr    $0x10,%eax
  80c9ef:	83 e0 7f             	and    $0x7f,%eax
  80c9f2:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80c9f5:	8b 07                	mov    (%edi),%eax
  80c9f7:	89 04 24             	mov    %eax,(%esp)
  80c9fa:	e8 c6 df ff ff       	call   80a9c5 <ntohl>
  80c9ff:	c1 e8 08             	shr    $0x8,%eax
  80ca02:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80ca05:	8b 07                	mov    (%edi),%eax
  80ca07:	89 04 24             	mov    %eax,(%esp)
  80ca0a:	e8 b6 df ff ff       	call   80a9c5 <ntohl>
  80ca0f:	88 45 e7             	mov    %al,-0x19(%ebp)
  80ca12:	8d 55 e2             	lea    -0x1e(%ebp),%edx
  80ca15:	eb 2a                	jmp    80ca41 <etharp_output+0xe5>
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80ca17:	8b 43 04             	mov    0x4(%ebx),%eax
  80ca1a:	33 07                	xor    (%edi),%eax
  80ca1c:	85 43 08             	test   %eax,0x8(%ebx)
  80ca1f:	74 0e                	je     80ca2f <etharp_output+0xd3>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80ca21:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80ca26:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80ca2a:	74 24                	je     80ca50 <etharp_output+0xf4>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80ca2c:	8d 7b 0c             	lea    0xc(%ebx),%edi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80ca2f:	89 74 24 08          	mov    %esi,0x8(%esp)
  80ca33:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80ca37:	89 1c 24             	mov    %ebx,(%esp)
  80ca3a:	e8 08 fd ff ff       	call   80c747 <etharp_query>
  80ca3f:	eb 0f                	jmp    80ca50 <etharp_output+0xf4>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80ca41:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80ca44:	89 14 24             	mov    %edx,(%esp)
  80ca47:	89 f2                	mov    %esi,%edx
  80ca49:	89 d8                	mov    %ebx,%eax
  80ca4b:	e8 60 f8 ff ff       	call   80c2b0 <etharp_send_ip>
}
  80ca50:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ca53:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ca56:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ca59:	89 ec                	mov    %ebp,%esp
  80ca5b:	5d                   	pop    %ebp
  80ca5c:	c3                   	ret    

0080ca5d <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80ca5d:	55                   	push   %ebp
  80ca5e:	89 e5                	mov    %esp,%ebp
  80ca60:	53                   	push   %ebx
  80ca61:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  80ca64:	ba 02 00 00 00       	mov    $0x2,%edx
  80ca69:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ca6c:	e8 a2 fa ff ff       	call   80c513 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80ca71:	84 c0                	test   %al,%al
  80ca73:	78 29                	js     80ca9e <etharp_find_addr+0x41>
  80ca75:	0f be d0             	movsbl %al,%edx
  80ca78:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80ca7b:	83 b9 70 5a b3 00 02 	cmpl   $0x2,0xb35a70(%ecx)
  80ca82:	75 1a                	jne    80ca9e <etharp_find_addr+0x41>
      *eth_ret = &arp_table[i].ethaddr;
  80ca84:	89 ca                	mov    %ecx,%edx
  80ca86:	81 c2 60 5a b3 00    	add    $0xb35a60,%edx
  80ca8c:	8d 5a 08             	lea    0x8(%edx),%ebx
  80ca8f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80ca92:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  80ca94:	83 c2 04             	add    $0x4,%edx
  80ca97:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80ca9a:	89 11                	mov    %edx,(%ecx)
      return i;
  80ca9c:	eb 05                	jmp    80caa3 <etharp_find_addr+0x46>
  80ca9e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
  return -1;
}
  80caa3:	83 c4 04             	add    $0x4,%esp
  80caa6:	5b                   	pop    %ebx
  80caa7:	5d                   	pop    %ebp
  80caa8:	c3                   	ret    

0080caa9 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  80caa9:	55                   	push   %ebp
  80caaa:	89 e5                	mov    %esp,%ebp
  80caac:	57                   	push   %edi
  80caad:	56                   	push   %esi
  80caae:	53                   	push   %ebx
  80caaf:	83 ec 0c             	sub    $0xc,%esp
  80cab2:	bb 00 00 00 00       	mov    $0x0,%ebx
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80cab7:	be 74 5a b3 00       	mov    $0xb35a74,%esi
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80cabc:	bf 70 5a b3 00       	mov    $0xb35a70,%edi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80cac1:	0f b6 14 33          	movzbl (%ebx,%esi,1),%edx
  80cac5:	83 c2 01             	add    $0x1,%edx
  80cac8:	88 14 33             	mov    %dl,(%ebx,%esi,1)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80cacb:	8b 04 3b             	mov    (%ebx,%edi,1),%eax
  80cace:	83 f8 02             	cmp    $0x2,%eax
  80cad1:	75 07                	jne    80cada <etharp_tmr+0x31>
  80cad3:	80 fa ef             	cmp    $0xef,%dl
  80cad6:	77 12                	ja     80caea <etharp_tmr+0x41>
  80cad8:	eb 30                	jmp    80cb0a <etharp_tmr+0x61>
  80cada:	83 f8 01             	cmp    $0x1,%eax
  80cadd:	8d 76 00             	lea    0x0(%esi),%esi
  80cae0:	75 28                	jne    80cb0a <etharp_tmr+0x61>
  80cae2:	80 fa 01             	cmp    $0x1,%dl
  80cae5:	8d 76 00             	lea    0x0(%esi),%esi
  80cae8:	76 20                	jbe    80cb0a <etharp_tmr+0x61>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  80caea:	8b 83 60 5a b3 00    	mov    0xb35a60(%ebx),%eax
  80caf0:	85 c0                	test   %eax,%eax
  80caf2:	74 0f                	je     80cb03 <etharp_tmr+0x5a>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  80caf4:	e8 7d f9 ff ff       	call   80c476 <free_etharp_q>
        arp_table[i].q = NULL;
  80caf9:	c7 83 60 5a b3 00 00 	movl   $0x0,0xb35a60(%ebx)
  80cb00:	00 00 00 
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  80cb03:	c7 04 3b 00 00 00 00 	movl   $0x0,(%ebx,%edi,1)
  80cb0a:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80cb0d:	81 fb 18 01 00 00    	cmp    $0x118,%ebx
  80cb13:	75 ac                	jne    80cac1 <etharp_tmr+0x18>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  80cb15:	83 c4 0c             	add    $0xc,%esp
  80cb18:	5b                   	pop    %ebx
  80cb19:	5e                   	pop    %esi
  80cb1a:	5f                   	pop    %edi
  80cb1b:	5d                   	pop    %ebp
  80cb1c:	c3                   	ret    

0080cb1d <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80cb1d:	55                   	push   %ebp
  80cb1e:	89 e5                	mov    %esp,%ebp
  80cb20:	83 ec 38             	sub    $0x38,%esp
  80cb23:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80cb26:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80cb29:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80cb2c:	89 c6                	mov    %eax,%esi
  80cb2e:	89 d3                	mov    %edx,%ebx
  80cb30:	89 cf                	mov    %ecx,%edi
  80cb32:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
  80cb36:	88 45 e4             	mov    %al,-0x1c(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80cb39:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80cb3d:	74 1c                	je     80cb5b <update_arp_entry+0x3e>
  80cb3f:	c7 44 24 08 7c 3c 81 	movl   $0x813c7c,0x8(%esp)
  80cb46:	00 
  80cb47:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  80cb4e:	00 
  80cb4f:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80cb56:	e8 b9 3d ff ff       	call   800914 <_panic>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80cb5b:	85 d2                	test   %edx,%edx
  80cb5d:	0f 84 14 01 00 00    	je     80cc77 <update_arp_entry+0x15a>
  80cb63:	83 3a 00             	cmpl   $0x0,(%edx)
  80cb66:	0f 84 0b 01 00 00    	je     80cc77 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
  80cb6c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cb70:	89 14 24             	mov    %edx,(%esp)
  80cb73:	e8 00 c8 ff ff       	call   809378 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80cb78:	84 c0                	test   %al,%al
  80cb7a:	0f 85 f7 00 00 00    	jne    80cc77 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  80cb80:	8b 13                	mov    (%ebx),%edx
  80cb82:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80cb85:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80cb8c:	e8 34 de ff ff       	call   80a9c5 <ntohl>
  80cb91:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80cb94:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80cb9b:	e8 25 de ff ff       	call   80a9c5 <ntohl>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80cba0:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80cba3:	23 55 e0             	and    -0x20(%ebp),%edx
  80cba6:	39 c2                	cmp    %eax,%edx
  80cba8:	0f 84 c9 00 00 00    	je     80cc77 <update_arp_entry+0x15a>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80cbae:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
  80cbb2:	89 d8                	mov    %ebx,%eax
  80cbb4:	e8 5a f9 ff ff       	call   80c513 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  80cbb9:	84 c0                	test   %al,%al
  80cbbb:	0f 88 bb 00 00 00    	js     80cc7c <update_arp_entry+0x15f>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  80cbc1:	0f be c0             	movsbl %al,%eax
  80cbc4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80cbc7:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80cbca:	c7 80 70 5a b3 00 02 	movl   $0x2,0xb35a70(%eax)
  80cbd1:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80cbd4:	89 b0 78 5a b3 00    	mov    %esi,0xb35a78(%eax)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80cbda:	0f b6 5f 05          	movzbl 0x5(%edi),%ebx
  80cbde:	88 98 6d 5a b3 00    	mov    %bl,0xb35a6d(%eax)
  80cbe4:	6b 4d e0 07          	imul   $0x7,-0x20(%ebp),%ecx
  80cbe8:	bb 60 5a b3 00       	mov    $0xb35a60,%ebx
  80cbed:	0f b6 57 04          	movzbl 0x4(%edi),%edx
  80cbf1:	88 54 8b 0c          	mov    %dl,0xc(%ebx,%ecx,4)
  80cbf5:	0f b6 4f 03          	movzbl 0x3(%edi),%ecx
  80cbf9:	88 88 6b 5a b3 00    	mov    %cl,0xb35a6b(%eax)
  80cbff:	6b 4d e0 0e          	imul   $0xe,-0x20(%ebp),%ecx
  80cc03:	0f b6 57 02          	movzbl 0x2(%edi),%edx
  80cc07:	88 54 4b 0a          	mov    %dl,0xa(%ebx,%ecx,2)
  80cc0b:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
  80cc0f:	88 88 69 5a b3 00    	mov    %cl,0xb35a69(%eax)
  80cc15:	0f b6 0f             	movzbl (%edi),%ecx
  80cc18:	88 4c 18 08          	mov    %cl,0x8(%eax,%ebx,1)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  80cc1c:	c6 80 74 5a b3 00 00 	movb   $0x0,0xb35a74(%eax)
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80cc23:	8d 4e 25             	lea    0x25(%esi),%ecx
  80cc26:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80cc29:	6b 45 e0 1c          	imul   $0x1c,-0x20(%ebp),%eax
  80cc2d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80cc30:	eb 39                	jmp    80cc6b <update_arp_entry+0x14e>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  80cc32:	8b 10                	mov    (%eax),%edx
  80cc34:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80cc37:	89 14 19             	mov    %edx,(%ecx,%ebx,1)
    /* get the packet pointer */
    p = q->p;
  80cc3a:	8b 50 04             	mov    0x4(%eax),%edx
  80cc3d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  80cc40:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cc44:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80cc4b:	e8 b4 a5 ff ff       	call   807204 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80cc50:	89 3c 24             	mov    %edi,(%esp)
  80cc53:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80cc56:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cc59:	89 f0                	mov    %esi,%eax
  80cc5b:	e8 50 f6 ff ff       	call   80c2b0 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80cc60:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80cc63:	89 0c 24             	mov    %ecx,(%esp)
  80cc66:	e8 22 ad ff ff       	call   80798d <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80cc6b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80cc6e:	8b 04 1a             	mov    (%edx,%ebx,1),%eax
  80cc71:	85 c0                	test   %eax,%eax
  80cc73:	75 bd                	jne    80cc32 <update_arp_entry+0x115>
  80cc75:	eb 05                	jmp    80cc7c <update_arp_entry+0x15f>
  80cc77:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  80cc7c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80cc7f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80cc82:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80cc85:	89 ec                	mov    %ebp,%esp
  80cc87:	5d                   	pop    %ebp
  80cc88:	c3                   	ret    

0080cc89 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  80cc89:	55                   	push   %ebp
  80cc8a:	89 e5                	mov    %esp,%ebp
  80cc8c:	83 ec 18             	sub    $0x18,%esp
  80cc8f:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80cc92:	85 c0                	test   %eax,%eax
  80cc94:	75 1c                	jne    80ccb2 <etharp_ip_input+0x29>
  80cc96:	c7 44 24 08 3b 2f 81 	movl   $0x812f3b,0x8(%esp)
  80cc9d:	00 
  80cc9e:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  80cca5:	00 
  80cca6:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80ccad:	e8 62 3c ff ff       	call   800914 <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80ccb2:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ccb5:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80ccb8:	8b 48 04             	mov    0x4(%eax),%ecx
  80ccbb:	33 4a 1c             	xor    0x1c(%edx),%ecx
  80ccbe:	85 48 08             	test   %ecx,0x8(%eax)
  80ccc1:	75 12                	jne    80ccd5 <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80ccc3:	8d 4a 06             	lea    0x6(%edx),%ecx
  80ccc6:	83 c2 1c             	add    $0x1c,%edx
  80ccc9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ccd0:	e8 48 fe ff ff       	call   80cb1d <update_arp_entry>
}
  80ccd5:	c9                   	leave  
  80ccd6:	c3                   	ret    

0080ccd7 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80ccd7:	55                   	push   %ebp
  80ccd8:	89 e5                	mov    %esp,%ebp
  80ccda:	83 ec 38             	sub    $0x38,%esp
  80ccdd:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80cce0:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80cce3:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80cce6:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80cce9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80cced:	75 1c                	jne    80cd0b <etharp_arp_input+0x34>
  80ccef:	c7 44 24 08 3b 2f 81 	movl   $0x812f3b,0x8(%esp)
  80ccf6:	00 
  80ccf7:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80ccfe:	00 
  80ccff:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80cd06:	e8 09 3c ff ff       	call   800914 <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  80cd0b:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  80cd10:	77 0d                	ja     80cd1f <etharp_arp_input+0x48>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80cd12:	89 1c 24             	mov    %ebx,(%esp)
  80cd15:	e8 73 ac ff ff       	call   80798d <pbuf_free>
    return;
  80cd1a:	e9 ab 01 00 00       	jmp    80ceca <etharp_arp_input+0x1f3>
  }

  hdr = p->payload;
  80cd1f:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80cd22:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  80cd26:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80cd2d:	e8 51 da ff ff       	call   80a783 <htons>
  80cd32:	66 39 c7             	cmp    %ax,%di
  80cd35:	75 3f                	jne    80cd76 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80cd37:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  80cd3b:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80cd42:	e8 3c da ff ff       	call   80a783 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80cd47:	66 39 c7             	cmp    %ax,%di
  80cd4a:	75 2a                	jne    80cd76 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80cd4c:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  80cd50:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80cd57:	e8 27 da ff ff       	call   80a783 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80cd5c:	66 39 c7             	cmp    %ax,%di
  80cd5f:	75 15                	jne    80cd76 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80cd61:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  80cd65:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80cd6c:	e8 12 da ff ff       	call   80a783 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80cd71:	66 39 c7             	cmp    %ax,%di
  80cd74:	74 0f                	je     80cd85 <etharp_arp_input+0xae>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80cd76:	89 1c 24             	mov    %ebx,(%esp)
  80cd79:	e8 0f ac ff ff       	call   80798d <pbuf_free>
    return;
  80cd7e:	66 90                	xchg   %ax,%ax
  80cd80:	e9 45 01 00 00       	jmp    80ceca <etharp_arp_input+0x1f3>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80cd85:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80cd8c:	00 
  80cd8d:	8d 46 1c             	lea    0x1c(%esi),%eax
  80cd90:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cd94:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80cd97:	89 04 24             	mov    %eax,(%esp)
  80cd9a:	e8 d2 45 ff ff       	call   801371 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80cd9f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80cda6:	00 
  80cda7:	8d 46 26             	lea    0x26(%esi),%eax
  80cdaa:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cdae:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80cdb1:	89 04 24             	mov    %eax,(%esp)
  80cdb4:	e8 b8 45 ff ff       	call   801371 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80cdb9:	8b 55 08             	mov    0x8(%ebp),%edx
  80cdbc:	8b 42 04             	mov    0x4(%edx),%eax

  /* ARP message directed to us? */
  if (for_us) {
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80cdbf:	bf 00 00 00 00       	mov    $0x0,%edi
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80cdc4:	85 c0                	test   %eax,%eax
  80cdc6:	74 21                	je     80cde9 <etharp_arp_input+0x112>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  80cdc8:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  80cdcb:	0f 94 c0             	sete   %al
  80cdce:	89 c7                	mov    %eax,%edi
  80cdd0:	75 17                	jne    80cde9 <etharp_arp_input+0x112>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80cdd2:	8d 4e 16             	lea    0x16(%esi),%ecx
  80cdd5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80cdd8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80cddf:	8b 45 08             	mov    0x8(%ebp),%eax
  80cde2:	e8 36 fd ff ff       	call   80cb1d <update_arp_entry>
  80cde7:	eb 15                	jmp    80cdfe <etharp_arp_input+0x127>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80cde9:	8d 4e 16             	lea    0x16(%esi),%ecx
  80cdec:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80cdef:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80cdf6:	8b 45 08             	mov    0x8(%ebp),%eax
  80cdf9:	e8 1f fd ff ff       	call   80cb1d <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80cdfe:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  80ce02:	89 04 24             	mov    %eax,(%esp)
  80ce05:	e8 79 d9 ff ff       	call   80a783 <htons>
  80ce0a:	66 83 f8 01          	cmp    $0x1,%ax
  80ce0e:	74 15                	je     80ce25 <etharp_arp_input+0x14e>
  80ce10:	66 83 f8 02          	cmp    $0x2,%ax
  80ce14:	0f 85 a8 00 00 00    	jne    80cec2 <etharp_arp_input+0x1eb>
  80ce1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80ce20:	e9 8b 00 00 00       	jmp    80ceb0 <etharp_arp_input+0x1d9>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  80ce25:	89 fa                	mov    %edi,%edx
  80ce27:	84 d2                	test   %dl,%dl
  80ce29:	0f 84 93 00 00 00    	je     80cec2 <etharp_arp_input+0x1eb>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  80ce2f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80ce36:	e8 48 d9 ff ff       	call   80a783 <htons>
  80ce3b:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  80ce3f:	8b 46 1c             	mov    0x1c(%esi),%eax
  80ce42:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80ce45:	8b 55 08             	mov    0x8(%ebp),%edx
  80ce48:	8b 42 04             	mov    0x4(%edx),%eax
  80ce4b:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80ce4e:	ba 06 00 00 00       	mov    $0x6,%edx
  80ce53:	8b 45 08             	mov    0x8(%ebp),%eax
  80ce56:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80ce5a:	74 1c                	je     80ce78 <etharp_arp_input+0x1a1>
  80ce5c:	c7 44 24 08 dc 3b 81 	movl   $0x813bdc,0x8(%esp)
  80ce63:	00 
  80ce64:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  80ce6b:	00 
  80ce6c:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80ce73:	e8 9c 3a ff ff       	call   800914 <_panic>
  80ce78:	8b 7d 0c             	mov    0xc(%ebp),%edi
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  80ce7b:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80ce7e:	0f b6 c2             	movzbl %dl,%eax
  80ce81:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  80ce86:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80ce8a:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80ce8d:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80ce91:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  80ce95:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80ce99:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  80ce9d:	84 d2                	test   %dl,%dl
  80ce9f:	75 da                	jne    80ce7b <etharp_arp_input+0x1a4>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  80cea1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80cea5:	8b 55 08             	mov    0x8(%ebp),%edx
  80cea8:	89 14 24             	mov    %edx,(%esp)
  80ceab:	ff 52 18             	call   *0x18(%edx)
  80ceae:	eb 12                	jmp    80cec2 <etharp_arp_input+0x1eb>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  80ceb0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ceb3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ceb7:	8b 45 08             	mov    0x8(%ebp),%eax
  80ceba:	89 04 24             	mov    %eax,(%esp)
  80cebd:	e8 75 90 ff ff       	call   805f37 <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  80cec2:	89 1c 24             	mov    %ebx,(%esp)
  80cec5:	e8 c3 aa ff ff       	call   80798d <pbuf_free>
}
  80ceca:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80cecd:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ced0:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ced3:	89 ec                	mov    %ebp,%esp
  80ced5:	5d                   	pop    %ebp
  80ced6:	c3                   	ret    

0080ced7 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80ced7:	55                   	push   %ebp
  80ced8:	89 e5                	mov    %esp,%ebp
  80ceda:	83 ec 18             	sub    $0x18,%esp
  80cedd:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80cee0:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80cee3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80cee6:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80cee9:	8b 43 04             	mov    0x4(%ebx),%eax
  80ceec:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cef0:	89 04 24             	mov    %eax,(%esp)
  80cef3:	e8 8b d8 ff ff       	call   80a783 <htons>
  80cef8:	66 3d 00 08          	cmp    $0x800,%ax
  80cefc:	74 0c                	je     80cf0a <ethernet_input+0x33>
  80cefe:	66 3d 06 08          	cmp    $0x806,%ax
  80cf02:	75 65                	jne    80cf69 <ethernet_input+0x92>
  80cf04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80cf08:	eb 4a                	jmp    80cf54 <ethernet_input+0x7d>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80cf0a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80cf0e:	89 34 24             	mov    %esi,(%esp)
  80cf11:	e8 73 fd ff ff       	call   80cc89 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80cf16:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80cf1d:	ff 
  80cf1e:	89 1c 24             	mov    %ebx,(%esp)
  80cf21:	e8 fd a6 ff ff       	call   807623 <pbuf_header>
  80cf26:	84 c0                	test   %al,%al
  80cf28:	74 1c                	je     80cf46 <ethernet_input+0x6f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80cf2a:	c7 44 24 08 a4 3c 81 	movl   $0x813ca4,0x8(%esp)
  80cf31:	00 
  80cf32:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80cf39:	00 
  80cf3a:	c7 04 24 c5 3c 81 00 	movl   $0x813cc5,(%esp)
  80cf41:	e8 ce 39 ff ff       	call   800914 <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80cf46:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cf4a:	89 1c 24             	mov    %ebx,(%esp)
  80cf4d:	e8 f2 c6 ff ff       	call   809644 <ip_input>
      }
      break;
  80cf52:	eb 1d                	jmp    80cf71 <ethernet_input+0x9a>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80cf54:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80cf58:	8d 46 25             	lea    0x25(%esi),%eax
  80cf5b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cf5f:	89 34 24             	mov    %esi,(%esp)
  80cf62:	e8 70 fd ff ff       	call   80ccd7 <etharp_arp_input>
      break;
  80cf67:	eb 08                	jmp    80cf71 <ethernet_input+0x9a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80cf69:	89 1c 24             	mov    %ebx,(%esp)
  80cf6c:	e8 1c aa ff ff       	call   80798d <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80cf71:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf76:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80cf79:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80cf7c:	89 ec                	mov    %ebp,%esp
  80cf7e:	5d                   	pop    %ebp
  80cf7f:	c3                   	ret    

0080cf80 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80cf80:	55                   	push   %ebp
  80cf81:	89 e5                	mov    %esp,%ebp
  80cf83:	56                   	push   %esi
  80cf84:	53                   	push   %ebx
  80cf85:	b8 80 5b b3 00       	mov    $0xb35b80,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80cf8a:	be 80 6f b3 00       	mov    $0xb36f80,%esi
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80cf8f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80cf95:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80cf97:	8b 15 80 6f b3 00    	mov    0xb36f80,%edx
  80cf9d:	89 50 0c             	mov    %edx,0xc(%eax)
  80cfa0:	85 d2                	test   %edx,%edx
  80cfa2:	74 06                	je     80cfaa <sys_init+0x2a>
  80cfa4:	8d 58 0c             	lea    0xc(%eax),%ebx
  80cfa7:	89 5a 10             	mov    %ebx,0x10(%edx)
  80cfaa:	89 0d 80 6f b3 00    	mov    %ecx,0xb36f80
  80cfb0:	c7 40 10 80 6f b3 00 	movl   $0xb36f80,0x10(%eax)
  80cfb7:	83 c0 14             	add    $0x14,%eax

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80cfba:	39 f0                	cmp    %esi,%eax
  80cfbc:	75 d1                	jne    80cf8f <sys_init+0xf>
  80cfbe:	b8 a0 6f b3 00       	mov    $0xb36fa0,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80cfc3:	be a0 bd b3 00       	mov    $0xb3bda0,%esi
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80cfc8:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80cfce:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80cfd0:	8b 15 a0 bd b3 00    	mov    0xb3bda0,%edx
  80cfd6:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80cfdc:	85 d2                	test   %edx,%edx
  80cfde:	74 0c                	je     80cfec <sys_init+0x6c>
  80cfe0:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  80cfe6:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  80cfec:	89 0d a0 bd b3 00    	mov    %ecx,0xb3bda0
  80cff2:	c7 80 98 00 00 00 a0 	movl   $0xb3bda0,0x98(%eax)
  80cff9:	bd b3 00 
  80cffc:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80d001:	39 f0                	cmp    %esi,%eax
  80d003:	75 c3                	jne    80cfc8 <sys_init+0x48>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  80d005:	5b                   	pop    %ebx
  80d006:	5e                   	pop    %esi
  80d007:	5d                   	pop    %ebp
  80d008:	c3                   	ret    

0080d009 <lwip_core_lock>:
    return &t->tmo;
}

void
lwip_core_lock(void)
{
  80d009:	55                   	push   %ebp
  80d00a:	89 e5                	mov    %esp,%ebp
}
  80d00c:	5d                   	pop    %ebp
  80d00d:	c3                   	ret    

0080d00e <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80d00e:	55                   	push   %ebp
  80d00f:	89 e5                	mov    %esp,%ebp
}
  80d011:	5d                   	pop    %ebp
  80d012:	c3                   	ret    

0080d013 <sys_sem_free>:
    return se - &sems[0];
}

void
sys_sem_free(sys_sem_t sem)
{
  80d013:	55                   	push   %ebp
  80d014:	89 e5                	mov    %esp,%ebp
  80d016:	56                   	push   %esi
  80d017:	53                   	push   %ebx
  80d018:	83 ec 10             	sub    $0x10,%esp
  80d01b:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80d01e:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80d021:	83 3c 95 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%edx,4)
  80d028:	00 
  80d029:	74 24                	je     80d04f <sys_sem_free+0x3c>
  80d02b:	c7 44 24 0c 47 3d 81 	movl   $0x813d47,0xc(%esp)
  80d032:	00 
  80d033:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d03a:	00 
  80d03b:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80d042:	00 
  80d043:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d04a:	e8 c5 38 ff ff       	call   800914 <_panic>
    sems[sem].freed = 1;
  80d04f:	b9 80 5b b3 00       	mov    $0xb35b80,%ecx
  80d054:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80d05b:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
  80d05e:	c7 04 99 01 00 00 00 	movl   $0x1,(%ecx,%ebx,4)
    sems[sem].gen++;
  80d065:	c1 e3 02             	shl    $0x2,%ebx
  80d068:	8b 74 0b 04          	mov    0x4(%ebx,%ecx,1),%esi
  80d06c:	83 c6 01             	add    $0x1,%esi
  80d06f:	89 74 0b 04          	mov    %esi,0x4(%ebx,%ecx,1)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80d073:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80d076:	8d 04 85 80 5b b3 00 	lea    0xb35b80(,%eax,4),%eax
  80d07d:	8b 15 80 6f b3 00    	mov    0xb36f80,%edx
  80d083:	89 50 0c             	mov    %edx,0xc(%eax)
  80d086:	85 d2                	test   %edx,%edx
  80d088:	74 06                	je     80d090 <sys_sem_free+0x7d>
  80d08a:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d08d:	89 4a 10             	mov    %ecx,0x10(%edx)
  80d090:	a3 80 6f b3 00       	mov    %eax,0xb36f80
  80d095:	c7 40 10 80 6f b3 00 	movl   $0xb36f80,0x10(%eax)
}
  80d09c:	83 c4 10             	add    $0x10,%esp
  80d09f:	5b                   	pop    %ebx
  80d0a0:	5e                   	pop    %esi
  80d0a1:	5d                   	pop    %ebp
  80d0a2:	c3                   	ret    

0080d0a3 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80d0a3:	55                   	push   %ebp
  80d0a4:	89 e5                	mov    %esp,%ebp
  80d0a6:	56                   	push   %esi
  80d0a7:	53                   	push   %ebx
  80d0a8:	83 ec 10             	sub    $0x10,%esp
  80d0ab:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80d0ae:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d0b4:	83 b8 a0 6f b3 00 00 	cmpl   $0x0,0xb36fa0(%eax)
  80d0bb:	74 24                	je     80d0e1 <sys_mbox_free+0x3e>
  80d0bd:	c7 44 24 0c 75 3d 81 	movl   $0x813d75,0xc(%esp)
  80d0c4:	00 
  80d0c5:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d0cc:	00 
  80d0cd:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  80d0d4:	00 
  80d0d5:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d0dc:	e8 33 38 ff ff       	call   800914 <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80d0e1:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80d0e7:	8b 83 2c 70 b3 00    	mov    0xb3702c(%ebx),%eax
  80d0ed:	89 04 24             	mov    %eax,(%esp)
  80d0f0:	e8 1e ff ff ff       	call   80d013 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80d0f5:	8b 83 30 70 b3 00    	mov    0xb37030(%ebx),%eax
  80d0fb:	89 04 24             	mov    %eax,(%esp)
  80d0fe:	e8 10 ff ff ff       	call   80d013 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80d103:	81 c3 a0 6f b3 00    	add    $0xb36fa0,%ebx
  80d109:	a1 a0 bd b3 00       	mov    0xb3bda0,%eax
  80d10e:	89 83 94 00 00 00    	mov    %eax,0x94(%ebx)
  80d114:	85 c0                	test   %eax,%eax
  80d116:	74 0c                	je     80d124 <sys_mbox_free+0x81>
  80d118:	8d 93 94 00 00 00    	lea    0x94(%ebx),%edx
  80d11e:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80d124:	89 1d a0 bd b3 00    	mov    %ebx,0xb3bda0
  80d12a:	c7 83 98 00 00 00 a0 	movl   $0xb3bda0,0x98(%ebx)
  80d131:	bd b3 00 
    mboxes[mbox].freed = 1;
  80d134:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80d13a:	c7 86 a0 6f b3 00 01 	movl   $0x1,0xb36fa0(%esi)
  80d141:	00 00 00 
}
  80d144:	83 c4 10             	add    $0x10,%esp
  80d147:	5b                   	pop    %ebx
  80d148:	5e                   	pop    %esi
  80d149:	5d                   	pop    %ebp
  80d14a:	c3                   	ret    

0080d14b <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80d14b:	55                   	push   %ebp
  80d14c:	89 e5                	mov    %esp,%ebp
  80d14e:	57                   	push   %edi
  80d14f:	56                   	push   %esi
  80d150:	53                   	push   %ebx
  80d151:	83 ec 1c             	sub    $0x1c,%esp
    thread_id_t tid = thread_id();
  80d154:	e8 0a 08 00 00       	call   80d963 <thread_id>
  80d159:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d15b:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d160:	f7 e2                	mul    %edx
  80d162:	c1 ea 08             	shr    $0x8,%edx
  80d165:	89 d0                	mov    %edx,%eax
  80d167:	c1 e0 08             	shl    $0x8,%eax
  80d16a:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80d16d:	89 f0                	mov    %esi,%eax
  80d16f:	29 d0                	sub    %edx,%eax
  80d171:	8d 3c 85 c0 bd b3 00 	lea    0xb3bdc0(,%eax,4),%edi
  80d178:	8b 1f                	mov    (%edi),%ebx
  80d17a:	85 db                	test   %ebx,%ebx
  80d17c:	74 24                	je     80d1a2 <sys_arch_timeouts+0x57>
	if (t->tid == tid)
  80d17e:	3b 33                	cmp    (%ebx),%esi
  80d180:	75 14                	jne    80d196 <sys_arch_timeouts+0x4b>
  80d182:	e9 b4 00 00 00       	jmp    80d23b <sys_arch_timeouts+0xf0>
  80d187:	3b 33                	cmp    (%ebx),%esi
  80d189:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80d190:	0f 84 a5 00 00 00    	je     80d23b <sys_arch_timeouts+0xf0>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d196:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80d199:	85 db                	test   %ebx,%ebx
  80d19b:	90                   	nop
  80d19c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80d1a0:	75 e5                	jne    80d187 <sys_arch_timeouts+0x3c>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80d1a2:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80d1a9:	e8 c5 5b ff ff       	call   802d73 <malloc>
  80d1ae:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80d1b0:	85 c0                	test   %eax,%eax
  80d1b2:	75 1c                	jne    80d1d0 <sys_arch_timeouts+0x85>
	panic("sys_arch_timeouts: cannot malloc");
  80d1b4:	c7 44 24 08 d8 3d 81 	movl   $0x813dd8,0x8(%esp)
  80d1bb:	00 
  80d1bc:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  80d1c3:	00 
  80d1c4:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d1cb:	e8 44 37 ff ff       	call   800914 <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80d1d0:	c7 04 24 46 d2 80 00 	movl   $0x80d246,(%esp)
  80d1d7:	e8 da 07 00 00       	call   80d9b6 <thread_onhalt>
    if (r < 0)
  80d1dc:	85 c0                	test   %eax,%eax
  80d1de:	79 28                	jns    80d208 <sys_arch_timeouts+0xbd>
	panic("thread_onhalt failed: %s", e2s(r));
  80d1e0:	89 04 24             	mov    %eax,(%esp)
  80d1e3:	e8 40 0b 00 00       	call   80dd28 <e2s>
  80d1e8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d1ec:	c7 44 24 08 89 3d 81 	movl   $0x813d89,0x8(%esp)
  80d1f3:	00 
  80d1f4:	c7 44 24 04 31 01 00 	movl   $0x131,0x4(%esp)
  80d1fb:	00 
  80d1fc:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d203:	e8 0c 37 ff ff       	call   800914 <_panic>

    t->tid = tid;
  80d208:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80d20a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d211:	00 
  80d212:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80d219:	00 
  80d21a:	8d 43 04             	lea    0x4(%ebx),%eax
  80d21d:	89 04 24             	mov    %eax,(%esp)
  80d220:	e8 71 40 ff ff       	call   801296 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80d225:	8b 07                	mov    (%edi),%eax
  80d227:	89 43 08             	mov    %eax,0x8(%ebx)
  80d22a:	85 c0                	test   %eax,%eax
  80d22c:	74 08                	je     80d236 <sys_arch_timeouts+0xeb>
  80d22e:	8b 07                	mov    (%edi),%eax
  80d230:	8d 53 08             	lea    0x8(%ebx),%edx
  80d233:	89 50 0c             	mov    %edx,0xc(%eax)
  80d236:	89 1f                	mov    %ebx,(%edi)
  80d238:	89 7b 0c             	mov    %edi,0xc(%ebx)
  80d23b:	8d 43 04             	lea    0x4(%ebx),%eax

out:
    return &t->tmo;
}
  80d23e:	83 c4 1c             	add    $0x1c,%esp
  80d241:	5b                   	pop    %ebx
  80d242:	5e                   	pop    %esi
  80d243:	5f                   	pop    %edi
  80d244:	5d                   	pop    %ebp
  80d245:	c3                   	ret    

0080d246 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80d246:	55                   	push   %ebp
  80d247:	89 e5                	mov    %esp,%ebp
  80d249:	83 ec 18             	sub    $0x18,%esp
  80d24c:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d24f:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d254:	89 c8                	mov    %ecx,%eax
  80d256:	f7 e2                	mul    %edx
  80d258:	c1 ea 08             	shr    $0x8,%edx
  80d25b:	89 d0                	mov    %edx,%eax
  80d25d:	c1 e0 08             	shl    $0x8,%eax
  80d260:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80d263:	89 c8                	mov    %ecx,%eax
  80d265:	29 d0                	sub    %edx,%eax
  80d267:	8b 04 85 c0 bd b3 00 	mov    0xb3bdc0(,%eax,4),%eax
  80d26e:	85 c0                	test   %eax,%eax
  80d270:	74 36                	je     80d2a8 <timeout_cleanup+0x62>
	if (t->tid == tid) {
  80d272:	39 08                	cmp    %ecx,(%eax)
  80d274:	75 2b                	jne    80d2a1 <timeout_cleanup+0x5b>
  80d276:	eb 0a                	jmp    80d282 <timeout_cleanup+0x3c>
  80d278:	39 08                	cmp    %ecx,(%eax)
  80d27a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80d280:	75 1f                	jne    80d2a1 <timeout_cleanup+0x5b>
	    LIST_REMOVE(t, link);
  80d282:	8b 50 08             	mov    0x8(%eax),%edx
  80d285:	85 d2                	test   %edx,%edx
  80d287:	74 06                	je     80d28f <timeout_cleanup+0x49>
  80d289:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d28c:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80d28f:	8b 50 0c             	mov    0xc(%eax),%edx
  80d292:	8b 48 08             	mov    0x8(%eax),%ecx
  80d295:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  80d297:	89 04 24             	mov    %eax,(%esp)
  80d29a:	e8 01 5a ff ff       	call   802ca0 <free>
	    goto done;
  80d29f:	eb 07                	jmp    80d2a8 <timeout_cleanup+0x62>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d2a1:	8b 40 08             	mov    0x8(%eax),%eax
  80d2a4:	85 c0                	test   %eax,%eax
  80d2a6:	75 d0                	jne    80d278 <timeout_cleanup+0x32>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80d2a8:	c9                   	leave  
  80d2a9:	c3                   	ret    

0080d2aa <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80d2aa:	55                   	push   %ebp
  80d2ab:	89 e5                	mov    %esp,%ebp
  80d2ad:	53                   	push   %ebx
  80d2ae:	83 ec 14             	sub    $0x14,%esp
  80d2b1:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80d2b4:	8b 43 04             	mov    0x4(%ebx),%eax
  80d2b7:	89 04 24             	mov    %eax,(%esp)
  80d2ba:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80d2bc:	89 1c 24             	mov    %ebx,(%esp)
  80d2bf:	e8 dc 59 ff ff       	call   802ca0 <free>
}
  80d2c4:	83 c4 14             	add    $0x14,%esp
  80d2c7:	5b                   	pop    %ebx
  80d2c8:	5d                   	pop    %ebp
  80d2c9:	c3                   	ret    

0080d2ca <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80d2ca:	55                   	push   %ebp
  80d2cb:	89 e5                	mov    %esp,%ebp
  80d2cd:	53                   	push   %ebx
  80d2ce:	83 ec 24             	sub    $0x24,%esp
  80d2d1:	8b 5d 14             	mov    0x14(%ebp),%ebx
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80d2d4:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80d2db:	e8 93 5a ff ff       	call   802d73 <malloc>
    if (lt == 0)
  80d2e0:	85 c0                	test   %eax,%eax
  80d2e2:	75 1c                	jne    80d300 <sys_thread_new+0x36>
	panic("sys_thread_new: cannot allocate thread struct");
  80d2e4:	c7 44 24 08 fc 3d 81 	movl   $0x813dfc,0x8(%esp)
  80d2eb:	00 
  80d2ec:	c7 44 24 04 fe 00 00 	movl   $0xfe,0x4(%esp)
  80d2f3:	00 
  80d2f4:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d2fb:	e8 14 36 ff ff       	call   800914 <_panic>

    if (stacksize > PGSIZE)
  80d300:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  80d306:	7e 20                	jle    80d328 <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80d308:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80d30c:	c7 44 24 08 a2 3d 81 	movl   $0x813da2,0x8(%esp)
  80d313:	00 
  80d314:	c7 44 24 04 01 01 00 	movl   $0x101,0x4(%esp)
  80d31b:	00 
  80d31c:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d323:	e8 ec 35 ff ff       	call   800914 <_panic>

    lt->func = thread;
  80d328:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d32b:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80d32d:	8b 55 10             	mov    0x10(%ebp),%edx
  80d330:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80d333:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d337:	c7 44 24 08 aa d2 80 	movl   $0x80d2aa,0x8(%esp)
  80d33e:	00 
  80d33f:	8b 45 08             	mov    0x8(%ebp),%eax
  80d342:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d346:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80d349:	89 04 24             	mov    %eax,(%esp)
  80d34c:	e8 d6 07 00 00       	call   80db27 <thread_create>

    if (r < 0)
  80d351:	85 c0                	test   %eax,%eax
  80d353:	79 28                	jns    80d37d <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80d355:	89 04 24             	mov    %eax,(%esp)
  80d358:	e8 cb 09 00 00       	call   80dd28 <e2s>
  80d35d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d361:	c7 44 24 08 2c 3e 81 	movl   $0x813e2c,0x8(%esp)
  80d368:	00 
  80d369:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80d370:	00 
  80d371:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d378:	e8 97 35 ff ff       	call   800914 <_panic>

    return tid;
}
  80d37d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80d380:	83 c4 24             	add    $0x24,%esp
  80d383:	5b                   	pop    %ebx
  80d384:	5d                   	pop    %ebp
  80d385:	c3                   	ret    

0080d386 <sys_arch_sem_wait>:
    }
}

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80d386:	55                   	push   %ebp
  80d387:	89 e5                	mov    %esp,%ebp
  80d389:	57                   	push   %edi
  80d38a:	56                   	push   %esi
  80d38b:	53                   	push   %ebx
  80d38c:	83 ec 3c             	sub    $0x3c,%esp
    assert(!sems[sem].freed);
  80d38f:	8b 55 08             	mov    0x8(%ebp),%edx
  80d392:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d395:	83 3c 85 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%eax,4)
  80d39c:	00 
  80d39d:	74 24                	je     80d3c3 <sys_arch_sem_wait+0x3d>
  80d39f:	c7 44 24 0c 47 3d 81 	movl   $0x813d47,0xc(%esp)
  80d3a6:	00 
  80d3a7:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d3ae:	00 
  80d3af:	c7 44 24 04 ad 00 00 	movl   $0xad,0x4(%esp)
  80d3b6:	00 
  80d3b7:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d3be:	e8 51 35 ff ff       	call   800914 <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80d3c3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d3c6:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80d3c9:	8b 04 85 84 5b b3 00 	mov    0xb35b84(,%eax,4),%eax
  80d3d0:	89 45 dc             	mov    %eax,-0x24(%ebp)

    while (tm_msec == 0 || waited < tm_msec) {
  80d3d3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80d3d7:	0f 94 45 d7          	sete   -0x29(%ebp)
  80d3db:	0f 95 45 e3          	setne  -0x1d(%ebp)
  80d3df:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80d3e3:	75 0a                	jne    80d3ef <sys_arch_sem_wait+0x69>
  80d3e5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80d3e9:	0f 84 d7 00 00 00    	je     80d4c6 <sys_arch_sem_wait+0x140>
	if (sems[sem].counter > 0) {
  80d3ef:	8b 55 08             	mov    0x8(%ebp),%edx
  80d3f2:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d3f5:	0f b7 04 85 88 5b b3 	movzwl 0xb35b88(,%eax,4),%eax
  80d3fc:	00 
  80d3fd:	bf 00 00 00 00       	mov    $0x0,%edi
  80d402:	66 85 c0             	test   %ax,%ax
  80d405:	75 17                	jne    80d41e <sys_arch_sem_wait+0x98>
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80d407:	83 7d 0c fe          	cmpl   $0xfffffffe,0xc(%ebp)
  80d40b:	75 27                	jne    80d434 <sys_arch_sem_wait+0xae>
  80d40d:	e9 b4 00 00 00       	jmp    80d4c6 <sys_arch_sem_wait+0x140>
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80d412:	0f b7 83 88 5b b3 00 	movzwl 0xb35b88(%ebx),%eax
  80d419:	66 85 c0             	test   %ax,%ax
  80d41c:	74 31                	je     80d44f <sys_arch_sem_wait+0xc9>
	    sems[sem].counter--;
  80d41e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d421:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80d424:	83 e8 01             	sub    $0x1,%eax
  80d427:	66 89 04 95 88 5b b3 	mov    %ax,0xb35b88(,%edx,4)
  80d42e:	00 
	    return waited;
  80d42f:	e9 97 00 00 00       	jmp    80d4cb <sys_arch_sem_wait+0x145>
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80d434:	8b 55 08             	mov    0x8(%ebp),%edx
  80d437:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d43a:	8d 04 85 88 5b b3 00 	lea    0xb35b88(,%eax,4),%eax
  80d441:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80d444:	bf 00 00 00 00       	mov    $0x0,%edi
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
  80d449:	8d 1c 92             	lea    (%edx,%edx,4),%ebx
  80d44c:	c1 e3 02             	shl    $0x2,%ebx
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80d44f:	e8 56 41 ff ff       	call   8015aa <sys_time_msec>
  80d454:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80d457:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80d45c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80d460:	74 08                	je     80d46a <sys_arch_sem_wait+0xe4>
  80d462:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d465:	03 45 0c             	add    0xc(%ebp),%eax
  80d468:	29 f8                	sub    %edi,%eax
	    sems[sem].waiters = 1;
  80d46a:	be 80 5b b3 00       	mov    $0xb35b80,%esi
  80d46f:	66 c7 44 33 0a 01 00 	movw   $0x1,0xa(%ebx,%esi,1)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80d476:	89 44 24 08          	mov    %eax,0x8(%esp)
  80d47a:	8b 44 33 08          	mov    0x8(%ebx,%esi,1),%eax
  80d47e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d482:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80d485:	89 0c 24             	mov    %ecx,(%esp)
  80d488:	e8 e2 07 00 00       	call   80dc6f <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80d48d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80d490:	39 44 33 04          	cmp    %eax,0x4(%ebx,%esi,1)
  80d494:	74 13                	je     80d4a9 <sys_arch_sem_wait+0x123>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80d496:	c7 04 24 58 3e 81 00 	movl   $0x813e58,(%esp)
  80d49d:	e8 2b 35 ff ff       	call   8009cd <cprintf>
  80d4a2:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		return SYS_ARCH_TIMEOUT;
  80d4a7:	eb 22                	jmp    80d4cb <sys_arch_sem_wait+0x145>
	    }
	    uint32_t b = sys_time_msec();
  80d4a9:	e8 fc 40 ff ff       	call   8015aa <sys_time_msec>
	    waited += (b - a);
  80d4ae:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80d4b1:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80d4b3:	39 7d 0c             	cmp    %edi,0xc(%ebp)
  80d4b6:	0f 87 56 ff ff ff    	ja     80d412 <sys_arch_sem_wait+0x8c>
  80d4bc:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80d4c0:	0f 85 4c ff ff ff    	jne    80d412 <sys_arch_sem_wait+0x8c>
  80d4c6:	bf ff ff ff ff       	mov    $0xffffffff,%edi
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80d4cb:	89 f8                	mov    %edi,%eax
  80d4cd:	83 c4 3c             	add    $0x3c,%esp
  80d4d0:	5b                   	pop    %ebx
  80d4d1:	5e                   	pop    %esi
  80d4d2:	5f                   	pop    %edi
  80d4d3:	5d                   	pop    %ebp
  80d4d4:	c3                   	ret    

0080d4d5 <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80d4d5:	55                   	push   %ebp
  80d4d6:	89 e5                	mov    %esp,%ebp
  80d4d8:	53                   	push   %ebx
  80d4d9:	83 ec 14             	sub    $0x14,%esp
  80d4dc:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80d4e0:	a1 80 6f b3 00       	mov    0xb36f80,%eax
    if (!se) {
  80d4e5:	85 c0                	test   %eax,%eax
  80d4e7:	75 13                	jne    80d4fc <sys_sem_new+0x27>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80d4e9:	c7 04 24 84 3e 81 00 	movl   $0x813e84,(%esp)
  80d4f0:	e8 d8 34 ff ff       	call   8009cd <cprintf>
  80d4f5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return SYS_SEM_NULL;
  80d4fa:	eb 5d                	jmp    80d559 <sys_sem_new+0x84>
    }
    LIST_REMOVE(se, link);
  80d4fc:	8b 50 0c             	mov    0xc(%eax),%edx
  80d4ff:	85 d2                	test   %edx,%edx
  80d501:	74 06                	je     80d509 <sys_sem_new+0x34>
  80d503:	8b 58 10             	mov    0x10(%eax),%ebx
  80d506:	89 5a 10             	mov    %ebx,0x10(%edx)
  80d509:	8b 50 10             	mov    0x10(%eax),%edx
  80d50c:	8b 58 0c             	mov    0xc(%eax),%ebx
  80d50f:	89 1a                	mov    %ebx,(%edx)
    assert(se->freed);
  80d511:	83 38 00             	cmpl   $0x0,(%eax)
  80d514:	75 24                	jne    80d53a <sys_sem_new+0x65>
  80d516:	c7 44 24 0c b1 3d 81 	movl   $0x813db1,0xc(%esp)
  80d51d:	00 
  80d51e:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d525:	00 
  80d526:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80d52d:	00 
  80d52e:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d535:	e8 da 33 ff ff       	call   800914 <_panic>
    se->freed = 0;
  80d53a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80d540:	0f b6 c9             	movzbl %cl,%ecx
  80d543:	66 89 48 08          	mov    %cx,0x8(%eax)
    se->gen++;
  80d547:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80d54b:	2d 80 5b b3 00       	sub    $0xb35b80,%eax
  80d550:	c1 f8 02             	sar    $0x2,%eax
  80d553:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80d559:	83 c4 14             	add    $0x14,%esp
  80d55c:	5b                   	pop    %ebx
  80d55d:	5d                   	pop    %ebp
  80d55e:	c3                   	ret    

0080d55f <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80d55f:	55                   	push   %ebp
  80d560:	89 e5                	mov    %esp,%ebp
  80d562:	56                   	push   %esi
  80d563:	53                   	push   %ebx
  80d564:	83 ec 10             	sub    $0x10,%esp
    assert(size < MBOXSLOTS);
  80d567:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80d56b:	7e 24                	jle    80d591 <sys_mbox_new+0x32>
  80d56d:	c7 44 24 0c bb 3d 81 	movl   $0x813dbb,0xc(%esp)
  80d574:	00 
  80d575:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d57c:	00 
  80d57d:	c7 44 24 04 46 00 00 	movl   $0x46,0x4(%esp)
  80d584:	00 
  80d585:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d58c:	e8 83 33 ff ff       	call   800914 <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80d591:	8b 1d a0 bd b3 00    	mov    0xb3bda0,%ebx
    if (!mbe) {
  80d597:	85 db                	test   %ebx,%ebx
  80d599:	75 16                	jne    80d5b1 <sys_mbox_new+0x52>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80d59b:	c7 04 24 ac 3e 81 00 	movl   $0x813eac,(%esp)
  80d5a2:	e8 26 34 ff ff       	call   8009cd <cprintf>
  80d5a7:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
  80d5ac:	e9 bd 00 00 00       	jmp    80d66e <sys_mbox_new+0x10f>
    }
    LIST_REMOVE(mbe, link);
  80d5b1:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80d5b7:	85 c0                	test   %eax,%eax
  80d5b9:	74 0c                	je     80d5c7 <sys_mbox_new+0x68>
  80d5bb:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80d5c1:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80d5c7:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80d5cd:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80d5d3:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80d5d5:	83 3b 00             	cmpl   $0x0,(%ebx)
  80d5d8:	75 24                	jne    80d5fe <sys_mbox_new+0x9f>
  80d5da:	c7 44 24 0c cc 3d 81 	movl   $0x813dcc,0xc(%esp)
  80d5e1:	00 
  80d5e2:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d5e9:	00 
  80d5ea:	c7 44 24 04 4d 00 00 	movl   $0x4d,0x4(%esp)
  80d5f1:	00 
  80d5f2:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d5f9:	e8 16 33 ff ff       	call   800914 <_panic>
    mbe->freed = 0;
  80d5fe:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80d604:	89 de                	mov    %ebx,%esi
  80d606:	81 ee a0 6f b3 00    	sub    $0xb36fa0,%esi
  80d60c:	c1 fe 02             	sar    $0x2,%esi
  80d60f:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
    mbe->head = -1;
  80d615:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80d61c:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80d623:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80d62a:	e8 a6 fe ff ff       	call   80d4d5 <sys_sem_new>
  80d62f:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80d635:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80d63c:	e8 94 fe ff ff       	call   80d4d5 <sys_sem_new>
  80d641:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80d647:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80d64e:	74 05                	je     80d655 <sys_mbox_new+0xf6>
  80d650:	83 f8 ff             	cmp    $0xffffffff,%eax
  80d653:	75 19                	jne    80d66e <sys_mbox_new+0x10f>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80d655:	89 34 24             	mov    %esi,(%esp)
  80d658:	e8 46 fa ff ff       	call   80d0a3 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80d65d:	c7 04 24 d4 3e 81 00 	movl   $0x813ed4,(%esp)
  80d664:	e8 64 33 ff ff       	call   8009cd <cprintf>
  80d669:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
    }
    return i;
}
  80d66e:	89 f0                	mov    %esi,%eax
  80d670:	83 c4 10             	add    $0x10,%esp
  80d673:	5b                   	pop    %ebx
  80d674:	5e                   	pop    %esi
  80d675:	5d                   	pop    %ebp
  80d676:	c3                   	ret    

0080d677 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80d677:	55                   	push   %ebp
  80d678:	89 e5                	mov    %esp,%ebp
  80d67a:	83 ec 18             	sub    $0x18,%esp
  80d67d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80d680:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80d683:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80d686:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80d689:	83 3c 95 80 5b b3 00 	cmpl   $0x0,0xb35b80(,%edx,4)
  80d690:	00 
  80d691:	74 24                	je     80d6b7 <sys_sem_signal+0x40>
  80d693:	c7 44 24 0c 47 3d 81 	movl   $0x813d47,0xc(%esp)
  80d69a:	00 
  80d69b:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d6a2:	00 
  80d6a3:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
  80d6aa:	00 
  80d6ab:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d6b2:	e8 5d 32 ff ff       	call   800914 <_panic>
    sems[sem].counter++;
  80d6b7:	ba 80 5b b3 00       	mov    $0xb35b80,%edx
  80d6bc:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
  80d6c3:	8d 1c 01             	lea    (%ecx,%eax,1),%ebx
  80d6c6:	c1 e3 02             	shl    $0x2,%ebx
  80d6c9:	0f b7 74 13 08       	movzwl 0x8(%ebx,%edx,1),%esi
  80d6ce:	83 c6 01             	add    $0x1,%esi
  80d6d1:	66 89 74 13 08       	mov    %si,0x8(%ebx,%edx,1)
    if (sems[sem].waiters) {
  80d6d6:	01 c1                	add    %eax,%ecx
  80d6d8:	66 83 7c 8a 0a 00    	cmpw   $0x0,0xa(%edx,%ecx,4)
  80d6de:	74 19                	je     80d6f9 <sys_sem_signal+0x82>
	sems[sem].waiters = 0;
  80d6e0:	66 c7 04 8d 8a 5b b3 	movw   $0x0,0xb35b8a(,%ecx,4)
  80d6e7:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80d6ea:	8d 04 8d 88 5b b3 00 	lea    0xb35b88(,%ecx,4),%eax
  80d6f1:	89 04 24             	mov    %eax,(%esp)
  80d6f4:	e8 76 02 00 00       	call   80d96f <thread_wakeup>
    }
}
  80d6f9:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80d6fc:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80d6ff:	89 ec                	mov    %ebp,%esp
  80d701:	5d                   	pop    %ebp
  80d702:	c3                   	ret    

0080d703 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80d703:	55                   	push   %ebp
  80d704:	89 e5                	mov    %esp,%ebp
  80d706:	83 ec 28             	sub    $0x28,%esp
  80d709:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80d70c:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80d70f:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80d712:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80d715:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80d718:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80d71e:	83 b8 a0 6f b3 00 00 	cmpl   $0x0,0xb36fa0(%eax)
  80d725:	74 24                	je     80d74b <sys_arch_mbox_fetch+0x48>
  80d727:	c7 44 24 0c 75 3d 81 	movl   $0x813d75,0xc(%esp)
  80d72e:	00 
  80d72f:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d736:	00 
  80d737:	c7 44 24 04 cf 00 00 	movl   $0xcf,0x4(%esp)
  80d73e:	00 
  80d73f:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d746:	e8 c9 31 ff ff       	call   800914 <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80d74b:	8b 45 10             	mov    0x10(%ebp),%eax
  80d74e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d752:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80d758:	8b 80 2c 70 b3 00    	mov    0xb3702c(%eax),%eax
  80d75e:	89 04 24             	mov    %eax,(%esp)
  80d761:	e8 20 fc ff ff       	call   80d386 <sys_arch_sem_wait>
  80d766:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80d768:	83 f8 ff             	cmp    $0xffffffff,%eax
  80d76b:	0f 84 85 00 00 00    	je     80d7f6 <sys_arch_mbox_fetch+0xf3>
	return waited;

    int slot = mboxes[mbox].head;
  80d771:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80d777:	8b 80 a4 6f b3 00    	mov    0xb36fa4(%eax),%eax
    if (slot == -1)
  80d77d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80d780:	75 1c                	jne    80d79e <sys_arch_mbox_fetch+0x9b>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80d782:	c7 44 24 08 00 3f 81 	movl   $0x813f00,0x8(%esp)
  80d789:	00 
  80d78a:	c7 44 24 04 d7 00 00 	movl   $0xd7,0x4(%esp)
  80d791:	00 
  80d792:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d799:	e8 76 31 ff ff       	call   800914 <_panic>
    if (msg)
  80d79e:	85 ff                	test   %edi,%edi
  80d7a0:	74 0e                	je     80d7b0 <sys_arch_mbox_fetch+0xad>
	*msg = mboxes[mbox].msg[slot];
  80d7a2:	6b d3 27             	imul   $0x27,%ebx,%edx
  80d7a5:	01 c2                	add    %eax,%edx
  80d7a7:	8b 14 95 ac 6f b3 00 	mov    0xb36fac(,%edx,4),%edx
  80d7ae:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80d7b0:	8d 48 01             	lea    0x1(%eax),%ecx
  80d7b3:	89 ca                	mov    %ecx,%edx
  80d7b5:	c1 fa 1f             	sar    $0x1f,%edx
  80d7b8:	c1 ea 1b             	shr    $0x1b,%edx
  80d7bb:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  80d7be:	83 e0 1f             	and    $0x1f,%eax
  80d7c1:	29 d0                	sub    %edx,%eax
  80d7c3:	ba a0 6f b3 00       	mov    $0xb36fa0,%edx
  80d7c8:	69 cb 9c 00 00 00    	imul   $0x9c,%ebx,%ecx
  80d7ce:	89 44 11 04          	mov    %eax,0x4(%ecx,%edx,1)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80d7d2:	3b 44 11 08          	cmp    0x8(%ecx,%edx,1),%eax
  80d7d6:	75 0a                	jne    80d7e2 <sys_arch_mbox_fetch+0xdf>
	mboxes[mbox].head = -1;
  80d7d8:	c7 81 a4 6f b3 00 ff 	movl   $0xffffffff,0xb36fa4(%ecx)
  80d7df:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80d7e2:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80d7e8:	8b 83 30 70 b3 00    	mov    0xb37030(%ebx),%eax
  80d7ee:	89 04 24             	mov    %eax,(%esp)
  80d7f1:	e8 81 fe ff ff       	call   80d677 <sys_sem_signal>
    return waited;
}
  80d7f6:	89 f0                	mov    %esi,%eax
  80d7f8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d7fb:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d7fe:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d801:	89 ec                	mov    %ebp,%esp
  80d803:	5d                   	pop    %ebp
  80d804:	c3                   	ret    

0080d805 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80d805:	55                   	push   %ebp
  80d806:	89 e5                	mov    %esp,%ebp
  80d808:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80d80b:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80d812:	ff 
  80d813:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d816:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d81a:	8b 45 08             	mov    0x8(%ebp),%eax
  80d81d:	89 04 24             	mov    %eax,(%esp)
  80d820:	e8 de fe ff ff       	call   80d703 <sys_arch_mbox_fetch>
}
  80d825:	c9                   	leave  
  80d826:	c3                   	ret    

0080d827 <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80d827:	55                   	push   %ebp
  80d828:	89 e5                	mov    %esp,%ebp
  80d82a:	83 ec 28             	sub    $0x28,%esp
  80d82d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80d830:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80d833:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80d836:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80d839:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d83f:	83 b8 a0 6f b3 00 00 	cmpl   $0x0,0xb36fa0(%eax)
  80d846:	74 24                	je     80d86c <sys_mbox_trypost+0x45>
  80d848:	c7 44 24 0c 75 3d 81 	movl   $0x813d75,0xc(%esp)
  80d84f:	00 
  80d850:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d857:	00 
  80d858:	c7 44 24 04 73 00 00 	movl   $0x73,0x4(%esp)
  80d85f:	00 
  80d860:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d867:	e8 a8 30 ff ff       	call   800914 <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80d86c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80d873:	00 
  80d874:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80d87a:	8b 83 30 70 b3 00    	mov    0xb37030(%ebx),%eax
  80d880:	89 04 24             	mov    %eax,(%esp)
  80d883:	e8 fe fa ff ff       	call   80d386 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80d888:	b9 a0 6f b3 00       	mov    $0xb36fa0,%ecx
  80d88d:	8b 54 0b 08          	mov    0x8(%ebx,%ecx,1),%edx
  80d891:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80d896:	3b 54 0b 04          	cmp    0x4(%ebx,%ecx,1),%edx
  80d89a:	74 4c                	je     80d8e8 <sys_mbox_trypost+0xc1>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80d89c:	89 c8                	mov    %ecx,%eax
  80d89e:	89 d9                	mov    %ebx,%ecx
  80d8a0:	8d 7a 01             	lea    0x1(%edx),%edi
  80d8a3:	89 fb                	mov    %edi,%ebx
  80d8a5:	c1 fb 1f             	sar    $0x1f,%ebx
  80d8a8:	c1 eb 1b             	shr    $0x1b,%ebx
  80d8ab:	01 df                	add    %ebx,%edi
  80d8ad:	83 e7 1f             	and    $0x1f,%edi
  80d8b0:	29 df                	sub    %ebx,%edi
  80d8b2:	89 7c 01 08          	mov    %edi,0x8(%ecx,%eax,1)
    mboxes[mbox].msg[slot] = msg;
  80d8b6:	6b de 27             	imul   $0x27,%esi,%ebx
  80d8b9:	01 d3                	add    %edx,%ebx
  80d8bb:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80d8be:	89 7c 98 0c          	mov    %edi,0xc(%eax,%ebx,4)

    if (mboxes[mbox].head == -1)
  80d8c2:	83 7c 01 04 ff       	cmpl   $0xffffffff,0x4(%ecx,%eax,1)
  80d8c7:	75 06                	jne    80d8cf <sys_mbox_trypost+0xa8>
	mboxes[mbox].head = slot;
  80d8c9:	89 91 a4 6f b3 00    	mov    %edx,0xb36fa4(%ecx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80d8cf:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80d8d5:	8b 86 2c 70 b3 00    	mov    0xb3702c(%esi),%eax
  80d8db:	89 04 24             	mov    %eax,(%esp)
  80d8de:	e8 94 fd ff ff       	call   80d677 <sys_sem_signal>
  80d8e3:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80d8e8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d8eb:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d8ee:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d8f1:	89 ec                	mov    %ebp,%esp
  80d8f3:	5d                   	pop    %ebp
  80d8f4:	c3                   	ret    

0080d8f5 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80d8f5:	55                   	push   %ebp
  80d8f6:	89 e5                	mov    %esp,%ebp
  80d8f8:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80d8fb:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d8fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d902:	8b 45 08             	mov    0x8(%ebp),%eax
  80d905:	89 04 24             	mov    %eax,(%esp)
  80d908:	e8 1a ff ff ff       	call   80d827 <sys_mbox_trypost>
  80d90d:	84 c0                	test   %al,%al
  80d90f:	74 24                	je     80d935 <sys_mbox_post+0x40>
  80d911:	c7 44 24 0c 28 3f 81 	movl   $0x813f28,0xc(%esp)
  80d918:	00 
  80d919:	c7 44 24 08 a1 28 81 	movl   $0x8128a1,0x8(%esp)
  80d920:	00 
  80d921:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
  80d928:	00 
  80d929:	c7 04 24 58 3d 81 00 	movl   $0x813d58,(%esp)
  80d930:	e8 df 2f ff ff       	call   800914 <_panic>
}
  80d935:	c9                   	leave  
  80d936:	c3                   	ret    
	...

0080d940 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80d940:	55                   	push   %ebp
  80d941:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80d943:	c7 05 cc c1 b3 00 00 	movl   $0x0,0xb3c1cc
  80d94a:	00 00 00 
    tq->tq_last = 0;
  80d94d:	c7 05 d0 c1 b3 00 00 	movl   $0x0,0xb3c1d0
  80d954:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80d957:	c7 05 c4 c1 b3 00 00 	movl   $0x0,0xb3c1c4
  80d95e:	00 00 00 
}
  80d961:	5d                   	pop    %ebp
  80d962:	c3                   	ret    

0080d963 <thread_id>:

uint32_t
thread_id(void) {
  80d963:	55                   	push   %ebp
  80d964:	89 e5                	mov    %esp,%ebp
  80d966:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80d96b:	8b 00                	mov    (%eax),%eax
    return cur_tc->tc_tid;
}
  80d96d:	5d                   	pop    %ebp
  80d96e:	c3                   	ret    

0080d96f <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80d96f:	55                   	push   %ebp
  80d970:	89 e5                	mov    %esp,%ebp
  80d972:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80d975:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
    while (tc) {
  80d97a:	85 c0                	test   %eax,%eax
  80d97c:	74 10                	je     80d98e <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80d97e:	39 50 48             	cmp    %edx,0x48(%eax)
  80d981:	75 04                	jne    80d987 <thread_wakeup+0x18>
	    tc->tc_wakeup = 1;
  80d983:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80d987:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80d98a:	85 c0                	test   %eax,%eax
  80d98c:	75 f0                	jne    80d97e <thread_wakeup+0xf>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80d98e:	5d                   	pop    %ebp
  80d98f:	90                   	nop
  80d990:	c3                   	ret    

0080d991 <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80d991:	55                   	push   %ebp
  80d992:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80d994:	8b 15 cc c1 b3 00    	mov    0xb3c1cc,%edx
    int n = 0;
    while (tc) {
  80d99a:	b8 00 00 00 00       	mov    $0x0,%eax
  80d99f:	85 d2                	test   %edx,%edx
  80d9a1:	74 11                	je     80d9b4 <thread_wakeups_pending+0x23>
	if (tc->tc_wakeup)
  80d9a3:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80d9a7:	80 f9 01             	cmp    $0x1,%cl
  80d9aa:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80d9ad:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80d9b0:	85 d2                	test   %edx,%edx
  80d9b2:	75 ef                	jne    80d9a3 <thread_wakeups_pending+0x12>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80d9b4:	5d                   	pop    %ebp
  80d9b5:	c3                   	ret    

0080d9b6 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80d9b6:	55                   	push   %ebp
  80d9b7:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80d9b9:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80d9bf:	8b 4a 60             	mov    0x60(%edx),%ecx
  80d9c2:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80d9c7:	83 f9 03             	cmp    $0x3,%ecx
  80d9ca:	7f 12                	jg     80d9de <thread_onhalt+0x28>
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80d9cc:	8b 45 08             	mov    0x8(%ebp),%eax
  80d9cf:	89 44 8a 50          	mov    %eax,0x50(%edx,%ecx,4)
  80d9d3:	83 c1 01             	add    $0x1,%ecx
  80d9d6:	89 4a 60             	mov    %ecx,0x60(%edx)
  80d9d9:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80d9de:	5d                   	pop    %ebp
  80d9df:	c3                   	ret    

0080d9e0 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80d9e0:	55                   	push   %ebp
  80d9e1:	89 e5                	mov    %esp,%ebp
  80d9e3:	53                   	push   %ebx
  80d9e4:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80d9e7:	8b 1d cc c1 b3 00    	mov    0xb3c1cc,%ebx
  80d9ed:	85 db                	test   %ebx,%ebx
  80d9ef:	74 69                	je     80da5a <thread_yield+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80d9f1:	8b 43 64             	mov    0x64(%ebx),%eax
  80d9f4:	a3 cc c1 b3 00       	mov    %eax,0xb3c1cc
    tc->tc_queue_link = 0;
  80d9f9:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80da00:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80da05:	85 c0                	test   %eax,%eax
  80da07:	74 3e                	je     80da47 <thread_yield+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80da09:	83 c0 30             	add    $0x30,%eax
  80da0c:	89 04 24             	mov    %eax,(%esp)
  80da0f:	e8 cc 02 00 00       	call   80dce0 <jos_setjmp>
  80da14:	85 c0                	test   %eax,%eax
  80da16:	75 42                	jne    80da5a <thread_yield+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80da18:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80da1d:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80da24:	83 3d cc c1 b3 00 00 	cmpl   $0x0,0xb3c1cc
  80da2b:	75 0c                	jne    80da39 <thread_yield+0x59>
	tq->tq_first = tc;
  80da2d:	a3 cc c1 b3 00       	mov    %eax,0xb3c1cc
	tq->tq_last = tc;
  80da32:	a3 d0 c1 b3 00       	mov    %eax,0xb3c1d0
  80da37:	eb 0e                	jmp    80da47 <thread_yield+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80da39:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
  80da3f:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80da42:	a3 d0 c1 b3 00       	mov    %eax,0xb3c1d0
    }

    cur_tc = next_tc;
  80da47:	89 1d c8 c1 b3 00    	mov    %ebx,0xb3c1c8
    jos_longjmp(&cur_tc->tc_jb, 1);
  80da4d:	8d 43 30             	lea    0x30(%ebx),%eax
  80da50:	ba 01 00 00 00       	mov    $0x1,%edx
  80da55:	e8 b6 02 00 00       	call   80dd10 <jos_longjmp>
}
  80da5a:	83 c4 14             	add    $0x14,%esp
  80da5d:	5b                   	pop    %ebx
  80da5e:	5d                   	pop    %ebp
  80da5f:	c3                   	ret    

0080da60 <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80da60:	55                   	push   %ebp
  80da61:	89 e5                	mov    %esp,%ebp
  80da63:	56                   	push   %esi
  80da64:	53                   	push   %ebx
  80da65:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80da68:	8b 1d d4 c1 b3 00    	mov    0xb3c1d4,%ebx
  80da6e:	85 db                	test   %ebx,%ebx
  80da70:	0f 84 88 00 00 00    	je     80dafe <thread_halt+0x9e>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80da76:	8b 43 64             	mov    0x64(%ebx),%eax
  80da79:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
    tc->tc_queue_link = 0;
  80da7e:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80da85:	83 7b 60 00          	cmpl   $0x0,0x60(%ebx)
  80da89:	7e 16                	jle    80daa1 <thread_halt+0x41>
  80da8b:	be 00 00 00 00       	mov    $0x0,%esi
	tc->tc_onhalt[i](tc->tc_tid);
  80da90:	8b 03                	mov    (%ebx),%eax
  80da92:	89 04 24             	mov    %eax,(%esp)
  80da95:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80da99:	83 c6 01             	add    $0x1,%esi
  80da9c:	3b 73 60             	cmp    0x60(%ebx),%esi
  80da9f:	7c ef                	jl     80da90 <thread_halt+0x30>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80daa1:	8b 43 04             	mov    0x4(%ebx),%eax
  80daa4:	89 04 24             	mov    %eax,(%esp)
  80daa7:	e8 f4 51 ff ff       	call   802ca0 <free>
    free(tc);
  80daac:	89 1c 24             	mov    %ebx,(%esp)
  80daaf:	e8 ec 51 ff ff       	call   802ca0 <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80dab4:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80dab9:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80dac0:	83 3d d4 c1 b3 00 00 	cmpl   $0x0,0xb3c1d4
  80dac7:	75 0c                	jne    80dad5 <thread_halt+0x75>
	tq->tq_first = tc;
  80dac9:	a3 d4 c1 b3 00       	mov    %eax,0xb3c1d4
	tq->tq_last = tc;
  80dace:	a3 d8 c1 b3 00       	mov    %eax,0xb3c1d8
  80dad3:	eb 0e                	jmp    80dae3 <thread_halt+0x83>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80dad5:	8b 15 d8 c1 b3 00    	mov    0xb3c1d8,%edx
  80dadb:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80dade:	a3 d8 c1 b3 00       	mov    %eax,0xb3c1d8
    cur_tc = NULL;
  80dae3:	c7 05 c8 c1 b3 00 00 	movl   $0x0,0xb3c1c8
  80daea:	00 00 00 
    thread_yield();
  80daed:	e8 ee fe ff ff       	call   80d9e0 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80daf2:	e8 01 2e ff ff       	call   8008f8 <exit>
}
  80daf7:	83 c4 10             	add    $0x10,%esp
  80dafa:	5b                   	pop    %ebx
  80dafb:	5e                   	pop    %esi
  80dafc:	5d                   	pop    %ebp
  80dafd:	c3                   	ret    
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80dafe:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80db03:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
  80db0a:	eb bd                	jmp    80dac9 <thread_halt+0x69>

0080db0c <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80db0c:	55                   	push   %ebp
  80db0d:	89 e5                	mov    %esp,%ebp
  80db0f:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80db12:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80db17:	8b 50 2c             	mov    0x2c(%eax),%edx
  80db1a:	89 14 24             	mov    %edx,(%esp)
  80db1d:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80db20:	e8 3b ff ff ff       	call   80da60 <thread_halt>
}
  80db25:	c9                   	leave  
  80db26:	c3                   	ret    

0080db27 <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80db27:	55                   	push   %ebp
  80db28:	89 e5                	mov    %esp,%ebp
  80db2a:	57                   	push   %edi
  80db2b:	56                   	push   %esi
  80db2c:	53                   	push   %ebx
  80db2d:	83 ec 1c             	sub    $0x1c,%esp
  80db30:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80db33:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80db3a:	e8 34 52 ff ff       	call   802d73 <malloc>
  80db3f:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80db41:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80db46:	85 db                	test   %ebx,%ebx
  80db48:	0f 84 19 01 00 00    	je     80dc67 <thread_create+0x140>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80db4e:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80db55:	00 
  80db56:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80db5d:	00 
  80db5e:	89 1c 24             	mov    %ebx,(%esp)
  80db61:	e8 30 37 ff ff       	call   801296 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80db66:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80db6d:	00 
  80db6e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80db71:	89 44 24 04          	mov    %eax,0x4(%esp)
  80db75:	8d 43 08             	lea    0x8(%ebx),%eax
  80db78:	89 04 24             	mov    %eax,(%esp)
  80db7b:	e8 d6 35 ff ff       	call   801156 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80db80:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80db84:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80db89:	8d 50 01             	lea    0x1(%eax),%edx
  80db8c:	89 15 c4 c1 b3 00    	mov    %edx,0xb3c1c4
    if (max_tid == (uint32_t)~0)
  80db92:	83 fa ff             	cmp    $0xffffffff,%edx
  80db95:	75 1c                	jne    80dbb3 <thread_create+0x8c>
	panic("alloc_tid: no more thread ids");
  80db97:	c7 44 24 08 4e 3f 81 	movl   $0x813f4e,0x8(%esp)
  80db9e:	00 
  80db9f:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80dba6:	00 
  80dba7:	c7 04 24 6c 3f 81 00 	movl   $0x813f6c,(%esp)
  80dbae:	e8 61 2d ff ff       	call   800914 <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80dbb3:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80dbb5:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80dbbc:	e8 b2 51 ff ff       	call   802d73 <malloc>
  80dbc1:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80dbc4:	85 c0                	test   %eax,%eax
  80dbc6:	75 12                	jne    80dbda <thread_create+0xb3>
	free(tc);
  80dbc8:	89 1c 24             	mov    %ebx,(%esp)
  80dbcb:	e8 d0 50 ff ff       	call   802ca0 <free>
  80dbd0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	return -E_NO_MEM;
  80dbd5:	e9 8d 00 00 00       	jmp    80dc67 <thread_create+0x140>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80dbda:	8d b0 fc 0f 00 00    	lea    0xffc(%eax),%esi
    memset(stacktop, 0, 4);
  80dbe0:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80dbe7:	00 
  80dbe8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80dbef:	00 
  80dbf0:	89 34 24             	mov    %esi,(%esp)
  80dbf3:	e8 9e 36 ff ff       	call   801296 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80dbf8:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80dbff:	00 
  80dc00:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80dc07:	00 
  80dc08:	8d 43 30             	lea    0x30(%ebx),%eax
  80dc0b:	89 04 24             	mov    %eax,(%esp)
  80dc0e:	e8 83 36 ff ff       	call   801296 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80dc13:	89 73 34             	mov    %esi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80dc16:	c7 43 30 0c db 80 00 	movl   $0x80db0c,0x30(%ebx)
    tc->tc_entry = entry;
  80dc1d:	8b 45 10             	mov    0x10(%ebp),%eax
  80dc20:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80dc23:	8b 45 14             	mov    0x14(%ebp),%eax
  80dc26:	89 43 2c             	mov    %eax,0x2c(%ebx)
  80dc29:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80dc30:	83 3d cc c1 b3 00 00 	cmpl   $0x0,0xb3c1cc
  80dc37:	75 0e                	jne    80dc47 <thread_create+0x120>
	tq->tq_first = tc;
  80dc39:	89 1d cc c1 b3 00    	mov    %ebx,0xb3c1cc
	tq->tq_last = tc;
  80dc3f:	89 1d d0 c1 b3 00    	mov    %ebx,0xb3c1d0
  80dc45:	eb 0e                	jmp    80dc55 <thread_create+0x12e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80dc47:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80dc4c:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80dc4f:	89 1d d0 c1 b3 00    	mov    %ebx,0xb3c1d0

    threadq_push(&thread_queue, tc);

    if (tid)
  80dc55:	b8 00 00 00 00       	mov    $0x0,%eax
  80dc5a:	85 ff                	test   %edi,%edi
  80dc5c:	74 09                	je     80dc67 <thread_create+0x140>
	*tid = tc->tc_tid;
  80dc5e:	8b 03                	mov    (%ebx),%eax
  80dc60:	89 07                	mov    %eax,(%edi)
  80dc62:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80dc67:	83 c4 1c             	add    $0x1c,%esp
  80dc6a:	5b                   	pop    %ebx
  80dc6b:	5e                   	pop    %esi
  80dc6c:	5f                   	pop    %edi
  80dc6d:	5d                   	pop    %ebp
  80dc6e:	c3                   	ret    

0080dc6f <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80dc6f:	55                   	push   %ebp
  80dc70:	89 e5                	mov    %esp,%ebp
  80dc72:	57                   	push   %edi
  80dc73:	56                   	push   %esi
  80dc74:	53                   	push   %ebx
  80dc75:	83 ec 0c             	sub    $0xc,%esp
  80dc78:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dc7b:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80dc7e:	e8 27 39 ff ff       	call   8015aa <sys_time_msec>
  80dc83:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80dc85:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80dc8a:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80dc8d:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)

    while (p < msec) {
  80dc91:	39 fe                	cmp    %edi,%esi
  80dc93:	72 06                	jb     80dc9b <thread_wait+0x2c>
  80dc95:	eb 2d                	jmp    80dcc4 <thread_wait+0x55>
	if (p < s)
  80dc97:	39 c6                	cmp    %eax,%esi
  80dc99:	77 29                	ja     80dcc4 <thread_wait+0x55>
	    break;
	if (addr && *addr != val)
  80dc9b:	85 db                	test   %ebx,%ebx
  80dc9d:	8d 76 00             	lea    0x0(%esi),%esi
  80dca0:	74 07                	je     80dca9 <thread_wait+0x3a>
  80dca2:	8b 03                	mov    (%ebx),%eax
  80dca4:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80dca7:	75 1b                	jne    80dcc4 <thread_wait+0x55>
	    break;
	if (cur_tc->tc_wakeup)
  80dca9:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80dcae:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80dcb2:	84 c0                	test   %al,%al
  80dcb4:	75 0e                	jne    80dcc4 <thread_wait+0x55>
	    break;

	thread_yield();
  80dcb6:	e8 25 fd ff ff       	call   80d9e0 <thread_yield>
	p = sys_time_msec();
  80dcbb:	e8 ea 38 ff ff       	call   8015aa <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80dcc0:	39 c7                	cmp    %eax,%edi
  80dcc2:	77 d3                	ja     80dc97 <thread_wait+0x28>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80dcc4:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80dcc9:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80dcd0:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80dcd4:	83 c4 0c             	add    $0xc,%esp
  80dcd7:	5b                   	pop    %ebx
  80dcd8:	5e                   	pop    %esi
  80dcd9:	5f                   	pop    %edi
  80dcda:	5d                   	pop    %ebp
  80dcdb:	c3                   	ret    
  80dcdc:	00 00                	add    %al,(%eax)
	...

0080dce0 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80dce0:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80dce4:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80dce7:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80dce9:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80dced:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80dcf0:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80dcf3:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80dcf6:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80dcf9:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80dcfc:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80dd01:	c3                   	ret    
  80dd02:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80dd09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080dd10 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80dd10:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80dd12:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80dd15:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80dd18:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80dd1b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80dd1e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80dd21:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80dd23:	ff e1                	jmp    *%ecx
  80dd25:	00 00                	add    %al,(%eax)
	...

0080dd28 <e2s>:
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
  80dd28:	55                   	push   %ebp
  80dd29:	89 e5                	mov    %esp,%ebp
  80dd2b:	8b 45 08             	mov    0x8(%ebp),%eax
  80dd2e:	8b 04 85 60 50 81 00 	mov    0x815060(,%eax,4),%eax
	return sys_errlist[err];
}
  80dd35:	5d                   	pop    %ebp
  80dd36:	c3                   	ret    

0080dd37 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80dd37:	55                   	push   %ebp
  80dd38:	89 e5                	mov    %esp,%ebp
  80dd3a:	83 ec 18             	sub    $0x18,%esp
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80dd3d:	a1 20 c2 b3 00       	mov    0xb3c220,%eax
  80dd42:	89 04 24             	mov    %eax,(%esp)
  80dd45:	e8 de ff ff ff       	call   80dd28 <e2s>
  80dd4a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80dd4e:	8b 45 08             	mov    0x8(%ebp),%eax
  80dd51:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dd55:	c7 04 24 87 3f 81 00 	movl   $0x813f87,(%esp)
  80dd5c:	e8 6c 2c ff ff       	call   8009cd <cprintf>
}
  80dd61:	c9                   	leave  
  80dd62:	c3                   	ret    
	...

0080dd70 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80dd70:	55                   	push   %ebp
  80dd71:	89 e5                	mov    %esp,%ebp
  80dd73:	83 ec 38             	sub    $0x38,%esp
  80dd76:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80dd79:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80dd7c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80dd7f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80dd82:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80dd89:	e8 62 8e ff ff       	call   806bf0 <mem_malloc>
  80dd8e:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80dd90:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80dd95:	85 f6                	test   %esi,%esi
  80dd97:	0f 84 8a 00 00 00    	je     80de27 <jif_init+0xb7>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80dd9d:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80dda0:	89 73 1c             	mov    %esi,0x1c(%ebx)
    netif->output = jif_output;
  80dda3:	c7 43 14 49 df 80 00 	movl   $0x80df49,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80ddaa:	c7 43 18 34 de 80 00 	movl   $0x80de34,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80ddb1:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80ddb8:	00 
  80ddb9:	c7 44 24 04 f7 28 81 	movl   $0x8128f7,0x4(%esp)
  80ddc0:	00 
  80ddc1:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80ddc4:	89 04 24             	mov    %eax,(%esp)
  80ddc7:	e8 a5 35 ff ff       	call   801371 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80ddcc:	8d 43 25             	lea    0x25(%ebx),%eax
  80ddcf:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80ddd1:	8b 07                	mov    (%edi),%eax
  80ddd3:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80ddd6:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80ddda:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80dde0:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80dde4:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80dde8:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80ddec:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80ddf0:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80ddf4:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80ddf8:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80ddfc:	c7 04 24 ac 1f 81 00 	movl   $0x811fac,(%esp)
  80de03:	e8 98 cb ff ff       	call   80a9a0 <inet_addr>
  80de08:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80de0b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80de12:	00 
  80de13:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80de16:	89 44 24 04          	mov    %eax,0x4(%esp)
  80de1a:	89 1c 24             	mov    %ebx,(%esp)
  80de1d:	e8 25 e9 ff ff       	call   80c747 <etharp_query>
  80de22:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80de27:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80de2a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80de2d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80de30:	89 ec                	mov    %ebp,%esp
  80de32:	5d                   	pop    %ebp
  80de33:	c3                   	ret    

0080de34 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80de34:	55                   	push   %ebp
  80de35:	89 e5                	mov    %esp,%ebp
  80de37:	57                   	push   %edi
  80de38:	56                   	push   %esi
  80de39:	53                   	push   %ebx
  80de3a:	83 ec 2c             	sub    $0x2c,%esp
  80de3d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80de40:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80de47:	00 
  80de48:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80de4f:	10 
  80de50:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80de57:	e8 11 39 ff ff       	call   80176d <sys_page_alloc>
    if (r < 0)
  80de5c:	85 c0                	test   %eax,%eax
  80de5e:	79 1c                	jns    80de7c <low_level_output+0x48>
	panic("jif: could not allocate page of memory");
  80de60:	c7 44 24 08 80 44 81 	movl   $0x814480,0x8(%esp)
  80de67:	00 
  80de68:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80de6f:	00 
  80de70:	c7 04 24 69 44 81 00 	movl   $0x814469,(%esp)
  80de77:	e8 98 2a ff ff       	call   800914 <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80de7c:	8b 45 08             	mov    0x8(%ebp),%eax
  80de7f:	8b 78 1c             	mov    0x1c(%eax),%edi

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80de82:	be 00 00 00 00       	mov    $0x0,%esi
  80de87:	85 db                	test   %ebx,%ebx
  80de89:	74 74                	je     80deff <low_level_output+0xcb>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80de8b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80de8f:	0f b7 d0             	movzwl %ax,%edx
  80de92:	81 fa d0 07 00 00    	cmp    $0x7d0,%edx
  80de98:	7e 38                	jle    80ded2 <low_level_output+0x9e>
  80de9a:	eb 12                	jmp    80deae <low_level_output+0x7a>
  80de9c:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80dea0:	0f b7 d0             	movzwl %ax,%edx
  80dea3:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
  80dea6:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80deac:	7e 29                	jle    80ded7 <low_level_output+0xa3>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80deae:	89 74 24 10          	mov    %esi,0x10(%esp)
  80deb2:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80deb6:	c7 44 24 08 a8 44 81 	movl   $0x8144a8,0x8(%esp)
  80debd:	00 
  80debe:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  80dec5:	00 
  80dec6:	c7 04 24 69 44 81 00 	movl   $0x814469,(%esp)
  80decd:	e8 42 2a ff ff       	call   800914 <_panic>
  80ded2:	be 00 00 00 00       	mov    $0x0,%esi
	memcpy(&txbuf[txsize], q->payload, q->len);
  80ded7:	8d 96 04 00 00 10    	lea    0x10000004(%esi),%edx
  80dedd:	0f b7 c0             	movzwl %ax,%eax
  80dee0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80dee4:	8b 43 04             	mov    0x4(%ebx),%eax
  80dee7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80deeb:	89 14 24             	mov    %edx,(%esp)
  80deee:	e8 7e 34 ff ff       	call   801371 <memcpy>
	txsize += q->len;
  80def3:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80def7:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80def9:	8b 1b                	mov    (%ebx),%ebx
  80defb:	85 db                	test   %ebx,%ebx
  80defd:	75 9d                	jne    80de9c <low_level_output+0x68>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80deff:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80df05:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80df0c:	00 
  80df0d:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80df14:	10 
  80df15:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80df1c:	00 
  80df1d:	8b 47 04             	mov    0x4(%edi),%eax
  80df20:	89 04 24             	mov    %eax,(%esp)
  80df23:	e8 71 3e ff ff       	call   801d99 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80df28:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80df2f:	10 
  80df30:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80df37:	e8 c0 37 ff ff       	call   8016fc <sys_page_unmap>

    return ERR_OK;
}
  80df3c:	b8 00 00 00 00       	mov    $0x0,%eax
  80df41:	83 c4 2c             	add    $0x2c,%esp
  80df44:	5b                   	pop    %ebx
  80df45:	5e                   	pop    %esi
  80df46:	5f                   	pop    %edi
  80df47:	5d                   	pop    %ebp
  80df48:	c3                   	ret    

0080df49 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80df49:	55                   	push   %ebp
  80df4a:	89 e5                	mov    %esp,%ebp
  80df4c:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80df4f:	8b 45 10             	mov    0x10(%ebp),%eax
  80df52:	89 44 24 08          	mov    %eax,0x8(%esp)
  80df56:	8b 45 0c             	mov    0xc(%ebp),%eax
  80df59:	89 44 24 04          	mov    %eax,0x4(%esp)
  80df5d:	8b 45 08             	mov    0x8(%ebp),%eax
  80df60:	89 04 24             	mov    %eax,(%esp)
  80df63:	e8 f4 e9 ff ff       	call   80c95c <etharp_output>
}
  80df68:	c9                   	leave  
  80df69:	c3                   	ret    

0080df6a <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80df6a:	55                   	push   %ebp
  80df6b:	89 e5                	mov    %esp,%ebp
  80df6d:	57                   	push   %edi
  80df6e:	56                   	push   %esi
  80df6f:	53                   	push   %ebx
  80df70:	83 ec 2c             	sub    $0x2c,%esp
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80df73:	8b 45 08             	mov    0x8(%ebp),%eax
  80df76:	8b 40 1c             	mov    0x1c(%eax),%eax
  80df79:	89 45 d8             	mov    %eax,-0x28(%ebp)
 *
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  80df7c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    s16_t len = pkt->jp_len;
  80df7f:	0f b7 33             	movzwl (%ebx),%esi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80df82:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80df89:	00 
  80df8a:	0f b7 c6             	movzwl %si,%eax
  80df8d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80df91:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80df98:	e8 ac 9c ff ff       	call   807c49 <pbuf_alloc>
  80df9d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80dfa0:	85 c0                	test   %eax,%eax
  80dfa2:	0f 84 ca 00 00 00    	je     80e072 <jif_input+0x108>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80dfa8:	83 c3 04             	add    $0x4,%ebx
  80dfab:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80dfae:	89 c3                	mov    %eax,%ebx
  80dfb0:	bf 00 00 00 00       	mov    $0x0,%edi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80dfb5:	0f bf f6             	movswl %si,%esi
  80dfb8:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80dfbb:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80dfbf:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80dfc2:	29 fe                	sub    %edi,%esi
  80dfc4:	39 c6                	cmp    %eax,%esi
  80dfc6:	0f 4f f0             	cmovg  %eax,%esi
	if (bytes > (len - copied))
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80dfc9:	89 74 24 08          	mov    %esi,0x8(%esp)
  80dfcd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80dfd0:	01 f8                	add    %edi,%eax
  80dfd2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dfd6:	8b 43 04             	mov    0x4(%ebx),%eax
  80dfd9:	89 04 24             	mov    %eax,(%esp)
  80dfdc:	e8 90 33 ff ff       	call   801371 <memcpy>
	copied += bytes;
  80dfe1:	01 f7                	add    %esi,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80dfe3:	8b 1b                	mov    (%ebx),%ebx
  80dfe5:	85 db                	test   %ebx,%ebx
  80dfe7:	75 d2                	jne    80dfbb <jif_input+0x51>
  80dfe9:	eb 61                	jmp    80e04c <jif_input+0xe2>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80dfeb:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80dfee:	89 54 24 04          	mov    %edx,0x4(%esp)
  80dff2:	8b 45 08             	mov    0x8(%ebp),%eax
  80dff5:	89 04 24             	mov    %eax,(%esp)
  80dff8:	e8 8c ec ff ff       	call   80cc89 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80dffd:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80e004:	ff 
  80e005:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e008:	89 14 24             	mov    %edx,(%esp)
  80e00b:	e8 13 96 ff ff       	call   807623 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80e010:	8b 45 08             	mov    0x8(%ebp),%eax
  80e013:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e017:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e01a:	89 14 24             	mov    %edx,(%esp)
  80e01d:	ff 50 10             	call   *0x10(%eax)
	break;
  80e020:	eb 50                	jmp    80e072 <jif_input+0x108>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80e022:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80e025:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e029:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80e02c:	8b 02                	mov    (%edx),%eax
  80e02e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e032:	8b 45 08             	mov    0x8(%ebp),%eax
  80e035:	89 04 24             	mov    %eax,(%esp)
  80e038:	e8 9a ec ff ff       	call   80ccd7 <etharp_arp_input>
	break;
  80e03d:	eb 33                	jmp    80e072 <jif_input+0x108>

    default:
	pbuf_free(p);
  80e03f:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e042:	89 14 24             	mov    %edx,(%esp)
  80e045:	e8 43 99 ff ff       	call   80798d <pbuf_free>
  80e04a:	eb 26                	jmp    80e072 <jif_input+0x108>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80e04c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e04f:	8b 42 04             	mov    0x4(%edx),%eax
  80e052:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80e056:	89 04 24             	mov    %eax,(%esp)
  80e059:	e8 25 c7 ff ff       	call   80a783 <htons>
  80e05e:	66 3d 00 08          	cmp    $0x800,%ax
  80e062:	74 87                	je     80dfeb <jif_input+0x81>
  80e064:	66 3d 06 08          	cmp    $0x806,%ax
  80e068:	75 d5                	jne    80e03f <jif_input+0xd5>
  80e06a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80e070:	eb b0                	jmp    80e022 <jif_input+0xb8>
	break;

    default:
	pbuf_free(p);
    }
}
  80e072:	83 c4 2c             	add    $0x2c,%esp
  80e075:	5b                   	pop    %ebx
  80e076:	5e                   	pop    %esi
  80e077:	5f                   	pop    %edi
  80e078:	5d                   	pop    %ebp
  80e079:	c3                   	ret    
  80e07a:	00 00                	add    %al,(%eax)
  80e07c:	00 00                	add    %al,(%eax)
	...

0080e080 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80e080:	55                   	push   %ebp
  80e081:	89 e5                	mov    %esp,%ebp
  80e083:	83 ec 18             	sub    $0x18,%esp
  80e086:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80e089:	85 c0                	test   %eax,%eax
  80e08b:	75 1c                	jne    80e0a9 <netconn_type+0x29>
  80e08d:	c7 44 24 08 d1 44 81 	movl   $0x8144d1,0x8(%esp)
  80e094:	00 
  80e095:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80e09c:	00 
  80e09d:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e0a4:	e8 6b 28 ff ff       	call   800914 <_panic>
  80e0a9:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80e0ab:	c9                   	leave  
  80e0ac:	c3                   	ret    

0080e0ad <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80e0ad:	55                   	push   %ebp
  80e0ae:	89 e5                	mov    %esp,%ebp
  80e0b0:	53                   	push   %ebx
  80e0b1:	83 ec 34             	sub    $0x34,%esp
  80e0b4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e0b7:	85 db                	test   %ebx,%ebx
  80e0b9:	75 1c                	jne    80e0d7 <netconn_close+0x2a>
  80e0bb:	c7 44 24 08 03 45 81 	movl   $0x814503,0x8(%esp)
  80e0c2:	00 
  80e0c3:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80e0ca:	00 
  80e0cb:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e0d2:	e8 3d 28 ff ff       	call   800914 <_panic>

  msg.function = do_close;
  80e0d7:	c7 45 e4 bf ea 80 00 	movl   $0x80eabf,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e0de:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80e0e1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e0e4:	89 04 24             	mov    %eax,(%esp)
  80e0e7:	e8 ab 6b ff ff       	call   804c97 <tcpip_apimsg>
  80e0ec:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e0f0:	83 c4 34             	add    $0x34,%esp
  80e0f3:	5b                   	pop    %ebx
  80e0f4:	5d                   	pop    %ebp
  80e0f5:	c3                   	ret    

0080e0f6 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80e0f6:	55                   	push   %ebp
  80e0f7:	89 e5                	mov    %esp,%ebp
  80e0f9:	53                   	push   %ebx
  80e0fa:	83 ec 34             	sub    $0x34,%esp
  80e0fd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e100:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e104:	85 db                	test   %ebx,%ebx
  80e106:	75 1c                	jne    80e124 <netconn_write+0x2e>
  80e108:	c7 44 24 08 1f 45 81 	movl   $0x81451f,0x8(%esp)
  80e10f:	00 
  80e110:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80e117:	00 
  80e118:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e11f:	e8 f0 27 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80e124:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e127:	74 1c                	je     80e145 <netconn_write+0x4f>
  80e129:	c7 44 24 08 6c 46 81 	movl   $0x81466c,0x8(%esp)
  80e130:	00 
  80e131:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80e138:	00 
  80e139:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e140:	e8 cf 27 ff ff       	call   800914 <_panic>

  msg.function = do_write;
  80e145:	c7 45 e4 3e ee 80 00 	movl   $0x80ee3e,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e14c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80e14f:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e152:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80e155:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80e158:	8b 45 10             	mov    0x10(%ebp),%eax
  80e15b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80e15e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e161:	89 04 24             	mov    %eax,(%esp)
  80e164:	e8 2e 6b ff ff       	call   804c97 <tcpip_apimsg>
  80e169:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e16d:	83 c4 34             	add    $0x34,%esp
  80e170:	5b                   	pop    %ebx
  80e171:	5d                   	pop    %ebp
  80e172:	c3                   	ret    

0080e173 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80e173:	55                   	push   %ebp
  80e174:	89 e5                	mov    %esp,%ebp
  80e176:	53                   	push   %ebx
  80e177:	83 ec 34             	sub    $0x34,%esp
  80e17a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e17d:	85 db                	test   %ebx,%ebx
  80e17f:	75 1c                	jne    80e19d <netconn_send+0x2a>
  80e181:	c7 44 24 08 3b 45 81 	movl   $0x81453b,0x8(%esp)
  80e188:	00 
  80e189:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80e190:	00 
  80e191:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e198:	e8 77 27 ff ff       	call   800914 <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80e19d:	c7 45 e4 cc ee 80 00 	movl   $0x80eecc,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e1a4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80e1a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e1aa:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80e1ad:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e1b0:	89 04 24             	mov    %eax,(%esp)
  80e1b3:	e8 df 6a ff ff       	call   804c97 <tcpip_apimsg>
  80e1b8:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e1bc:	83 c4 34             	add    $0x34,%esp
  80e1bf:	5b                   	pop    %ebx
  80e1c0:	5d                   	pop    %ebp
  80e1c1:	c3                   	ret    

0080e1c2 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80e1c2:	55                   	push   %ebp
  80e1c3:	89 e5                	mov    %esp,%ebp
  80e1c5:	83 ec 18             	sub    $0x18,%esp
  80e1c8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e1cb:	0f b7 4d 14          	movzwl 0x14(%ebp),%ecx
  if (buf != NULL) {
  80e1cf:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80e1d4:	85 d2                	test   %edx,%edx
  80e1d6:	74 19                	je     80e1f1 <netconn_sendto+0x2f>
    buf->addr = addr;
  80e1d8:	8b 45 10             	mov    0x10(%ebp),%eax
  80e1db:	89 42 08             	mov    %eax,0x8(%edx)
    buf->port = port;
  80e1de:	66 89 4a 0c          	mov    %cx,0xc(%edx)
    return netconn_send(conn, buf);
  80e1e2:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e1e6:	8b 45 08             	mov    0x8(%ebp),%eax
  80e1e9:	89 04 24             	mov    %eax,(%esp)
  80e1ec:	e8 82 ff ff ff       	call   80e173 <netconn_send>
  }
  return ERR_VAL;
}
  80e1f1:	c9                   	leave  
  80e1f2:	c3                   	ret    

0080e1f3 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80e1f3:	55                   	push   %ebp
  80e1f4:	89 e5                	mov    %esp,%ebp
  80e1f6:	53                   	push   %ebx
  80e1f7:	83 ec 34             	sub    $0x34,%esp
  80e1fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80e1fd:	85 db                	test   %ebx,%ebx
  80e1ff:	75 1c                	jne    80e21d <netconn_listen_with_backlog+0x2a>
  80e201:	c7 44 24 08 56 45 81 	movl   $0x814556,0x8(%esp)
  80e208:	00 
  80e209:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80e210:	00 
  80e211:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e218:	e8 f7 26 ff ff       	call   800914 <_panic>

  msg.function = do_listen;
  80e21d:	c7 45 e4 8f ef 80 00 	movl   $0x80ef8f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e224:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80e227:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e22a:	89 04 24             	mov    %eax,(%esp)
  80e22d:	e8 65 6a ff ff       	call   804c97 <tcpip_apimsg>
  80e232:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e236:	83 c4 34             	add    $0x34,%esp
  80e239:	5b                   	pop    %ebx
  80e23a:	5d                   	pop    %ebp
  80e23b:	c3                   	ret    

0080e23c <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80e23c:	55                   	push   %ebp
  80e23d:	89 e5                	mov    %esp,%ebp
  80e23f:	53                   	push   %ebx
  80e240:	83 ec 34             	sub    $0x34,%esp
  80e243:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e246:	85 db                	test   %ebx,%ebx
  80e248:	75 1c                	jne    80e266 <netconn_disconnect+0x2a>
  80e24a:	c7 44 24 08 90 46 81 	movl   $0x814690,0x8(%esp)
  80e251:	00 
  80e252:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80e259:	00 
  80e25a:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e261:	e8 ae 26 ff ff       	call   800914 <_panic>

  msg.function = do_disconnect;
  80e266:	c7 45 e4 59 f1 80 00 	movl   $0x80f159,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e26d:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80e270:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e273:	89 04 24             	mov    %eax,(%esp)
  80e276:	e8 1c 6a ff ff       	call   804c97 <tcpip_apimsg>
  80e27b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e27f:	83 c4 34             	add    $0x34,%esp
  80e282:	5b                   	pop    %ebx
  80e283:	5d                   	pop    %ebp
  80e284:	c3                   	ret    

0080e285 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e285:	55                   	push   %ebp
  80e286:	89 e5                	mov    %esp,%ebp
  80e288:	53                   	push   %ebx
  80e289:	83 ec 34             	sub    $0x34,%esp
  80e28c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e28f:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e293:	85 db                	test   %ebx,%ebx
  80e295:	75 1c                	jne    80e2b3 <netconn_connect+0x2e>
  80e297:	c7 44 24 08 73 45 81 	movl   $0x814573,0x8(%esp)
  80e29e:	00 
  80e29f:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80e2a6:	00 
  80e2a7:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e2ae:	e8 61 26 ff ff       	call   800914 <_panic>

  msg.function = do_connect;
  80e2b3:	c7 45 e4 90 f1 80 00 	movl   $0x80f190,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e2ba:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e2bd:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e2c0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80e2c3:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80e2c7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e2ca:	89 04 24             	mov    %eax,(%esp)
  80e2cd:	e8 c5 69 ff ff       	call   804c97 <tcpip_apimsg>
  80e2d2:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e2d6:	83 c4 34             	add    $0x34,%esp
  80e2d9:	5b                   	pop    %ebx
  80e2da:	5d                   	pop    %ebp
  80e2db:	c3                   	ret    

0080e2dc <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e2dc:	55                   	push   %ebp
  80e2dd:	89 e5                	mov    %esp,%ebp
  80e2df:	53                   	push   %ebx
  80e2e0:	83 ec 34             	sub    $0x34,%esp
  80e2e3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e2e6:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80e2ea:	85 db                	test   %ebx,%ebx
  80e2ec:	75 1c                	jne    80e30a <netconn_bind+0x2e>
  80e2ee:	c7 44 24 08 91 45 81 	movl   $0x814591,0x8(%esp)
  80e2f5:	00 
  80e2f6:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80e2fd:	00 
  80e2fe:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e305:	e8 0a 26 ff ff       	call   800914 <_panic>

  msg.function = do_bind;
  80e30a:	c7 45 e4 58 f2 80 00 	movl   $0x80f258,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e311:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e314:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e317:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80e31a:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80e31e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e321:	89 04 24             	mov    %eax,(%esp)
  80e324:	e8 6e 69 ff ff       	call   804c97 <tcpip_apimsg>
  80e329:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e32d:	83 c4 34             	add    $0x34,%esp
  80e330:	5b                   	pop    %ebx
  80e331:	5d                   	pop    %ebp
  80e332:	c3                   	ret    

0080e333 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80e333:	55                   	push   %ebp
  80e334:	89 e5                	mov    %esp,%ebp
  80e336:	53                   	push   %ebx
  80e337:	83 ec 34             	sub    $0x34,%esp
  80e33a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e33d:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e340:	8b 45 10             	mov    0x10(%ebp),%eax
  80e343:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80e347:	85 db                	test   %ebx,%ebx
  80e349:	75 1c                	jne    80e367 <netconn_getaddr+0x34>
  80e34b:	c7 44 24 08 ac 45 81 	movl   $0x8145ac,0x8(%esp)
  80e352:	00 
  80e353:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80e35a:	00 
  80e35b:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e362:	e8 ad 25 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80e367:	85 d2                	test   %edx,%edx
  80e369:	75 1c                	jne    80e387 <netconn_getaddr+0x54>
  80e36b:	c7 44 24 08 ca 45 81 	movl   $0x8145ca,0x8(%esp)
  80e372:	00 
  80e373:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80e37a:	00 
  80e37b:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e382:	e8 8d 25 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80e387:	85 c0                	test   %eax,%eax
  80e389:	75 1c                	jne    80e3a7 <netconn_getaddr+0x74>
  80e38b:	c7 44 24 08 e8 45 81 	movl   $0x8145e8,0x8(%esp)
  80e392:	00 
  80e393:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80e39a:	00 
  80e39b:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e3a2:	e8 6d 25 ff ff       	call   800914 <_panic>

  msg.function = do_getaddr;
  80e3a7:	c7 45 e4 50 e7 80 00 	movl   $0x80e750,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e3ae:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80e3b1:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80e3b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80e3b7:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80e3ba:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e3bd:	89 04 24             	mov    %eax,(%esp)
  80e3c0:	e8 d2 68 ff ff       	call   804c97 <tcpip_apimsg>
  80e3c5:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax

  return conn->err;
}
  80e3c9:	83 c4 34             	add    $0x34,%esp
  80e3cc:	5b                   	pop    %ebx
  80e3cd:	5d                   	pop    %ebp
  80e3ce:	c3                   	ret    

0080e3cf <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80e3cf:	55                   	push   %ebp
  80e3d0:	89 e5                	mov    %esp,%ebp
  80e3d2:	53                   	push   %ebx
  80e3d3:	83 ec 24             	sub    $0x24,%esp
  80e3d6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80e3d9:	85 db                	test   %ebx,%ebx
  80e3db:	75 1c                	jne    80e3f9 <netconn_accept+0x2a>
  80e3dd:	c7 44 24 08 06 46 81 	movl   $0x814606,0x8(%esp)
  80e3e4:	00 
  80e3e5:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80e3ec:	00 
  80e3ed:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e3f4:	e8 1b 25 ff ff       	call   800914 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80e3f9:	8b 43 18             	mov    0x18(%ebx),%eax
  80e3fc:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e3ff:	75 1c                	jne    80e41d <netconn_accept+0x4e>
  80e401:	c7 44 24 08 b4 46 81 	movl   $0x8146b4,0x8(%esp)
  80e408:	00 
  80e409:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80e410:	00 
  80e411:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e418:	e8 f7 24 ff ff       	call   800914 <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80e41d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e424:	00 
  80e425:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80e428:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e42c:	89 04 24             	mov    %eax,(%esp)
  80e42f:	e8 cf f2 ff ff       	call   80d703 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80e434:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80e437:	85 c0                	test   %eax,%eax
  80e439:	74 15                	je     80e450 <netconn_accept+0x81>
  80e43b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e442:	00 
  80e443:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e44a:	00 
  80e44b:	89 1c 24             	mov    %ebx,(%esp)
  80e44e:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80e450:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80e453:	83 c4 24             	add    $0x24,%esp
  80e456:	5b                   	pop    %ebx
  80e457:	5d                   	pop    %ebp
  80e458:	c3                   	ret    

0080e459 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80e459:	55                   	push   %ebp
  80e45a:	89 e5                	mov    %esp,%ebp
  80e45c:	53                   	push   %ebx
  80e45d:	83 ec 34             	sub    $0x34,%esp
  80e460:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80e463:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80e46a:	85 db                	test   %ebx,%ebx
  80e46c:	75 1c                	jne    80e48a <netconn_recv+0x31>
  80e46e:	c7 44 24 08 23 46 81 	movl   $0x814623,0x8(%esp)
  80e475:	00 
  80e476:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80e47d:	00 
  80e47e:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e485:	e8 8a 24 ff ff       	call   800914 <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80e48a:	8b 43 14             	mov    0x14(%ebx),%eax
  80e48d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e490:	75 0e                	jne    80e4a0 <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80e492:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80e496:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  80e49b:	e9 65 01 00 00       	jmp    80e605 <netconn_recv+0x1ac>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80e4a0:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80e4a4:	0f 8c 56 01 00 00    	jl     80e600 <netconn_recv+0x1a7>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80e4aa:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e4ad:	8d 76 00             	lea    0x0(%esi),%esi
  80e4b0:	0f 85 fc 00 00 00    	jne    80e5b2 <netconn_recv+0x159>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80e4b6:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80e4ba:	75 0e                	jne    80e4ca <netconn_recv+0x71>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80e4bc:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80e4c0:	b8 00 00 00 00       	mov    $0x0,%eax
      return NULL;
  80e4c5:	e9 3b 01 00 00       	jmp    80e605 <netconn_recv+0x1ac>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80e4ca:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80e4d1:	e8 72 8d ff ff       	call   807248 <memp_malloc>
  80e4d6:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80e4d9:	85 c0                	test   %eax,%eax
  80e4db:	75 09                	jne    80e4e6 <netconn_recv+0x8d>
      conn->err = ERR_MEM;
  80e4dd:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80e4e1:	e9 1f 01 00 00       	jmp    80e605 <netconn_recv+0x1ac>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80e4e6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e4ed:	00 
  80e4ee:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80e4f1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e4f5:	8b 43 14             	mov    0x14(%ebx),%eax
  80e4f8:	89 04 24             	mov    %eax,(%esp)
  80e4fb:	e8 03 f2 ff ff       	call   80d703 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80e500:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e503:	b8 00 00 00 00       	mov    $0x0,%eax
  80e508:	85 d2                	test   %edx,%edx
  80e50a:	74 08                	je     80e514 <netconn_recv+0xbb>
      len = p->tot_len;
  80e50c:	0f b7 42 08          	movzwl 0x8(%edx),%eax
      SYS_ARCH_DEC(conn->recv_avail, len);
  80e510:	66 29 43 20          	sub    %ax,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80e514:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80e517:	85 d2                	test   %edx,%edx
  80e519:	74 14                	je     80e52f <netconn_recv+0xd6>
  80e51b:	0f b7 c0             	movzwl %ax,%eax
  80e51e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e522:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e529:	00 
  80e52a:	89 1c 24             	mov    %ebx,(%esp)
  80e52d:	ff d2                	call   *%edx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80e52f:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80e532:	85 c0                	test   %eax,%eax
  80e534:	75 2b                	jne    80e561 <netconn_recv+0x108>
      memp_free(MEMP_NETBUF, buf);
  80e536:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e539:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e53d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80e544:	e8 bb 8c ff ff       	call   807204 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80e549:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80e54d:	0f 85 ad 00 00 00    	jne    80e600 <netconn_recv+0x1a7>
        conn->err = ERR_CLSD;
  80e553:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80e557:	b8 00 00 00 00       	mov    $0x0,%eax
  80e55c:	e9 a4 00 00 00       	jmp    80e605 <netconn_recv+0x1ac>
      }
      return NULL;
    }

    buf->p = p;
  80e561:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e564:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80e566:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e569:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e56c:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80e56f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e572:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80e578:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e57b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80e582:	c7 45 e4 8b ee 80 00 	movl   $0x80ee8b,-0x1c(%ebp)
    msg.msg.conn = conn;
  80e589:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80e58c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e58f:	85 c0                	test   %eax,%eax
  80e591:	74 0c                	je     80e59f <netconn_recv+0x146>
      msg.msg.msg.r.len = buf->p->tot_len;
  80e593:	8b 00                	mov    (%eax),%eax
  80e595:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e599:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80e59d:	eb 06                	jmp    80e5a5 <netconn_recv+0x14c>
    } else {
      msg.msg.msg.r.len = 1;
  80e59f:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80e5a5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e5a8:	89 04 24             	mov    %eax,(%esp)
  80e5ab:	e8 e7 66 ff ff       	call   804c97 <tcpip_apimsg>
  80e5b0:	eb 49                	jmp    80e5fb <netconn_recv+0x1a2>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80e5b2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e5b9:	00 
  80e5ba:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80e5bd:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e5c1:	89 04 24             	mov    %eax,(%esp)
  80e5c4:	e8 3a f1 ff ff       	call   80d703 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80e5c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e5cc:	85 c0                	test   %eax,%eax
  80e5ce:	74 2b                	je     80e5fb <netconn_recv+0x1a2>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80e5d0:	8b 00                	mov    (%eax),%eax
  80e5d2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e5d6:	66 29 43 20          	sub    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80e5da:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80e5dd:	85 c0                	test   %eax,%eax
  80e5df:	74 1a                	je     80e5fb <netconn_recv+0x1a2>
  80e5e1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80e5e4:	8b 12                	mov    (%edx),%edx
  80e5e6:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80e5ea:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e5ee:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e5f5:	00 
  80e5f6:	89 1c 24             	mov    %ebx,(%esp)
  80e5f9:	ff d0                	call   *%eax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80e5fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e5fe:	eb 05                	jmp    80e605 <netconn_recv+0x1ac>
  80e600:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e605:	83 c4 34             	add    $0x34,%esp
  80e608:	5b                   	pop    %ebx
  80e609:	5d                   	pop    %ebp
  80e60a:	c3                   	ret    

0080e60b <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80e60b:	55                   	push   %ebp
  80e60c:	89 e5                	mov    %esp,%ebp
  80e60e:	53                   	push   %ebx
  80e60f:	83 ec 34             	sub    $0x34,%esp
  80e612:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80e615:	85 db                	test   %ebx,%ebx
  80e617:	74 24                	je     80e63d <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80e619:	c7 45 e4 f9 f2 80 00 	movl   $0x80f2f9,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e620:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80e623:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e626:	89 04 24             	mov    %eax,(%esp)
  80e629:	e8 69 66 ff ff       	call   804c97 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80e62e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80e635:	89 1c 24             	mov    %ebx,(%esp)
  80e638:	e8 74 0d 00 00       	call   80f3b1 <netconn_free>

  return ERR_OK;
}
  80e63d:	b8 00 00 00 00       	mov    $0x0,%eax
  80e642:	83 c4 34             	add    $0x34,%esp
  80e645:	5b                   	pop    %ebx
  80e646:	5d                   	pop    %ebp
  80e647:	c3                   	ret    

0080e648 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80e648:	55                   	push   %ebp
  80e649:	89 e5                	mov    %esp,%ebp
  80e64b:	56                   	push   %esi
  80e64c:	53                   	push   %ebx
  80e64d:	83 ec 30             	sub    $0x30,%esp
  80e650:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80e654:	8b 45 10             	mov    0x10(%ebp),%eax
  80e657:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e65b:	8b 45 08             	mov    0x8(%ebp),%eax
  80e65e:	89 04 24             	mov    %eax,(%esp)
  80e661:	e8 47 0f 00 00       	call   80f5ad <netconn_alloc>
  80e666:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80e668:	85 c0                	test   %eax,%eax
  80e66a:	0f 84 d6 00 00 00    	je     80e746 <netconn_new_with_proto_and_callback+0xfe>
    msg.function = do_newconn;
  80e670:	c7 45 e4 1a f7 80 00 	movl   $0x80f71a,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80e677:	89 f0                	mov    %esi,%eax
  80e679:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80e67c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80e67f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e682:	89 04 24             	mov    %eax,(%esp)
  80e685:	e8 0d 66 ff ff       	call   804c97 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80e68a:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80e68e:	0f 84 b2 00 00 00    	je     80e746 <netconn_new_with_proto_and_callback+0xfe>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80e694:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80e698:	74 1c                	je     80e6b6 <netconn_new_with_proto_and_callback+0x6e>
  80e69a:	c7 44 24 08 d8 46 81 	movl   $0x8146d8,0x8(%esp)
  80e6a1:	00 
  80e6a2:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80e6a9:	00 
  80e6aa:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e6b1:	e8 5e 22 ff ff       	call   800914 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80e6b6:	8b 43 10             	mov    0x10(%ebx),%eax
  80e6b9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e6bc:	75 1c                	jne    80e6da <netconn_new_with_proto_and_callback+0x92>
  80e6be:	c7 44 24 08 3e 46 81 	movl   $0x81463e,0x8(%esp)
  80e6c5:	00 
  80e6c6:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80e6cd:	00 
  80e6ce:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e6d5:	e8 3a 22 ff ff       	call   800914 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80e6da:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80e6de:	75 1c                	jne    80e6fc <netconn_new_with_proto_and_callback+0xb4>
  80e6e0:	c7 44 24 08 57 46 81 	movl   $0x814657,0x8(%esp)
  80e6e7:	00 
  80e6e8:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80e6ef:	00 
  80e6f0:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e6f7:	e8 18 22 ff ff       	call   800914 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80e6fc:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80e700:	74 1c                	je     80e71e <netconn_new_with_proto_and_callback+0xd6>
  80e702:	c7 44 24 08 fc 46 81 	movl   $0x8146fc,0x8(%esp)
  80e709:	00 
  80e70a:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80e711:	00 
  80e712:	c7 04 24 ec 44 81 00 	movl   $0x8144ec,(%esp)
  80e719:	e8 f6 21 ff ff       	call   800914 <_panic>
      sys_sem_free(conn->op_completed);
  80e71e:	89 04 24             	mov    %eax,(%esp)
  80e721:	e8 ed e8 ff ff       	call   80d013 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80e726:	8b 43 14             	mov    0x14(%ebx),%eax
  80e729:	89 04 24             	mov    %eax,(%esp)
  80e72c:	e8 72 e9 ff ff       	call   80d0a3 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80e731:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e735:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80e73c:	e8 c3 8a ff ff       	call   807204 <memp_free>
  80e741:	bb 00 00 00 00       	mov    $0x0,%ebx
      return NULL;
    }
  }
  return conn;
}
  80e746:	89 d8                	mov    %ebx,%eax
  80e748:	83 c4 30             	add    $0x30,%esp
  80e74b:	5b                   	pop    %ebx
  80e74c:	5e                   	pop    %esi
  80e74d:	5d                   	pop    %ebp
  80e74e:	c3                   	ret    
	...

0080e750 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80e750:	55                   	push   %ebp
  80e751:	89 e5                	mov    %esp,%ebp
  80e753:	83 ec 18             	sub    $0x18,%esp
  80e756:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80e759:	8b 08                	mov    (%eax),%ecx
  80e75b:	8b 51 08             	mov    0x8(%ecx),%edx
  80e75e:	85 d2                	test   %edx,%edx
  80e760:	0f 84 9f 00 00 00    	je     80e805 <do_getaddr+0xb5>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80e766:	8b 48 04             	mov    0x4(%eax),%ecx
  80e769:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80e76d:	74 06                	je     80e775 <do_getaddr+0x25>
  80e76f:	8b 12                	mov    (%edx),%edx
  80e771:	89 11                	mov    %edx,(%ecx)
  80e773:	eb 05                	jmp    80e77a <do_getaddr+0x2a>
  80e775:	8b 52 04             	mov    0x4(%edx),%edx
  80e778:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80e77a:	8b 08                	mov    (%eax),%ecx
  80e77c:	8b 11                	mov    (%ecx),%edx
  80e77e:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80e784:	83 fa 20             	cmp    $0x20,%edx
  80e787:	74 2e                	je     80e7b7 <do_getaddr+0x67>
  80e789:	83 fa 40             	cmp    $0x40,%edx
  80e78c:	74 0c                	je     80e79a <do_getaddr+0x4a>
  80e78e:	83 fa 10             	cmp    $0x10,%edx
  80e791:	75 76                	jne    80e809 <do_getaddr+0xb9>
  80e793:	90                   	nop
  80e794:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80e798:	eb 4d                	jmp    80e7e7 <do_getaddr+0x97>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80e79a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80e79e:	66 90                	xchg   %ax,%ax
  80e7a0:	74 0f                	je     80e7b1 <do_getaddr+0x61>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80e7a2:	8b 50 08             	mov    0x8(%eax),%edx
  80e7a5:	8b 49 08             	mov    0x8(%ecx),%ecx
  80e7a8:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80e7ac:	66 89 0a             	mov    %cx,(%edx)
  80e7af:	eb 58                	jmp    80e809 <do_getaddr+0xb9>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80e7b1:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80e7b5:	eb 52                	jmp    80e809 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80e7b7:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80e7bb:	74 0f                	je     80e7cc <do_getaddr+0x7c>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80e7bd:	8b 50 08             	mov    0x8(%eax),%edx
  80e7c0:	8b 49 08             	mov    0x8(%ecx),%ecx
  80e7c3:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80e7c7:	66 89 0a             	mov    %cx,(%edx)
  80e7ca:	eb 3d                	jmp    80e809 <do_getaddr+0xb9>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80e7cc:	8b 51 08             	mov    0x8(%ecx),%edx
  80e7cf:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80e7d3:	75 06                	jne    80e7db <do_getaddr+0x8b>
          msg->conn->err = ERR_CONN;
  80e7d5:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80e7d9:	eb 2e                	jmp    80e809 <do_getaddr+0xb9>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80e7db:	8b 48 08             	mov    0x8(%eax),%ecx
  80e7de:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80e7e2:	66 89 11             	mov    %dx,(%ecx)
  80e7e5:	eb 22                	jmp    80e809 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80e7e7:	8b 50 08             	mov    0x8(%eax),%edx
  80e7ea:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80e7ee:	74 09                	je     80e7f9 <do_getaddr+0xa9>
  80e7f0:	8b 49 08             	mov    0x8(%ecx),%ecx
  80e7f3:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80e7f7:	eb 07                	jmp    80e800 <do_getaddr+0xb0>
  80e7f9:	8b 49 08             	mov    0x8(%ecx),%ecx
  80e7fc:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80e800:	66 89 0a             	mov    %cx,(%edx)
  80e803:	eb 04                	jmp    80e809 <do_getaddr+0xb9>
      break;
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80e805:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80e809:	8b 00                	mov    (%eax),%eax
  80e80b:	8b 40 10             	mov    0x10(%eax),%eax
  80e80e:	89 04 24             	mov    %eax,(%esp)
  80e811:	e8 61 ee ff ff       	call   80d677 <sys_sem_signal>
}
  80e816:	c9                   	leave  
  80e817:	c3                   	ret    

0080e818 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80e818:	55                   	push   %ebp
  80e819:	89 e5                	mov    %esp,%ebp
  80e81b:	53                   	push   %ebx
  80e81c:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80e81f:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80e822:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e826:	89 1c 24             	mov    %ebx,(%esp)
  80e829:	e8 ca 9a ff ff       	call   8082f8 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80e82e:	c7 44 24 04 80 f0 80 	movl   $0x80f080,0x4(%esp)
  80e835:	00 
  80e836:	89 1c 24             	mov    %ebx,(%esp)
  80e839:	e8 c8 9a ff ff       	call   808306 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80e83e:	c7 44 24 04 8c ed 80 	movl   $0x80ed8c,0x4(%esp)
  80e845:	00 
  80e846:	89 1c 24             	mov    %ebx,(%esp)
  80e849:	e8 c9 9a ff ff       	call   808317 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80e84e:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80e855:	00 
  80e856:	c7 44 24 04 3a ed 80 	movl   $0x80ed3a,0x4(%esp)
  80e85d:	00 
  80e85e:	89 1c 24             	mov    %ebx,(%esp)
  80e861:	e8 e1 9a ff ff       	call   808347 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80e866:	c7 44 24 04 f8 ea 80 	movl   $0x80eaf8,0x4(%esp)
  80e86d:	00 
  80e86e:	89 1c 24             	mov    %ebx,(%esp)
  80e871:	e8 b2 9a ff ff       	call   808328 <tcp_err>
}
  80e876:	83 c4 14             	add    $0x14,%esp
  80e879:	5b                   	pop    %ebx
  80e87a:	5d                   	pop    %ebp
  80e87b:	c3                   	ret    

0080e87c <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80e87c:	55                   	push   %ebp
  80e87d:	89 e5                	mov    %esp,%ebp
  80e87f:	53                   	push   %ebx
  80e880:	83 ec 14             	sub    $0x14,%esp
  80e883:	0f b6 55 10          	movzbl 0x10(%ebp),%edx
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  80e887:	8b 5d 08             	mov    0x8(%ebp),%ebx

  if (conn == NULL) {
  80e88a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80e88f:	85 db                	test   %ebx,%ebx
  80e891:	74 2a                	je     80e8bd <do_connected+0x41>
    return ERR_VAL;
  }

  conn->err = err;
  80e893:	88 53 0c             	mov    %dl,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80e896:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e899:	75 0b                	jne    80e8a6 <do_connected+0x2a>
  80e89b:	84 d2                	test   %dl,%dl
  80e89d:	75 07                	jne    80e8a6 <do_connected+0x2a>
    setup_tcp(conn);
  80e89f:	89 d8                	mov    %ebx,%eax
  80e8a1:	e8 72 ff ff ff       	call   80e818 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80e8a6:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80e8ad:	8b 43 10             	mov    0x10(%ebx),%eax
  80e8b0:	89 04 24             	mov    %eax,(%esp)
  80e8b3:	e8 bf ed ff ff       	call   80d677 <sys_sem_signal>
  80e8b8:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80e8bd:	83 c4 14             	add    $0x14,%esp
  80e8c0:	5b                   	pop    %ebx
  80e8c1:	5d                   	pop    %ebp
  80e8c2:	c3                   	ret    

0080e8c3 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80e8c3:	55                   	push   %ebp
  80e8c4:	89 e5                	mov    %esp,%ebp
  80e8c6:	53                   	push   %ebx
  80e8c7:	83 ec 14             	sub    $0x14,%esp
  80e8ca:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80e8cc:	85 c0                	test   %eax,%eax
  80e8ce:	75 1c                	jne    80e8ec <do_close_internal+0x29>
  80e8d0:	c7 44 24 08 49 45 81 	movl   $0x814549,0x8(%esp)
  80e8d7:	00 
  80e8d8:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80e8df:	00 
  80e8e0:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80e8e7:	e8 28 20 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80e8ec:	83 38 10             	cmpl   $0x10,(%eax)
  80e8ef:	74 1c                	je     80e90d <do_close_internal+0x4a>
  80e8f1:	c7 44 24 08 34 47 81 	movl   $0x814734,0x8(%esp)
  80e8f8:	00 
  80e8f9:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80e900:	00 
  80e901:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80e908:	e8 07 20 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80e90d:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80e911:	74 1c                	je     80e92f <do_close_internal+0x6c>
  80e913:	c7 44 24 08 00 48 81 	movl   $0x814800,0x8(%esp)
  80e91a:	00 
  80e91b:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80e922:	00 
  80e923:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80e92a:	e8 e5 1f ff ff       	call   800914 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80e92f:	8b 40 08             	mov    0x8(%eax),%eax
  80e932:	85 c0                	test   %eax,%eax
  80e934:	75 1c                	jne    80e952 <do_close_internal+0x8f>
  80e936:	c7 44 24 08 52 47 81 	movl   $0x814752,0x8(%esp)
  80e93d:	00 
  80e93e:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80e945:	00 
  80e946:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80e94d:	e8 c2 1f ff ff       	call   800914 <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80e952:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e959:	00 
  80e95a:	89 04 24             	mov    %eax,(%esp)
  80e95d:	e8 96 99 ff ff       	call   8082f8 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80e962:	8b 43 08             	mov    0x8(%ebx),%eax
  80e965:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80e969:	75 12                	jne    80e97d <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80e96b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e972:	00 
  80e973:	89 04 24             	mov    %eax,(%esp)
  80e976:	e8 be 99 ff ff       	call   808339 <tcp_accept>
  80e97b:	eb 64                	jmp    80e9e1 <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80e97d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e984:	00 
  80e985:	89 04 24             	mov    %eax,(%esp)
  80e988:	e8 79 99 ff ff       	call   808306 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80e98d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e994:	00 
  80e995:	8b 43 08             	mov    0x8(%ebx),%eax
  80e998:	89 04 24             	mov    %eax,(%esp)
  80e99b:	e8 99 99 ff ff       	call   808339 <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80e9a0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e9a7:	00 
  80e9a8:	8b 43 08             	mov    0x8(%ebx),%eax
  80e9ab:	89 04 24             	mov    %eax,(%esp)
  80e9ae:	e8 64 99 ff ff       	call   808317 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80e9b3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80e9ba:	00 
  80e9bb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e9c2:	00 
  80e9c3:	8b 43 08             	mov    0x8(%ebx),%eax
  80e9c6:	89 04 24             	mov    %eax,(%esp)
  80e9c9:	e8 79 99 ff ff       	call   808347 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80e9ce:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e9d5:	00 
  80e9d6:	8b 43 08             	mov    0x8(%ebx),%eax
  80e9d9:	89 04 24             	mov    %eax,(%esp)
  80e9dc:	e8 47 99 ff ff       	call   808328 <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80e9e1:	8b 43 08             	mov    0x8(%ebx),%eax
  80e9e4:	89 04 24             	mov    %eax,(%esp)
  80e9e7:	e8 ff a7 ff ff       	call   8091eb <tcp_close>
  if (err == ERR_OK) {
  80e9ec:	84 c0                	test   %al,%al
  80e9ee:	75 57                	jne    80ea47 <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80e9f0:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80e9f7:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80e9fe:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80ea02:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ea05:	85 c0                	test   %eax,%eax
  80ea07:	74 31                	je     80ea3a <do_close_internal+0x177>
  80ea09:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ea10:	00 
  80ea11:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ea18:	00 
  80ea19:	89 1c 24             	mov    %ebx,(%esp)
  80ea1c:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80ea1e:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ea21:	85 c0                	test   %eax,%eax
  80ea23:	74 15                	je     80ea3a <do_close_internal+0x177>
  80ea25:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ea2c:	00 
  80ea2d:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80ea34:	00 
  80ea35:	89 1c 24             	mov    %ebx,(%esp)
  80ea38:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80ea3a:	8b 43 10             	mov    0x10(%ebx),%eax
  80ea3d:	89 04 24             	mov    %eax,(%esp)
  80ea40:	e8 32 ec ff ff       	call   80d677 <sys_sem_signal>
  80ea45:	eb 72                	jmp    80eab9 <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80ea47:	8b 43 08             	mov    0x8(%ebx),%eax
  80ea4a:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80ea4e:	75 1c                	jne    80ea6c <do_close_internal+0x1a9>
  80ea50:	c7 44 24 08 24 48 81 	movl   $0x814824,0x8(%esp)
  80ea57:	00 
  80ea58:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80ea5f:	00 
  80ea60:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80ea67:	e8 a8 1e ff ff       	call   800914 <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80ea6c:	c7 44 24 04 8c ed 80 	movl   $0x80ed8c,0x4(%esp)
  80ea73:	00 
  80ea74:	89 04 24             	mov    %eax,(%esp)
  80ea77:	e8 9b 98 ff ff       	call   808317 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80ea7c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ea83:	00 
  80ea84:	c7 44 24 04 3a ed 80 	movl   $0x80ed3a,0x4(%esp)
  80ea8b:	00 
  80ea8c:	8b 43 08             	mov    0x8(%ebx),%eax
  80ea8f:	89 04 24             	mov    %eax,(%esp)
  80ea92:	e8 b0 98 ff ff       	call   808347 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80ea97:	c7 44 24 04 f8 ea 80 	movl   $0x80eaf8,0x4(%esp)
  80ea9e:	00 
  80ea9f:	8b 43 08             	mov    0x8(%ebx),%eax
  80eaa2:	89 04 24             	mov    %eax,(%esp)
  80eaa5:	e8 7e 98 ff ff       	call   808328 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80eaaa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80eaae:	8b 43 08             	mov    0x8(%ebx),%eax
  80eab1:	89 04 24             	mov    %eax,(%esp)
  80eab4:	e8 3f 98 ff ff       	call   8082f8 <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80eab9:	83 c4 14             	add    $0x14,%esp
  80eabc:	5b                   	pop    %ebx
  80eabd:	5d                   	pop    %ebp
  80eabe:	c3                   	ret    

0080eabf <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80eabf:	55                   	push   %ebp
  80eac0:	89 e5                	mov    %esp,%ebp
  80eac2:	83 ec 18             	sub    $0x18,%esp
  80eac5:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80eac8:	8b 02                	mov    (%edx),%eax
  80eaca:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80eace:	74 15                	je     80eae5 <do_close+0x26>
  80ead0:	83 38 10             	cmpl   $0x10,(%eax)
  80ead3:	75 10                	jne    80eae5 <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80ead5:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80eadc:	8b 02                	mov    (%edx),%eax
  80eade:	e8 e0 fd ff ff       	call   80e8c3 <do_close_internal>
 */
void
do_close(struct api_msg_msg *msg)
{
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80eae3:	eb 11                	jmp    80eaf6 <do_close+0x37>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80eae5:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80eae9:	8b 02                	mov    (%edx),%eax
  80eaeb:	8b 40 10             	mov    0x10(%eax),%eax
  80eaee:	89 04 24             	mov    %eax,(%esp)
  80eaf1:	e8 81 eb ff ff       	call   80d677 <sys_sem_signal>
  }
}
  80eaf6:	c9                   	leave  
  80eaf7:	c3                   	ret    

0080eaf8 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80eaf8:	55                   	push   %ebp
  80eaf9:	89 e5                	mov    %esp,%ebp
  80eafb:	53                   	push   %ebx
  80eafc:	83 ec 14             	sub    $0x14,%esp
  80eaff:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  80eb03:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80eb06:	85 db                	test   %ebx,%ebx
  80eb08:	75 1c                	jne    80eb26 <err_tcp+0x2e>
  80eb0a:	c7 44 24 08 65 47 81 	movl   $0x814765,0x8(%esp)
  80eb11:	00 
  80eb12:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80eb19:	00 
  80eb1a:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80eb21:	e8 ee 1d ff ff       	call   800914 <_panic>

  conn->pcb.tcp = NULL;
  80eb26:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80eb2d:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80eb30:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80eb34:	74 2f                	je     80eb65 <err_tcp+0x6d>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80eb36:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eb39:	85 c0                	test   %eax,%eax
  80eb3b:	74 15                	je     80eb52 <err_tcp+0x5a>
  80eb3d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eb44:	00 
  80eb45:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eb4c:	00 
  80eb4d:	89 1c 24             	mov    %ebx,(%esp)
  80eb50:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80eb52:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eb59:	00 
  80eb5a:	8b 43 14             	mov    0x14(%ebx),%eax
  80eb5d:	89 04 24             	mov    %eax,(%esp)
  80eb60:	e8 90 ed ff ff       	call   80d8f5 <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80eb65:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  80eb69:	74 18                	je     80eb83 <err_tcp+0x8b>
  80eb6b:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80eb6f:	75 12                	jne    80eb83 <err_tcp+0x8b>
    conn->state = NETCONN_NONE;
  80eb71:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80eb78:	8b 43 10             	mov    0x10(%ebx),%eax
  80eb7b:	89 04 24             	mov    %eax,(%esp)
  80eb7e:	e8 f4 ea ff ff       	call   80d677 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80eb83:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80eb87:	74 2f                	je     80ebb8 <err_tcp+0xc0>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80eb89:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eb8c:	85 c0                	test   %eax,%eax
  80eb8e:	74 15                	je     80eba5 <err_tcp+0xad>
  80eb90:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eb97:	00 
  80eb98:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eb9f:	00 
  80eba0:	89 1c 24             	mov    %ebx,(%esp)
  80eba3:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80eba5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ebac:	00 
  80ebad:	8b 43 18             	mov    0x18(%ebx),%eax
  80ebb0:	89 04 24             	mov    %eax,(%esp)
  80ebb3:	e8 3d ed ff ff       	call   80d8f5 <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80ebb8:	8b 43 04             	mov    0x4(%ebx),%eax
  80ebbb:	83 f8 01             	cmp    $0x1,%eax
  80ebbe:	74 05                	je     80ebc5 <err_tcp+0xcd>
  80ebc0:	83 f8 04             	cmp    $0x4,%eax
  80ebc3:	75 12                	jne    80ebd7 <err_tcp+0xdf>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80ebc5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80ebcc:	8b 43 10             	mov    0x10(%ebx),%eax
  80ebcf:	89 04 24             	mov    %eax,(%esp)
  80ebd2:	e8 a0 ea ff ff       	call   80d677 <sys_sem_signal>
  }
}
  80ebd7:	83 c4 14             	add    $0x14,%esp
  80ebda:	5b                   	pop    %ebx
  80ebdb:	5d                   	pop    %ebp
  80ebdc:	c3                   	ret    

0080ebdd <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80ebdd:	55                   	push   %ebp
  80ebde:	89 e5                	mov    %esp,%ebp
  80ebe0:	57                   	push   %edi
  80ebe1:	56                   	push   %esi
  80ebe2:	53                   	push   %ebx
  80ebe3:	83 ec 2c             	sub    $0x2c,%esp
  80ebe6:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80ebe8:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80ebec:	74 1c                	je     80ec0a <do_writemore+0x2d>
  80ebee:	c7 44 24 08 72 47 81 	movl   $0x814772,0x8(%esp)
  80ebf5:	00 
  80ebf6:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80ebfd:	00 
  80ebfe:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80ec05:	e8 0a 1d ff ff       	call   800914 <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80ec0a:	8b 50 24             	mov    0x24(%eax),%edx
  80ec0d:	8b 42 04             	mov    0x4(%edx),%eax
  80ec10:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80ec13:	8b 43 28             	mov    0x28(%ebx),%eax
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80ec16:	8b 72 08             	mov    0x8(%edx),%esi
  80ec19:	89 f1                	mov    %esi,%ecx
  80ec1b:	29 c1                	sub    %eax,%ecx
  80ec1d:	66 29 c6             	sub    %ax,%si
  80ec20:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80ec26:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
  80ec2b:	0f 4d f1             	cmovge %ecx,%esi
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80ec2e:	8b 4b 08             	mov    0x8(%ebx),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80ec31:	66 3b 71 6e          	cmp    0x6e(%ecx),%si
  80ec35:	0f b7 79 6e          	movzwl 0x6e(%ecx),%edi
  80ec39:	0f 47 f7             	cmova  %edi,%esi
  80ec3c:	0f b7 f6             	movzwl %si,%esi
  80ec3f:	0f b6 52 0c          	movzbl 0xc(%edx),%edx
  80ec43:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80ec47:	89 74 24 08          	mov    %esi,0x8(%esp)
  80ec4b:	03 45 e4             	add    -0x1c(%ebp),%eax
  80ec4e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ec52:	89 0c 24             	mov    %ecx,(%esp)
  80ec55:	e8 ef cd ff ff       	call   80ba49 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80ec5a:	89 f2                	mov    %esi,%edx
  80ec5c:	03 53 28             	add    0x28(%ebx),%edx
  80ec5f:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80ec62:	3b 51 08             	cmp    0x8(%ecx),%edx
  80ec65:	7e 1c                	jle    80ec83 <do_writemore+0xa6>
  80ec67:	c7 44 24 08 8f 47 81 	movl   $0x81478f,0x8(%esp)
  80ec6e:	00 
  80ec6f:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80ec76:	00 
  80ec77:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80ec7e:	e8 91 1c ff ff       	call   800914 <_panic>
  if (err == ERR_OK) {
  80ec83:	84 c0                	test   %al,%al
  80ec85:	75 72                	jne    80ecf9 <do_writemore+0x11c>
    conn->write_offset += len;
  80ec87:	89 53 28             	mov    %edx,0x28(%ebx)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80ec8a:	8b 43 24             	mov    0x24(%ebx),%eax
  80ec8d:	bf 00 00 00 00       	mov    $0x0,%edi
  80ec92:	3b 50 08             	cmp    0x8(%eax),%edx
  80ec95:	75 13                	jne    80ecaa <do_writemore+0xcd>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80ec97:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80ec9e:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  80eca5:	bf 01 00 00 00       	mov    $0x1,%edi
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80ecaa:	8b 43 08             	mov    0x8(%ebx),%eax
  80ecad:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80ecb1:	74 12                	je     80ecc5 <do_writemore+0xe8>
  80ecb3:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80ecb7:	75 0c                	jne    80ecc5 <do_writemore+0xe8>
  80ecb9:	8b 50 74             	mov    0x74(%eax),%edx
  80ecbc:	85 d2                	test   %edx,%edx
  80ecbe:	74 74                	je     80ed34 <do_writemore+0x157>
  80ecc0:	83 3a 00             	cmpl   $0x0,(%edx)
  80ecc3:	74 6f                	je     80ed34 <do_writemore+0x157>
  80ecc5:	89 04 24             	mov    %eax,(%esp)
  80ecc8:	e8 3e c1 ff ff       	call   80ae0b <tcp_output>
    conn->err = err;
  80eccd:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80ecd0:	84 c0                	test   %al,%al
  80ecd2:	75 3b                	jne    80ed0f <do_writemore+0x132>
  80ecd4:	8b 43 08             	mov    0x8(%ebx),%eax
  80ecd7:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80ecdd:	77 30                	ja     80ed0f <do_writemore+0x132>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80ecdf:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ece2:	85 c0                	test   %eax,%eax
  80ece4:	74 29                	je     80ed0f <do_writemore+0x132>
  80ece6:	89 74 24 08          	mov    %esi,0x8(%esp)
  80ecea:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80ecf1:	00 
  80ecf2:	89 1c 24             	mov    %ebx,(%esp)
  80ecf5:	ff d0                	call   *%eax
  80ecf7:	eb 16                	jmp    80ed0f <do_writemore+0x132>
    }
  } else if (err == ERR_MEM) {
  80ecf9:	3c ff                	cmp    $0xff,%al
  80ecfb:	75 0d                	jne    80ed0a <do_writemore+0x12d>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80ecfd:	8b 43 08             	mov    0x8(%ebx),%eax
  80ed00:	89 04 24             	mov    %eax,(%esp)
  80ed03:	e8 03 c1 ff ff       	call   80ae0b <tcp_output>
  80ed08:	eb 1d                	jmp    80ed27 <do_writemore+0x14a>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80ed0a:	88 43 0c             	mov    %al,0xc(%ebx)
  80ed0d:	eb 06                	jmp    80ed15 <do_writemore+0x138>
    write_finished = 1;
  }

  if (write_finished) {
  80ed0f:	89 f8                	mov    %edi,%eax
  80ed11:	84 c0                	test   %al,%al
  80ed13:	74 12                	je     80ed27 <do_writemore+0x14a>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80ed15:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80ed1c:	8b 43 10             	mov    0x10(%ebx),%eax
  80ed1f:	89 04 24             	mov    %eax,(%esp)
  80ed22:	e8 50 e9 ff ff       	call   80d677 <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80ed27:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed2c:	83 c4 2c             	add    $0x2c,%esp
  80ed2f:	5b                   	pop    %ebx
  80ed30:	5e                   	pop    %esi
  80ed31:	5f                   	pop    %edi
  80ed32:	5d                   	pop    %ebp
  80ed33:	c3                   	ret    
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80ed34:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80ed38:	eb 9a                	jmp    80ecd4 <do_writemore+0xf7>

0080ed3a <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80ed3a:	55                   	push   %ebp
  80ed3b:	89 e5                	mov    %esp,%ebp
  80ed3d:	83 ec 18             	sub    $0x18,%esp
  struct netconn *conn = arg;
  80ed40:	8b 45 08             	mov    0x8(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ed43:	85 c0                	test   %eax,%eax
  80ed45:	75 1c                	jne    80ed63 <poll_tcp+0x29>
  80ed47:	c7 44 24 08 65 47 81 	movl   $0x814765,0x8(%esp)
  80ed4e:	00 
  80ed4f:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80ed56:	00 
  80ed57:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80ed5e:	e8 b1 1b ff ff       	call   800914 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80ed63:	8b 50 04             	mov    0x4(%eax),%edx
  80ed66:	83 fa 01             	cmp    $0x1,%edx
  80ed69:	75 07                	jne    80ed72 <poll_tcp+0x38>
    do_writemore(conn);
  80ed6b:	e8 6d fe ff ff       	call   80ebdd <do_writemore>
  80ed70:	eb 13                	jmp    80ed85 <poll_tcp+0x4b>
  } else if (conn->state == NETCONN_CLOSE) {
  80ed72:	83 fa 04             	cmp    $0x4,%edx
  80ed75:	75 0e                	jne    80ed85 <poll_tcp+0x4b>
    do_close_internal(conn);
  80ed77:	89 f6                	mov    %esi,%esi
  80ed79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  80ed80:	e8 3e fb ff ff       	call   80e8c3 <do_close_internal>
  }

  return ERR_OK;
}
  80ed85:	b8 00 00 00 00       	mov    $0x0,%eax
  80ed8a:	c9                   	leave  
  80ed8b:	c3                   	ret    

0080ed8c <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80ed8c:	55                   	push   %ebp
  80ed8d:	89 e5                	mov    %esp,%ebp
  80ed8f:	83 ec 18             	sub    $0x18,%esp
  80ed92:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80ed95:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80ed98:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct netconn *conn = arg;
  80ed9c:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80ed9f:	85 db                	test   %ebx,%ebx
  80eda1:	75 1c                	jne    80edbf <sent_tcp+0x33>
  80eda3:	c7 44 24 08 65 47 81 	movl   $0x814765,0x8(%esp)
  80edaa:	00 
  80edab:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80edb2:	00 
  80edb3:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80edba:	e8 55 1b ff ff       	call   800914 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80edbf:	8b 43 04             	mov    0x4(%ebx),%eax
  80edc2:	83 f8 01             	cmp    $0x1,%eax
  80edc5:	75 2b                	jne    80edf2 <sent_tcp+0x66>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80edc7:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80edcb:	75 1c                	jne    80ede9 <sent_tcp+0x5d>
  80edcd:	c7 44 24 08 ad 47 81 	movl   $0x8147ad,0x8(%esp)
  80edd4:	00 
  80edd5:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80eddc:	00 
  80eddd:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80ede4:	e8 2b 1b ff ff       	call   800914 <_panic>
    do_writemore(conn);
  80ede9:	89 d8                	mov    %ebx,%eax
  80edeb:	e8 ed fd ff ff       	call   80ebdd <do_writemore>
  80edf0:	eb 13                	jmp    80ee05 <sent_tcp+0x79>
  } else if (conn->state == NETCONN_CLOSE) {
  80edf2:	83 f8 04             	cmp    $0x4,%eax
  80edf5:	75 0e                	jne    80ee05 <sent_tcp+0x79>
    do_close_internal(conn);
  80edf7:	89 d8                	mov    %ebx,%eax
  80edf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80ee00:	e8 be fa ff ff       	call   80e8c3 <do_close_internal>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80ee05:	8b 43 08             	mov    0x8(%ebx),%eax
  80ee08:	85 c0                	test   %eax,%eax
  80ee0a:	74 23                	je     80ee2f <sent_tcp+0xa3>
  80ee0c:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80ee12:	76 1b                	jbe    80ee2f <sent_tcp+0xa3>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80ee14:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ee17:	85 c0                	test   %eax,%eax
  80ee19:	74 14                	je     80ee2f <sent_tcp+0xa3>
  80ee1b:	0f b7 f6             	movzwl %si,%esi
  80ee1e:	89 74 24 08          	mov    %esi,0x8(%esp)
  80ee22:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80ee29:	00 
  80ee2a:	89 1c 24             	mov    %ebx,(%esp)
  80ee2d:	ff d0                	call   *%eax
    }
  }
  
  return ERR_OK;
}
  80ee2f:	b8 00 00 00 00       	mov    $0x0,%eax
  80ee34:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80ee37:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80ee3a:	89 ec                	mov    %ebp,%esp
  80ee3c:	5d                   	pop    %ebp
  80ee3d:	c3                   	ret    

0080ee3e <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80ee3e:	55                   	push   %ebp
  80ee3f:	89 e5                	mov    %esp,%ebp
  80ee41:	83 ec 18             	sub    $0x18,%esp
  80ee44:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ee47:	8b 02                	mov    (%edx),%eax
  80ee49:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80ee4d:	7c 2d                	jl     80ee7c <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80ee4f:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80ee53:	74 23                	je     80ee78 <do_write+0x3a>
  80ee55:	83 38 10             	cmpl   $0x10,(%eax)
  80ee58:	75 1e                	jne    80ee78 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80ee5a:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80ee61:	8b 02                	mov    (%edx),%eax
  80ee63:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80ee66:	8b 02                	mov    (%edx),%eax
  80ee68:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80ee6f:	8b 02                	mov    (%edx),%eax
  80ee71:	e8 67 fd ff ff       	call   80ebdd <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80ee76:	eb 11                	jmp    80ee89 <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80ee78:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80ee7c:	8b 02                	mov    (%edx),%eax
  80ee7e:	8b 40 10             	mov    0x10(%eax),%eax
  80ee81:	89 04 24             	mov    %eax,(%esp)
  80ee84:	e8 ee e7 ff ff       	call   80d677 <sys_sem_signal>
}
  80ee89:	c9                   	leave  
  80ee8a:	c3                   	ret    

0080ee8b <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80ee8b:	55                   	push   %ebp
  80ee8c:	89 e5                	mov    %esp,%ebp
  80ee8e:	53                   	push   %ebx
  80ee8f:	83 ec 14             	sub    $0x14,%esp
  80ee92:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80ee95:	8b 03                	mov    (%ebx),%eax
  80ee97:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80ee9b:	7c 1c                	jl     80eeb9 <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80ee9d:	8b 50 08             	mov    0x8(%eax),%edx
  80eea0:	85 d2                	test   %edx,%edx
  80eea2:	74 15                	je     80eeb9 <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80eea4:	83 38 10             	cmpl   $0x10,(%eax)
  80eea7:	75 10                	jne    80eeb9 <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80eea9:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80eead:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eeb1:	89 14 24             	mov    %edx,(%esp)
  80eeb4:	e8 ee 94 ff ff       	call   8083a7 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80eeb9:	8b 03                	mov    (%ebx),%eax
  80eebb:	8b 40 10             	mov    0x10(%eax),%eax
  80eebe:	89 04 24             	mov    %eax,(%esp)
  80eec1:	e8 b1 e7 ff ff       	call   80d677 <sys_sem_signal>
}
  80eec6:	83 c4 14             	add    $0x14,%esp
  80eec9:	5b                   	pop    %ebx
  80eeca:	5d                   	pop    %ebp
  80eecb:	c3                   	ret    

0080eecc <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80eecc:	55                   	push   %ebp
  80eecd:	89 e5                	mov    %esp,%ebp
  80eecf:	83 ec 28             	sub    $0x28,%esp
  80eed2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80eed5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80eed8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80eedb:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80eede:	8b 1e                	mov    (%esi),%ebx
  80eee0:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80eee4:	0f 8c 8b 00 00 00    	jl     80ef75 <do_send+0xa9>
    if (msg->conn->pcb.tcp != NULL) {
  80eeea:	8b 43 08             	mov    0x8(%ebx),%eax
  80eeed:	85 c0                	test   %eax,%eax
  80eeef:	0f 84 80 00 00 00    	je     80ef75 <do_send+0xa9>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80eef5:	8b 13                	mov    (%ebx),%edx
  80eef7:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80eefd:	83 fa 20             	cmp    $0x20,%edx
  80ef00:	74 39                	je     80ef3b <do_send+0x6f>
  80ef02:	83 fa 40             	cmp    $0x40,%edx
  80ef05:	75 6e                	jne    80ef75 <do_send+0xa9>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80ef07:	8b 56 04             	mov    0x4(%esi),%edx
  80ef0a:	8b 4a 08             	mov    0x8(%edx),%ecx
  80ef0d:	85 c9                	test   %ecx,%ecx
  80ef0f:	75 13                	jne    80ef24 <do_send+0x58>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80ef11:	8b 12                	mov    (%edx),%edx
  80ef13:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ef17:	89 04 24             	mov    %eax,(%esp)
  80ef1a:	e8 43 27 00 00       	call   811662 <raw_send>
  80ef1f:	88 43 0c             	mov    %al,0xc(%ebx)
  80ef22:	eb 51                	jmp    80ef75 <do_send+0xa9>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80ef24:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80ef28:	8b 12                	mov    (%edx),%edx
  80ef2a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ef2e:	89 04 24             	mov    %eax,(%esp)
  80ef31:	e8 22 26 00 00       	call   811558 <raw_sendto>
  80ef36:	88 43 0c             	mov    %al,0xc(%ebx)
  80ef39:	eb 3a                	jmp    80ef75 <do_send+0xa9>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80ef3b:	8b 56 04             	mov    0x4(%esi),%edx
  80ef3e:	8b 4a 08             	mov    0x8(%edx),%ecx
  80ef41:	85 c9                	test   %ecx,%ecx
  80ef43:	75 13                	jne    80ef58 <do_send+0x8c>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80ef45:	8b 12                	mov    (%edx),%edx
  80ef47:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ef4b:	89 04 24             	mov    %eax,(%esp)
  80ef4e:	e8 bc cf ff ff       	call   80bf0f <udp_send>
  80ef53:	88 43 0c             	mov    %al,0xc(%ebx)
  80ef56:	eb 1d                	jmp    80ef75 <do_send+0xa9>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80ef58:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  80ef5c:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80ef60:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80ef64:	8b 12                	mov    (%edx),%edx
  80ef66:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ef6a:	89 04 24             	mov    %eax,(%esp)
  80ef6d:	e8 4c cf ff ff       	call   80bebe <udp_sendto>
  80ef72:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80ef75:	8b 06                	mov    (%esi),%eax
  80ef77:	8b 40 10             	mov    0x10(%eax),%eax
  80ef7a:	89 04 24             	mov    %eax,(%esp)
  80ef7d:	e8 f5 e6 ff ff       	call   80d677 <sys_sem_signal>
}
  80ef82:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ef85:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ef88:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ef8b:	89 ec                	mov    %ebp,%esp
  80ef8d:	5d                   	pop    %ebp
  80ef8e:	c3                   	ret    

0080ef8f <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80ef8f:	55                   	push   %ebp
  80ef90:	89 e5                	mov    %esp,%ebp
  80ef92:	83 ec 28             	sub    $0x28,%esp
  80ef95:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ef98:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ef9b:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80ef9e:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80efa1:	8b 03                	mov    (%ebx),%eax
  80efa3:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80efa7:	0f 8c b9 00 00 00    	jl     80f066 <do_listen+0xd7>
    if (msg->conn->pcb.tcp != NULL) {
  80efad:	8b 50 08             	mov    0x8(%eax),%edx
  80efb0:	85 d2                	test   %edx,%edx
  80efb2:	0f 84 ae 00 00 00    	je     80f066 <do_listen+0xd7>
      if (msg->conn->type == NETCONN_TCP) {
  80efb8:	83 38 10             	cmpl   $0x10,(%eax)
  80efbb:	0f 85 a5 00 00 00    	jne    80f066 <do_listen+0xd7>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80efc1:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80efc5:	0f 85 97 00 00 00    	jne    80f062 <do_listen+0xd3>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80efcb:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80efd2:	00 
  80efd3:	89 14 24             	mov    %edx,(%esp)
  80efd6:	e8 0e 97 ff ff       	call   8086e9 <tcp_listen_with_backlog>
  80efdb:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80efdd:	85 c0                	test   %eax,%eax
  80efdf:	75 08                	jne    80efe9 <do_listen+0x5a>
            msg->conn->err = ERR_MEM;
  80efe1:	8b 03                	mov    (%ebx),%eax
  80efe3:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80efe7:	eb 7d                	jmp    80f066 <do_listen+0xd7>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80efe9:	8b 03                	mov    (%ebx),%eax
  80efeb:	8b 40 14             	mov    0x14(%eax),%eax
  80efee:	83 f8 ff             	cmp    $0xffffffff,%eax
  80eff1:	74 11                	je     80f004 <do_listen+0x75>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80eff3:	89 04 24             	mov    %eax,(%esp)
  80eff6:	e8 a8 e0 ff ff       	call   80d0a3 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80effb:	8b 03                	mov    (%ebx),%eax
  80effd:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80f004:	8b 3b                	mov    (%ebx),%edi
  80f006:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80f00a:	75 1a                	jne    80f026 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80f00c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f013:	e8 47 e5 ff ff       	call   80d55f <sys_mbox_new>
  80f018:	89 47 18             	mov    %eax,0x18(%edi)
  80f01b:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f01e:	75 06                	jne    80f026 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  80f020:	8b 03                	mov    (%ebx),%eax
  80f022:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80f026:	8b 03                	mov    (%ebx),%eax
  80f028:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80f02c:	75 38                	jne    80f066 <do_listen+0xd7>
              msg->conn->state = NETCONN_LISTEN;
  80f02e:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80f035:	8b 03                	mov    (%ebx),%eax
  80f037:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80f03a:	8b 03                	mov    (%ebx),%eax
  80f03c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f040:	8b 40 08             	mov    0x8(%eax),%eax
  80f043:	89 04 24             	mov    %eax,(%esp)
  80f046:	e8 ad 92 ff ff       	call   8082f8 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80f04b:	c7 44 24 04 64 f6 80 	movl   $0x80f664,0x4(%esp)
  80f052:	00 
  80f053:	8b 03                	mov    (%ebx),%eax
  80f055:	8b 40 08             	mov    0x8(%eax),%eax
  80f058:	89 04 24             	mov    %eax,(%esp)
  80f05b:	e8 d9 92 ff ff       	call   808339 <tcp_accept>
  80f060:	eb 04                	jmp    80f066 <do_listen+0xd7>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80f062:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80f066:	8b 03                	mov    (%ebx),%eax
  80f068:	8b 40 10             	mov    0x10(%eax),%eax
  80f06b:	89 04 24             	mov    %eax,(%esp)
  80f06e:	e8 04 e6 ff ff       	call   80d677 <sys_sem_signal>
}
  80f073:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f076:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f079:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f07c:	89 ec                	mov    %ebp,%esp
  80f07e:	5d                   	pop    %ebp
  80f07f:	c3                   	ret    

0080f080 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80f080:	55                   	push   %ebp
  80f081:	89 e5                	mov    %esp,%ebp
  80f083:	83 ec 18             	sub    $0x18,%esp
  80f086:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f089:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f08c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f08f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f092:	8b 75 10             	mov    0x10(%ebp),%esi
  80f095:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80f099:	85 c0                	test   %eax,%eax
  80f09b:	75 1c                	jne    80f0b9 <recv_tcp+0x39>
  80f09d:	c7 44 24 08 48 48 81 	movl   $0x814848,0x8(%esp)
  80f0a4:	00 
  80f0a5:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80f0ac:	00 
  80f0ad:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f0b4:	e8 5b 18 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80f0b9:	85 db                	test   %ebx,%ebx
  80f0bb:	75 1c                	jne    80f0d9 <recv_tcp+0x59>
  80f0bd:	c7 44 24 08 6c 48 81 	movl   $0x81486c,0x8(%esp)
  80f0c4:	00 
  80f0c5:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80f0cc:	00 
  80f0cd:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f0d4:	e8 3b 18 ff ff       	call   800914 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80f0d9:	39 43 08             	cmp    %eax,0x8(%ebx)
  80f0dc:	74 1c                	je     80f0fa <recv_tcp+0x7a>
  80f0de:	c7 44 24 08 c3 47 81 	movl   $0x8147c3,0x8(%esp)
  80f0e5:	00 
  80f0e6:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80f0ed:	00 
  80f0ee:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f0f5:	e8 1a 18 ff ff       	call   800914 <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80f0fa:	85 db                	test   %ebx,%ebx
  80f0fc:	74 4c                	je     80f14a <recv_tcp+0xca>
  80f0fe:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f102:	74 46                	je     80f14a <recv_tcp+0xca>
    return ERR_VAL;
  }

  conn->err = err;
  80f104:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80f107:	b8 00 00 00 00       	mov    $0x0,%eax
  80f10c:	85 f6                	test   %esi,%esi
  80f10e:	74 08                	je     80f118 <recv_tcp+0x98>
    len = p->tot_len;
  80f110:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80f114:	66 01 43 20          	add    %ax,0x20(%ebx)
  } else {
    len = 0;
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80f118:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80f11b:	85 d2                	test   %edx,%edx
  80f11d:	74 14                	je     80f133 <recv_tcp+0xb3>
  80f11f:	0f b7 c0             	movzwl %ax,%eax
  80f122:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f126:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f12d:	00 
  80f12e:	89 1c 24             	mov    %ebx,(%esp)
  80f131:	ff d2                	call   *%edx
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80f133:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f137:	8b 43 14             	mov    0x14(%ebx),%eax
  80f13a:	89 04 24             	mov    %eax,(%esp)
  80f13d:	e8 e5 e6 ff ff       	call   80d827 <sys_mbox_trypost>
  80f142:	3c 01                	cmp    $0x1,%al
  80f144:	19 c0                	sbb    %eax,%eax
  80f146:	f7 d0                	not    %eax
  80f148:	eb 05                	jmp    80f14f <recv_tcp+0xcf>
  80f14a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80f14f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f152:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f155:	89 ec                	mov    %ebp,%esp
  80f157:	5d                   	pop    %ebp
  80f158:	c3                   	ret    

0080f159 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80f159:	55                   	push   %ebp
  80f15a:	89 e5                	mov    %esp,%ebp
  80f15c:	53                   	push   %ebx
  80f15d:	83 ec 14             	sub    $0x14,%esp
  80f160:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80f163:	8b 03                	mov    (%ebx),%eax
  80f165:	8b 10                	mov    (%eax),%edx
  80f167:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f16d:	83 fa 20             	cmp    $0x20,%edx
  80f170:	75 0b                	jne    80f17d <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  80f172:	8b 40 08             	mov    0x8(%eax),%eax
  80f175:	89 04 24             	mov    %eax,(%esp)
  80f178:	e8 93 c9 ff ff       	call   80bb10 <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80f17d:	8b 03                	mov    (%ebx),%eax
  80f17f:	8b 40 10             	mov    0x10(%eax),%eax
  80f182:	89 04 24             	mov    %eax,(%esp)
  80f185:	e8 ed e4 ff ff       	call   80d677 <sys_sem_signal>
}
  80f18a:	83 c4 14             	add    $0x14,%esp
  80f18d:	5b                   	pop    %ebx
  80f18e:	5d                   	pop    %ebp
  80f18f:	c3                   	ret    

0080f190 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80f190:	55                   	push   %ebp
  80f191:	89 e5                	mov    %esp,%ebp
  80f193:	56                   	push   %esi
  80f194:	53                   	push   %ebx
  80f195:	83 ec 10             	sub    $0x10,%esp
  80f198:	8b 75 08             	mov    0x8(%ebp),%esi
  if (msg->conn->pcb.tcp == NULL) {
  80f19b:	8b 1e                	mov    (%esi),%ebx
  80f19d:	8b 53 08             	mov    0x8(%ebx),%edx
  80f1a0:	85 d2                	test   %edx,%edx
  80f1a2:	75 10                	jne    80f1b4 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80f1a4:	8b 43 10             	mov    0x10(%ebx),%eax
  80f1a7:	89 04 24             	mov    %eax,(%esp)
  80f1aa:	e8 c8 e4 ff ff       	call   80d677 <sys_sem_signal>
    return;
  80f1af:	e9 9d 00 00 00       	jmp    80f251 <do_connect+0xc1>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f1b4:	8b 03                	mov    (%ebx),%eax
  80f1b6:	25 f0 00 00 00       	and    $0xf0,%eax
  80f1bb:	83 f8 20             	cmp    $0x20,%eax
  80f1be:	74 33                	je     80f1f3 <do_connect+0x63>
  80f1c0:	83 f8 40             	cmp    $0x40,%eax
  80f1c3:	74 0d                	je     80f1d2 <do_connect+0x42>
  80f1c5:	83 f8 10             	cmp    $0x10,%eax
  80f1c8:	0f 85 83 00 00 00    	jne    80f251 <do_connect+0xc1>
  80f1ce:	66 90                	xchg   %ax,%ax
  80f1d0:	eb 4a                	jmp    80f21c <do_connect+0x8c>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f1d2:	8b 46 04             	mov    0x4(%esi),%eax
  80f1d5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f1d9:	89 14 24             	mov    %edx,(%esp)
  80f1dc:	e8 9c 22 00 00       	call   81147d <raw_connect>
  80f1e1:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f1e4:	8b 06                	mov    (%esi),%eax
  80f1e6:	8b 40 10             	mov    0x10(%eax),%eax
  80f1e9:	89 04 24             	mov    %eax,(%esp)
  80f1ec:	e8 86 e4 ff ff       	call   80d677 <sys_sem_signal>
    break;
  80f1f1:	eb 5e                	jmp    80f251 <do_connect+0xc1>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f1f3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f1f7:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f1fb:	8b 46 04             	mov    0x4(%esi),%eax
  80f1fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f202:	89 14 24             	mov    %edx,(%esp)
  80f205:	e8 84 ca ff ff       	call   80bc8e <udp_connect>
  80f20a:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f20d:	8b 06                	mov    (%esi),%eax
  80f20f:	8b 40 10             	mov    0x10(%eax),%eax
  80f212:	89 04 24             	mov    %eax,(%esp)
  80f215:	e8 5d e4 ff ff       	call   80d677 <sys_sem_signal>
    break;
  80f21a:	eb 35                	jmp    80f251 <do_connect+0xc1>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80f21c:	c7 43 04 03 00 00 00 	movl   $0x3,0x4(%ebx)
    setup_tcp(msg->conn);
  80f223:	8b 06                	mov    (%esi),%eax
  80f225:	e8 ee f5 ff ff       	call   80e818 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80f22a:	8b 1e                	mov    (%esi),%ebx
  80f22c:	c7 44 24 0c 7c e8 80 	movl   $0x80e87c,0xc(%esp)
  80f233:	00 
  80f234:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f238:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f23c:	8b 46 04             	mov    0x4(%esi),%eax
  80f23f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f243:	8b 43 08             	mov    0x8(%ebx),%eax
  80f246:	89 04 24             	mov    %eax,(%esp)
  80f249:	e8 e5 96 ff ff       	call   808933 <tcp_connect>
  80f24e:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80f251:	83 c4 10             	add    $0x10,%esp
  80f254:	5b                   	pop    %ebx
  80f255:	5e                   	pop    %esi
  80f256:	5d                   	pop    %ebp
  80f257:	c3                   	ret    

0080f258 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80f258:	55                   	push   %ebp
  80f259:	89 e5                	mov    %esp,%ebp
  80f25b:	83 ec 18             	sub    $0x18,%esp
  80f25e:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f261:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f264:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f267:	8b 1e                	mov    (%esi),%ebx
  80f269:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80f26d:	7c 73                	jl     80f2e2 <do_bind+0x8a>
    if (msg->conn->pcb.tcp != NULL) {
  80f26f:	8b 53 08             	mov    0x8(%ebx),%edx
  80f272:	85 d2                	test   %edx,%edx
  80f274:	74 68                	je     80f2de <do_bind+0x86>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f276:	8b 03                	mov    (%ebx),%eax
  80f278:	25 f0 00 00 00       	and    $0xf0,%eax
  80f27d:	83 f8 20             	cmp    $0x20,%eax
  80f280:	74 24                	je     80f2a6 <do_bind+0x4e>
  80f282:	83 f8 40             	cmp    $0x40,%eax
  80f285:	74 0b                	je     80f292 <do_bind+0x3a>
  80f287:	83 f8 10             	cmp    $0x10,%eax
  80f28a:	75 56                	jne    80f2e2 <do_bind+0x8a>
  80f28c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f290:	eb 30                	jmp    80f2c2 <do_bind+0x6a>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f292:	8b 46 04             	mov    0x4(%esi),%eax
  80f295:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f299:	89 14 24             	mov    %edx,(%esp)
  80f29c:	e8 bf 21 00 00       	call   811460 <raw_bind>
  80f2a1:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80f2a4:	eb 3c                	jmp    80f2e2 <do_bind+0x8a>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f2a6:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f2aa:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f2ae:	8b 46 04             	mov    0x4(%esi),%eax
  80f2b1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f2b5:	89 14 24             	mov    %edx,(%esp)
  80f2b8:	e8 0b c9 ff ff       	call   80bbc8 <udp_bind>
  80f2bd:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80f2c0:	eb 20                	jmp    80f2e2 <do_bind+0x8a>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f2c2:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f2c6:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f2ca:	8b 46 04             	mov    0x4(%esi),%eax
  80f2cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f2d1:	89 14 24             	mov    %edx,(%esp)
  80f2d4:	e8 15 95 ff ff       	call   8087ee <tcp_bind>
  80f2d9:	88 43 0c             	mov    %al,0xc(%ebx)
  80f2dc:	eb 04                	jmp    80f2e2 <do_bind+0x8a>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80f2de:	c6 43 0c f7          	movb   $0xf7,0xc(%ebx)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f2e2:	8b 06                	mov    (%esi),%eax
  80f2e4:	8b 40 10             	mov    0x10(%eax),%eax
  80f2e7:	89 04 24             	mov    %eax,(%esp)
  80f2ea:	e8 88 e3 ff ff       	call   80d677 <sys_sem_signal>
}
  80f2ef:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f2f2:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f2f5:	89 ec                	mov    %ebp,%esp
  80f2f7:	5d                   	pop    %ebp
  80f2f8:	c3                   	ret    

0080f2f9 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80f2f9:	55                   	push   %ebp
  80f2fa:	89 e5                	mov    %esp,%ebp
  80f2fc:	53                   	push   %ebx
  80f2fd:	83 ec 14             	sub    $0x14,%esp
  80f300:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80f303:	8b 03                	mov    (%ebx),%eax
  80f305:	8b 48 08             	mov    0x8(%eax),%ecx
  80f308:	85 c9                	test   %ecx,%ecx
  80f30a:	74 51                	je     80f35d <do_delconn+0x64>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f30c:	8b 10                	mov    (%eax),%edx
  80f30e:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f314:	83 fa 20             	cmp    $0x20,%edx
  80f317:	74 1e                	je     80f337 <do_delconn+0x3e>
  80f319:	83 fa 40             	cmp    $0x40,%edx
  80f31c:	74 0c                	je     80f32a <do_delconn+0x31>
  80f31e:	83 fa 10             	cmp    $0x10,%edx
  80f321:	75 3a                	jne    80f35d <do_delconn+0x64>
  80f323:	90                   	nop
  80f324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f328:	eb 23                	jmp    80f34d <do_delconn+0x54>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80f32a:	89 0c 24             	mov    %ecx,(%esp)
  80f32d:	8d 76 00             	lea    0x0(%esi),%esi
  80f330:	e8 d7 21 00 00       	call   81150c <raw_remove>
      break;
  80f335:	eb 26                	jmp    80f35d <do_delconn+0x64>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80f337:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80f33e:	8b 03                	mov    (%ebx),%eax
  80f340:	8b 40 08             	mov    0x8(%eax),%eax
  80f343:	89 04 24             	mov    %eax,(%esp)
  80f346:	e8 31 c8 ff ff       	call   80bb7c <udp_remove>
      break;
  80f34b:	eb 10                	jmp    80f35d <do_delconn+0x64>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80f34d:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80f354:	8b 03                	mov    (%ebx),%eax
  80f356:	e8 68 f5 ff ff       	call   80e8c3 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80f35b:	eb 4e                	jmp    80f3ab <do_delconn+0xb2>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80f35d:	8b 13                	mov    (%ebx),%edx
  80f35f:	8b 42 2c             	mov    0x2c(%edx),%eax
  80f362:	85 c0                	test   %eax,%eax
  80f364:	74 33                	je     80f399 <do_delconn+0xa0>
  80f366:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f36d:	00 
  80f36e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f375:	00 
  80f376:	89 14 24             	mov    %edx,(%esp)
  80f379:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80f37b:	8b 13                	mov    (%ebx),%edx
  80f37d:	8b 42 2c             	mov    0x2c(%edx),%eax
  80f380:	85 c0                	test   %eax,%eax
  80f382:	74 15                	je     80f399 <do_delconn+0xa0>
  80f384:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f38b:	00 
  80f38c:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80f393:	00 
  80f394:	89 14 24             	mov    %edx,(%esp)
  80f397:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80f399:	8b 03                	mov    (%ebx),%eax
  80f39b:	8b 40 10             	mov    0x10(%eax),%eax
  80f39e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f3a1:	74 08                	je     80f3ab <do_delconn+0xb2>
    sys_sem_signal(msg->conn->op_completed);
  80f3a3:	89 04 24             	mov    %eax,(%esp)
  80f3a6:	e8 cc e2 ff ff       	call   80d677 <sys_sem_signal>
  }
}
  80f3ab:	83 c4 14             	add    $0x14,%esp
  80f3ae:	5b                   	pop    %ebx
  80f3af:	5d                   	pop    %ebp
  80f3b0:	c3                   	ret    

0080f3b1 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80f3b1:	55                   	push   %ebp
  80f3b2:	89 e5                	mov    %esp,%ebp
  80f3b4:	56                   	push   %esi
  80f3b5:	53                   	push   %ebx
  80f3b6:	83 ec 20             	sub    $0x20,%esp
  80f3b9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80f3bc:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f3c0:	74 1c                	je     80f3de <netconn_free+0x2d>
  80f3c2:	c7 44 24 08 8c 48 81 	movl   $0x81488c,0x8(%esp)
  80f3c9:	00 
  80f3ca:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80f3d1:	00 
  80f3d2:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f3d9:	e8 36 15 ff ff       	call   800914 <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f3de:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80f3e1:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f3e5:	75 27                	jne    80f40e <netconn_free+0x5d>
  80f3e7:	eb 4b                	jmp    80f434 <netconn_free+0x83>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80f3e9:	83 3b 10             	cmpl   $0x10,(%ebx)
  80f3ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f3f0:	75 11                	jne    80f403 <netconn_free+0x52>
        if(mem != NULL) {
  80f3f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f3f5:	85 c0                	test   %eax,%eax
  80f3f7:	74 15                	je     80f40e <netconn_free+0x5d>
          pbuf_free((struct pbuf *)mem);
  80f3f9:	89 04 24             	mov    %eax,(%esp)
  80f3fc:	e8 8c 85 ff ff       	call   80798d <pbuf_free>
  80f401:	eb 0b                	jmp    80f40e <netconn_free+0x5d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80f403:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f406:	89 04 24             	mov    %eax,(%esp)
  80f409:	e8 a0 5c ff ff       	call   8050ae <netbuf_delete>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f40e:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f412:	8b 43 14             	mov    0x14(%ebx),%eax
  80f415:	89 04 24             	mov    %eax,(%esp)
  80f418:	e8 e8 e3 ff ff       	call   80d805 <sys_arch_mbox_tryfetch>
  80f41d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f420:	75 c7                	jne    80f3e9 <netconn_free+0x38>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80f422:	8b 43 14             	mov    0x14(%ebx),%eax
  80f425:	89 04 24             	mov    %eax,(%esp)
  80f428:	e8 76 dc ff ff       	call   80d0a3 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80f42d:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f434:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80f437:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80f43b:	75 0d                	jne    80f44a <netconn_free+0x99>
  80f43d:	eb 31                	jmp    80f470 <netconn_free+0xbf>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80f43f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f442:	89 04 24             	mov    %eax,(%esp)
  80f445:	e8 c1 f1 ff ff       	call   80e60b <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f44a:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f44e:	8b 43 18             	mov    0x18(%ebx),%eax
  80f451:	89 04 24             	mov    %eax,(%esp)
  80f454:	e8 ac e3 ff ff       	call   80d805 <sys_arch_mbox_tryfetch>
  80f459:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f45c:	75 e1                	jne    80f43f <netconn_free+0x8e>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80f45e:	8b 43 18             	mov    0x18(%ebx),%eax
  80f461:	89 04 24             	mov    %eax,(%esp)
  80f464:	e8 3a dc ff ff       	call   80d0a3 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80f469:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80f470:	8b 43 10             	mov    0x10(%ebx),%eax
  80f473:	89 04 24             	mov    %eax,(%esp)
  80f476:	e8 98 db ff ff       	call   80d013 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80f47b:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80f482:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f486:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f48d:	e8 72 7d ff ff       	call   807204 <memp_free>
}
  80f492:	83 c4 20             	add    $0x20,%esp
  80f495:	5b                   	pop    %ebx
  80f496:	5e                   	pop    %esi
  80f497:	5d                   	pop    %ebp
  80f498:	c3                   	ret    

0080f499 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80f499:	55                   	push   %ebp
  80f49a:	89 e5                	mov    %esp,%ebp
  80f49c:	83 ec 38             	sub    $0x38,%esp
  80f49f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f4a2:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f4a5:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f4a8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f4ab:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f4ae:	8b 7d 10             	mov    0x10(%ebp),%edi
  80f4b1:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80f4b5:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80f4b9:	85 c0                	test   %eax,%eax
  80f4bb:	75 1c                	jne    80f4d9 <recv_udp+0x40>
  80f4bd:	c7 44 24 08 bc 48 81 	movl   $0x8148bc,0x8(%esp)
  80f4c4:	00 
  80f4c5:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80f4cc:	00 
  80f4cd:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f4d4:	e8 3b 14 ff ff       	call   800914 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80f4d9:	85 db                	test   %ebx,%ebx
  80f4db:	75 1c                	jne    80f4f9 <recv_udp+0x60>
  80f4dd:	c7 44 24 08 e0 48 81 	movl   $0x8148e0,0x8(%esp)
  80f4e4:	00 
  80f4e5:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80f4ec:	00 
  80f4ed:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f4f4:	e8 1b 14 ff ff       	call   800914 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80f4f9:	39 43 08             	cmp    %eax,0x8(%ebx)
  80f4fc:	74 1c                	je     80f51a <recv_udp+0x81>
  80f4fe:	c7 44 24 08 e1 47 81 	movl   $0x8147e1,0x8(%esp)
  80f505:	00 
  80f506:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80f50d:	00 
  80f50e:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f515:	e8 fa 13 ff ff       	call   800914 <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80f51a:	85 db                	test   %ebx,%ebx
  80f51c:	74 06                	je     80f524 <recv_udp+0x8b>
  80f51e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f522:	75 0e                	jne    80f532 <recv_udp+0x99>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80f524:	89 3c 24             	mov    %edi,(%esp)
  80f527:	e8 61 84 ff ff       	call   80798d <pbuf_free>
    return;
  80f52c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f530:	eb 6e                	jmp    80f5a0 <recv_udp+0x107>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80f532:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80f539:	e8 0a 7d ff ff       	call   807248 <memp_malloc>
  80f53e:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80f540:	85 c0                	test   %eax,%eax
  80f542:	75 0a                	jne    80f54e <recv_udp+0xb5>
    pbuf_free(p);
  80f544:	89 3c 24             	mov    %edi,(%esp)
  80f547:	e8 41 84 ff ff       	call   80798d <pbuf_free>
    return;
  80f54c:	eb 52                	jmp    80f5a0 <recv_udp+0x107>
  } else {
    buf->p = p;
  80f54e:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80f550:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80f553:	8b 45 14             	mov    0x14(%ebp),%eax
  80f556:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80f559:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80f55d:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80f561:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80f565:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80f569:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f56c:	85 c0                	test   %eax,%eax
  80f56e:	74 15                	je     80f585 <recv_udp+0xec>
  80f570:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80f574:	89 54 24 08          	mov    %edx,0x8(%esp)
  80f578:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f57f:	00 
  80f580:	89 1c 24             	mov    %ebx,(%esp)
  80f583:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80f585:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f589:	8b 43 14             	mov    0x14(%ebx),%eax
  80f58c:	89 04 24             	mov    %eax,(%esp)
  80f58f:	e8 93 e2 ff ff       	call   80d827 <sys_mbox_trypost>
  80f594:	84 c0                	test   %al,%al
  80f596:	74 08                	je     80f5a0 <recv_udp+0x107>
    netbuf_delete(buf);
  80f598:	89 34 24             	mov    %esi,(%esp)
  80f59b:	e8 0e 5b ff ff       	call   8050ae <netbuf_delete>
    return;
  }
}
  80f5a0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f5a3:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f5a6:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f5a9:	89 ec                	mov    %ebp,%esp
  80f5ab:	5d                   	pop    %ebp
  80f5ac:	c3                   	ret    

0080f5ad <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80f5ad:	55                   	push   %ebp
  80f5ae:	89 e5                	mov    %esp,%ebp
  80f5b0:	53                   	push   %ebx
  80f5b1:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80f5b4:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f5bb:	e8 88 7c ff ff       	call   807248 <memp_malloc>
  80f5c0:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80f5c2:	85 c0                	test   %eax,%eax
  80f5c4:	0f 84 92 00 00 00    	je     80f65c <netconn_alloc+0xaf>
    return NULL;
  }

  conn->err = ERR_OK;
  80f5ca:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80f5ce:	8b 45 08             	mov    0x8(%ebp),%eax
  80f5d1:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80f5d3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80f5da:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f5e1:	e8 ef de ff ff       	call   80d4d5 <sys_sem_new>
  80f5e6:	89 43 10             	mov    %eax,0x10(%ebx)
  80f5e9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f5ec:	75 17                	jne    80f605 <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  80f5ee:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f5f2:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f5f9:	e8 06 7c ff ff       	call   807204 <memp_free>
  80f5fe:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80f603:	eb 57                	jmp    80f65c <netconn_alloc+0xaf>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80f605:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f60c:	e8 4e df ff ff       	call   80d55f <sys_mbox_new>
  80f611:	89 43 14             	mov    %eax,0x14(%ebx)
  80f614:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f617:	75 22                	jne    80f63b <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  80f619:	8b 43 10             	mov    0x10(%ebx),%eax
  80f61c:	89 04 24             	mov    %eax,(%esp)
  80f61f:	e8 ef d9 ff ff       	call   80d013 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80f624:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f628:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80f62f:	e8 d0 7b ff ff       	call   807204 <memp_free>
  80f634:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80f639:	eb 21                	jmp    80f65c <netconn_alloc+0xaf>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80f63b:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80f642:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80f649:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80f650:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f653:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80f656:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80f65c:	89 d8                	mov    %ebx,%eax
  80f65e:	83 c4 14             	add    $0x14,%esp
  80f661:	5b                   	pop    %ebx
  80f662:	5d                   	pop    %ebp
  80f663:	c3                   	ret    

0080f664 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80f664:	55                   	push   %ebp
  80f665:	89 e5                	mov    %esp,%ebp
  80f667:	83 ec 28             	sub    $0x28,%esp
  80f66a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f66d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f670:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f673:	0f b6 7d 10          	movzbl 0x10(%ebp),%edi
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  80f677:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80f67a:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80f67e:	75 1c                	jne    80f69c <accept_function+0x38>
  80f680:	c7 44 24 08 00 49 81 	movl   $0x814900,0x8(%esp)
  80f687:	00 
  80f688:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80f68f:	00 
  80f690:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f697:	e8 78 12 ff ff       	call   800914 <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80f69c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f69f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f6a3:	8b 03                	mov    (%ebx),%eax
  80f6a5:	89 04 24             	mov    %eax,(%esp)
  80f6a8:	e8 00 ff ff ff       	call   80f5ad <netconn_alloc>
  80f6ad:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80f6af:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80f6b4:	85 f6                	test   %esi,%esi
  80f6b6:	74 55                	je     80f70d <accept_function+0xa9>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80f6b8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f6bb:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80f6be:	89 f0                	mov    %esi,%eax
  80f6c0:	e8 53 f1 ff ff       	call   80e818 <setup_tcp>
  newconn->err = err;
  80f6c5:	89 f8                	mov    %edi,%eax
  80f6c7:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80f6ca:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f6cd:	85 c0                	test   %eax,%eax
  80f6cf:	74 15                	je     80f6e6 <accept_function+0x82>
  80f6d1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f6d8:	00 
  80f6d9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f6e0:	00 
  80f6e1:	89 1c 24             	mov    %ebx,(%esp)
  80f6e4:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80f6e6:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f6ea:	8b 43 18             	mov    0x18(%ebx),%eax
  80f6ed:	89 04 24             	mov    %eax,(%esp)
  80f6f0:	e8 32 e1 ff ff       	call   80d827 <sys_mbox_trypost>
  80f6f5:	84 c0                	test   %al,%al
  80f6f7:	74 14                	je     80f70d <accept_function+0xa9>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80f6f9:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80f700:	89 34 24             	mov    %esi,(%esp)
  80f703:	e8 a9 fc ff ff       	call   80f3b1 <netconn_free>
  80f708:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  return ERR_OK;
}
  80f70d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f710:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f713:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f716:	89 ec                	mov    %ebp,%esp
  80f718:	5d                   	pop    %ebp
  80f719:	c3                   	ret    

0080f71a <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80f71a:	55                   	push   %ebp
  80f71b:	89 e5                	mov    %esp,%ebp
  80f71d:	83 ec 18             	sub    $0x18,%esp
  80f720:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f723:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f726:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80f729:	8b 03                	mov    (%ebx),%eax
  80f72b:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f72f:	0f 85 d5 00 00 00    	jne    80f80a <do_newconn+0xf0>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80f735:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80f739:	8b 33                	mov    (%ebx),%esi
  80f73b:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80f73f:	74 1c                	je     80f75d <do_newconn+0x43>
  80f741:	c7 44 24 08 2c 49 81 	movl   $0x81492c,0x8(%esp)
  80f748:	00 
  80f749:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80f750:	00 
  80f751:	c7 04 24 1d 47 81 00 	movl   $0x81471d,(%esp)
  80f758:	e8 b7 11 ff ff       	call   800914 <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80f75d:	8b 06                	mov    (%esi),%eax
  80f75f:	25 f0 00 00 00       	and    $0xf0,%eax
  80f764:	83 f8 20             	cmp    $0x20,%eax
  80f767:	74 45                	je     80f7ae <do_newconn+0x94>
  80f769:	83 f8 40             	cmp    $0x40,%eax
  80f76c:	74 0c                	je     80f77a <do_newconn+0x60>
  80f76e:	83 f8 10             	cmp    $0x10,%eax
  80f771:	0f 85 8f 00 00 00    	jne    80f806 <do_newconn+0xec>
  80f777:	90                   	nop
  80f778:	eb 6f                	jmp    80f7e9 <do_newconn+0xcf>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80f77a:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80f77e:	89 04 24             	mov    %eax,(%esp)
  80f781:	e8 29 1d 00 00       	call   8114af <raw_new>
  80f786:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80f789:	8b 03                	mov    (%ebx),%eax
  80f78b:	8b 50 08             	mov    0x8(%eax),%edx
  80f78e:	85 d2                	test   %edx,%edx
  80f790:	75 06                	jne    80f798 <do_newconn+0x7e>
       msg->conn->err = ERR_MEM;
  80f792:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f796:	eb 72                	jmp    80f80a <do_newconn+0xf0>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80f798:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f79c:	c7 44 24 04 21 f8 80 	movl   $0x80f821,0x4(%esp)
  80f7a3:	00 
  80f7a4:	89 14 24             	mov    %edx,(%esp)
  80f7a7:	e8 ef 1c 00 00       	call   81149b <raw_recv>
  80f7ac:	eb 5c                	jmp    80f80a <do_newconn+0xf0>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80f7ae:	e8 8c c3 ff ff       	call   80bb3f <udp_new>
  80f7b3:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80f7b6:	8b 03                	mov    (%ebx),%eax
  80f7b8:	8b 50 08             	mov    0x8(%eax),%edx
  80f7bb:	85 d2                	test   %edx,%edx
  80f7bd:	75 06                	jne    80f7c5 <do_newconn+0xab>
       msg->conn->err = ERR_MEM;
  80f7bf:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f7c3:	eb 45                	jmp    80f80a <do_newconn+0xf0>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80f7c5:	83 38 22             	cmpl   $0x22,(%eax)
  80f7c8:	75 04                	jne    80f7ce <do_newconn+0xb4>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80f7ca:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80f7ce:	8b 03                	mov    (%ebx),%eax
  80f7d0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f7d4:	c7 44 24 04 99 f4 80 	movl   $0x80f499,0x4(%esp)
  80f7db:	00 
  80f7dc:	8b 40 08             	mov    0x8(%eax),%eax
  80f7df:	89 04 24             	mov    %eax,(%esp)
  80f7e2:	e8 44 c3 ff ff       	call   80bb2b <udp_recv>
  80f7e7:	eb 21                	jmp    80f80a <do_newconn+0xf0>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80f7e9:	e8 6c 95 ff ff       	call   808d5a <tcp_new>
  80f7ee:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80f7f1:	8b 03                	mov    (%ebx),%eax
  80f7f3:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f7f7:	75 06                	jne    80f7ff <do_newconn+0xe5>
       msg->conn->err = ERR_MEM;
  80f7f9:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f7fd:	eb 0b                	jmp    80f80a <do_newconn+0xf0>
       break;
     }
     setup_tcp(msg->conn);
  80f7ff:	e8 14 f0 ff ff       	call   80e818 <setup_tcp>
  80f804:	eb 04                	jmp    80f80a <do_newconn+0xf0>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80f806:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80f80a:	8b 03                	mov    (%ebx),%eax
  80f80c:	8b 40 10             	mov    0x10(%eax),%eax
  80f80f:	89 04 24             	mov    %eax,(%esp)
  80f812:	e8 60 de ff ff       	call   80d677 <sys_sem_signal>
}
  80f817:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f81a:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f81d:	89 ec                	mov    %ebp,%esp
  80f81f:	5d                   	pop    %ebp
  80f820:	c3                   	ret    

0080f821 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80f821:	55                   	push   %ebp
  80f822:	89 e5                	mov    %esp,%ebp
  80f824:	83 ec 28             	sub    $0x28,%esp
  80f827:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f82a:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f82d:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f830:	8b 7d 10             	mov    0x10(%ebp),%edi
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  80f833:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80f836:	85 db                	test   %ebx,%ebx
  80f838:	0f 84 b0 00 00 00    	je     80f8ee <recv_raw+0xcd>
  80f83e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f842:	0f 84 a6 00 00 00    	je     80f8ee <recv_raw+0xcd>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80f848:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f84f:	00 
  80f850:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80f854:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f858:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80f85f:	e8 e5 83 ff ff       	call   807c49 <pbuf_alloc>
  80f864:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80f866:	85 c0                	test   %eax,%eax
  80f868:	0f 84 80 00 00 00    	je     80f8ee <recv_raw+0xcd>
      if (pbuf_copy(q, p) != ERR_OK) {
  80f86e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f872:	89 04 24             	mov    %eax,(%esp)
  80f875:	e8 6a 7f ff ff       	call   8077e4 <pbuf_copy>
  80f87a:	84 c0                	test   %al,%al
  80f87c:	0f 84 7e 00 00 00    	je     80f900 <recv_raw+0xdf>
        pbuf_free(q);
  80f882:	89 34 24             	mov    %esi,(%esp)
  80f885:	e8 03 81 ff ff       	call   80798d <pbuf_free>
  80f88a:	eb 62                	jmp    80f8ee <recv_raw+0xcd>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80f88c:	89 34 24             	mov    %esi,(%esp)
  80f88f:	e8 f9 80 ff ff       	call   80798d <pbuf_free>
        return 0;
  80f894:	eb 58                	jmp    80f8ee <recv_raw+0xcd>
      }

      buf->p = q;
  80f896:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80f898:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80f89b:	8b 46 04             	mov    0x4(%esi),%eax
  80f89e:	83 c0 0c             	add    $0xc,%eax
  80f8a1:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80f8a4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f8a7:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80f8ab:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80f8af:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f8b3:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80f8b7:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f8ba:	85 c0                	test   %eax,%eax
  80f8bc:	74 15                	je     80f8d3 <recv_raw+0xb2>
  80f8be:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80f8c2:	89 54 24 08          	mov    %edx,0x8(%esp)
  80f8c6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f8cd:	00 
  80f8ce:	89 1c 24             	mov    %ebx,(%esp)
  80f8d1:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80f8d3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f8d7:	8b 43 14             	mov    0x14(%ebx),%eax
  80f8da:	89 04 24             	mov    %eax,(%esp)
  80f8dd:	e8 45 df ff ff       	call   80d827 <sys_mbox_trypost>
  80f8e2:	84 c0                	test   %al,%al
  80f8e4:	74 08                	je     80f8ee <recv_raw+0xcd>
        netbuf_delete(buf);
  80f8e6:	89 3c 24             	mov    %edi,(%esp)
  80f8e9:	e8 c0 57 ff ff       	call   8050ae <netbuf_delete>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80f8ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80f8f3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f8f6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f8f9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f8fc:	89 ec                	mov    %ebp,%esp
  80f8fe:	5d                   	pop    %ebp
  80f8ff:	c3                   	ret    
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80f900:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80f907:	e8 3c 79 ff ff       	call   807248 <memp_malloc>
  80f90c:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80f90e:	85 c0                	test   %eax,%eax
  80f910:	75 84                	jne    80f896 <recv_raw+0x75>
  80f912:	e9 75 ff ff ff       	jmp    80f88c <recv_raw+0x6b>
	...

0080f920 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80f920:	55                   	push   %ebp
  80f921:	89 e5                	mov    %esp,%ebp
  80f923:	57                   	push   %edi
  80f924:	56                   	push   %esi
  80f925:	53                   	push   %ebx
  80f926:	83 ec 1c             	sub    $0x1c,%esp
  80f929:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80f92b:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80f930:	8d 70 14             	lea    0x14(%eax),%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80f933:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80f937:	89 04 24             	mov    %eax,(%esp)
  80f93a:	e8 51 ae ff ff       	call   80a790 <ntohs>
  80f93f:	66 c1 e8 0c          	shr    $0xc,%ax
  80f943:	bb 00 00 00 00       	mov    $0x0,%ebx
  80f948:	66 83 f8 05          	cmp    $0x5,%ax
  80f94c:	77 54                	ja     80f9a2 <tcp_parseopt+0x82>
  80f94e:	eb 78                	jmp    80f9c8 <tcp_parseopt+0xa8>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80f950:	0f b6 d3             	movzbl %bl,%edx
  80f953:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80f957:	84 c0                	test   %al,%al
  80f959:	74 6d                	je     80f9c8 <tcp_parseopt+0xa8>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80f95b:	3c 01                	cmp    $0x1,%al
  80f95d:	8d 76 00             	lea    0x0(%esi),%esi
  80f960:	75 05                	jne    80f967 <tcp_parseopt+0x47>
        ++c;
  80f962:	83 c3 01             	add    $0x1,%ebx
  80f965:	eb 3b                	jmp    80f9a2 <tcp_parseopt+0x82>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80f967:	3c 02                	cmp    $0x2,%al
  80f969:	75 2c                	jne    80f997 <tcp_parseopt+0x77>
        opts[c + 1] == 0x04) {
  80f96b:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80f970:	75 25                	jne    80f997 <tcp_parseopt+0x77>
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80f972:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80f977:	c1 e0 08             	shl    $0x8,%eax
  80f97a:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80f97f:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80f981:	8d 50 ff             	lea    -0x1(%eax),%edx
  80f984:	66 81 fa b4 05       	cmp    $0x5b4,%dx
  80f989:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80f98e:	0f 43 c2             	cmovae %edx,%eax
  80f991:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80f995:	eb 31                	jmp    80f9c8 <tcp_parseopt+0xa8>
      } else {
        if (opts[c + 1] == 0) {
  80f997:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80f99c:	84 c0                	test   %al,%al
  80f99e:	74 28                	je     80f9c8 <tcp_parseopt+0xa8>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80f9a0:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80f9a2:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80f9a7:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80f9ab:	89 04 24             	mov    %eax,(%esp)
  80f9ae:	e8 dd ad ff ff       	call   80a790 <ntohs>
  80f9b3:	0f b6 d3             	movzbl %bl,%edx
  80f9b6:	66 c1 e8 0c          	shr    $0xc,%ax
  80f9ba:	0f b7 c0             	movzwl %ax,%eax
  80f9bd:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80f9c4:	39 c2                	cmp    %eax,%edx
  80f9c6:	7c 88                	jl     80f950 <tcp_parseopt+0x30>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80f9c8:	83 c4 1c             	add    $0x1c,%esp
  80f9cb:	5b                   	pop    %ebx
  80f9cc:	5e                   	pop    %esi
  80f9cd:	5f                   	pop    %edi
  80f9ce:	5d                   	pop    %ebp
  80f9cf:	c3                   	ret    

0080f9d0 <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80f9d0:	55                   	push   %ebp
  80f9d1:	89 e5                	mov    %esp,%ebp
  80f9d3:	57                   	push   %edi
  80f9d4:	56                   	push   %esi
  80f9d5:	53                   	push   %ebx
  80f9d6:	83 ec 2c             	sub    $0x2c,%esp
  80f9d9:	89 c3                	mov    %eax,%ebx
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80f9db:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  80f9e2:	0f 84 6c 04 00 00    	je     80fe54 <tcp_receive+0x484>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80f9e8:	0f b7 70 5c          	movzwl 0x5c(%eax),%esi
  80f9ec:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80f9ef:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  80f9f4:	39 c2                	cmp    %eax,%edx
  80f9f6:	78 24                	js     80fa1c <tcp_receive+0x4c>
  80f9f8:	39 c2                	cmp    %eax,%edx
  80f9fa:	75 0a                	jne    80fa06 <tcp_receive+0x36>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80f9fc:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80fa01:	39 43 64             	cmp    %eax,0x64(%ebx)
  80fa04:	78 16                	js     80fa1c <tcp_receive+0x4c>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80fa06:	8b 43 64             	mov    0x64(%ebx),%eax
  80fa09:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  80fa0f:	75 3f                	jne    80fa50 <tcp_receive+0x80>
  80fa11:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80fa16:	66 3b 70 0e          	cmp    0xe(%eax),%si
  80fa1a:	73 34                	jae    80fa50 <tcp_receive+0x80>
      pcb->snd_wnd = tcphdr->wnd;
  80fa1c:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  80fa21:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  80fa25:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno;
  80fa29:	8b 0d f8 c1 b3 00    	mov    0xb3c1f8,%ecx
  80fa2f:	89 4b 60             	mov    %ecx,0x60(%ebx)
      pcb->snd_wl2 = ackno;
  80fa32:	8b 0d fc c1 b3 00    	mov    0xb3c1fc,%ecx
  80fa38:	89 4b 64             	mov    %ecx,0x64(%ebx)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80fa3b:	66 85 c0             	test   %ax,%ax
  80fa3e:	74 10                	je     80fa50 <tcp_receive+0x80>
  80fa40:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  80fa47:	74 07                	je     80fa50 <tcp_receive+0x80>
          pcb->persist_backoff = 0;
  80fa49:	c6 83 a4 00 00 00 00 	movb   $0x0,0xa4(%ebx)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80fa50:	8b 4b 48             	mov    0x48(%ebx),%ecx
  80fa53:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80fa58:	39 c1                	cmp    %eax,%ecx
  80fa5a:	0f 85 ab 00 00 00    	jne    80fb0b <tcp_receive+0x13b>
      pcb->acked = 0;
  80fa60:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80fa66:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  80fa6a:	03 43 60             	add    0x60(%ebx),%eax
  80fa6d:	0f b7 f6             	movzwl %si,%esi
  80fa70:	8d 14 16             	lea    (%esi,%edx,1),%edx
  80fa73:	39 d0                	cmp    %edx,%eax
  80fa75:	0f 85 fe 02 00 00    	jne    80fd79 <tcp_receive+0x3a9>
        ++pcb->dupacks;
  80fa7b:	0f b6 43 4c          	movzbl 0x4c(%ebx),%eax
  80fa7f:	83 c0 01             	add    $0x1,%eax
  80fa82:	88 43 4c             	mov    %al,0x4c(%ebx)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80fa85:	3c 02                	cmp    $0x2,%al
  80fa87:	0f 86 ec 02 00 00    	jbe    80fd79 <tcp_receive+0x3a9>
  80fa8d:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80fa91:	0f 84 e2 02 00 00    	je     80fd79 <tcp_receive+0x3a9>
          if (!(pcb->flags & TF_INFR)) {
  80fa97:	f6 43 20 04          	testb  $0x4,0x20(%ebx)
  80fa9b:	75 52                	jne    80faef <tcp_receive+0x11f>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80fa9d:	89 1c 24             	mov    %ebx,(%esp)
  80faa0:	e8 13 b8 ff ff       	call   80b2b8 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80faa5:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  80faa9:	0f b7 53 5c          	movzwl 0x5c(%ebx),%edx
  80faad:	66 39 d0             	cmp    %dx,%ax
  80fab0:	76 09                	jbe    80fabb <tcp_receive+0xeb>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80fab2:	66 d1 ea             	shr    %dx
  80fab5:	66 89 53 50          	mov    %dx,0x50(%ebx)
  80fab9:	eb 07                	jmp    80fac2 <tcp_receive+0xf2>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80fabb:	66 d1 e8             	shr    %ax
  80fabe:	66 89 43 50          	mov    %ax,0x50(%ebx)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80fac2:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80fac6:	0f b7 4b 50          	movzwl 0x50(%ebx),%ecx
  80faca:	0f b7 d0             	movzwl %ax,%edx
  80facd:	01 d2                	add    %edx,%edx
  80facf:	39 d1                	cmp    %edx,%ecx
  80fad1:	7d 06                	jge    80fad9 <tcp_receive+0x109>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80fad3:	01 c0                	add    %eax,%eax
  80fad5:	66 89 43 50          	mov    %ax,0x50(%ebx)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80fad9:	66 6b 43 34 03       	imul   $0x3,0x34(%ebx),%ax
  80fade:	66 03 43 50          	add    0x50(%ebx),%ax
  80fae2:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
            pcb->flags |= TF_INFR;
  80fae6:	80 4b 20 04          	orb    $0x4,0x20(%ebx)
  80faea:	e9 8a 02 00 00       	jmp    80fd79 <tcp_receive+0x3a9>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80faef:	0f b7 53 4e          	movzwl 0x4e(%ebx),%edx
  80faf3:	89 d0                	mov    %edx,%eax
  80faf5:	66 03 43 34          	add    0x34(%ebx),%ax
  80faf9:	66 39 c2             	cmp    %ax,%dx
  80fafc:	0f 83 77 02 00 00    	jae    80fd79 <tcp_receive+0x3a9>
              pcb->cwnd += pcb->mss;
  80fb02:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80fb06:	e9 6e 02 00 00       	jmp    80fd79 <tcp_receive+0x3a9>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80fb0b:	f7 d1                	not    %ecx
  80fb0d:	01 c1                	add    %eax,%ecx
  80fb0f:	0f 88 b2 01 00 00    	js     80fcc7 <tcp_receive+0x2f7>
  80fb15:	2b 43 58             	sub    0x58(%ebx),%eax
  80fb18:	85 c0                	test   %eax,%eax
  80fb1a:	0f 8f a7 01 00 00    	jg     80fcc7 <tcp_receive+0x2f7>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80fb20:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80fb24:	a8 04                	test   $0x4,%al
  80fb26:	74 0e                	je     80fb36 <tcp_receive+0x166>
        pcb->flags &= ~TF_INFR;
  80fb28:	83 e0 fb             	and    $0xfffffffb,%eax
  80fb2b:	88 43 20             	mov    %al,0x20(%ebx)
        pcb->cwnd = pcb->ssthresh;
  80fb2e:	0f b7 43 50          	movzwl 0x50(%ebx),%eax
  80fb32:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80fb36:	c6 43 46 00          	movb   $0x0,0x46(%ebx)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80fb3a:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  80fb3e:	66 c1 f8 03          	sar    $0x3,%ax
  80fb42:	66 03 43 42          	add    0x42(%ebx),%ax
  80fb46:	66 89 43 44          	mov    %ax,0x44(%ebx)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80fb4a:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80fb4f:	66 2b 43 48          	sub    0x48(%ebx),%ax
  80fb53:	66 89 43 6c          	mov    %ax,0x6c(%ebx)

      pcb->snd_buf += pcb->acked;
  80fb57:	66 01 43 6e          	add    %ax,0x6e(%ebx)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80fb5b:	c6 43 4c 00          	movb   $0x0,0x4c(%ebx)
      pcb->lastack = ackno;
  80fb5f:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80fb64:	89 43 48             	mov    %eax,0x48(%ebx)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80fb67:	83 7b 10 03          	cmpl   $0x3,0x10(%ebx)
  80fb6b:	0f 86 d3 00 00 00    	jbe    80fc44 <tcp_receive+0x274>
        if (pcb->cwnd < pcb->ssthresh) {
  80fb71:	0f b7 4b 4e          	movzwl 0x4e(%ebx),%ecx
  80fb75:	66 3b 4b 50          	cmp    0x50(%ebx),%cx
  80fb79:	73 18                	jae    80fb93 <tcp_receive+0x1c3>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80fb7b:	89 c8                	mov    %ecx,%eax
  80fb7d:	66 03 43 34          	add    0x34(%ebx),%ax
  80fb81:	66 39 c1             	cmp    %ax,%cx
  80fb84:	0f 83 ba 00 00 00    	jae    80fc44 <tcp_receive+0x274>
            pcb->cwnd += pcb->mss;
  80fb8a:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80fb8e:	e9 b1 00 00 00       	jmp    80fc44 <tcp_receive+0x274>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80fb93:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80fb97:	0f af d2             	imul   %edx,%edx
  80fb9a:	0f b7 f1             	movzwl %cx,%esi
  80fb9d:	89 d0                	mov    %edx,%eax
  80fb9f:	c1 fa 1f             	sar    $0x1f,%edx
  80fba2:	f7 fe                	idiv   %esi
  80fba4:	8d 04 01             	lea    (%ecx,%eax,1),%eax
          if (new_cwnd > pcb->cwnd) {
  80fba7:	66 39 c1             	cmp    %ax,%cx
  80fbaa:	0f 83 94 00 00 00    	jae    80fc44 <tcp_receive+0x274>
            pcb->cwnd = new_cwnd;
  80fbb0:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  80fbb4:	e9 8b 00 00 00       	jmp    80fc44 <tcp_receive+0x274>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80fbb9:	8b 73 78             	mov    0x78(%ebx),%esi
        pcb->unacked = pcb->unacked->next;
  80fbbc:	8b 06                	mov    (%esi),%eax
  80fbbe:	89 43 78             	mov    %eax,0x78(%ebx)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80fbc1:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80fbc5:	8b 46 04             	mov    0x4(%esi),%eax
  80fbc8:	89 04 24             	mov    %eax,(%esp)
  80fbcb:	e8 60 79 ff ff       	call   807530 <pbuf_clen>
  80fbd0:	0f b6 c0             	movzbl %al,%eax
  80fbd3:	66 39 c7             	cmp    %ax,%di
  80fbd6:	73 1c                	jae    80fbf4 <tcp_receive+0x224>
  80fbd8:	c7 44 24 08 4c 49 81 	movl   $0x81494c,0x8(%esp)
  80fbdf:	00 
  80fbe0:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  80fbe7:	00 
  80fbe8:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fbef:	e8 20 0d ff ff       	call   800914 <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80fbf4:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80fbf8:	8b 46 04             	mov    0x4(%esi),%eax
  80fbfb:	89 04 24             	mov    %eax,(%esp)
  80fbfe:	e8 2d 79 ff ff       	call   807530 <pbuf_clen>
  80fc03:	0f b6 c0             	movzbl %al,%eax
  80fc06:	66 29 c7             	sub    %ax,%di
  80fc09:	66 89 7b 70          	mov    %di,0x70(%ebx)
        tcp_seg_free(next);
  80fc0d:	89 34 24             	mov    %esi,(%esp)
  80fc10:	e8 ec 88 ff ff       	call   808501 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80fc15:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  80fc1a:	74 28                	je     80fc44 <tcp_receive+0x274>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80fc1c:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80fc20:	75 22                	jne    80fc44 <tcp_receive+0x274>
  80fc22:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  80fc26:	75 1c                	jne    80fc44 <tcp_receive+0x274>
  80fc28:	c7 44 24 08 74 49 81 	movl   $0x814974,0x8(%esp)
  80fc2f:	00 
  80fc30:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  80fc37:	00 
  80fc38:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fc3f:	e8 d0 0c ff ff       	call   800914 <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80fc44:	8b 43 78             	mov    0x78(%ebx),%eax
  80fc47:	85 c0                	test   %eax,%eax
  80fc49:	74 65                	je     80fcb0 <tcp_receive+0x2e0>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80fc4b:	8b 40 10             	mov    0x10(%eax),%eax
  80fc4e:	8b 40 04             	mov    0x4(%eax),%eax
  80fc51:	89 04 24             	mov    %eax,(%esp)
  80fc54:	e8 6c ad ff ff       	call   80a9c5 <ntohl>
  80fc59:	89 c6                	mov    %eax,%esi
  80fc5b:	8b 43 78             	mov    0x78(%ebx),%eax
  80fc5e:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  80fc62:	8b 40 10             	mov    0x10(%eax),%eax
  80fc65:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fc69:	89 04 24             	mov    %eax,(%esp)
  80fc6c:	e8 1f ab ff ff       	call   80a790 <ntohs>
  80fc71:	a8 01                	test   $0x1,%al
  80fc73:	75 1b                	jne    80fc90 <tcp_receive+0x2c0>
  80fc75:	8b 43 78             	mov    0x78(%ebx),%eax
  80fc78:	8b 40 10             	mov    0x10(%eax),%eax
  80fc7b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fc7f:	89 04 24             	mov    %eax,(%esp)
  80fc82:	e8 09 ab ff ff       	call   80a790 <ntohs>
  80fc87:	ba 00 00 00 00       	mov    $0x0,%edx
  80fc8c:	a8 02                	test   $0x2,%al
  80fc8e:	74 05                	je     80fc95 <tcp_receive+0x2c5>
  80fc90:	ba 01 00 00 00       	mov    $0x1,%edx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80fc95:	2b 35 fc c1 b3 00    	sub    0xb3c1fc,%esi
  80fc9b:	0f b7 ff             	movzwl %di,%edi
  80fc9e:	01 fa                	add    %edi,%edx
  80fca0:	01 d6                	add    %edx,%esi
  80fca2:	85 f6                	test   %esi,%esi
  80fca4:	0f 8e 0f ff ff ff    	jle    80fbb9 <tcp_receive+0x1e9>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80fcaa:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80fcae:	75 08                	jne    80fcb8 <tcp_receive+0x2e8>
        pcb->rtime = -1;
  80fcb0:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80fcb6:	eb 06                	jmp    80fcbe <tcp_receive+0x2ee>
      else
        pcb->rtime = 0;
  80fcb8:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

      pcb->polltmr = 0;
  80fcbe:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80fcc2:	e9 b2 00 00 00       	jmp    80fd79 <tcp_receive+0x3a9>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80fcc7:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)
  80fccd:	8d 76 00             	lea    0x0(%esi),%esi
  80fcd0:	e9 a4 00 00 00       	jmp    80fd79 <tcp_receive+0x3a9>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80fcd5:	8b 73 74             	mov    0x74(%ebx),%esi
      pcb->unsent = pcb->unsent->next;
  80fcd8:	8b 06                	mov    (%esi),%eax
  80fcda:	89 43 74             	mov    %eax,0x74(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80fcdd:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80fce1:	8b 46 04             	mov    0x4(%esi),%eax
  80fce4:	89 04 24             	mov    %eax,(%esp)
  80fce7:	e8 44 78 ff ff       	call   807530 <pbuf_clen>
  80fcec:	0f b6 c0             	movzbl %al,%eax
  80fcef:	66 39 c7             	cmp    %ax,%di
  80fcf2:	73 1c                	jae    80fd10 <tcp_receive+0x340>
  80fcf4:	c7 44 24 08 4c 49 81 	movl   $0x81494c,0x8(%esp)
  80fcfb:	00 
  80fcfc:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  80fd03:	00 
  80fd04:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fd0b:	e8 04 0c ff ff       	call   800914 <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80fd10:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  80fd14:	8b 46 04             	mov    0x4(%esi),%eax
  80fd17:	89 04 24             	mov    %eax,(%esp)
  80fd1a:	e8 11 78 ff ff       	call   807530 <pbuf_clen>
  80fd1f:	0f b6 c0             	movzbl %al,%eax
  80fd22:	66 29 c7             	sub    %ax,%di
  80fd25:	66 89 7b 70          	mov    %di,0x70(%ebx)
      tcp_seg_free(next);
  80fd29:	89 34 24             	mov    %esi,(%esp)
  80fd2c:	e8 d0 87 ff ff       	call   808501 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80fd31:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  80fd36:	74 29                	je     80fd61 <tcp_receive+0x391>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80fd38:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80fd3c:	75 23                	jne    80fd61 <tcp_receive+0x391>
  80fd3e:	8b 43 74             	mov    0x74(%ebx),%eax
  80fd41:	85 c0                	test   %eax,%eax
  80fd43:	75 23                	jne    80fd68 <tcp_receive+0x398>
  80fd45:	c7 44 24 08 74 49 81 	movl   $0x814974,0x8(%esp)
  80fd4c:	00 
  80fd4d:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  80fd54:	00 
  80fd55:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fd5c:	e8 b3 0b ff ff       	call   800914 <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80fd61:	8b 43 74             	mov    0x74(%ebx),%eax
  80fd64:	85 c0                	test   %eax,%eax
  80fd66:	74 11                	je     80fd79 <tcp_receive+0x3a9>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80fd68:	8b 40 10             	mov    0x10(%eax),%eax
  80fd6b:	8b 40 04             	mov    0x4(%eax),%eax
  80fd6e:	89 04 24             	mov    %eax,(%esp)
  80fd71:	e8 2e aa ff ff       	call   80a7a4 <htonl>
  80fd76:	89 43 54             	mov    %eax,0x54(%ebx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80fd79:	8b 43 74             	mov    0x74(%ebx),%eax
  80fd7c:	85 c0                	test   %eax,%eax
  80fd7e:	74 70                	je     80fdf0 <tcp_receive+0x420>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80fd80:	8b 35 fc c1 b3 00    	mov    0xb3c1fc,%esi
  80fd86:	8b 40 10             	mov    0x10(%eax),%eax
  80fd89:	8b 40 04             	mov    0x4(%eax),%eax
  80fd8c:	89 04 24             	mov    %eax,(%esp)
  80fd8f:	e8 31 ac ff ff       	call   80a9c5 <ntohl>
  80fd94:	89 c7                	mov    %eax,%edi
  80fd96:	8b 43 74             	mov    0x74(%ebx),%eax
  80fd99:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  80fd9d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  80fda1:	8b 40 10             	mov    0x10(%eax),%eax
  80fda4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fda8:	89 04 24             	mov    %eax,(%esp)
  80fdab:	e8 e0 a9 ff ff       	call   80a790 <ntohs>
  80fdb0:	a8 01                	test   $0x1,%al
  80fdb2:	75 1b                	jne    80fdcf <tcp_receive+0x3ff>
  80fdb4:	8b 43 74             	mov    0x74(%ebx),%eax
  80fdb7:	8b 40 10             	mov    0x10(%eax),%eax
  80fdba:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fdbe:	89 04 24             	mov    %eax,(%esp)
  80fdc1:	e8 ca a9 ff ff       	call   80a790 <ntohs>
  80fdc6:	ba 00 00 00 00       	mov    $0x0,%edx
  80fdcb:	a8 02                	test   $0x2,%al
  80fdcd:	74 05                	je     80fdd4 <tcp_receive+0x404>
  80fdcf:	ba 01 00 00 00       	mov    $0x1,%edx
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80fdd4:	29 fe                	sub    %edi,%esi
  80fdd6:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80fdda:	01 c2                	add    %eax,%edx
  80fddc:	39 d6                	cmp    %edx,%esi
  80fdde:	78 10                	js     80fdf0 <tcp_receive+0x420>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80fde0:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  80fde5:	2b 43 58             	sub    0x58(%ebx),%eax
  80fde8:	85 c0                	test   %eax,%eax
  80fdea:	0f 8e e5 fe ff ff    	jle    80fcd5 <tcp_receive+0x305>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80fdf0:	8b 43 38             	mov    0x38(%ebx),%eax
  80fdf3:	85 c0                	test   %eax,%eax
  80fdf5:	74 5d                	je     80fe54 <tcp_receive+0x484>
  80fdf7:	8b 35 fc c1 b3 00    	mov    0xb3c1fc,%esi
  80fdfd:	39 73 3c             	cmp    %esi,0x3c(%ebx)
  80fe00:	79 52                	jns    80fe54 <tcp_receive+0x484>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80fe02:	0f b7 53 40          	movzwl 0x40(%ebx),%edx
  80fe06:	8b 0d 10 f0 b3 00    	mov    0xb3f010,%ecx
  80fe0c:	66 29 c1             	sub    %ax,%cx
  80fe0f:	89 c8                	mov    %ecx,%eax
  80fe11:	89 d1                	mov    %edx,%ecx
  80fe13:	66 c1 f9 03          	sar    $0x3,%cx
  80fe17:	66 29 c8             	sub    %cx,%ax
      pcb->sa += m;
  80fe1a:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80fe1d:	66 89 53 40          	mov    %dx,0x40(%ebx)
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
  80fe21:	0f b7 4b 42          	movzwl 0x42(%ebx),%ecx
      pcb->sv += m;
  80fe25:	89 ce                	mov    %ecx,%esi
  80fe27:	66 c1 fe 02          	sar    $0x2,%si
  80fe2b:	66 29 f1             	sub    %si,%cx
  80fe2e:	89 ce                	mov    %ecx,%esi
  80fe30:	89 c1                	mov    %eax,%ecx
  80fe32:	66 c1 f9 0f          	sar    $0xf,%cx
  80fe36:	31 c8                	xor    %ecx,%eax
  80fe38:	66 29 c8             	sub    %cx,%ax
  80fe3b:	8d 04 06             	lea    (%esi,%eax,1),%eax
  80fe3e:	66 89 43 42          	mov    %ax,0x42(%ebx)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80fe42:	66 c1 fa 03          	sar    $0x3,%dx
  80fe46:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80fe49:	66 89 43 44          	mov    %ax,0x44(%ebx)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80fe4d:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80fe54:	0f b7 0d 02 c2 b3 00 	movzwl 0xb3c202,%ecx
  80fe5b:	66 85 c9             	test   %cx,%cx
  80fe5e:	0f 84 a5 07 00 00    	je     810609 <tcp_receive+0xc39>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80fe64:	8b 53 24             	mov    0x24(%ebx),%edx
  80fe67:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  80fe6c:	89 c6                	mov    %eax,%esi
  80fe6e:	f7 d6                	not    %esi
  80fe70:	01 d6                	add    %edx,%esi
  80fe72:	0f 88 3a 01 00 00    	js     80ffb2 <tcp_receive+0x5e2>
  80fe78:	8d 7a 01             	lea    0x1(%edx),%edi
  80fe7b:	29 c7                	sub    %eax,%edi
  80fe7d:	0f b7 f1             	movzwl %cx,%esi
  80fe80:	89 f9                	mov    %edi,%ecx
  80fe82:	29 f1                	sub    %esi,%ecx
  80fe84:	85 c9                	test   %ecx,%ecx
  80fe86:	0f 8f 26 01 00 00    	jg     80ffb2 <tcp_receive+0x5e2>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
  80fe8c:	8b 35 e0 c1 b3 00    	mov    0xb3c1e0,%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80fe92:	85 f6                	test   %esi,%esi
  80fe94:	75 1c                	jne    80feb2 <tcp_receive+0x4e2>
  80fe96:	c7 44 24 08 cf 4a 81 	movl   $0x814acf,0x8(%esp)
  80fe9d:	00 
  80fe9e:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  80fea5:	00 
  80fea6:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fead:	e8 62 0a ff ff       	call   800914 <_panic>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80feb2:	29 c2                	sub    %eax,%edx
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80feb4:	81 fa fe 7f 00 00    	cmp    $0x7ffe,%edx
  80feba:	7e 1c                	jle    80fed8 <tcp_receive+0x508>
  80febc:	c7 44 24 08 df 4a 81 	movl   $0x814adf,0x8(%esp)
  80fec3:	00 
  80fec4:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  80fecb:	00 
  80fecc:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80fed3:	e8 3c 0a ff ff       	call   800914 <_panic>
      if (inseg.p->len < off) {
  80fed8:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80fedc:	39 c2                	cmp    %eax,%edx
  80fede:	7e 71                	jle    80ff51 <tcp_receive+0x581>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80fee0:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  80fee4:	0f b7 f9             	movzwl %cx,%edi
  80fee7:	39 fa                	cmp    %edi,%edx
  80fee9:	7e 1c                	jle    80ff07 <tcp_receive+0x537>
  80feeb:	c7 44 24 08 ee 4a 81 	movl   $0x814aee,0x8(%esp)
  80fef2:	00 
  80fef3:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  80fefa:	00 
  80fefb:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80ff02:	e8 0d 0a ff ff       	call   800914 <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80ff07:	66 29 d1             	sub    %dx,%cx
        while (p->len < off) {
          off -= p->len;
  80ff0a:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80ff0c:	66 89 4e 08          	mov    %cx,0x8(%esi)
          p->len = 0;
  80ff10:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
          p = p->next;
  80ff16:	8b 36                	mov    (%esi),%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80ff18:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80ff1c:	39 d0                	cmp    %edx,%eax
  80ff1e:	7c ea                	jl     80ff0a <tcp_receive+0x53a>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80ff20:	f7 da                	neg    %edx
  80ff22:	0f bf c2             	movswl %dx,%eax
  80ff25:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ff29:	89 34 24             	mov    %esi,(%esp)
  80ff2c:	e8 f2 76 ff ff       	call   807623 <pbuf_header>
  80ff31:	84 c0                	test   %al,%al
  80ff33:	74 4d                	je     80ff82 <tcp_receive+0x5b2>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80ff35:	c7 44 24 08 fe 4a 81 	movl   $0x814afe,0x8(%esp)
  80ff3c:	00 
  80ff3d:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  80ff44:	00 
  80ff45:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80ff4c:	e8 c3 09 ff ff       	call   800914 <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80ff51:	f7 da                	neg    %edx
  80ff53:	0f bf c2             	movswl %dx,%eax
  80ff56:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ff5a:	89 34 24             	mov    %esi,(%esp)
  80ff5d:	e8 c1 76 ff ff       	call   807623 <pbuf_header>
  80ff62:	84 c0                	test   %al,%al
  80ff64:	74 1c                	je     80ff82 <tcp_receive+0x5b2>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80ff66:	c7 44 24 08 fe 4a 81 	movl   $0x814afe,0x8(%esp)
  80ff6d:	00 
  80ff6e:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  80ff75:	00 
  80ff76:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  80ff7d:	e8 92 09 ff ff       	call   800914 <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80ff82:	8b 46 04             	mov    0x4(%esi),%eax
  80ff85:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80ff8a:	b8 e8 c1 b3 00       	mov    $0xb3c1e8,%eax
  80ff8f:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  80ff95:	66 03 10             	add    (%eax),%dx
  80ff98:	66 2b 53 24          	sub    0x24(%ebx),%dx
  80ff9c:	66 89 10             	mov    %dx,(%eax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80ff9f:	8b 43 24             	mov    0x24(%ebx),%eax
  80ffa2:	a3 f8 c1 b3 00       	mov    %eax,0xb3c1f8
  80ffa7:	8b 15 ec c1 b3 00    	mov    0xb3c1ec,%edx
  80ffad:	89 42 04             	mov    %eax,0x4(%edx)
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80ffb0:	eb 10                	jmp    80ffc2 <tcp_receive+0x5f2>
      inseg.dataptr = p->payload;
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80ffb2:	39 d0                	cmp    %edx,%eax
  80ffb4:	79 1c                	jns    80ffd2 <tcp_receive+0x602>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80ffb6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80ffba:	89 1c 24             	mov    %ebx,(%esp)
  80ffbd:	e8 49 ae ff ff       	call   80ae0b <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80ffc2:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  80ffc7:	8b 53 24             	mov    0x24(%ebx),%edx
  80ffca:	39 d0                	cmp    %edx,%eax
  80ffcc:	0f 88 24 06 00 00    	js     8105f6 <tcp_receive+0xc26>
  80ffd2:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80ffd6:	89 c7                	mov    %eax,%edi
  80ffd8:	29 cf                	sub    %ecx,%edi
  80ffda:	8d 4f 01             	lea    0x1(%edi),%ecx
  80ffdd:	29 d1                	sub    %edx,%ecx
  80ffdf:	85 c9                	test   %ecx,%ecx
  80ffe1:	0f 8f 0f 06 00 00    	jg     8105f6 <tcp_receive+0xc26>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80ffe7:	39 d0                	cmp    %edx,%eax
  80ffe9:	0f 85 95 03 00 00    	jne    810384 <tcp_receive+0x9b4>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80ffef:	8b 53 7c             	mov    0x7c(%ebx),%edx
  80fff2:	85 d2                	test   %edx,%edx
  80fff4:	0f 84 86 00 00 00    	je     810080 <tcp_receive+0x6b0>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80fffa:	8b 4a 10             	mov    0x10(%edx),%ecx
  80fffd:	8b 49 04             	mov    0x4(%ecx),%ecx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  810000:	0f b7 35 e8 c1 b3 00 	movzwl 0xb3c1e8,%esi
  810007:	89 cf                	mov    %ecx,%edi
  810009:	29 f7                	sub    %esi,%edi
  81000b:	89 fe                	mov    %edi,%esi
  81000d:	29 c6                	sub    %eax,%esi
  81000f:	85 f6                	test   %esi,%esi
  810011:	7f 6d                	jg     810080 <tcp_receive+0x6b0>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  810013:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  810018:	74 20                	je     81003a <tcp_receive+0x66a>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81001a:	66 29 c1             	sub    %ax,%cx
  81001d:	66 89 0d e8 c1 b3 00 	mov    %cx,0xb3c1e8
            pbuf_realloc(inseg.p, inseg.len);
  810024:	0f b7 c1             	movzwl %cx,%eax
  810027:	89 44 24 04          	mov    %eax,0x4(%esp)
  81002b:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  810030:	89 04 24             	mov    %eax,(%esp)
  810033:	e8 e1 7a ff ff       	call   807b19 <pbuf_realloc>
  810038:	eb 46                	jmp    810080 <tcp_receive+0x6b0>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  81003a:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  81003f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810043:	89 04 24             	mov    %eax,(%esp)
  810046:	e8 45 a7 ff ff       	call   80a790 <ntohs>
  81004b:	89 c6                	mov    %eax,%esi
  81004d:	8b 43 7c             	mov    0x7c(%ebx),%eax
  810050:	8b 40 10             	mov    0x10(%eax),%eax
  810053:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810057:	89 04 24             	mov    %eax,(%esp)
  81005a:	e8 31 a7 ff ff       	call   80a790 <ntohs>
  81005f:	31 c6                	xor    %eax,%esi
  810061:	66 f7 c6 03 00       	test   $0x3,%si
  810066:	75 18                	jne    810080 <tcp_receive+0x6b0>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  810068:	8b 43 7c             	mov    0x7c(%ebx),%eax
              pcb->ooseq = pcb->ooseq->next;
  81006b:	8b 10                	mov    (%eax),%edx
  81006d:	89 53 7c             	mov    %edx,0x7c(%ebx)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  810070:	89 44 24 04          	mov    %eax,0x4(%esp)
  810074:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  81007b:	e8 84 71 ff ff       	call   807204 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  810080:	0f b7 35 e8 c1 b3 00 	movzwl 0xb3c1e8,%esi
  810087:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  81008c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810090:	89 04 24             	mov    %eax,(%esp)
  810093:	e8 f8 a6 ff ff       	call   80a790 <ntohs>
  810098:	a8 01                	test   $0x1,%al
  81009a:	75 1a                	jne    8100b6 <tcp_receive+0x6e6>
  81009c:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  8100a1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8100a5:	89 04 24             	mov    %eax,(%esp)
  8100a8:	e8 e3 a6 ff ff       	call   80a790 <ntohs>
  8100ad:	ba 00 00 00 00       	mov    $0x0,%edx
  8100b2:	a8 02                	test   $0x2,%al
  8100b4:	74 05                	je     8100bb <tcp_receive+0x6eb>
  8100b6:	ba 01 00 00 00       	mov    $0x1,%edx
  8100bb:	01 d6                	add    %edx,%esi
  8100bd:	66 89 35 02 c2 b3 00 	mov    %si,0xb3c202

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  8100c4:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8100c8:	74 06                	je     8100d0 <tcp_receive+0x700>
          pcb->rcv_nxt += tcplen;
  8100ca:	0f b7 f6             	movzwl %si,%esi
  8100cd:	01 73 24             	add    %esi,0x24(%ebx)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  8100d0:	0f b7 53 28          	movzwl 0x28(%ebx),%edx
  8100d4:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  8100db:	66 39 c2             	cmp    %ax,%dx
  8100de:	73 08                	jae    8100e8 <tcp_receive+0x718>
          pcb->rcv_wnd = 0;
  8100e0:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  8100e6:	eb 07                	jmp    8100ef <tcp_receive+0x71f>
        } else {
          pcb->rcv_wnd -= tcplen;
  8100e8:	66 29 c2             	sub    %ax,%dx
  8100eb:	66 89 53 28          	mov    %dx,0x28(%ebx)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  8100ef:	0f b7 53 2a          	movzwl 0x2a(%ebx),%edx
  8100f3:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  8100fa:	66 39 c2             	cmp    %ax,%dx
  8100fd:	73 08                	jae    810107 <tcp_receive+0x737>
          pcb->rcv_ann_wnd = 0;
  8100ff:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  810105:	eb 07                	jmp    81010e <tcp_receive+0x73e>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  810107:	66 29 c2             	sub    %ax,%dx
  81010a:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  81010e:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  810113:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  810118:	74 0f                	je     810129 <tcp_receive+0x759>
          recv_data = inseg.p;
  81011a:	a3 08 c2 b3 00       	mov    %eax,0xb3c208
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  81011f:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  810126:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  810129:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  81012e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810132:	89 04 24             	mov    %eax,(%esp)
  810135:	e8 56 a6 ff ff       	call   80a790 <ntohs>
  81013a:	a8 01                	test   $0x1,%al
  81013c:	74 07                	je     810145 <tcp_receive+0x775>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  81013e:	c6 05 04 c2 b3 00 20 	movb   $0x20,0xb3c204
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  810145:	8b 73 7c             	mov    0x7c(%ebx),%esi
  810148:	85 f6                	test   %esi,%esi
  81014a:	0f 84 01 02 00 00    	je     810351 <tcp_receive+0x981>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  810150:	8b 46 10             	mov    0x10(%esi),%eax
  810153:	8b 40 04             	mov    0x4(%eax),%eax
  810156:	3b 43 24             	cmp    0x24(%ebx),%eax
  810159:	0f 85 f2 01 00 00    	jne    810351 <tcp_receive+0x981>

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  81015f:	a3 f8 c1 b3 00       	mov    %eax,0xb3c1f8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  810164:	8b 43 24             	mov    0x24(%ebx),%eax
  810167:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  81016a:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  81016e:	8b 46 10             	mov    0x10(%esi),%eax
  810171:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810175:	89 04 24             	mov    %eax,(%esp)
  810178:	e8 13 a6 ff ff       	call   80a790 <ntohs>
  81017d:	a8 01                	test   $0x1,%al
  81017f:	75 18                	jne    810199 <tcp_receive+0x7c9>
  810181:	8b 46 10             	mov    0x10(%esi),%eax
  810184:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810188:	89 04 24             	mov    %eax,(%esp)
  81018b:	e8 00 a6 ff ff       	call   80a790 <ntohs>
  810190:	ba 00 00 00 00       	mov    $0x0,%edx
  810195:	a8 02                	test   $0x2,%al
  810197:	74 05                	je     81019e <tcp_receive+0x7ce>
  810199:	ba 01 00 00 00       	mov    $0x1,%edx
  81019e:	0f b7 ff             	movzwl %di,%edi
  8101a1:	01 fa                	add    %edi,%edx
  8101a3:	03 55 e4             	add    -0x1c(%ebp),%edx
  8101a6:	89 53 24             	mov    %edx,0x24(%ebx)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  8101a9:	0f b7 7b 28          	movzwl 0x28(%ebx),%edi
  8101ad:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  8101b1:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  8101b5:	8b 46 10             	mov    0x10(%esi),%eax
  8101b8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8101bc:	89 04 24             	mov    %eax,(%esp)
  8101bf:	e8 cc a5 ff ff       	call   80a790 <ntohs>
  8101c4:	a8 01                	test   $0x1,%al
  8101c6:	75 18                	jne    8101e0 <tcp_receive+0x810>
  8101c8:	8b 46 10             	mov    0x10(%esi),%eax
  8101cb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8101cf:	89 04 24             	mov    %eax,(%esp)
  8101d2:	e8 b9 a5 ff ff       	call   80a790 <ntohs>
  8101d7:	ba 00 00 00 00       	mov    $0x0,%edx
  8101dc:	a8 02                	test   $0x2,%al
  8101de:	74 05                	je     8101e5 <tcp_receive+0x815>
  8101e0:	ba 01 00 00 00       	mov    $0x1,%edx
  8101e5:	0f b7 ff             	movzwl %di,%edi
  8101e8:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8101ec:	01 c2                	add    %eax,%edx
  8101ee:	39 d7                	cmp    %edx,%edi
  8101f0:	7d 08                	jge    8101fa <tcp_receive+0x82a>
            pcb->rcv_wnd = 0;
  8101f2:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  8101f8:	eb 47                	jmp    810241 <tcp_receive+0x871>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  8101fa:	0f b7 7b 28          	movzwl 0x28(%ebx),%edi
  8101fe:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  810202:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  810206:	8b 46 10             	mov    0x10(%esi),%eax
  810209:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81020d:	89 04 24             	mov    %eax,(%esp)
  810210:	e8 7b a5 ff ff       	call   80a790 <ntohs>
  810215:	a8 01                	test   $0x1,%al
  810217:	75 18                	jne    810231 <tcp_receive+0x861>
  810219:	8b 46 10             	mov    0x10(%esi),%eax
  81021c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810220:	89 04 24             	mov    %eax,(%esp)
  810223:	e8 68 a5 ff ff       	call   80a790 <ntohs>
  810228:	ba 00 00 00 00       	mov    $0x0,%edx
  81022d:	a8 02                	test   $0x2,%al
  81022f:	74 05                	je     810236 <tcp_receive+0x866>
  810231:	ba 01 00 00 00       	mov    $0x1,%edx
  810236:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  81023a:	66 29 d7             	sub    %dx,%di
  81023d:	66 89 7b 28          	mov    %di,0x28(%ebx)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  810241:	0f b7 7b 2a          	movzwl 0x2a(%ebx),%edi
  810245:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  810249:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  81024d:	8b 46 10             	mov    0x10(%esi),%eax
  810250:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810254:	89 04 24             	mov    %eax,(%esp)
  810257:	e8 34 a5 ff ff       	call   80a790 <ntohs>
  81025c:	a8 01                	test   $0x1,%al
  81025e:	75 18                	jne    810278 <tcp_receive+0x8a8>
  810260:	8b 46 10             	mov    0x10(%esi),%eax
  810263:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810267:	89 04 24             	mov    %eax,(%esp)
  81026a:	e8 21 a5 ff ff       	call   80a790 <ntohs>
  81026f:	ba 00 00 00 00       	mov    $0x0,%edx
  810274:	a8 02                	test   $0x2,%al
  810276:	74 05                	je     81027d <tcp_receive+0x8ad>
  810278:	ba 01 00 00 00       	mov    $0x1,%edx
  81027d:	0f b7 ff             	movzwl %di,%edi
  810280:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  810284:	01 c2                	add    %eax,%edx
  810286:	39 d7                	cmp    %edx,%edi
  810288:	7d 08                	jge    810292 <tcp_receive+0x8c2>
            pcb->rcv_ann_wnd = 0;
  81028a:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  810290:	eb 47                	jmp    8102d9 <tcp_receive+0x909>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  810292:	0f b7 7b 2a          	movzwl 0x2a(%ebx),%edi
  810296:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  81029a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  81029e:	8b 46 10             	mov    0x10(%esi),%eax
  8102a1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8102a5:	89 04 24             	mov    %eax,(%esp)
  8102a8:	e8 e3 a4 ff ff       	call   80a790 <ntohs>
  8102ad:	a8 01                	test   $0x1,%al
  8102af:	75 18                	jne    8102c9 <tcp_receive+0x8f9>
  8102b1:	8b 46 10             	mov    0x10(%esi),%eax
  8102b4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8102b8:	89 04 24             	mov    %eax,(%esp)
  8102bb:	e8 d0 a4 ff ff       	call   80a790 <ntohs>
  8102c0:	ba 00 00 00 00       	mov    $0x0,%edx
  8102c5:	a8 02                	test   $0x2,%al
  8102c7:	74 05                	je     8102ce <tcp_receive+0x8fe>
  8102c9:	ba 01 00 00 00       	mov    $0x1,%edx
  8102ce:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  8102d2:	66 29 d7             	sub    %dx,%di
  8102d5:	66 89 7b 2a          	mov    %di,0x2a(%ebx)
          }

          if (cseg->p->tot_len > 0) {
  8102d9:	8b 46 04             	mov    0x4(%esi),%eax
  8102dc:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  8102e1:	74 24                	je     810307 <tcp_receive+0x937>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  8102e3:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  8102e9:	85 d2                	test   %edx,%edx
  8102eb:	74 0e                	je     8102fb <tcp_receive+0x92b>
              pbuf_cat(recv_data, cseg->p);
  8102ed:	89 44 24 04          	mov    %eax,0x4(%esp)
  8102f1:	89 14 24             	mov    %edx,(%esp)
  8102f4:	e8 62 72 ff ff       	call   80755b <pbuf_cat>
  8102f9:	eb 05                	jmp    810300 <tcp_receive+0x930>
            } else {
              recv_data = cseg->p;
  8102fb:	a3 08 c2 b3 00       	mov    %eax,0xb3c208
            }
            cseg->p = NULL;
  810300:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  810307:	8b 46 10             	mov    0x10(%esi),%eax
  81030a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81030e:	89 04 24             	mov    %eax,(%esp)
  810311:	e8 7a a4 ff ff       	call   80a790 <ntohs>
  810316:	a8 01                	test   $0x1,%al
  810318:	74 14                	je     81032e <tcp_receive+0x95e>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81031a:	c6 05 04 c2 b3 00 20 	movb   $0x20,0xb3c204
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  810321:	83 7b 10 04          	cmpl   $0x4,0x10(%ebx)
  810325:	75 07                	jne    81032e <tcp_receive+0x95e>
              pcb->state = CLOSE_WAIT;
  810327:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
            } 
          }


          pcb->ooseq = cseg->next;
  81032e:	8b 06                	mov    (%esi),%eax
  810330:	89 43 7c             	mov    %eax,0x7c(%ebx)
          tcp_seg_free(cseg);
  810333:	89 34 24             	mov    %esi,(%esp)
  810336:	e8 c6 81 ff ff       	call   808501 <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81033b:	8b 73 7c             	mov    0x7c(%ebx),%esi
  81033e:	85 f6                	test   %esi,%esi
  810340:	74 0f                	je     810351 <tcp_receive+0x981>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  810342:	8b 46 10             	mov    0x10(%esi),%eax
  810345:	8b 40 04             	mov    0x4(%eax),%eax
  810348:	3b 43 24             	cmp    0x24(%ebx),%eax
  81034b:	0f 84 0e fe ff ff    	je     81015f <tcp_receive+0x78f>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  810351:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  810355:	a8 01                	test   $0x1,%al
  810357:	74 1b                	je     810374 <tcp_receive+0x9a4>
  810359:	83 e0 fe             	and    $0xfffffffe,%eax
  81035c:	83 c8 02             	or     $0x2,%eax
  81035f:	88 43 20             	mov    %al,0x20(%ebx)
  810362:	89 1c 24             	mov    %ebx,(%esp)
  810365:	e8 a1 aa ff ff       	call   80ae0b <tcp_output>
  81036a:	b8 01 00 00 00       	mov    $0x1,%eax
  81036f:	e9 cb 02 00 00       	jmp    81063f <tcp_receive+0xc6f>
  810374:	83 c8 01             	or     $0x1,%eax
  810377:	88 43 20             	mov    %al,0x20(%ebx)
  81037a:	b8 01 00 00 00       	mov    $0x1,%eax
  81037f:	e9 bb 02 00 00       	jmp    81063f <tcp_receive+0xc6f>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  810384:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810388:	89 1c 24             	mov    %ebx,(%esp)
  81038b:	e8 7b aa ff ff       	call   80ae0b <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  810390:	8b 73 7c             	mov    0x7c(%ebx),%esi
  810393:	85 f6                	test   %esi,%esi
  810395:	74 31                	je     8103c8 <tcp_receive+0x9f8>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  810397:	8b 46 10             	mov    0x10(%esi),%eax
  81039a:	8b 40 04             	mov    0x4(%eax),%eax
  81039d:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  8103a3:	39 d0                	cmp    %edx,%eax
  8103a5:	74 18                	je     8103bf <tcp_receive+0x9ef>
  8103a7:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  8103aa:	bf 00 00 00 00       	mov    $0x0,%edi
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  8103af:	8d 72 01             	lea    0x1(%edx),%esi
  8103b2:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8103b5:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  8103b8:	89 f3                	mov    %esi,%ebx
  8103ba:	e9 b7 00 00 00       	jmp    810476 <tcp_receive+0xaa6>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  8103bf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8103c6:	eb 1f                	jmp    8103e7 <tcp_receive+0xa17>
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
          pcb->ooseq = tcp_seg_copy(&inseg);
  8103c8:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  8103cf:	e8 ea 80 ff ff       	call   8084be <tcp_seg_copy>
  8103d4:	89 43 7c             	mov    %eax,0x7c(%ebx)
  8103d7:	b8 00 00 00 00       	mov    $0x0,%eax
  8103dc:	e9 5e 02 00 00       	jmp    81063f <tcp_receive+0xc6f>
  8103e1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8103e4:	8b 5d e0             	mov    -0x20(%ebp),%ebx
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  8103e7:	0f b7 05 e8 c1 b3 00 	movzwl 0xb3c1e8,%eax
  8103ee:	66 3b 46 0c          	cmp    0xc(%esi),%ax
  8103f2:	0f 86 42 02 00 00    	jbe    81063a <tcp_receive+0xc6a>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  8103f8:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  8103ff:	e8 ba 80 ff ff       	call   8084be <tcp_seg_copy>
  810404:	89 c7                	mov    %eax,%edi
                if (cseg != NULL) {
  810406:	85 c0                	test   %eax,%eax
  810408:	0f 84 2c 02 00 00    	je     81063a <tcp_receive+0xc6a>
                  cseg->next = next->next;
  81040e:	8b 06                	mov    (%esi),%eax
  810410:	89 07                	mov    %eax,(%edi)
                  if (prev != NULL) {
  810412:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  810416:	74 07                	je     81041f <tcp_receive+0xa4f>
                    prev->next = cseg;
  810418:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  81041b:	89 3b                	mov    %edi,(%ebx)
  81041d:	eb 03                	jmp    810422 <tcp_receive+0xa52>
                  } else {
                    pcb->ooseq = cseg;
  81041f:	89 7b 7c             	mov    %edi,0x7c(%ebx)
                  }
                  tcp_seg_free(next);
  810422:	89 34 24             	mov    %esi,(%esp)
  810425:	e8 d7 80 ff ff       	call   808501 <tcp_seg_free>
                  if (cseg->next != NULL) {
  81042a:	8b 17                	mov    (%edi),%edx
  81042c:	85 d2                	test   %edx,%edx
  81042e:	0f 84 06 02 00 00    	je     81063a <tcp_receive+0xc6a>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  810434:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810439:	8b 52 10             	mov    0x10(%edx),%edx
  81043c:	8b 52 04             	mov    0x4(%edx),%edx
  81043f:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  810443:	29 d1                	sub    %edx,%ecx
  810445:	01 c1                	add    %eax,%ecx
  810447:	85 c9                	test   %ecx,%ecx
  810449:	0f 8e eb 01 00 00    	jle    81063a <tcp_receive+0xc6a>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  81044f:	66 29 c2             	sub    %ax,%dx
  810452:	66 89 57 0c          	mov    %dx,0xc(%edi)
                      pbuf_realloc(cseg->p, cseg->len);
  810456:	0f b7 c2             	movzwl %dx,%eax
  810459:	89 44 24 04          	mov    %eax,0x4(%esp)
  81045d:	8b 47 04             	mov    0x4(%edi),%eax
  810460:	89 04 24             	mov    %eax,(%esp)
  810463:	e8 b1 76 ff ff       	call   807b19 <pbuf_realloc>
  810468:	b8 00 00 00 00       	mov    $0x0,%eax
  81046d:	e9 cd 01 00 00       	jmp    81063f <tcp_receive+0xc6f>
  810472:	89 cf                	mov    %ecx,%edi
  810474:	89 f1                	mov    %esi,%ecx
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  810476:	85 ff                	test   %edi,%edi
  810478:	75 60                	jne    8104da <tcp_receive+0xb0a>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  81047a:	39 c2                	cmp    %eax,%edx
  81047c:	0f 89 fd 00 00 00    	jns    81057f <tcp_receive+0xbaf>
  810482:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  810485:	8b 5d e0             	mov    -0x20(%ebp),%ebx
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  810488:	0f b7 0d e8 c1 b3 00 	movzwl 0xb3c1e8,%ecx
  81048f:	01 d1                	add    %edx,%ecx
  810491:	29 c1                	sub    %eax,%ecx
  810493:	85 c9                	test   %ecx,%ecx
  810495:	7e 1d                	jle    8104b4 <tcp_receive+0xae4>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  810497:	66 29 d0             	sub    %dx,%ax
  81049a:	66 a3 e8 c1 b3 00    	mov    %ax,0xb3c1e8
                    pbuf_realloc(inseg.p, inseg.len);
  8104a0:	0f b7 c0             	movzwl %ax,%eax
  8104a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8104a7:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  8104ac:	89 04 24             	mov    %eax,(%esp)
  8104af:	e8 65 76 ff ff       	call   807b19 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  8104b4:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  8104bb:	e8 fe 7f ff ff       	call   8084be <tcp_seg_copy>
                  if (cseg != NULL) {
  8104c0:	85 c0                	test   %eax,%eax
  8104c2:	0f 84 72 01 00 00    	je     81063a <tcp_receive+0xc6a>
                    cseg->next = next;
  8104c8:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8104cb:	89 30                	mov    %esi,(%eax)
                    pcb->ooseq = cseg;
  8104cd:	89 43 7c             	mov    %eax,0x7c(%ebx)
  8104d0:	b8 00 00 00 00       	mov    $0x0,%eax
  8104d5:	e9 65 01 00 00       	jmp    81063f <tcp_receive+0xc6f>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  8104da:	8b 77 10             	mov    0x10(%edi),%esi
  8104dd:	8b 76 04             	mov    0x4(%esi),%esi
  8104e0:	f7 d6                	not    %esi
  8104e2:	01 d6                	add    %edx,%esi
  8104e4:	0f 88 95 00 00 00    	js     81057f <tcp_receive+0xbaf>
  8104ea:	89 de                	mov    %ebx,%esi
  8104ec:	29 c6                	sub    %eax,%esi
  8104ee:	85 f6                	test   %esi,%esi
  8104f0:	0f 8f 89 00 00 00    	jg     81057f <tcp_receive+0xbaf>
  8104f6:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  8104f9:	0f b7 0d e8 c1 b3 00 	movzwl 0xb3c1e8,%ecx
  810500:	01 d1                	add    %edx,%ecx
  810502:	29 c1                	sub    %eax,%ecx
  810504:	85 c9                	test   %ecx,%ecx
  810506:	7e 1d                	jle    810525 <tcp_receive+0xb55>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  810508:	66 29 d0             	sub    %dx,%ax
  81050b:	66 a3 e8 c1 b3 00    	mov    %ax,0xb3c1e8
                  pbuf_realloc(inseg.p, inseg.len);
  810511:	0f b7 c0             	movzwl %ax,%eax
  810514:	89 44 24 04          	mov    %eax,0x4(%esp)
  810518:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  81051d:	89 04 24             	mov    %eax,(%esp)
  810520:	e8 f4 75 ff ff       	call   807b19 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  810525:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  81052c:	e8 8d 7f ff ff       	call   8084be <tcp_seg_copy>
                if (cseg != NULL) {
  810531:	85 c0                	test   %eax,%eax
  810533:	0f 84 01 01 00 00    	je     81063a <tcp_receive+0xc6a>
                  cseg->next = next;
  810539:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  81053c:	89 10                	mov    %edx,(%eax)
                  prev->next = cseg;
  81053e:	89 07                	mov    %eax,(%edi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  810540:	8b 47 10             	mov    0x10(%edi),%eax
  810543:	8b 40 04             	mov    0x4(%eax),%eax
  810546:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  81054c:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  810550:	29 d1                	sub    %edx,%ecx
  810552:	01 c1                	add    %eax,%ecx
  810554:	85 c9                	test   %ecx,%ecx
  810556:	0f 8e de 00 00 00    	jle    81063a <tcp_receive+0xc6a>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  81055c:	66 29 c2             	sub    %ax,%dx
  81055f:	66 89 57 0c          	mov    %dx,0xc(%edi)
                    pbuf_realloc(prev->p, prev->len);
  810563:	0f b7 c2             	movzwl %dx,%eax
  810566:	89 44 24 04          	mov    %eax,0x4(%esp)
  81056a:	8b 47 04             	mov    0x4(%edi),%eax
  81056d:	89 04 24             	mov    %eax,(%esp)
  810570:	e8 a4 75 ff ff       	call   807b19 <pbuf_realloc>
  810575:	b8 00 00 00 00       	mov    $0x0,%eax
  81057a:	e9 c0 00 00 00       	jmp    81063f <tcp_receive+0xc6f>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  81057f:	8b 31                	mov    (%ecx),%esi
  810581:	85 f6                	test   %esi,%esi
  810583:	75 5e                	jne    8105e3 <tcp_receive+0xc13>
  810585:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  810588:	29 c2                	sub    %eax,%edx
  81058a:	85 d2                	test   %edx,%edx
  81058c:	0f 8e a8 00 00 00    	jle    81063a <tcp_receive+0xc6a>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  810592:	c7 04 24 dc c1 b3 00 	movl   $0xb3c1dc,(%esp)
  810599:	e8 20 7f ff ff       	call   8084be <tcp_seg_copy>
  81059e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8105a1:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  8105a3:	85 c0                	test   %eax,%eax
  8105a5:	0f 84 8f 00 00 00    	je     81063a <tcp_receive+0xc6a>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  8105ab:	8b 43 10             	mov    0x10(%ebx),%eax
  8105ae:	8b 40 04             	mov    0x4(%eax),%eax
  8105b1:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  8105b7:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  8105bb:	29 d1                	sub    %edx,%ecx
  8105bd:	01 c1                	add    %eax,%ecx
  8105bf:	85 c9                	test   %ecx,%ecx
  8105c1:	7e 77                	jle    81063a <tcp_receive+0xc6a>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  8105c3:	66 29 c2             	sub    %ax,%dx
  8105c6:	66 89 53 0c          	mov    %dx,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  8105ca:	0f b7 c2             	movzwl %dx,%eax
  8105cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8105d1:	8b 43 04             	mov    0x4(%ebx),%eax
  8105d4:	89 04 24             	mov    %eax,(%esp)
  8105d7:	e8 3d 75 ff ff       	call   807b19 <pbuf_realloc>
  8105dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8105e1:	eb 5c                	jmp    81063f <tcp_receive+0xc6f>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  8105e3:	8b 46 10             	mov    0x10(%esi),%eax
  8105e6:	8b 40 04             	mov    0x4(%eax),%eax
  8105e9:	39 d0                	cmp    %edx,%eax
  8105eb:	0f 85 81 fe ff ff    	jne    810472 <tcp_receive+0xaa2>
  8105f1:	e9 eb fd ff ff       	jmp    8103e1 <tcp_receive+0xa11>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  8105f6:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8105fa:	89 1c 24             	mov    %ebx,(%esp)
  8105fd:	e8 09 a8 ff ff       	call   80ae0b <tcp_output>
  810602:	b8 00 00 00 00       	mov    $0x0,%eax
  810607:	eb 36                	jmp    81063f <tcp_receive+0xc6f>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  810609:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  81060f:	8b 43 24             	mov    0x24(%ebx),%eax
  810612:	39 c2                	cmp    %eax,%edx
  810614:	78 11                	js     810627 <tcp_receive+0xc57>
  810616:	83 c2 01             	add    $0x1,%edx
  810619:	29 c2                	sub    %eax,%edx
  81061b:	89 d0                	mov    %edx,%eax
  81061d:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  810621:	29 c8                	sub    %ecx,%eax
  810623:	85 c0                	test   %eax,%eax
  810625:	7e 13                	jle    81063a <tcp_receive+0xc6a>
      tcp_ack_now(pcb);
  810627:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81062b:	89 1c 24             	mov    %ebx,(%esp)
  81062e:	e8 d8 a7 ff ff       	call   80ae0b <tcp_output>
  810633:	b8 00 00 00 00       	mov    $0x0,%eax
  810638:	eb 05                	jmp    81063f <tcp_receive+0xc6f>
  81063a:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  return accepted_inseq;
}
  81063f:	83 c4 2c             	add    $0x2c,%esp
  810642:	5b                   	pop    %ebx
  810643:	5e                   	pop    %esi
  810644:	5f                   	pop    %edi
  810645:	5d                   	pop    %ebp
  810646:	c3                   	ret    

00810647 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  810647:	55                   	push   %ebp
  810648:	89 e5                	mov    %esp,%ebp
  81064a:	57                   	push   %edi
  81064b:	56                   	push   %esi
  81064c:	53                   	push   %ebx
  81064d:	83 ec 5c             	sub    $0x5c,%esp
  810650:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  810653:	8b 46 04             	mov    0x4(%esi),%eax
  810656:	a3 f4 c1 b3 00       	mov    %eax,0xb3c1f4
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  81065b:	8b 5e 04             	mov    0x4(%esi),%ebx
  81065e:	0f b7 00             	movzwl (%eax),%eax
  810661:	89 04 24             	mov    %eax,(%esp)
  810664:	e8 27 a1 ff ff       	call   80a790 <ntohs>
  810669:	c1 e8 06             	shr    $0x6,%eax
  81066c:	83 e0 3c             	and    $0x3c,%eax
  81066f:	01 c3                	add    %eax,%ebx
  810671:	89 1d f0 c1 b3 00    	mov    %ebx,0xb3c1f0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  810677:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  81067c:	0f b7 00             	movzwl (%eax),%eax
  81067f:	89 04 24             	mov    %eax,(%esp)
  810682:	e8 09 a1 ff ff       	call   80a790 <ntohs>
  810687:	66 c1 e8 06          	shr    $0x6,%ax
  81068b:	83 e0 3c             	and    $0x3c,%eax
  81068e:	f7 d8                	neg    %eax
  810690:	98                   	cwtl   
  810691:	89 44 24 04          	mov    %eax,0x4(%esp)
  810695:	89 34 24             	mov    %esi,(%esp)
  810698:	e8 86 6f ff ff       	call   807623 <pbuf_header>
  81069d:	84 c0                	test   %al,%al
  81069f:	75 07                	jne    8106a8 <tcp_input+0x61>
  8106a1:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  8106a6:	77 12                	ja     8106ba <tcp_input+0x73>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  8106a8:	89 34 24             	mov    %esi,(%esp)
  8106ab:	90                   	nop
  8106ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8106b0:	e8 d8 72 ff ff       	call   80798d <pbuf_free>
    return;
  8106b5:	e9 9a 0d 00 00       	jmp    811454 <tcp_input+0xe0d>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  8106ba:	8b 45 0c             	mov    0xc(%ebp),%eax
  8106bd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8106c1:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  8106c6:	83 c0 10             	add    $0x10,%eax
  8106c9:	89 04 24             	mov    %eax,(%esp)
  8106cc:	e8 a7 8c ff ff       	call   809378 <ip_addr_isbroadcast>
  8106d1:	84 c0                	test   %al,%al
  8106d3:	75 28                	jne    8106fd <tcp_input+0xb6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  8106d5:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  8106da:	8b 78 10             	mov    0x10(%eax),%edi
  8106dd:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  8106e4:	e8 dc a2 ff ff       	call   80a9c5 <ntohl>
  8106e9:	89 c3                	mov    %eax,%ebx
  8106eb:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8106f2:	e8 ce a2 ff ff       	call   80a9c5 <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  8106f7:	21 fb                	and    %edi,%ebx
  8106f9:	39 c3                	cmp    %eax,%ebx
  8106fb:	75 0d                	jne    81070a <tcp_input+0xc3>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  8106fd:	89 34 24             	mov    %esi,(%esp)
  810700:	e8 88 72 ff ff       	call   80798d <pbuf_free>
    return;
  810705:	e9 4a 0d 00 00       	jmp    811454 <tcp_input+0xe0d>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  81070a:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81070f:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  810713:	89 54 24 10          	mov    %edx,0x10(%esp)
  810717:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  81071e:	00 
  81071f:	8d 50 10             	lea    0x10(%eax),%edx
  810722:	89 54 24 08          	mov    %edx,0x8(%esp)
  810726:	83 c0 0c             	add    $0xc,%eax
  810729:	89 44 24 04          	mov    %eax,0x4(%esp)
  81072d:	89 34 24             	mov    %esi,(%esp)
  810730:	e8 4b 9d ff ff       	call   80a480 <inet_chksum_pseudo>
  810735:	66 85 c0             	test   %ax,%ax
  810738:	74 0d                	je     810747 <tcp_input+0x100>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  81073a:	89 34 24             	mov    %esi,(%esp)
  81073d:	e8 4b 72 ff ff       	call   80798d <pbuf_free>
    return;
  810742:	e9 0d 0d 00 00       	jmp    811454 <tcp_input+0xe0d>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  810747:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  81074c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810750:	89 04 24             	mov    %eax,(%esp)
  810753:	e8 38 a0 ff ff       	call   80a790 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  810758:	66 c1 e8 0c          	shr    $0xc,%ax
  81075c:	f7 d8                	neg    %eax
  81075e:	c1 e0 02             	shl    $0x2,%eax
  810761:	98                   	cwtl   
  810762:	89 44 24 04          	mov    %eax,0x4(%esp)
  810766:	89 34 24             	mov    %esi,(%esp)
  810769:	e8 b5 6e ff ff       	call   807623 <pbuf_header>
  81076e:	84 c0                	test   %al,%al
  810770:	74 0d                	je     81077f <tcp_input+0x138>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810772:	89 34 24             	mov    %esi,(%esp)
  810775:	e8 13 72 ff ff       	call   80798d <pbuf_free>
    return;
  81077a:	e9 d5 0c 00 00       	jmp    811454 <tcp_input+0xe0d>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  81077f:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  810785:	0f b7 03             	movzwl (%ebx),%eax
  810788:	89 04 24             	mov    %eax,(%esp)
  81078b:	e8 00 a0 ff ff       	call   80a790 <ntohs>
  810790:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  810793:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  810799:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  81079d:	89 04 24             	mov    %eax,(%esp)
  8107a0:	e8 eb 9f ff ff       	call   80a790 <ntohs>
  8107a5:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  8107a9:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  8107af:	8b 43 04             	mov    0x4(%ebx),%eax
  8107b2:	89 04 24             	mov    %eax,(%esp)
  8107b5:	e8 0b a2 ff ff       	call   80a9c5 <ntohl>
  8107ba:	89 43 04             	mov    %eax,0x4(%ebx)
  8107bd:	a3 f8 c1 b3 00       	mov    %eax,0xb3c1f8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  8107c2:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  8107c8:	8b 43 08             	mov    0x8(%ebx),%eax
  8107cb:	89 04 24             	mov    %eax,(%esp)
  8107ce:	e8 f2 a1 ff ff       	call   80a9c5 <ntohl>
  8107d3:	89 43 08             	mov    %eax,0x8(%ebx)
  8107d6:	a3 fc c1 b3 00       	mov    %eax,0xb3c1fc
  tcphdr->wnd = ntohs(tcphdr->wnd);
  8107db:	8b 1d f0 c1 b3 00    	mov    0xb3c1f0,%ebx
  8107e1:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  8107e5:	89 04 24             	mov    %eax,(%esp)
  8107e8:	e8 a3 9f ff ff       	call   80a790 <ntohs>
  8107ed:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  8107f1:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  8107f6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8107fa:	89 04 24             	mov    %eax,(%esp)
  8107fd:	e8 8e 9f ff ff       	call   80a790 <ntohs>
  810802:	83 e0 3f             	and    $0x3f,%eax
  810805:	a2 00 c2 b3 00       	mov    %al,0xb3c200
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  81080a:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  81080e:	ba 01 00 00 00       	mov    $0x1,%edx
  810813:	a8 01                	test   $0x1,%al
  810815:	75 07                	jne    81081e <tcp_input+0x1d7>
  810817:	d1 e8                	shr    %eax
  810819:	89 c2                	mov    %eax,%edx
  81081b:	83 e2 01             	and    $0x1,%edx
  81081e:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  810821:	66 89 15 02 c2 b3 00 	mov    %dx,0xb3c202
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810828:	8b 1d 0c f0 b3 00    	mov    0xb3f00c,%ebx
  81082e:	85 db                	test   %ebx,%ebx
  810830:	0f 84 32 01 00 00    	je     810968 <tcp_input+0x321>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  810836:	8b 43 10             	mov    0x10(%ebx),%eax
  810839:	85 c0                	test   %eax,%eax
  81083b:	74 15                	je     810852 <tcp_input+0x20b>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81083d:	83 f8 0a             	cmp    $0xa,%eax
  810840:	74 31                	je     810873 <tcp_input+0x22c>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  810842:	83 f8 01             	cmp    $0x1,%eax
  810845:	75 6f                	jne    8108b6 <tcp_input+0x26f>
  810847:	90                   	nop
  810848:	eb 50                	jmp    81089a <tcp_input+0x253>
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  81084a:	8b 50 10             	mov    0x10(%eax),%edx
  81084d:	85 d2                	test   %edx,%edx
  81084f:	90                   	nop
  810850:	75 1c                	jne    81086e <tcp_input+0x227>
  810852:	c7 44 24 08 94 49 81 	movl   $0x814994,0x8(%esp)
  810859:	00 
  81085a:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  810861:	00 
  810862:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  810869:	e8 a6 00 ff ff       	call   800914 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  81086e:	83 fa 0a             	cmp    $0xa,%edx
  810871:	75 1c                	jne    81088f <tcp_input+0x248>
  810873:	c7 44 24 08 bc 49 81 	movl   $0x8149bc,0x8(%esp)
  81087a:	00 
  81087b:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  810882:	00 
  810883:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  81088a:	e8 85 00 ff ff       	call   800914 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  81088f:	83 fa 01             	cmp    $0x1,%edx
  810892:	74 06                	je     81089a <tcp_input+0x253>
  810894:	89 da                	mov    %ebx,%edx
  810896:	89 c3                	mov    %eax,%ebx
  810898:	eb 35                	jmp    8108cf <tcp_input+0x288>
  81089a:	c7 44 24 08 e8 49 81 	movl   $0x8149e8,0x8(%esp)
  8108a1:	00 
  8108a2:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  8108a9:	00 
  8108aa:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  8108b1:	e8 5e 00 ff ff       	call   800914 <_panic>
    if (pcb->remote_port == tcphdr->src &&
  8108b6:	8b 3d f0 c1 b3 00    	mov    0xb3c1f0,%edi
  8108bc:	0f b7 0f             	movzwl (%edi),%ecx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  8108bf:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  8108c4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8108c7:	ba 00 00 00 00       	mov    $0x0,%edx
  8108cc:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  8108cf:	66 39 4b 1e          	cmp    %cx,0x1e(%ebx)
  8108d3:	75 7b                	jne    810950 <tcp_input+0x309>
       pcb->local_port == tcphdr->dest &&
  8108d5:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  8108d9:	66 3b 47 02          	cmp    0x2(%edi),%ax
  8108dd:	75 71                	jne    810950 <tcp_input+0x309>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  8108df:	8b 43 04             	mov    0x4(%ebx),%eax
  8108e2:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  8108e5:	3b 46 0c             	cmp    0xc(%esi),%eax
  8108e8:	75 66                	jne    810950 <tcp_input+0x309>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  8108ea:	8b 03                	mov    (%ebx),%eax
  8108ec:	3b 46 10             	cmp    0x10(%esi),%eax
  8108ef:	75 5f                	jne    810950 <tcp_input+0x309>
  8108f1:	8b 75 c4             	mov    -0x3c(%ebp),%esi
  8108f4:	89 d8                	mov    %ebx,%eax

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  8108f6:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  8108f9:	39 d9                	cmp    %ebx,%ecx
  8108fb:	75 1c                	jne    810919 <tcp_input+0x2d2>
  8108fd:	c7 44 24 08 10 4a 81 	movl   $0x814a10,0x8(%esp)
  810904:	00 
  810905:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  81090c:	00 
  81090d:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  810914:	e8 fb ff fe ff       	call   800914 <_panic>
      if (prev != NULL) {
  810919:	85 d2                	test   %edx,%edx
  81091b:	74 43                	je     810960 <tcp_input+0x319>
        prev->next = pcb->next;
  81091d:	89 4a 0c             	mov    %ecx,0xc(%edx)
        pcb->next = tcp_active_pcbs;
  810920:	8b 15 0c f0 b3 00    	mov    0xb3f00c,%edx
  810926:	89 53 0c             	mov    %edx,0xc(%ebx)
        tcp_active_pcbs = pcb;
  810929:	89 1d 0c f0 b3 00    	mov    %ebx,0xb3f00c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  81092f:	39 5b 0c             	cmp    %ebx,0xc(%ebx)
  810932:	75 2c                	jne    810960 <tcp_input+0x319>
  810934:	c7 44 24 08 3c 4a 81 	movl   $0x814a3c,0x8(%esp)
  81093b:	00 
  81093c:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  810943:	00 
  810944:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  81094b:	e8 c4 ff fe ff       	call   800914 <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810950:	8b 43 0c             	mov    0xc(%ebx),%eax
  810953:	85 c0                	test   %eax,%eax
  810955:	0f 85 ef fe ff ff    	jne    81084a <tcp_input+0x203>
  81095b:	8b 75 c4             	mov    -0x3c(%ebp),%esi
  81095e:	eb 08                	jmp    810968 <tcp_input+0x321>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  810960:	85 c0                	test   %eax,%eax
  810962:	0f 85 be 02 00 00    	jne    810c26 <tcp_input+0x5df>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810968:	8b 1d 20 f0 b3 00    	mov    0xb3f020,%ebx
  81096e:	85 db                	test   %ebx,%ebx
  810970:	0f 84 ad 00 00 00    	je     810a23 <tcp_input+0x3dc>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  810976:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  81097a:	74 2a                	je     8109a6 <tcp_input+0x35f>
  81097c:	eb 0c                	jmp    81098a <tcp_input+0x343>
  81097e:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  810982:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810988:	74 2b                	je     8109b5 <tcp_input+0x36e>
  81098a:	c7 44 24 08 68 4a 81 	movl   $0x814a68,0x8(%esp)
  810991:	00 
  810992:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  810999:	00 
  81099a:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  8109a1:	e8 6e ff fe ff       	call   800914 <_panic>
      if (pcb->remote_port == tcphdr->src &&
  8109a6:	8b 0d f0 c1 b3 00    	mov    0xb3c1f0,%ecx
  8109ac:	0f b7 01             	movzwl (%ecx),%eax
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  8109af:	8b 3d f4 c1 b3 00    	mov    0xb3c1f4,%edi
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  8109b5:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  8109b9:	75 5d                	jne    810a18 <tcp_input+0x3d1>
         pcb->local_port == tcphdr->dest &&
  8109bb:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  8109bf:	66 3b 51 02          	cmp    0x2(%ecx),%dx
  8109c3:	75 53                	jne    810a18 <tcp_input+0x3d1>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  8109c5:	8b 53 04             	mov    0x4(%ebx),%edx
  8109c8:	3b 57 0c             	cmp    0xc(%edi),%edx
  8109cb:	75 4b                	jne    810a18 <tcp_input+0x3d1>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  8109cd:	8b 13                	mov    (%ebx),%edx
  8109cf:	3b 57 10             	cmp    0x10(%edi),%edx
  8109d2:	75 44                	jne    810a18 <tcp_input+0x3d1>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  8109d4:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  8109db:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  8109e1:	89 c2                	mov    %eax,%edx
  8109e3:	2b 53 24             	sub    0x24(%ebx),%edx
  8109e6:	85 d2                	test   %edx,%edx
  8109e8:	7e 03                	jle    8109ed <tcp_input+0x3a6>
    pcb->rcv_nxt = seqno + tcplen;
  8109ea:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  8109ed:	66 83 3d 02 c2 b3 00 	cmpw   $0x0,0xb3c202
  8109f4:	00 
  8109f5:	74 0c                	je     810a03 <tcp_input+0x3bc>
    tcp_ack_now(pcb);
  8109f7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8109fb:	89 1c 24             	mov    %ebx,(%esp)
  8109fe:	e8 08 a4 ff ff       	call   80ae0b <tcp_output>
  }
  return tcp_output(pcb);
  810a03:	89 1c 24             	mov    %ebx,(%esp)
  810a06:	e8 00 a4 ff ff       	call   80ae0b <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  810a0b:	89 34 24             	mov    %esi,(%esp)
  810a0e:	e8 7a 6f ff ff       	call   80798d <pbuf_free>
        return;
  810a13:	e9 3c 0a 00 00       	jmp    811454 <tcp_input+0xe0d>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810a18:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  810a1b:	85 db                	test   %ebx,%ebx
  810a1d:	0f 85 5b ff ff ff    	jne    81097e <tcp_input+0x337>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  810a23:	8b 3d 14 f0 b3 00    	mov    0xb3f014,%edi
  810a29:	85 ff                	test   %edi,%edi
  810a2b:	0f 84 ed 01 00 00    	je     810c1e <tcp_input+0x5d7>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  810a31:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
        lpcb->local_port == tcphdr->dest) {
  810a36:	8b 0d f0 c1 b3 00    	mov    0xb3c1f0,%ecx
  810a3c:	ba 00 00 00 00       	mov    $0x0,%edx
  810a41:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  810a44:	89 c3                	mov    %eax,%ebx

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  810a46:	85 ff                	test   %edi,%edi
  810a48:	74 0f                	je     810a59 <tcp_input+0x412>
  810a4a:	8b 07                	mov    (%edi),%eax
  810a4c:	85 c0                	test   %eax,%eax
  810a4e:	74 09                	je     810a59 <tcp_input+0x412>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  810a50:	3b 43 10             	cmp    0x10(%ebx),%eax
  810a53:	0f 85 b1 01 00 00    	jne    810c0a <tcp_input+0x5c3>
        lpcb->local_port == tcphdr->dest) {
  810a59:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  810a5d:	66 3b 41 02          	cmp    0x2(%ecx),%ax
  810a61:	0f 85 a3 01 00 00    	jne    810c0a <tcp_input+0x5c3>
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  810a67:	85 d2                	test   %edx,%edx
  810a69:	74 14                	je     810a7f <tcp_input+0x438>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  810a6b:	8b 47 0c             	mov    0xc(%edi),%eax
  810a6e:	89 42 0c             	mov    %eax,0xc(%edx)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  810a71:	a1 14 f0 b3 00       	mov    0xb3f014,%eax
  810a76:	89 47 0c             	mov    %eax,0xc(%edi)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  810a79:	89 3d 14 f0 b3 00    	mov    %edi,0xb3f014
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  810a7f:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  810a86:	a8 10                	test   $0x10,%al
  810a88:	74 4e                	je     810ad8 <tcp_input+0x491>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  810a8a:	8b 15 f0 c1 b3 00    	mov    0xb3c1f0,%edx
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  810a90:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  810a95:	0f b7 0a             	movzwl (%edx),%ecx
  810a98:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  810a9c:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  810aa0:	89 54 24 10          	mov    %edx,0x10(%esp)
  810aa4:	8d 50 0c             	lea    0xc(%eax),%edx
  810aa7:	89 54 24 0c          	mov    %edx,0xc(%esp)
  810aab:	83 c0 10             	add    $0x10,%eax
  810aae:	89 44 24 08          	mov    %eax,0x8(%esp)
  810ab2:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  810ab9:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  810abf:	89 44 24 04          	mov    %eax,0x4(%esp)
  810ac3:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  810ac8:	83 c0 01             	add    $0x1,%eax
  810acb:	89 04 24             	mov    %eax,(%esp)
  810ace:	e8 d9 a1 ff ff       	call   80acac <tcp_rst>
  810ad3:	e9 25 01 00 00       	jmp    810bfd <tcp_input+0x5b6>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  810ad8:	a8 02                	test   $0x2,%al
  810ada:	0f 84 1d 01 00 00    	je     810bfd <tcp_input+0x5b6>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  810ae0:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  810ae4:	89 04 24             	mov    %eax,(%esp)
  810ae7:	e8 d2 80 ff ff       	call   808bbe <tcp_alloc>
  810aec:	89 c3                	mov    %eax,%ebx
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  810aee:	85 c0                	test   %eax,%eax
  810af0:	0f 84 07 01 00 00    	je     810bfd <tcp_input+0x5b6>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  810af6:	8b 15 f4 c1 b3 00    	mov    0xb3c1f4,%edx
  810afc:	b8 00 00 00 00       	mov    $0x0,%eax
  810b01:	83 fa f0             	cmp    $0xfffffff0,%edx
  810b04:	74 03                	je     810b09 <tcp_input+0x4c2>
  810b06:	8b 42 10             	mov    0x10(%edx),%eax
  810b09:	89 03                	mov    %eax,(%ebx)
    npcb->local_port = pcb->local_port;
  810b0b:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  810b0f:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  810b13:	8b 15 f4 c1 b3 00    	mov    0xb3c1f4,%edx
  810b19:	b8 00 00 00 00       	mov    $0x0,%eax
  810b1e:	83 fa f4             	cmp    $0xfffffff4,%edx
  810b21:	74 03                	je     810b26 <tcp_input+0x4df>
  810b23:	8b 42 0c             	mov    0xc(%edx),%eax
  810b26:	89 43 04             	mov    %eax,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  810b29:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810b2e:	0f b7 00             	movzwl (%eax),%eax
  810b31:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  810b35:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  810b3c:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810b41:	83 c0 01             	add    $0x1,%eax
  810b44:	89 43 24             	mov    %eax,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  810b47:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810b4c:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  810b50:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  810b54:	66 89 43 50          	mov    %ax,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  810b58:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810b5d:	83 e8 01             	sub    $0x1,%eax
  810b60:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  810b63:	8b 47 18             	mov    0x18(%edi),%eax
  810b66:	89 43 18             	mov    %eax,0x18(%ebx)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  810b69:	8b 47 20             	mov    0x20(%edi),%eax
  810b6c:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  810b72:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  810b76:	66 25 99 01          	and    $0x199,%ax
  810b7a:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  810b7e:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  810b83:	89 43 0c             	mov    %eax,0xc(%ebx)
  810b86:	89 1d 0c f0 b3 00    	mov    %ebx,0xb3f00c
  810b8c:	e8 9c 3e ff ff       	call   804a2d <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  810b91:	89 d8                	mov    %ebx,%eax
  810b93:	e8 88 ed ff ff       	call   80f920 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  810b98:	8d 43 04             	lea    0x4(%ebx),%eax
  810b9b:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b9f:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  810ba3:	89 04 24             	mov    %eax,(%esp)
  810ba6:	e8 c8 77 ff ff       	call   808373 <tcp_eff_send_mss>
  810bab:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  810baf:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  810bb6:	e8 e9 9b ff ff       	call   80a7a4 <htonl>
  810bbb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  810bbe:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  810bc5:	00 
  810bc6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  810bc9:	89 44 24 14          	mov    %eax,0x14(%esp)
  810bcd:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  810bd4:	00 
  810bd5:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  810bdc:	00 
  810bdd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810be4:	00 
  810be5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810bec:	00 
  810bed:	89 1c 24             	mov    %ebx,(%esp)
  810bf0:	e8 63 a7 ff ff       	call   80b358 <tcp_enqueue>
    return tcp_output(npcb);
  810bf5:	89 1c 24             	mov    %ebx,(%esp)
  810bf8:	e8 0e a2 ff ff       	call   80ae0b <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  810bfd:	89 34 24             	mov    %esi,(%esp)
  810c00:	e8 88 6d ff ff       	call   80798d <pbuf_free>
        return;
  810c05:	e9 4a 08 00 00       	jmp    811454 <tcp_input+0xe0d>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  810c0a:	8b 47 0c             	mov    0xc(%edi),%eax
  810c0d:	85 c0                	test   %eax,%eax
  810c0f:	90                   	nop
  810c10:	74 09                	je     810c1b <tcp_input+0x5d4>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
        return;
      }
      prev = (struct tcp_pcb *)lpcb;
  810c12:	89 fa                	mov    %edi,%edx
  810c14:	89 c7                	mov    %eax,%edi
  810c16:	e9 2b fe ff ff       	jmp    810a46 <tcp_input+0x3ff>
  810c1b:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  810c1e:	85 db                	test   %ebx,%ebx
  810c20:	0f 84 9b 07 00 00    	je     8113c1 <tcp_input+0xd7a>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  810c26:	c7 05 dc c1 b3 00 00 	movl   $0x0,0xb3c1dc
  810c2d:	00 00 00 
    inseg.len = p->tot_len;
  810c30:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  810c34:	66 a3 e8 c1 b3 00    	mov    %ax,0xb3c1e8
    inseg.dataptr = p->payload;
  810c3a:	8b 46 04             	mov    0x4(%esi),%eax
  810c3d:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4
    inseg.p = p;
  810c42:	89 35 e0 c1 b3 00    	mov    %esi,0xb3c1e0
    inseg.tcphdr = tcphdr;
  810c48:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810c4d:	a3 ec c1 b3 00       	mov    %eax,0xb3c1ec

    recv_data = NULL;
  810c52:	c7 05 08 c2 b3 00 00 	movl   $0x0,0xb3c208
  810c59:	00 00 00 
    recv_flags = 0;
  810c5c:	c6 05 04 c2 b3 00 00 	movb   $0x0,0xb3c204

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  810c63:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  810c69:	85 c0                	test   %eax,%eax
  810c6b:	74 49                	je     810cb6 <tcp_input+0x66f>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  810c6d:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  810c73:	85 d2                	test   %edx,%edx
  810c75:	74 1e                	je     810c95 <tcp_input+0x64e>
  810c77:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  810c7e:	00 
  810c7f:	89 44 24 08          	mov    %eax,0x8(%esp)
  810c83:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810c87:	8b 43 18             	mov    0x18(%ebx),%eax
  810c8a:	89 04 24             	mov    %eax,(%esp)
  810c8d:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  810c8f:	84 c0                	test   %al,%al
  810c91:	74 0a                	je     810c9d <tcp_input+0x656>
  810c93:	eb 14                	jmp    810ca9 <tcp_input+0x662>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  810c95:	89 04 24             	mov    %eax,(%esp)
  810c98:	e8 f0 6c ff ff       	call   80798d <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  810c9d:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  810ca4:	00 00 00 
  810ca7:	eb 0d                	jmp    810cb6 <tcp_input+0x66f>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  810ca9:	89 34 24             	mov    %esi,(%esp)
  810cac:	e8 dc 6c ff ff       	call   80798d <pbuf_free>
        return;
  810cb1:	e9 9e 07 00 00       	jmp    811454 <tcp_input+0xe0d>
      }
    }

    tcp_input_pcb = pcb;
  810cb6:	89 1d 28 f0 b3 00    	mov    %ebx,0xb3f028
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  810cbc:	f6 05 00 c2 b3 00 04 	testb  $0x4,0xb3c200
  810cc3:	74 68                	je     810d2d <tcp_input+0x6e6>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  810cc5:	8b 43 10             	mov    0x10(%ebx),%eax
  810cc8:	83 f8 02             	cmp    $0x2,%eax
  810ccb:	75 0e                	jne    810cdb <tcp_input+0x694>
  810ccd:	8b 53 54             	mov    0x54(%ebx),%edx
  810cd0:	3b 15 fc c1 b3 00    	cmp    0xb3c1fc,%edx
  810cd6:	0f 94 c2             	sete   %dl
  810cd9:	eb 1a                	jmp    810cf5 <tcp_input+0x6ae>
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  810cdb:	8b 15 f8 c1 b3 00    	mov    0xb3c1f8,%edx
  810ce1:	2b 53 24             	sub    0x24(%ebx),%edx
  810ce4:	0f 88 51 07 00 00    	js     81143b <tcp_input+0xdf4>
  810cea:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  810cee:	29 ca                	sub    %ecx,%edx
  810cf0:	85 d2                	test   %edx,%edx
  810cf2:	0f 9e c2             	setle  %dl
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  810cf5:	84 d2                	test   %dl,%dl
  810cf7:	0f 84 3e 07 00 00    	je     81143b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  810cfd:	85 c0                	test   %eax,%eax
  810cff:	75 1c                	jne    810d1d <tcp_input+0x6d6>
  810d01:	c7 44 24 08 98 4a 81 	movl   $0x814a98,0x8(%esp)
  810d08:	00 
  810d09:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  810d10:	00 
  810d11:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  810d18:	e8 f7 fb fe ff       	call   800914 <_panic>
      recv_flags = TF_RESET;
  810d1d:	c6 05 04 c2 b3 00 08 	movb   $0x8,0xb3c204
      pcb->flags &= ~TF_ACK_DELAY;
  810d24:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  810d28:	e9 0e 07 00 00       	jmp    81143b <tcp_input+0xdf4>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  810d2d:	a1 10 f0 b3 00       	mov    0xb3f010,%eax
  810d32:	89 43 2c             	mov    %eax,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  810d35:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  810d3c:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  810d40:	0f 87 07 05 00 00    	ja     81124d <tcp_input+0xc06>
  810d46:	8b 43 10             	mov    0x10(%ebx),%eax
  810d49:	ff 24 85 3c 4b 81 00 	jmp    *0x814b3c(,%eax,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  810d50:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  810d57:	83 e0 12             	and    $0x12,%eax
  810d5a:	83 f8 12             	cmp    $0x12,%eax
  810d5d:	0f 85 0c 01 00 00    	jne    810e6f <tcp_input+0x828>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  810d63:	8b 43 78             	mov    0x78(%ebx),%eax
  810d66:	8b 40 10             	mov    0x10(%eax),%eax
  810d69:	8b 40 04             	mov    0x4(%eax),%eax
  810d6c:	89 04 24             	mov    %eax,(%esp)
  810d6f:	e8 51 9c ff ff       	call   80a9c5 <ntohl>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  810d74:	83 c0 01             	add    $0x1,%eax
  810d77:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  810d7d:	0f 85 ec 00 00 00    	jne    810e6f <tcp_input+0x828>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
  810d83:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  810d88:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810d8d:	83 c0 01             	add    $0x1,%eax
  810d90:	89 43 24             	mov    %eax,0x24(%ebx)
      pcb->lastack = ackno;
  810d93:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  810d98:	89 43 48             	mov    %eax,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  810d9b:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810da0:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  810da4:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  810da8:	a1 f8 c1 b3 00       	mov    0xb3c1f8,%eax
  810dad:	83 e8 01             	sub    $0x1,%eax
  810db0:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  810db3:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  810dba:	89 d8                	mov    %ebx,%eax
  810dbc:	e8 5f eb ff ff       	call   80f920 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  810dc1:	8d 43 04             	lea    0x4(%ebx),%eax
  810dc4:	89 44 24 04          	mov    %eax,0x4(%esp)
  810dc8:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  810dcc:	89 04 24             	mov    %eax,(%esp)
  810dcf:	e8 9f 75 ff ff       	call   808373 <tcp_eff_send_mss>
  810dd4:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  810dd8:	6b d0 0a             	imul   $0xa,%eax,%edx
  810ddb:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  810ddf:	8d 14 00             	lea    (%eax,%eax,1),%edx
  810de2:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  810de7:	0f 44 c2             	cmove  %edx,%eax
  810dea:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  810dee:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  810df2:	66 85 c0             	test   %ax,%ax
  810df5:	75 1c                	jne    810e13 <tcp_input+0x7cc>
  810df7:	c7 44 24 08 11 4b 81 	movl   $0x814b11,0x8(%esp)
  810dfe:	00 
  810dff:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  810e06:	00 
  810e07:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  810e0e:	e8 01 fb fe ff       	call   800914 <_panic>
      --pcb->snd_queuelen;
  810e13:	83 e8 01             	sub    $0x1,%eax
  810e16:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  810e1a:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  810e1d:	8b 10                	mov    (%eax),%edx
  810e1f:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  810e22:	85 d2                	test   %edx,%edx
  810e24:	75 08                	jne    810e2e <tcp_input+0x7e7>
        pcb->rtime = -1;
  810e26:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  810e2c:	eb 0a                	jmp    810e38 <tcp_input+0x7f1>
      else {
        pcb->rtime = 0;
  810e2e:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  810e34:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  810e38:	89 04 24             	mov    %eax,(%esp)
  810e3b:	e8 c1 76 ff ff       	call   808501 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  810e40:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  810e46:	85 c0                	test   %eax,%eax
  810e48:	74 14                	je     810e5e <tcp_input+0x817>
  810e4a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810e51:	00 
  810e52:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810e56:	8b 53 18             	mov    0x18(%ebx),%edx
  810e59:	89 14 24             	mov    %edx,(%esp)
  810e5c:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  810e5e:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810e62:	89 1c 24             	mov    %ebx,(%esp)
  810e65:	e8 a1 9f ff ff       	call   80ae0b <tcp_output>
  810e6a:	e9 cc 05 00 00       	jmp    81143b <tcp_input+0xdf4>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  810e6f:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  810e76:	0f 84 bf 05 00 00    	je     81143b <tcp_input+0xdf4>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  810e7c:	8b 15 f0 c1 b3 00    	mov    0xb3c1f0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  810e82:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  810e87:	0f b7 0a             	movzwl (%edx),%ecx
  810e8a:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  810e8e:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  810e92:	89 54 24 10          	mov    %edx,0x10(%esp)
  810e96:	8d 50 0c             	lea    0xc(%eax),%edx
  810e99:	89 54 24 0c          	mov    %edx,0xc(%esp)
  810e9d:	83 c0 10             	add    $0x10,%eax
  810ea0:	89 44 24 08          	mov    %eax,0x8(%esp)
  810ea4:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  810eab:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  810eb1:	89 44 24 04          	mov    %eax,0x4(%esp)
  810eb5:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  810eba:	89 04 24             	mov    %eax,(%esp)
  810ebd:	e8 ea 9d ff ff       	call   80acac <tcp_rst>
  810ec2:	e9 74 05 00 00       	jmp    81143b <tcp_input+0xdf4>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  810ec7:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  810ece:	83 e0 14             	and    $0x14,%eax
  810ed1:	83 f8 10             	cmp    $0x10,%eax
  810ed4:	0f 85 61 05 00 00    	jne    81143b <tcp_input+0xdf4>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  810eda:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  810edf:	8b 53 48             	mov    0x48(%ebx),%edx
  810ee2:	f7 d2                	not    %edx
  810ee4:	01 c2                	add    %eax,%edx
  810ee6:	0f 88 b7 00 00 00    	js     810fa3 <tcp_input+0x95c>
  810eec:	89 c2                	mov    %eax,%edx
  810eee:	2b 53 54             	sub    0x54(%ebx),%edx
  810ef1:	85 d2                	test   %edx,%edx
  810ef3:	0f 8f aa 00 00 00    	jg     810fa3 <tcp_input+0x95c>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  810ef9:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  810f00:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  810f06:	85 c0                	test   %eax,%eax
  810f08:	75 1c                	jne    810f26 <tcp_input+0x8df>
  810f0a:	c7 44 24 08 27 4b 81 	movl   $0x814b27,0x8(%esp)
  810f11:	00 
  810f12:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  810f19:	00 
  810f1a:	c7 04 24 b8 4a 81 00 	movl   $0x814ab8,(%esp)
  810f21:	e8 ee f9 fe ff       	call   800914 <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  810f26:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810f2d:	00 
  810f2e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810f32:	8b 53 18             	mov    0x18(%ebx),%edx
  810f35:	89 14 24             	mov    %edx,(%esp)
  810f38:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  810f3a:	84 c0                	test   %al,%al
  810f3c:	74 17                	je     810f55 <tcp_input+0x90e>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  810f3e:	89 1c 24             	mov    %ebx,(%esp)
  810f41:	e8 68 7b ff ff       	call   808aae <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  810f46:	c7 05 28 f0 b3 00 00 	movl   $0x0,0xb3f028
  810f4d:	00 00 00 
  810f50:	e9 48 04 00 00       	jmp    81139d <tcp_input+0xd56>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  810f55:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  810f59:	89 d8                	mov    %ebx,%eax
  810f5b:	e8 70 ea ff ff       	call   80f9d0 <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  810f60:	66 83 fe 01          	cmp    $0x1,%si
  810f64:	75 08                	jne    810f6e <tcp_input+0x927>
  810f66:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  810f6a:	01 d2                	add    %edx,%edx
  810f6c:	eb 04                	jmp    810f72 <tcp_input+0x92b>
  810f6e:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  810f72:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  810f76:	f6 05 00 c2 b3 00 01 	testb  $0x1,0xb3c200
  810f7d:	0f 84 b8 04 00 00    	je     81143b <tcp_input+0xdf4>
  810f83:	84 c0                	test   %al,%al
  810f85:	0f 84 b0 04 00 00    	je     81143b <tcp_input+0xdf4>
          tcp_ack_now(pcb);
  810f8b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810f8f:	89 1c 24             	mov    %ebx,(%esp)
  810f92:	e8 74 9e ff ff       	call   80ae0b <tcp_output>
          pcb->state = CLOSE_WAIT;
  810f97:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  810f9e:	e9 98 04 00 00       	jmp    81143b <tcp_input+0xdf4>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  810fa3:	8b 0d f0 c1 b3 00    	mov    0xb3c1f0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  810fa9:	8b 15 f4 c1 b3 00    	mov    0xb3c1f4,%edx
  810faf:	0f b7 31             	movzwl (%ecx),%esi
  810fb2:	89 74 24 14          	mov    %esi,0x14(%esp)
  810fb6:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  810fba:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  810fbe:	8d 4a 0c             	lea    0xc(%edx),%ecx
  810fc1:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  810fc5:	83 c2 10             	add    $0x10,%edx
  810fc8:	89 54 24 08          	mov    %edx,0x8(%esp)
  810fcc:	0f b7 15 02 c2 b3 00 	movzwl 0xb3c202,%edx
  810fd3:	03 15 f8 c1 b3 00    	add    0xb3c1f8,%edx
  810fd9:	89 54 24 04          	mov    %edx,0x4(%esp)
  810fdd:	89 04 24             	mov    %eax,(%esp)
  810fe0:	e8 c7 9c ff ff       	call   80acac <tcp_rst>
  810fe5:	e9 51 04 00 00       	jmp    81143b <tcp_input+0xdf4>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  810fea:	89 d8                	mov    %ebx,%eax
  810fec:	e8 df e9 ff ff       	call   80f9d0 <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  810ff1:	f6 05 00 c2 b3 00 01 	testb  $0x1,0xb3c200
  810ff8:	0f 84 3d 04 00 00    	je     81143b <tcp_input+0xdf4>
  810ffe:	84 c0                	test   %al,%al
  811000:	0f 84 35 04 00 00    	je     81143b <tcp_input+0xdf4>
      tcp_ack_now(pcb);
  811006:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81100a:	89 1c 24             	mov    %ebx,(%esp)
  81100d:	e8 f9 9d ff ff       	call   80ae0b <tcp_output>
      pcb->state = CLOSE_WAIT;
  811012:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  811019:	e9 1d 04 00 00       	jmp    81143b <tcp_input+0xdf4>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  81101e:	89 d8                	mov    %ebx,%eax
  811020:	e8 ab e9 ff ff       	call   80f9d0 <tcp_receive>
    if (flags & TCP_FIN) {
  811025:	0f b6 05 00 c2 b3 00 	movzbl 0xb3c200,%eax
  81102c:	a8 01                	test   $0x1,%al
  81102e:	0f 84 a1 00 00 00    	je     8110d5 <tcp_input+0xa8e>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  811034:	a8 10                	test   $0x10,%al
  811036:	0f 84 81 00 00 00    	je     8110bd <tcp_input+0xa76>
  81103c:	8b 43 54             	mov    0x54(%ebx),%eax
  81103f:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  811045:	75 76                	jne    8110bd <tcp_input+0xa76>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  811047:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81104b:	89 1c 24             	mov    %ebx,(%esp)
  81104e:	e8 b8 9d ff ff       	call   80ae0b <tcp_output>
        tcp_pcb_purge(pcb);
  811053:	89 1c 24             	mov    %ebx,(%esp)
  811056:	e8 1c 75 ff ff       	call   808577 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  81105b:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  811060:	39 c3                	cmp    %eax,%ebx
  811062:	75 0a                	jne    81106e <tcp_input+0xa27>
  811064:	8b 43 0c             	mov    0xc(%ebx),%eax
  811067:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
  81106c:	eb 29                	jmp    811097 <tcp_input+0xa50>
  81106e:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  811073:	eb 19                	jmp    81108e <tcp_input+0xa47>
  811075:	8b 50 0c             	mov    0xc(%eax),%edx
  811078:	85 d2                	test   %edx,%edx
  81107a:	74 0c                	je     811088 <tcp_input+0xa41>
  81107c:	39 d3                	cmp    %edx,%ebx
  81107e:	75 08                	jne    811088 <tcp_input+0xa41>
  811080:	8b 53 0c             	mov    0xc(%ebx),%edx
  811083:	89 50 0c             	mov    %edx,0xc(%eax)
  811086:	eb 0f                	jmp    811097 <tcp_input+0xa50>
  811088:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  81108e:	a1 18 f0 b3 00       	mov    0xb3f018,%eax
  811093:	85 c0                	test   %eax,%eax
  811095:	75 de                	jne    811075 <tcp_input+0xa2e>
  811097:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
        pcb->state = TIME_WAIT;
  81109e:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  8110a5:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  8110aa:	89 43 0c             	mov    %eax,0xc(%ebx)
  8110ad:	89 1d 20 f0 b3 00    	mov    %ebx,0xb3f020
  8110b3:	e8 75 39 ff ff       	call   804a2d <tcp_timer_needed>
  8110b8:	e9 7e 03 00 00       	jmp    81143b <tcp_input+0xdf4>
      } else {
        tcp_ack_now(pcb);
  8110bd:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8110c1:	89 1c 24             	mov    %ebx,(%esp)
  8110c4:	e8 42 9d ff ff       	call   80ae0b <tcp_output>
        pcb->state = CLOSING;
  8110c9:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  8110d0:	e9 66 03 00 00       	jmp    81143b <tcp_input+0xdf4>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  8110d5:	a8 10                	test   $0x10,%al
  8110d7:	0f 84 5e 03 00 00    	je     81143b <tcp_input+0xdf4>
  8110dd:	8b 43 54             	mov    0x54(%ebx),%eax
  8110e0:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  8110e6:	0f 85 4f 03 00 00    	jne    81143b <tcp_input+0xdf4>
      pcb->state = FIN_WAIT_2;
  8110ec:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  8110f3:	e9 43 03 00 00       	jmp    81143b <tcp_input+0xdf4>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  8110f8:	89 d8                	mov    %ebx,%eax
  8110fa:	e8 d1 e8 ff ff       	call   80f9d0 <tcp_receive>
    if (flags & TCP_FIN) {
  8110ff:	f6 05 00 c2 b3 00 01 	testb  $0x1,0xb3c200
  811106:	0f 84 2f 03 00 00    	je     81143b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  81110c:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  811110:	89 1c 24             	mov    %ebx,(%esp)
  811113:	e8 f3 9c ff ff       	call   80ae0b <tcp_output>
      tcp_pcb_purge(pcb);
  811118:	89 1c 24             	mov    %ebx,(%esp)
  81111b:	e8 57 74 ff ff       	call   808577 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  811120:	8b 15 0c f0 b3 00    	mov    0xb3f00c,%edx
  811126:	39 d3                	cmp    %edx,%ebx
  811128:	75 0a                	jne    811134 <tcp_input+0xaed>
  81112a:	8b 43 0c             	mov    0xc(%ebx),%eax
  81112d:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
  811132:	eb 2a                	jmp    81115e <tcp_input+0xb17>
  811134:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  81113a:	85 d2                	test   %edx,%edx
  81113c:	74 20                	je     81115e <tcp_input+0xb17>
  81113e:	8b 42 0c             	mov    0xc(%edx),%eax
  811141:	85 c0                	test   %eax,%eax
  811143:	0f 84 dd 02 00 00    	je     811426 <tcp_input+0xddf>
  811149:	39 c3                	cmp    %eax,%ebx
  81114b:	75 08                	jne    811155 <tcp_input+0xb0e>
  81114d:	8b 43 0c             	mov    0xc(%ebx),%eax
  811150:	89 42 0c             	mov    %eax,0xc(%edx)
  811153:	eb 09                	jmp    81115e <tcp_input+0xb17>
  811155:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  81115a:	89 c2                	mov    %eax,%edx
  81115c:	eb e0                	jmp    81113e <tcp_input+0xaf7>
  81115e:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  811165:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81116c:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  811171:	89 43 0c             	mov    %eax,0xc(%ebx)
  811174:	89 1d 20 f0 b3 00    	mov    %ebx,0xb3f020
  81117a:	e8 ae 38 ff ff       	call   804a2d <tcp_timer_needed>
  81117f:	e9 b7 02 00 00       	jmp    81143b <tcp_input+0xdf4>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  811184:	89 d8                	mov    %ebx,%eax
  811186:	e8 45 e8 ff ff       	call   80f9d0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81118b:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  811192:	0f 84 a3 02 00 00    	je     81143b <tcp_input+0xdf4>
  811198:	8b 43 54             	mov    0x54(%ebx),%eax
  81119b:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  8111a1:	0f 85 94 02 00 00    	jne    81143b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  8111a7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8111ab:	89 1c 24             	mov    %ebx,(%esp)
  8111ae:	e8 58 9c ff ff       	call   80ae0b <tcp_output>
      tcp_pcb_purge(pcb);
  8111b3:	89 1c 24             	mov    %ebx,(%esp)
  8111b6:	e8 bc 73 ff ff       	call   808577 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  8111bb:	a1 0c f0 b3 00       	mov    0xb3f00c,%eax
  8111c0:	39 c3                	cmp    %eax,%ebx
  8111c2:	75 0a                	jne    8111ce <tcp_input+0xb87>
  8111c4:	8b 43 0c             	mov    0xc(%ebx),%eax
  8111c7:	a3 0c f0 b3 00       	mov    %eax,0xb3f00c
  8111cc:	eb 2a                	jmp    8111f8 <tcp_input+0xbb1>
  8111ce:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  8111d3:	85 c0                	test   %eax,%eax
  8111d5:	74 21                	je     8111f8 <tcp_input+0xbb1>
  8111d7:	8b 50 0c             	mov    0xc(%eax),%edx
  8111da:	85 d2                	test   %edx,%edx
  8111dc:	0f 84 4e 02 00 00    	je     811430 <tcp_input+0xde9>
  8111e2:	39 d3                	cmp    %edx,%ebx
  8111e4:	75 08                	jne    8111ee <tcp_input+0xba7>
  8111e6:	8b 53 0c             	mov    0xc(%ebx),%edx
  8111e9:	89 50 0c             	mov    %edx,0xc(%eax)
  8111ec:	eb 0a                	jmp    8111f8 <tcp_input+0xbb1>
  8111ee:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  8111f4:	89 d0                	mov    %edx,%eax
  8111f6:	eb df                	jmp    8111d7 <tcp_input+0xb90>
  8111f8:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  8111ff:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  811206:	a1 20 f0 b3 00       	mov    0xb3f020,%eax
  81120b:	89 43 0c             	mov    %eax,0xc(%ebx)
  81120e:	89 1d 20 f0 b3 00    	mov    %ebx,0xb3f020
  811214:	e8 14 38 ff ff       	call   804a2d <tcp_timer_needed>
  811219:	e9 1d 02 00 00       	jmp    81143b <tcp_input+0xdf4>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  81121e:	89 d8                	mov    %ebx,%eax
  811220:	e8 ab e7 ff ff       	call   80f9d0 <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  811225:	f6 05 00 c2 b3 00 10 	testb  $0x10,0xb3c200
  81122c:	0f 84 09 02 00 00    	je     81143b <tcp_input+0xdf4>
  811232:	8b 43 54             	mov    0x54(%ebx),%eax
  811235:	3b 05 fc c1 b3 00    	cmp    0xb3c1fc,%eax
  81123b:	0f 85 fa 01 00 00    	jne    81143b <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  811241:	c6 05 04 c2 b3 00 10 	movb   $0x10,0xb3c204
  811248:	e9 ee 01 00 00       	jmp    81143b <tcp_input+0xdf4>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  81124d:	c7 05 28 f0 b3 00 00 	movl   $0x0,0xb3f028
  811254:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  811257:	0f b6 05 04 c2 b3 00 	movzbl 0xb3c204,%eax
  81125e:	a8 08                	test   $0x8,%al
  811260:	74 3f                	je     8112a1 <tcp_input+0xc5a>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  811262:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  811268:	85 c0                	test   %eax,%eax
  81126a:	74 10                	je     81127c <tcp_input+0xc35>
  81126c:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  811273:	ff 
  811274:	8b 53 18             	mov    0x18(%ebx),%edx
  811277:	89 14 24             	mov    %edx,(%esp)
  81127a:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81127c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811280:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  811287:	e8 64 73 ff ff       	call   8085f0 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  81128c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811290:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  811297:	e8 68 5f ff ff       	call   807204 <memp_free>
  81129c:	e9 fc 00 00 00       	jmp    81139d <tcp_input+0xd56>
      } else if (recv_flags & TF_CLOSED) {
  8112a1:	a8 10                	test   $0x10,%al
  8112a3:	74 25                	je     8112ca <tcp_input+0xc83>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  8112a5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8112a9:	c7 04 24 0c f0 b3 00 	movl   $0xb3f00c,(%esp)
  8112b0:	e8 3b 73 ff ff       	call   8085f0 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  8112b5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8112b9:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8112c0:	e8 3f 5f ff ff       	call   807204 <memp_free>
  8112c5:	e9 d3 00 00 00       	jmp    81139d <tcp_input+0xd56>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  8112ca:	0f b7 43 6c          	movzwl 0x6c(%ebx),%eax
  8112ce:	66 85 c0             	test   %ax,%ax
  8112d1:	74 1f                	je     8112f2 <tcp_input+0xcab>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  8112d3:	8b 93 84 00 00 00    	mov    0x84(%ebx),%edx
  8112d9:	85 d2                	test   %edx,%edx
  8112db:	74 15                	je     8112f2 <tcp_input+0xcab>
  8112dd:	0f b7 c0             	movzwl %ax,%eax
  8112e0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8112e4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8112e8:	8b 43 18             	mov    0x18(%ebx),%eax
  8112eb:	89 04 24             	mov    %eax,(%esp)
  8112ee:	ff d2                	call   *%edx
  8112f0:	eb 05                	jmp    8112f7 <tcp_input+0xcb0>
  8112f2:	b8 00 00 00 00       	mov    $0x0,%eax
        }
      
        if (recv_data != NULL) {
  8112f7:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  8112fd:	85 d2                	test   %edx,%edx
  8112ff:	74 61                	je     811362 <tcp_input+0xd1b>
          if(flags & TCP_PSH) {
  811301:	f6 05 00 c2 b3 00 08 	testb  $0x8,0xb3c200
  811308:	74 04                	je     81130e <tcp_input+0xcc7>
            recv_data->flags |= PBUF_FLAG_PUSH;
  81130a:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81130e:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  811314:	85 c0                	test   %eax,%eax
  811316:	74 24                	je     81133c <tcp_input+0xcf5>
  811318:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  81131f:	00 
  811320:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  811326:	89 54 24 08          	mov    %edx,0x8(%esp)
  81132a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81132e:	8b 53 18             	mov    0x18(%ebx),%edx
  811331:	89 14 24             	mov    %edx,(%esp)
  811334:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  811336:	84 c0                	test   %al,%al
  811338:	75 1c                	jne    811356 <tcp_input+0xd0f>
  81133a:	eb 26                	jmp    811362 <tcp_input+0xd1b>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81133c:	a1 08 c2 b3 00       	mov    0xb3c208,%eax
  811341:	85 c0                	test   %eax,%eax
  811343:	0f 84 01 01 00 00    	je     81144a <tcp_input+0xe03>
  811349:	89 04 24             	mov    %eax,(%esp)
  81134c:	e8 3c 66 ff ff       	call   80798d <pbuf_free>
  811351:	e9 f4 00 00 00       	jmp    81144a <tcp_input+0xe03>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  811356:	8b 15 08 c2 b3 00    	mov    0xb3c208,%edx
  81135c:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  811362:	f6 05 04 c2 b3 00 20 	testb  $0x20,0xb3c204
  811369:	74 26                	je     811391 <tcp_input+0xd4a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81136b:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  811371:	85 c0                	test   %eax,%eax
  811373:	74 20                	je     811395 <tcp_input+0xd4e>
  811375:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  81137c:	00 
  81137d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811384:	00 
  811385:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811389:	8b 53 18             	mov    0x18(%ebx),%edx
  81138c:	89 14 24             	mov    %edx,(%esp)
  81138f:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  811391:	84 c0                	test   %al,%al
  811393:	75 08                	jne    81139d <tcp_input+0xd56>
          tcp_output(pcb);
  811395:	89 1c 24             	mov    %ebx,(%esp)
  811398:	e8 6e 9a ff ff       	call   80ae0b <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81139d:	a1 e0 c1 b3 00       	mov    0xb3c1e0,%eax
  8113a2:	85 c0                	test   %eax,%eax
  8113a4:	0f 84 aa 00 00 00    	je     811454 <tcp_input+0xe0d>
    {
      pbuf_free(inseg.p);
  8113aa:	89 04 24             	mov    %eax,(%esp)
  8113ad:	e8 db 65 ff ff       	call   80798d <pbuf_free>
      inseg.p = NULL;
  8113b2:	c7 05 e0 c1 b3 00 00 	movl   $0x0,0xb3c1e0
  8113b9:	00 00 00 
  8113bc:	e9 93 00 00 00       	jmp    811454 <tcp_input+0xe0d>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  8113c1:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  8113c6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8113ca:	89 04 24             	mov    %eax,(%esp)
  8113cd:	e8 be 93 ff ff       	call   80a790 <ntohs>
  8113d2:	a8 04                	test   $0x4,%al
  8113d4:	75 46                	jne    81141c <tcp_input+0xdd5>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  8113d6:	8b 15 f0 c1 b3 00    	mov    0xb3c1f0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  8113dc:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  8113e1:	0f b7 0a             	movzwl (%edx),%ecx
  8113e4:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  8113e8:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  8113ec:	89 54 24 10          	mov    %edx,0x10(%esp)
  8113f0:	8d 50 0c             	lea    0xc(%eax),%edx
  8113f3:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8113f7:	83 c0 10             	add    $0x10,%eax
  8113fa:	89 44 24 08          	mov    %eax,0x8(%esp)
  8113fe:	0f b7 05 02 c2 b3 00 	movzwl 0xb3c202,%eax
  811405:	03 05 f8 c1 b3 00    	add    0xb3c1f8,%eax
  81140b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81140f:	a1 fc c1 b3 00       	mov    0xb3c1fc,%eax
  811414:	89 04 24             	mov    %eax,(%esp)
  811417:	e8 90 98 ff ff       	call   80acac <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  81141c:	89 34 24             	mov    %esi,(%esp)
  81141f:	e8 69 65 ff ff       	call   80798d <pbuf_free>
  811424:	eb 2e                	jmp    811454 <tcp_input+0xe0d>
    tcp_receive(pcb);
    if (flags & TCP_FIN) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  811426:	a3 18 f0 b3 00       	mov    %eax,0xb3f018
  81142b:	e9 2e fd ff ff       	jmp    81115e <tcp_input+0xb17>
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  811430:	89 15 18 f0 b3 00    	mov    %edx,0xb3f018
  811436:	e9 bd fd ff ff       	jmp    8111f8 <tcp_input+0xbb1>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  81143b:	c7 05 28 f0 b3 00 00 	movl   $0x0,0xb3f028
  811442:	00 00 00 
  811445:	e9 0d fe ff ff       	jmp    811257 <tcp_input+0xc10>
  81144a:	b8 00 00 00 00       	mov    $0x0,%eax
  81144f:	e9 0e ff ff ff       	jmp    811362 <tcp_input+0xd1b>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  811454:	83 c4 5c             	add    $0x5c,%esp
  811457:	5b                   	pop    %ebx
  811458:	5e                   	pop    %esi
  811459:	5f                   	pop    %edi
  81145a:	5d                   	pop    %ebp
  81145b:	c3                   	ret    
  81145c:	00 00                	add    %al,(%eax)
	...

00811460 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  811460:	55                   	push   %ebp
  811461:	89 e5                	mov    %esp,%ebp
  811463:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  811466:	b8 00 00 00 00       	mov    $0x0,%eax
  81146b:	85 d2                	test   %edx,%edx
  81146d:	74 02                	je     811471 <raw_bind+0x11>
  81146f:	8b 02                	mov    (%edx),%eax
  811471:	8b 55 08             	mov    0x8(%ebp),%edx
  811474:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  811476:	b8 00 00 00 00       	mov    $0x0,%eax
  81147b:	5d                   	pop    %ebp
  81147c:	c3                   	ret    

0081147d <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  81147d:	55                   	push   %ebp
  81147e:	89 e5                	mov    %esp,%ebp
  811480:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  811483:	b8 00 00 00 00       	mov    $0x0,%eax
  811488:	85 d2                	test   %edx,%edx
  81148a:	74 02                	je     81148e <raw_connect+0x11>
  81148c:	8b 02                	mov    (%edx),%eax
  81148e:	8b 55 08             	mov    0x8(%ebp),%edx
  811491:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  811494:	b8 00 00 00 00       	mov    $0x0,%eax
  811499:	5d                   	pop    %ebp
  81149a:	c3                   	ret    

0081149b <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  81149b:	55                   	push   %ebp
  81149c:	89 e5                	mov    %esp,%ebp
  81149e:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  8114a1:	8b 55 0c             	mov    0xc(%ebp),%edx
  8114a4:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  8114a7:	8b 55 10             	mov    0x10(%ebp),%edx
  8114aa:	89 50 18             	mov    %edx,0x18(%eax)
}
  8114ad:	5d                   	pop    %ebp
  8114ae:	c3                   	ret    

008114af <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  8114af:	55                   	push   %ebp
  8114b0:	89 e5                	mov    %esp,%ebp
  8114b2:	83 ec 18             	sub    $0x18,%esp
  8114b5:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8114b8:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8114bb:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  8114bf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8114c6:	e8 7d 5d ff ff       	call   807248 <memp_malloc>
  8114cb:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  8114cd:	85 c0                	test   %eax,%eax
  8114cf:	74 2f                	je     811500 <raw_new+0x51>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  8114d1:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  8114d8:	00 
  8114d9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8114e0:	00 
  8114e1:	89 04 24             	mov    %eax,(%esp)
  8114e4:	e8 ad fd fe ff       	call   801296 <memset>
    pcb->protocol = proto;
  8114e9:	89 f0                	mov    %esi,%eax
  8114eb:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  8114ee:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  8114f2:	a1 0c c2 b3 00       	mov    0xb3c20c,%eax
  8114f7:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  8114fa:	89 1d 0c c2 b3 00    	mov    %ebx,0xb3c20c
  }
  return pcb;
}
  811500:	89 d8                	mov    %ebx,%eax
  811502:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  811505:	8b 75 fc             	mov    -0x4(%ebp),%esi
  811508:	89 ec                	mov    %ebp,%esp
  81150a:	5d                   	pop    %ebp
  81150b:	c3                   	ret    

0081150c <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  81150c:	55                   	push   %ebp
  81150d:	89 e5                	mov    %esp,%ebp
  81150f:	83 ec 18             	sub    $0x18,%esp
  811512:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  811515:	8b 15 0c c2 b3 00    	mov    0xb3c20c,%edx
  81151b:	39 ca                	cmp    %ecx,%edx
  81151d:	74 06                	je     811525 <raw_remove+0x19>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  81151f:	85 d2                	test   %edx,%edx
  811521:	75 0e                	jne    811531 <raw_remove+0x25>
  811523:	eb 21                	jmp    811546 <raw_remove+0x3a>
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  811525:	8b 42 0c             	mov    0xc(%edx),%eax
  811528:	a3 0c c2 b3 00       	mov    %eax,0xb3c20c
  81152d:	eb 17                	jmp    811546 <raw_remove+0x3a>
  81152f:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  811531:	8b 42 0c             	mov    0xc(%edx),%eax
  811534:	85 c0                	test   %eax,%eax
  811536:	74 0e                	je     811546 <raw_remove+0x3a>
  811538:	39 c1                	cmp    %eax,%ecx
  81153a:	75 f3                	jne    81152f <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  81153c:	8b 41 0c             	mov    0xc(%ecx),%eax
  81153f:	89 42 0c             	mov    %eax,0xc(%edx)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  811542:	85 c0                	test   %eax,%eax
  811544:	75 e9                	jne    81152f <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  811546:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  81154a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811551:	e8 ae 5c ff ff       	call   807204 <memp_free>
}
  811556:	c9                   	leave  
  811557:	c3                   	ret    

00811558 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  811558:	55                   	push   %ebp
  811559:	89 e5                	mov    %esp,%ebp
  81155b:	57                   	push   %edi
  81155c:	56                   	push   %esi
  81155d:	53                   	push   %ebx
  81155e:	83 ec 3c             	sub    $0x3c,%esp
  811561:	8b 5d 08             	mov    0x8(%ebp),%ebx
  811564:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  811567:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  81156e:	00 
  81156f:	89 3c 24             	mov    %edi,(%esp)
  811572:	e8 ac 60 ff ff       	call   807623 <pbuf_header>
  811577:	84 c0                	test   %al,%al
  811579:	74 38                	je     8115b3 <raw_sendto+0x5b>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  81157b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811582:	00 
  811583:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  81158a:	00 
  81158b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811592:	e8 b2 66 ff ff       	call   807c49 <pbuf_alloc>
  811597:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  811599:	c6 45 e7 ff          	movb   $0xff,-0x19(%ebp)
  81159d:	85 c0                	test   %eax,%eax
  81159f:	0f 84 b1 00 00 00    	je     811656 <raw_sendto+0xfe>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  8115a5:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8115a9:	89 04 24             	mov    %eax,(%esp)
  8115ac:	e8 4b 60 ff ff       	call   8075fc <pbuf_chain>
  8115b1:	eb 32                	jmp    8115e5 <raw_sendto+0x8d>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  8115b3:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  8115ba:	ff 
  8115bb:	89 3c 24             	mov    %edi,(%esp)
  8115be:	e8 60 60 ff ff       	call   807623 <pbuf_header>
  8115c3:	84 c0                	test   %al,%al
  8115c5:	74 1c                	je     8115e3 <raw_sendto+0x8b>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  8115c7:	c7 44 24 08 64 4b 81 	movl   $0x814b64,0x8(%esp)
  8115ce:	00 
  8115cf:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  8115d6:	00 
  8115d7:	c7 04 24 8a 4b 81 00 	movl   $0x814b8a,(%esp)
  8115de:	e8 31 f3 fe ff       	call   800914 <_panic>
  8115e3:	89 fe                	mov    %edi,%esi
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  8115e5:	8b 45 10             	mov    0x10(%ebp),%eax
  8115e8:	89 04 24             	mov    %eax,(%esp)
  8115eb:	e8 81 7f ff ff       	call   809571 <ip_route>
  8115f0:	85 c0                	test   %eax,%eax
  8115f2:	75 16                	jne    81160a <raw_sendto+0xb2>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  8115f4:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  8115f8:	39 fe                	cmp    %edi,%esi
  8115fa:	74 5a                	je     811656 <raw_sendto+0xfe>
      pbuf_free(q);
  8115fc:	89 34 24             	mov    %esi,(%esp)
  8115ff:	e8 89 63 ff ff       	call   80798d <pbuf_free>
  811604:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  811608:	eb 4c                	jmp    811656 <raw_sendto+0xfe>
    }
    return ERR_RTE;
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  81160a:	89 da                	mov    %ebx,%edx
  81160c:	85 db                	test   %ebx,%ebx
  81160e:	74 05                	je     811615 <raw_sendto+0xbd>
  811610:	83 3b 00             	cmpl   $0x0,(%ebx)
  811613:	75 03                	jne    811618 <raw_sendto+0xc0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  811615:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  811618:	89 44 24 18          	mov    %eax,0x18(%esp)
  81161c:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  811620:	89 44 24 14          	mov    %eax,0x14(%esp)
  811624:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  811628:	89 44 24 10          	mov    %eax,0x10(%esp)
  81162c:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  811630:	89 44 24 0c          	mov    %eax,0xc(%esp)
  811634:	8b 45 10             	mov    0x10(%ebp),%eax
  811637:	89 44 24 08          	mov    %eax,0x8(%esp)
  81163b:	89 54 24 04          	mov    %edx,0x4(%esp)
  81163f:	89 34 24             	mov    %esi,(%esp)
  811642:	e8 79 7d ff ff       	call   8093c0 <ip_output_if>
  811647:	88 45 e7             	mov    %al,-0x19(%ebp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  81164a:	39 fe                	cmp    %edi,%esi
  81164c:	74 08                	je     811656 <raw_sendto+0xfe>
    /* free the header */
    pbuf_free(q);
  81164e:	89 34 24             	mov    %esi,(%esp)
  811651:	e8 37 63 ff ff       	call   80798d <pbuf_free>
  }
  return err;
}
  811656:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  81165a:	83 c4 3c             	add    $0x3c,%esp
  81165d:	5b                   	pop    %ebx
  81165e:	5e                   	pop    %esi
  81165f:	5f                   	pop    %edi
  811660:	5d                   	pop    %ebp
  811661:	c3                   	ret    

00811662 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  811662:	55                   	push   %ebp
  811663:	89 e5                	mov    %esp,%ebp
  811665:	83 ec 18             	sub    $0x18,%esp
  811668:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  81166b:	8d 50 04             	lea    0x4(%eax),%edx
  81166e:	89 54 24 08          	mov    %edx,0x8(%esp)
  811672:	8b 55 0c             	mov    0xc(%ebp),%edx
  811675:	89 54 24 04          	mov    %edx,0x4(%esp)
  811679:	89 04 24             	mov    %eax,(%esp)
  81167c:	e8 d7 fe ff ff       	call   811558 <raw_sendto>
}
  811681:	c9                   	leave  
  811682:	c3                   	ret    

00811683 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  811683:	55                   	push   %ebp
  811684:	89 e5                	mov    %esp,%ebp
  811686:	57                   	push   %edi
  811687:	56                   	push   %esi
  811688:	53                   	push   %ebx
  811689:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  81168c:	8b 45 08             	mov    0x8(%ebp),%eax
  81168f:	8b 70 04             	mov    0x4(%eax),%esi
  proto = IPH_PROTO(iphdr);
  811692:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811696:	89 04 24             	mov    %eax,(%esp)
  811699:	e8 f2 90 ff ff       	call   80a790 <ntohs>
  81169e:	66 25 ff 00          	and    $0xff,%ax

  prev = NULL;
  pcb = raw_pcbs;
  8116a2:	8b 1d 0c c2 b3 00    	mov    0xb3c20c,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  8116a8:	85 db                	test   %ebx,%ebx
  8116aa:	74 6c                	je     811718 <raw_input+0x95>
    if (pcb->protocol == proto) {
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  8116ac:	83 c6 0c             	add    $0xc,%esi
  8116af:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  8116b2:	be 00 00 00 00       	mov    $0x0,%esi
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  8116b7:	0f bf f8             	movswl %ax,%edi
  8116ba:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  8116be:	39 f8                	cmp    %edi,%eax
  8116c0:	75 49                	jne    81170b <raw_input+0x88>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  8116c2:	8b 43 14             	mov    0x14(%ebx),%eax
  8116c5:	85 c0                	test   %eax,%eax
  8116c7:	74 42                	je     81170b <raw_input+0x88>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  8116c9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8116cc:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8116d0:	8b 55 08             	mov    0x8(%ebp),%edx
  8116d3:	89 54 24 08          	mov    %edx,0x8(%esp)
  8116d7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8116db:	8b 53 18             	mov    0x18(%ebx),%edx
  8116de:	89 14 24             	mov    %edx,(%esp)
  8116e1:	ff d0                	call   *%eax
  8116e3:	84 c0                	test   %al,%al
  8116e5:	74 24                	je     81170b <raw_input+0x88>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  8116e7:	b8 01 00 00 00       	mov    $0x1,%eax
  8116ec:	85 f6                	test   %esi,%esi
  8116ee:	74 2d                	je     81171d <raw_input+0x9a>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  8116f0:	8b 43 0c             	mov    0xc(%ebx),%eax
  8116f3:	89 46 0c             	mov    %eax,0xc(%esi)
            pcb->next = raw_pcbs;
  8116f6:	a1 0c c2 b3 00       	mov    0xb3c20c,%eax
  8116fb:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  8116fe:	89 1d 0c c2 b3 00    	mov    %ebx,0xb3c20c
  811704:	b8 01 00 00 00       	mov    $0x1,%eax
  811709:	eb 12                	jmp    81171d <raw_input+0x9a>
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  81170b:	8b 43 0c             	mov    0xc(%ebx),%eax

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81170e:	85 c0                	test   %eax,%eax
  811710:	74 06                	je     811718 <raw_input+0x95>
  811712:	89 de                	mov    %ebx,%esi
  811714:	89 c3                	mov    %eax,%ebx
  811716:	eb a2                	jmp    8116ba <raw_input+0x37>
  811718:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  81171d:	83 c4 2c             	add    $0x2c,%esp
  811720:	5b                   	pop    %ebx
  811721:	5e                   	pop    %esi
  811722:	5f                   	pop    %edi
  811723:	5d                   	pop    %ebp
  811724:	c3                   	ret    
	...

00811730 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  811730:	55                   	push   %ebp
  811731:	89 e5                	mov    %esp,%ebp
  811733:	57                   	push   %edi
  811734:	56                   	push   %esi
  811735:	53                   	push   %ebx
  811736:	83 ec 3c             	sub    $0x3c,%esp
  811739:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  81173c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811743:	00 
  811744:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  81174b:	00 
  81174c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811753:	e8 f1 64 ff ff       	call   807c49 <pbuf_alloc>
  811758:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  81175a:	85 c0                	test   %eax,%eax
  81175c:	0f 84 d8 00 00 00    	je     81183a <icmp_time_exceeded+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  811762:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  811767:	77 1c                	ja     811785 <icmp_time_exceeded+0x55>
  811769:	c7 44 24 08 a0 4b 81 	movl   $0x814ba0,0x8(%esp)
  811770:	00 
  811771:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  811778:	00 
  811779:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811780:	e8 8f f1 fe ff       	call   800914 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  811785:	8b 47 04             	mov    0x4(%edi),%eax
  811788:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  81178b:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  81178e:	0f b7 06             	movzwl (%esi),%eax
  811791:	89 04 24             	mov    %eax,(%esp)
  811794:	e8 f7 8f ff ff       	call   80a790 <ntohs>
  811799:	0f b6 c0             	movzbl %al,%eax
  81179c:	80 cc 0b             	or     $0xb,%ah
  81179f:	89 04 24             	mov    %eax,(%esp)
  8117a2:	e8 dc 8f ff ff       	call   80a783 <htons>
  8117a7:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  8117aa:	0f b7 c0             	movzwl %ax,%eax
  8117ad:	89 04 24             	mov    %eax,(%esp)
  8117b0:	e8 db 8f ff ff       	call   80a790 <ntohs>
  8117b5:	b0 00                	mov    $0x0,%al
  8117b7:	66 0b 45 0c          	or     0xc(%ebp),%ax
  8117bb:	0f b7 c0             	movzwl %ax,%eax
  8117be:	89 04 24             	mov    %eax,(%esp)
  8117c1:	e8 bd 8f ff ff       	call   80a783 <htons>
  8117c6:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  8117c9:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  8117d0:	00 
  8117d1:	8b 47 04             	mov    0x4(%edi),%eax
  8117d4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8117d8:	8b 43 04             	mov    0x4(%ebx),%eax
  8117db:	83 c0 08             	add    $0x8,%eax
  8117de:	89 04 24             	mov    %eax,(%esp)
  8117e1:	e8 8b fb fe ff       	call   801371 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  8117e6:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  8117ec:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8117f0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8117f4:	89 34 24             	mov    %esi,(%esp)
  8117f7:	e8 6e 8c ff ff       	call   80a46a <inet_chksum>
  8117fc:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811800:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811807:	00 
  811808:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  81180f:	00 
  811810:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811817:	00 
  811818:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81181b:	83 c0 0c             	add    $0xc,%eax
  81181e:	89 44 24 08          	mov    %eax,0x8(%esp)
  811822:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811829:	00 
  81182a:	89 1c 24             	mov    %ebx,(%esp)
  81182d:	e8 9b 7d ff ff       	call   8095cd <ip_output>
  pbuf_free(q);
  811832:	89 1c 24             	mov    %ebx,(%esp)
  811835:	e8 53 61 ff ff       	call   80798d <pbuf_free>
}
  81183a:	83 c4 3c             	add    $0x3c,%esp
  81183d:	5b                   	pop    %ebx
  81183e:	5e                   	pop    %esi
  81183f:	5f                   	pop    %edi
  811840:	5d                   	pop    %ebp
  811841:	c3                   	ret    

00811842 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  811842:	55                   	push   %ebp
  811843:	89 e5                	mov    %esp,%ebp
  811845:	57                   	push   %edi
  811846:	56                   	push   %esi
  811847:	53                   	push   %ebx
  811848:	83 ec 3c             	sub    $0x3c,%esp
  81184b:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  81184e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811855:	00 
  811856:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  81185d:	00 
  81185e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811865:	e8 df 63 ff ff       	call   807c49 <pbuf_alloc>
  81186a:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  81186c:	85 c0                	test   %eax,%eax
  81186e:	0f 84 d8 00 00 00    	je     81194c <icmp_dest_unreach+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  811874:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  811879:	77 1c                	ja     811897 <icmp_dest_unreach+0x55>
  81187b:	c7 44 24 08 a0 4b 81 	movl   $0x814ba0,0x8(%esp)
  811882:	00 
  811883:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  81188a:	00 
  81188b:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811892:	e8 7d f0 fe ff       	call   800914 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  811897:	8b 47 04             	mov    0x4(%edi),%eax
  81189a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = q->payload;
  81189d:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  8118a0:	0f b7 06             	movzwl (%esi),%eax
  8118a3:	89 04 24             	mov    %eax,(%esp)
  8118a6:	e8 e5 8e ff ff       	call   80a790 <ntohs>
  8118ab:	0f b6 c0             	movzbl %al,%eax
  8118ae:	80 cc 03             	or     $0x3,%ah
  8118b1:	89 04 24             	mov    %eax,(%esp)
  8118b4:	e8 ca 8e ff ff       	call   80a783 <htons>
  8118b9:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  8118bc:	0f b7 c0             	movzwl %ax,%eax
  8118bf:	89 04 24             	mov    %eax,(%esp)
  8118c2:	e8 c9 8e ff ff       	call   80a790 <ntohs>
  8118c7:	b0 00                	mov    $0x0,%al
  8118c9:	66 0b 45 0c          	or     0xc(%ebp),%ax
  8118cd:	0f b7 c0             	movzwl %ax,%eax
  8118d0:	89 04 24             	mov    %eax,(%esp)
  8118d3:	e8 ab 8e ff ff       	call   80a783 <htons>
  8118d8:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  8118db:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  8118e2:	00 
  8118e3:	8b 47 04             	mov    0x4(%edi),%eax
  8118e6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8118ea:	8b 43 04             	mov    0x4(%ebx),%eax
  8118ed:	83 c0 08             	add    $0x8,%eax
  8118f0:	89 04 24             	mov    %eax,(%esp)
  8118f3:	e8 79 fa fe ff       	call   801371 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  8118f8:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  8118fe:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  811902:	89 44 24 04          	mov    %eax,0x4(%esp)
  811906:	89 34 24             	mov    %esi,(%esp)
  811909:	e8 5c 8b ff ff       	call   80a46a <inet_chksum>
  81190e:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811912:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811919:	00 
  81191a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811921:	00 
  811922:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811929:	00 
  81192a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81192d:	83 c0 0c             	add    $0xc,%eax
  811930:	89 44 24 08          	mov    %eax,0x8(%esp)
  811934:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  81193b:	00 
  81193c:	89 1c 24             	mov    %ebx,(%esp)
  81193f:	e8 89 7c ff ff       	call   8095cd <ip_output>
  pbuf_free(q);
  811944:	89 1c 24             	mov    %ebx,(%esp)
  811947:	e8 41 60 ff ff       	call   80798d <pbuf_free>
}
  81194c:	83 c4 3c             	add    $0x3c,%esp
  81194f:	5b                   	pop    %ebx
  811950:	5e                   	pop    %esi
  811951:	5f                   	pop    %edi
  811952:	5d                   	pop    %ebp
  811953:	c3                   	ret    

00811954 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  811954:	55                   	push   %ebp
  811955:	89 e5                	mov    %esp,%ebp
  811957:	83 ec 48             	sub    $0x48,%esp
  81195a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  81195d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  811960:	89 7d fc             	mov    %edi,-0x4(%ebp)
  811963:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  811966:	8b 73 04             	mov    0x4(%ebx),%esi
  hlen = IPH_HL(iphdr) * 4;
  811969:	0f b7 06             	movzwl (%esi),%eax
  81196c:	89 04 24             	mov    %eax,(%esp)
  81196f:	e8 1c 8e ff ff       	call   80a790 <ntohs>
  811974:	66 c1 e8 06          	shr    $0x6,%ax
  811978:	83 e0 3c             	and    $0x3c,%eax
  81197b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  81197f:	89 c7                	mov    %eax,%edi
  811981:	f7 df                	neg    %edi
  811983:	0f bf ff             	movswl %di,%edi
  811986:	89 7c 24 04          	mov    %edi,0x4(%esp)
  81198a:	89 1c 24             	mov    %ebx,(%esp)
  81198d:	e8 91 5c ff ff       	call   807623 <pbuf_header>
  811992:	84 c0                	test   %al,%al
  811994:	0f 85 ee 02 00 00    	jne    811c88 <icmp_input+0x334>
  81199a:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  81199f:	0f 86 e3 02 00 00    	jbe    811c88 <icmp_input+0x334>

  type = *((u8_t *)p->payload);
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  8119a5:	8b 43 04             	mov    0x4(%ebx),%eax
  8119a8:	80 38 08             	cmpb   $0x8,(%eax)
  8119ab:	0f 85 cd 02 00 00    	jne    811c7e <icmp_input+0x32a>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  8119b1:	8b 45 0c             	mov    0xc(%ebp),%eax
  8119b4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8119b8:	8d 46 10             	lea    0x10(%esi),%eax
  8119bb:	89 04 24             	mov    %eax,(%esp)
  8119be:	e8 b5 79 ff ff       	call   809378 <ip_addr_isbroadcast>
  8119c3:	84 c0                	test   %al,%al
  8119c5:	75 2b                	jne    8119f2 <icmp_input+0x9e>
  8119c7:	8b 56 10             	mov    0x10(%esi),%edx
  8119ca:	89 55 dc             	mov    %edx,-0x24(%ebp)
  8119cd:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  8119d4:	e8 ec 8f ff ff       	call   80a9c5 <ntohl>
  8119d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8119dc:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8119e3:	e8 dd 8f ff ff       	call   80a9c5 <ntohl>
  8119e8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8119eb:	23 55 dc             	and    -0x24(%ebp),%edx
  8119ee:	39 c2                	cmp    %eax,%edx
  8119f0:	75 0d                	jne    8119ff <icmp_input+0xab>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  8119f2:	89 1c 24             	mov    %ebx,(%esp)
  8119f5:	e8 93 5f ff ff       	call   80798d <pbuf_free>
      return;
  8119fa:	e9 9b 02 00 00       	jmp    811c9a <icmp_input+0x346>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  8119ff:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  811a04:	0f 86 7e 02 00 00    	jbe    811c88 <icmp_input+0x334>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  811a0a:	89 1c 24             	mov    %ebx,(%esp)
  811a0d:	8d 76 00             	lea    0x0(%esi),%esi
  811a10:	e8 d0 89 ff ff       	call   80a3e5 <inet_chksum_pbuf>
  811a15:	66 85 c0             	test   %ax,%ax
  811a18:	74 0d                	je     811a27 <icmp_input+0xd3>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  811a1a:	89 1c 24             	mov    %ebx,(%esp)
  811a1d:	e8 6b 5f ff ff       	call   80798d <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  811a22:	e9 73 02 00 00       	jmp    811c9a <icmp_input+0x346>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811a27:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  811a2e:	00 
  811a2f:	89 1c 24             	mov    %ebx,(%esp)
  811a32:	e8 ec 5b ff ff       	call   807623 <pbuf_header>
  811a37:	84 c0                	test   %al,%al
  811a39:	0f 84 f0 00 00 00    	je     811b2f <icmp_input+0x1db>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  811a3f:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  811a43:	89 44 24 04          	mov    %eax,0x4(%esp)
  811a47:	89 1c 24             	mov    %ebx,(%esp)
  811a4a:	e8 d4 5b ff ff       	call   807623 <pbuf_header>
  811a4f:	84 c0                	test   %al,%al
  811a51:	74 1c                	je     811a6f <icmp_input+0x11b>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  811a53:	c7 44 24 08 cc 4b 81 	movl   $0x814bcc,0x8(%esp)
  811a5a:	00 
  811a5b:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  811a62:	00 
  811a63:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811a6a:	e8 a5 ee fe ff       	call   800914 <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  811a6f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811a76:	00 
  811a77:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  811a7b:	89 44 24 04          	mov    %eax,0x4(%esp)
  811a7f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  811a86:	e8 be 61 ff ff       	call   807c49 <pbuf_alloc>
  811a8b:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  811a8e:	85 c0                	test   %eax,%eax
  811a90:	0f 84 fc 01 00 00    	je     811c92 <icmp_input+0x33e>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  811a96:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  811a9a:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  811a9e:	83 c0 08             	add    $0x8,%eax
  811aa1:	39 c2                	cmp    %eax,%edx
  811aa3:	73 1c                	jae    811ac1 <icmp_input+0x16d>
  811aa5:	c7 44 24 08 00 4c 81 	movl   $0x814c00,0x8(%esp)
  811aac:	00 
  811aad:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  811ab4:	00 
  811ab5:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811abc:	e8 53 ee fe ff       	call   800914 <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  811ac1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811ac5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  811ac8:	89 04 24             	mov    %eax,(%esp)
  811acb:	e8 14 5d ff ff       	call   8077e4 <pbuf_copy>
  811ad0:	84 c0                	test   %al,%al
  811ad2:	74 1c                	je     811af0 <icmp_input+0x19c>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  811ad4:	c7 44 24 08 38 4c 81 	movl   $0x814c38,0x8(%esp)
  811adb:	00 
  811adc:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  811ae3:	00 
  811ae4:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811aeb:	e8 24 ee fe ff       	call   800914 <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  811af0:	8b 55 e0             	mov    -0x20(%ebp),%edx
  811af3:	8b 72 04             	mov    0x4(%edx),%esi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  811af6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811afa:	89 14 24             	mov    %edx,(%esp)
  811afd:	e8 21 5b ff ff       	call   807623 <pbuf_header>
  811b02:	84 c0                	test   %al,%al
  811b04:	74 1c                	je     811b22 <icmp_input+0x1ce>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  811b06:	c7 44 24 08 60 4c 81 	movl   $0x814c60,0x8(%esp)
  811b0d:	00 
  811b0e:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  811b15:	00 
  811b16:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811b1d:	e8 f2 ed fe ff       	call   800914 <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  811b22:	89 1c 24             	mov    %ebx,(%esp)
  811b25:	e8 63 5e ff ff       	call   80798d <pbuf_free>
  811b2a:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  811b2d:	eb 30                	jmp    811b5f <icmp_input+0x20b>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811b2f:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  811b36:	ff 
  811b37:	89 1c 24             	mov    %ebx,(%esp)
  811b3a:	e8 e4 5a ff ff       	call   807623 <pbuf_header>
  811b3f:	84 c0                	test   %al,%al
  811b41:	74 1c                	je     811b5f <icmp_input+0x20b>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  811b43:	c7 44 24 08 60 4c 81 	movl   $0x814c60,0x8(%esp)
  811b4a:	00 
  811b4b:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  811b52:	00 
  811b53:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811b5a:	e8 b5 ed fe ff       	call   800914 <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  811b5f:	8b 7b 04             	mov    0x4(%ebx),%edi
    tmpaddr.addr = iphdr->src.addr;
  811b62:	8b 46 0c             	mov    0xc(%esi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  811b65:	8b 56 10             	mov    0x10(%esi),%edx
  811b68:	89 56 0c             	mov    %edx,0xc(%esi)
    iphdr->dest.addr = tmpaddr.addr;
  811b6b:	89 46 10             	mov    %eax,0x10(%esi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  811b6e:	0f b7 07             	movzwl (%edi),%eax
  811b71:	89 04 24             	mov    %eax,(%esp)
  811b74:	e8 17 8c ff ff       	call   80a790 <ntohs>
  811b79:	0f b6 c0             	movzbl %al,%eax
  811b7c:	89 04 24             	mov    %eax,(%esp)
  811b7f:	e8 ff 8b ff ff       	call   80a783 <htons>
  811b84:	66 89 07             	mov    %ax,(%edi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  811b87:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  811b8b:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  811b8f:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  811b96:	e8 e8 8b ff ff       	call   80a783 <htons>
  811b9b:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  811b9f:	72 22                	jb     811bc3 <icmp_input+0x26f>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  811ba1:	0f b7 57 02          	movzwl 0x2(%edi),%edx
  811ba5:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
  811ba9:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  811bb0:	e8 ce 8b ff ff       	call   80a783 <htons>
  811bb5:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
  811bb9:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  811bbd:	66 89 47 02          	mov    %ax,0x2(%edi)
  811bc1:	eb 1c                	jmp    811bdf <icmp_input+0x28b>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  811bc3:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  811bc7:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  811bcb:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  811bd2:	e8 ac 8b ff ff       	call   80a783 <htons>
  811bd7:	66 03 45 e0          	add    -0x20(%ebp),%ax
  811bdb:	66 89 47 02          	mov    %ax,0x2(%edi)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  811bdf:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811be3:	89 04 24             	mov    %eax,(%esp)
  811be6:	e8 a5 8b ff ff       	call   80a790 <ntohs>
  811beb:	66 0d 00 ff          	or     $0xff00,%ax
  811bef:	0f b7 c0             	movzwl %ax,%eax
  811bf2:	89 04 24             	mov    %eax,(%esp)
  811bf5:	e8 89 8b ff ff       	call   80a783 <htons>
  811bfa:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  811bfe:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  811c04:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  811c0b:	00 
  811c0c:	89 34 24             	mov    %esi,(%esp)
  811c0f:	e8 56 88 ff ff       	call   80a46a <inet_chksum>
  811c14:	66 89 46 0a          	mov    %ax,0xa(%esi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  811c18:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  811c1c:	89 44 24 04          	mov    %eax,0x4(%esp)
  811c20:	89 1c 24             	mov    %ebx,(%esp)
  811c23:	e8 fb 59 ff ff       	call   807623 <pbuf_header>
  811c28:	84 c0                	test   %al,%al
  811c2a:	74 1c                	je     811c48 <icmp_input+0x2f4>
      LWIP_ASSERT("Can't move over header in packet", 0);
  811c2c:	c7 44 24 08 a4 3c 81 	movl   $0x813ca4,0x8(%esp)
  811c33:	00 
  811c34:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  811c3b:	00 
  811c3c:	c7 04 24 94 4c 81 00 	movl   $0x814c94,(%esp)
  811c43:	e8 cc ec fe ff       	call   800914 <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  811c48:	8b 55 0c             	mov    0xc(%ebp),%edx
  811c4b:	89 54 24 18          	mov    %edx,0x18(%esp)
  811c4f:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811c56:	00 
  811c57:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811c5e:	00 
  811c5f:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811c66:	00 
  811c67:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811c6e:	00 
  811c6f:	83 c6 0c             	add    $0xc,%esi
  811c72:	89 74 24 04          	mov    %esi,0x4(%esp)
  811c76:	89 1c 24             	mov    %ebx,(%esp)
  811c79:	e8 42 77 ff ff       	call   8093c0 <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  811c7e:	89 1c 24             	mov    %ebx,(%esp)
  811c81:	e8 07 5d ff ff       	call   80798d <pbuf_free>
  return;
  811c86:	eb 12                	jmp    811c9a <icmp_input+0x346>
lenerr:
  pbuf_free(p);
  811c88:	89 1c 24             	mov    %ebx,(%esp)
  811c8b:	e8 fd 5c ff ff       	call   80798d <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  811c90:	eb 08                	jmp    811c9a <icmp_input+0x346>
memerr:
  pbuf_free(p);
  811c92:	89 1c 24             	mov    %ebx,(%esp)
  811c95:	e8 f3 5c ff ff       	call   80798d <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  811c9a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  811c9d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  811ca0:	8b 7d fc             	mov    -0x4(%ebp),%edi
  811ca3:	89 ec                	mov    %ebp,%esp
  811ca5:	5d                   	pop    %ebp
  811ca6:	c3                   	ret    
	...

00811cb0 <__udivdi3>:
  811cb0:	55                   	push   %ebp
  811cb1:	89 e5                	mov    %esp,%ebp
  811cb3:	57                   	push   %edi
  811cb4:	56                   	push   %esi
  811cb5:	83 ec 10             	sub    $0x10,%esp
  811cb8:	8b 45 14             	mov    0x14(%ebp),%eax
  811cbb:	8b 55 08             	mov    0x8(%ebp),%edx
  811cbe:	8b 75 10             	mov    0x10(%ebp),%esi
  811cc1:	8b 7d 0c             	mov    0xc(%ebp),%edi
  811cc4:	85 c0                	test   %eax,%eax
  811cc6:	89 55 f0             	mov    %edx,-0x10(%ebp)
  811cc9:	75 35                	jne    811d00 <__udivdi3+0x50>
  811ccb:	39 fe                	cmp    %edi,%esi
  811ccd:	77 61                	ja     811d30 <__udivdi3+0x80>
  811ccf:	85 f6                	test   %esi,%esi
  811cd1:	75 0b                	jne    811cde <__udivdi3+0x2e>
  811cd3:	b8 01 00 00 00       	mov    $0x1,%eax
  811cd8:	31 d2                	xor    %edx,%edx
  811cda:	f7 f6                	div    %esi
  811cdc:	89 c6                	mov    %eax,%esi
  811cde:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  811ce1:	31 d2                	xor    %edx,%edx
  811ce3:	89 f8                	mov    %edi,%eax
  811ce5:	f7 f6                	div    %esi
  811ce7:	89 c7                	mov    %eax,%edi
  811ce9:	89 c8                	mov    %ecx,%eax
  811ceb:	f7 f6                	div    %esi
  811ced:	89 c1                	mov    %eax,%ecx
  811cef:	89 fa                	mov    %edi,%edx
  811cf1:	89 c8                	mov    %ecx,%eax
  811cf3:	83 c4 10             	add    $0x10,%esp
  811cf6:	5e                   	pop    %esi
  811cf7:	5f                   	pop    %edi
  811cf8:	5d                   	pop    %ebp
  811cf9:	c3                   	ret    
  811cfa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  811d00:	39 f8                	cmp    %edi,%eax
  811d02:	77 1c                	ja     811d20 <__udivdi3+0x70>
  811d04:	0f bd d0             	bsr    %eax,%edx
  811d07:	83 f2 1f             	xor    $0x1f,%edx
  811d0a:	89 55 f4             	mov    %edx,-0xc(%ebp)
  811d0d:	75 39                	jne    811d48 <__udivdi3+0x98>
  811d0f:	3b 75 f0             	cmp    -0x10(%ebp),%esi
  811d12:	0f 86 a0 00 00 00    	jbe    811db8 <__udivdi3+0x108>
  811d18:	39 f8                	cmp    %edi,%eax
  811d1a:	0f 82 98 00 00 00    	jb     811db8 <__udivdi3+0x108>
  811d20:	31 ff                	xor    %edi,%edi
  811d22:	31 c9                	xor    %ecx,%ecx
  811d24:	89 c8                	mov    %ecx,%eax
  811d26:	89 fa                	mov    %edi,%edx
  811d28:	83 c4 10             	add    $0x10,%esp
  811d2b:	5e                   	pop    %esi
  811d2c:	5f                   	pop    %edi
  811d2d:	5d                   	pop    %ebp
  811d2e:	c3                   	ret    
  811d2f:	90                   	nop
  811d30:	89 d1                	mov    %edx,%ecx
  811d32:	89 fa                	mov    %edi,%edx
  811d34:	89 c8                	mov    %ecx,%eax
  811d36:	31 ff                	xor    %edi,%edi
  811d38:	f7 f6                	div    %esi
  811d3a:	89 c1                	mov    %eax,%ecx
  811d3c:	89 fa                	mov    %edi,%edx
  811d3e:	89 c8                	mov    %ecx,%eax
  811d40:	83 c4 10             	add    $0x10,%esp
  811d43:	5e                   	pop    %esi
  811d44:	5f                   	pop    %edi
  811d45:	5d                   	pop    %ebp
  811d46:	c3                   	ret    
  811d47:	90                   	nop
  811d48:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  811d4c:	89 f2                	mov    %esi,%edx
  811d4e:	d3 e0                	shl    %cl,%eax
  811d50:	89 45 ec             	mov    %eax,-0x14(%ebp)
  811d53:	b8 20 00 00 00       	mov    $0x20,%eax
  811d58:	2b 45 f4             	sub    -0xc(%ebp),%eax
  811d5b:	89 c1                	mov    %eax,%ecx
  811d5d:	d3 ea                	shr    %cl,%edx
  811d5f:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  811d63:	0b 55 ec             	or     -0x14(%ebp),%edx
  811d66:	d3 e6                	shl    %cl,%esi
  811d68:	89 c1                	mov    %eax,%ecx
  811d6a:	89 75 e8             	mov    %esi,-0x18(%ebp)
  811d6d:	89 fe                	mov    %edi,%esi
  811d6f:	d3 ee                	shr    %cl,%esi
  811d71:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  811d75:	89 55 ec             	mov    %edx,-0x14(%ebp)
  811d78:	8b 55 f0             	mov    -0x10(%ebp),%edx
  811d7b:	d3 e7                	shl    %cl,%edi
  811d7d:	89 c1                	mov    %eax,%ecx
  811d7f:	d3 ea                	shr    %cl,%edx
  811d81:	09 d7                	or     %edx,%edi
  811d83:	89 f2                	mov    %esi,%edx
  811d85:	89 f8                	mov    %edi,%eax
  811d87:	f7 75 ec             	divl   -0x14(%ebp)
  811d8a:	89 d6                	mov    %edx,%esi
  811d8c:	89 c7                	mov    %eax,%edi
  811d8e:	f7 65 e8             	mull   -0x18(%ebp)
  811d91:	39 d6                	cmp    %edx,%esi
  811d93:	89 55 ec             	mov    %edx,-0x14(%ebp)
  811d96:	72 30                	jb     811dc8 <__udivdi3+0x118>
  811d98:	8b 55 f0             	mov    -0x10(%ebp),%edx
  811d9b:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  811d9f:	d3 e2                	shl    %cl,%edx
  811da1:	39 c2                	cmp    %eax,%edx
  811da3:	73 05                	jae    811daa <__udivdi3+0xfa>
  811da5:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  811da8:	74 1e                	je     811dc8 <__udivdi3+0x118>
  811daa:	89 f9                	mov    %edi,%ecx
  811dac:	31 ff                	xor    %edi,%edi
  811dae:	e9 71 ff ff ff       	jmp    811d24 <__udivdi3+0x74>
  811db3:	90                   	nop
  811db4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811db8:	31 ff                	xor    %edi,%edi
  811dba:	b9 01 00 00 00       	mov    $0x1,%ecx
  811dbf:	e9 60 ff ff ff       	jmp    811d24 <__udivdi3+0x74>
  811dc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811dc8:	8d 4f ff             	lea    -0x1(%edi),%ecx
  811dcb:	31 ff                	xor    %edi,%edi
  811dcd:	89 c8                	mov    %ecx,%eax
  811dcf:	89 fa                	mov    %edi,%edx
  811dd1:	83 c4 10             	add    $0x10,%esp
  811dd4:	5e                   	pop    %esi
  811dd5:	5f                   	pop    %edi
  811dd6:	5d                   	pop    %ebp
  811dd7:	c3                   	ret    
	...

00811de0 <__umoddi3>:
  811de0:	55                   	push   %ebp
  811de1:	89 e5                	mov    %esp,%ebp
  811de3:	57                   	push   %edi
  811de4:	56                   	push   %esi
  811de5:	83 ec 20             	sub    $0x20,%esp
  811de8:	8b 55 14             	mov    0x14(%ebp),%edx
  811deb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  811dee:	8b 7d 10             	mov    0x10(%ebp),%edi
  811df1:	8b 75 0c             	mov    0xc(%ebp),%esi
  811df4:	85 d2                	test   %edx,%edx
  811df6:	89 c8                	mov    %ecx,%eax
  811df8:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  811dfb:	75 13                	jne    811e10 <__umoddi3+0x30>
  811dfd:	39 f7                	cmp    %esi,%edi
  811dff:	76 3f                	jbe    811e40 <__umoddi3+0x60>
  811e01:	89 f2                	mov    %esi,%edx
  811e03:	f7 f7                	div    %edi
  811e05:	89 d0                	mov    %edx,%eax
  811e07:	31 d2                	xor    %edx,%edx
  811e09:	83 c4 20             	add    $0x20,%esp
  811e0c:	5e                   	pop    %esi
  811e0d:	5f                   	pop    %edi
  811e0e:	5d                   	pop    %ebp
  811e0f:	c3                   	ret    
  811e10:	39 f2                	cmp    %esi,%edx
  811e12:	77 4c                	ja     811e60 <__umoddi3+0x80>
  811e14:	0f bd ca             	bsr    %edx,%ecx
  811e17:	83 f1 1f             	xor    $0x1f,%ecx
  811e1a:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  811e1d:	75 51                	jne    811e70 <__umoddi3+0x90>
  811e1f:	3b 7d f4             	cmp    -0xc(%ebp),%edi
  811e22:	0f 87 e0 00 00 00    	ja     811f08 <__umoddi3+0x128>
  811e28:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811e2b:	29 f8                	sub    %edi,%eax
  811e2d:	19 d6                	sbb    %edx,%esi
  811e2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  811e32:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811e35:	89 f2                	mov    %esi,%edx
  811e37:	83 c4 20             	add    $0x20,%esp
  811e3a:	5e                   	pop    %esi
  811e3b:	5f                   	pop    %edi
  811e3c:	5d                   	pop    %ebp
  811e3d:	c3                   	ret    
  811e3e:	66 90                	xchg   %ax,%ax
  811e40:	85 ff                	test   %edi,%edi
  811e42:	75 0b                	jne    811e4f <__umoddi3+0x6f>
  811e44:	b8 01 00 00 00       	mov    $0x1,%eax
  811e49:	31 d2                	xor    %edx,%edx
  811e4b:	f7 f7                	div    %edi
  811e4d:	89 c7                	mov    %eax,%edi
  811e4f:	89 f0                	mov    %esi,%eax
  811e51:	31 d2                	xor    %edx,%edx
  811e53:	f7 f7                	div    %edi
  811e55:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811e58:	f7 f7                	div    %edi
  811e5a:	eb a9                	jmp    811e05 <__umoddi3+0x25>
  811e5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811e60:	89 c8                	mov    %ecx,%eax
  811e62:	89 f2                	mov    %esi,%edx
  811e64:	83 c4 20             	add    $0x20,%esp
  811e67:	5e                   	pop    %esi
  811e68:	5f                   	pop    %edi
  811e69:	5d                   	pop    %ebp
  811e6a:	c3                   	ret    
  811e6b:	90                   	nop
  811e6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811e70:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811e74:	d3 e2                	shl    %cl,%edx
  811e76:	89 55 f4             	mov    %edx,-0xc(%ebp)
  811e79:	ba 20 00 00 00       	mov    $0x20,%edx
  811e7e:	2b 55 f0             	sub    -0x10(%ebp),%edx
  811e81:	89 55 ec             	mov    %edx,-0x14(%ebp)
  811e84:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  811e88:	89 fa                	mov    %edi,%edx
  811e8a:	d3 ea                	shr    %cl,%edx
  811e8c:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811e90:	0b 55 f4             	or     -0xc(%ebp),%edx
  811e93:	d3 e7                	shl    %cl,%edi
  811e95:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  811e99:	89 55 f4             	mov    %edx,-0xc(%ebp)
  811e9c:	89 f2                	mov    %esi,%edx
  811e9e:	89 7d e8             	mov    %edi,-0x18(%ebp)
  811ea1:	89 c7                	mov    %eax,%edi
  811ea3:	d3 ea                	shr    %cl,%edx
  811ea5:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811ea9:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  811eac:	89 c2                	mov    %eax,%edx
  811eae:	d3 e6                	shl    %cl,%esi
  811eb0:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  811eb4:	d3 ea                	shr    %cl,%edx
  811eb6:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811eba:	09 d6                	or     %edx,%esi
  811ebc:	89 f0                	mov    %esi,%eax
  811ebe:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  811ec1:	d3 e7                	shl    %cl,%edi
  811ec3:	89 f2                	mov    %esi,%edx
  811ec5:	f7 75 f4             	divl   -0xc(%ebp)
  811ec8:	89 d6                	mov    %edx,%esi
  811eca:	f7 65 e8             	mull   -0x18(%ebp)
  811ecd:	39 d6                	cmp    %edx,%esi
  811ecf:	72 2b                	jb     811efc <__umoddi3+0x11c>
  811ed1:	39 c7                	cmp    %eax,%edi
  811ed3:	72 23                	jb     811ef8 <__umoddi3+0x118>
  811ed5:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811ed9:	29 c7                	sub    %eax,%edi
  811edb:	19 d6                	sbb    %edx,%esi
  811edd:	89 f0                	mov    %esi,%eax
  811edf:	89 f2                	mov    %esi,%edx
  811ee1:	d3 ef                	shr    %cl,%edi
  811ee3:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  811ee7:	d3 e0                	shl    %cl,%eax
  811ee9:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  811eed:	09 f8                	or     %edi,%eax
  811eef:	d3 ea                	shr    %cl,%edx
  811ef1:	83 c4 20             	add    $0x20,%esp
  811ef4:	5e                   	pop    %esi
  811ef5:	5f                   	pop    %edi
  811ef6:	5d                   	pop    %ebp
  811ef7:	c3                   	ret    
  811ef8:	39 d6                	cmp    %edx,%esi
  811efa:	75 d9                	jne    811ed5 <__umoddi3+0xf5>
  811efc:	2b 45 e8             	sub    -0x18(%ebp),%eax
  811eff:	1b 55 f4             	sbb    -0xc(%ebp),%edx
  811f02:	eb d1                	jmp    811ed5 <__umoddi3+0xf5>
  811f04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811f08:	39 f2                	cmp    %esi,%edx
  811f0a:	0f 82 18 ff ff ff    	jb     811e28 <__umoddi3+0x48>
  811f10:	e9 1d ff ff ff       	jmp    811e32 <__umoddi3+0x52>
